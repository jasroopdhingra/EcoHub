{"ast":null,"code":"var _a = Object.defineProperty;\nvar jr = r => {\n  throw TypeError(r);\n};\nvar za = (r, e, t) => e in r ? _a(r, e, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: t\n}) : r[e] = t;\nvar L = (r, e, t) => za(r, typeof e != \"symbol\" ? e + \"\" : e, t),\n  Rt = (r, e, t) => e.has(r) || jr(\"Cannot \" + t);\nvar E = (r, e, t) => (Rt(r, e, \"read from private field\"), t ? t.call(r) : e.get(r)),\n  ye = (r, e, t) => e.has(r) ? jr(\"Cannot add the same private member more than once\") : e instanceof WeakSet ? e.add(r) : e.set(r, t),\n  xe = (r, e, t, n) => (Rt(r, e, \"write to private field\"), n ? n.call(r, t) : e.set(r, t), t),\n  G = (r, e, t) => (Rt(r, e, \"access private method\"), t);\nimport S, { addProtocol as Nr } from \"maplibre-gl\";\nimport { Language as Pa, getLanguageInfoFromCode as Or, config as $t, MapStyle as qe, mapStylePresetList as jt, expandMapStyle as Ra, MapStyleVariant as $a, ReferenceMapStyle as ja, toLanguageInfo as Fr, getLanguageInfoFromFlag as Na, geolocation as Dr } from \"@maptiler/client\";\nimport { MapStyle as Uu, MapStyleVariant as Vu, ReferenceMapStyle as Gu, ServiceError as Hu, areSameLanguages as Ku, bufferToPixelDataBrowser as Wu, circumferenceAtLatitude as Zu, coordinates as Ju, data as Yu, elevation as Xu, expandMapStyle as Qu, geocoding as ec, geolocation as tc, getAutoLanguage as rc, getBufferToPixelDataParser as nc, getLanguageInfoFromCode as ac, getLanguageInfoFromFlag as oc, getLanguageInfoFromKey as ic, getTileCache as sc, isLanguageInfo as lc, mapStylePresetList as uc, math as cc, misc as pc, staticMaps as fc, styleToStyle as dc, toLanguageInfo as yc } from \"@maptiler/client\";\nimport Oa from \"events\";\nimport { v4 as Fa } from \"uuid\";\nimport { Base64 as Da } from \"js-base64\";\nconst M = {\n  /**\n   * Language mode to display labels in both the local language and the language of the visitor's device, concatenated.\n   * Note that if those two languages are the same, labels won't be duplicated.\n   */\n  VISITOR: {\n    code: null,\n    flag: \"visitor\",\n    name: \"Visitor\",\n    latin: !0,\n    isMode: !0,\n    geocoding: !1\n  },\n  /**\n   * Language mode to display labels in both the local language and English, concatenated.\n   * Note that if those two languages are the same, labels won't be duplicated.\n   */\n  VISITOR_ENGLISH: {\n    code: null,\n    flag: \"visitor_en\",\n    name: \"Visitor English\",\n    latin: !0,\n    isMode: !0,\n    geocoding: !1\n  },\n  /**\n   * Language mode to display labels in a language enforced in the style.\n   */\n  STYLE: {\n    code: null,\n    flag: \"style\",\n    name: \"Style\",\n    latin: !1,\n    isMode: !0,\n    geocoding: !1\n  },\n  /**\n   * Language mode to display labels in a language enforced in the style. The language cannot be further modified.\n   */\n  STYLE_LOCK: {\n    code: null,\n    flag: \"style_lock\",\n    name: \"Style Lock\",\n    latin: !1,\n    isMode: !0,\n    geocoding: !1\n  },\n  ...Pa\n};\nfunction qr() {\n  if (typeof navigator > \"u\") {\n    const e = Intl.DateTimeFormat().resolvedOptions().locale.split(\"-\")[0],\n      t = Or(e);\n    return t || M.ENGLISH;\n  }\n  return Array.from(new Set(navigator.languages.map(e => e.split(\"-\")[0]))).map(e => Or(e)).filter(e => e)[0] ?? M.LOCAL;\n}\nconst V = {\n  maptilerLogoURL: \"https://api.maptiler.com/resources/logo.svg\",\n  maptilerURL: \"https://www.maptiler.com/\",\n  maptilerApiHost: \"api.maptiler.com\",\n  telemetryURL: \"https://api.maptiler.com/metrics\",\n  rtlPluginURL: \"https://cdn.maptiler.com/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.min.js\",\n  primaryLanguage: M.STYLE,\n  secondaryLanguage: M.LOCAL,\n  terrainSourceURL: \"https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json\",\n  terrainSourceId: \"maptiler-terrain\"\n};\nObject.freeze(V);\nconst ur = Fa();\nclass qa extends Oa {\n  constructor() {\n    super(...arguments);\n    /**\n     * The primary language. By default, the language of the web browser is used.\n     */\n    L(this, \"primaryLanguage\", V.primaryLanguage);\n    /**\n     * The secondary language, to overwrite the default language defined in the map style.\n     * This settings is highly dependant on the style compatibility and may not work in most cases.\n     */\n    L(this, \"secondaryLanguage\");\n    /**\n     * Setting on whether of not the SDK runs with a session logic.\n     * A \"session\" is started at the initialization of the SDK and finished when the browser\n     * page is being refreshed.\n     * When `session` is enabled (default: true), the extra URL param `mtsid` is added to queries\n     * on the MapTiler Cloud API. This allows MapTiler to enable \"session based billing\".\n     */\n    L(this, \"session\", !0);\n    /**\n     * Enables client-side caching of requests for tiles and fonts.\n     * The cached requests persist multiple browser sessions and will be reused when possible.\n     * Works only for requests to the MapTiler Cloud API when sessions are enabled.\n     */\n    L(this, \"caching\", !0);\n    /**\n     * Telemetry is enabled by default but can be opted-out by setting this value to `false`.\n     * The telemetry is very valuable to the team at MapTiler because it shares information\n     * about where to add the extra effort. It also helps spotting some incompatibility issues\n     * that may arise between the SDK and a specific version of a module.\n     *\n     * It consists in sending metrics about usage of the following features:\n     * - SDK version [string]\n     * - API key [string]\n     * - MapTiler sesion ID (if opted-in) [string]\n     * - if tile caching is enabled [boolean]\n     * - if language specified at initialization [boolean]\n     * - if terrain is activated at initialization [boolean]\n     * - if globe projection is activated at initialization [boolean]\n     *\n     * In addition, each official module will be added to a list, alongside its version number.\n     */\n    L(this, \"telemetry\", !0);\n    /**\n     * Unit to be used\n     */\n    L(this, \"_unit\", \"metric\");\n    /**\n     * MapTiler Cloud API key\n     */\n    L(this, \"_apiKey\", \"\");\n  }\n  /**\n   * Set the unit system\n   */\n  set unit(t) {\n    this._unit = t, this.emit(\"unit\", t);\n  }\n  /**\n   * Get the unit system\n   */\n  get unit() {\n    return this._unit;\n  }\n  /**\n   * Set the MapTiler Cloud API key\n   */\n  set apiKey(t) {\n    this._apiKey = t, $t.apiKey = t, this.emit(\"apiKey\", t);\n  }\n  /**\n   * Get the MapTiler Cloud API key\n   */\n  get apiKey() {\n    return this._apiKey;\n  }\n  /**\n   * Set a the custom fetch function to replace the default one\n   */\n  set fetch(t) {\n    $t.fetch = t;\n  }\n  /**\n   * Get the fetch fucntion\n   */\n  get fetch() {\n    return $t.fetch;\n  }\n}\nconst O = new qa(),\n  Kt = \"localcache_source\",\n  Wt = \"localcache\",\n  Ba = \"maptiler_sdk\",\n  Ua = 1e3,\n  Va = 100,\n  Zt = typeof caches < \"u\";\nfunction Ga(r, e) {\n  if (Zt && O.caching && O.session && r.host === V.maptilerApiHost) {\n    if (e === \"Source\" && r.href.includes(\"tiles.json\")) return r.href.replace(\"https://\", `${Kt}://`);\n    if (e === \"Tile\" || e === \"Glyphs\") return r.href.replace(\"https://\", `${Wt}://`);\n  }\n  return r.href;\n}\nlet Nt;\nasync function xn() {\n  return Nt || (Nt = await caches.open(Ba)), Nt;\n}\nlet Br = 0;\nasync function Ha() {\n  const r = await xn(),\n    e = await r.keys(),\n    t = e.slice(0, Math.max(e.length - Ua, 0));\n  for (const n of t) r.delete(n);\n}\nfunction Ka() {\n  Nr(Kt, async (r, e) => {\n    if (!r.url) throw new Error(\"\");\n    r.url = r.url.replace(`${Kt}://`, \"https://\");\n    const t = r;\n    t.signal = e.signal;\n    const n = await fetch(r.url, t),\n      a = await n.json();\n    return a.tiles && a.tiles.length > 0 && (a.tiles[0] += `&last-modified=${n.headers.get(\"Last-Modified\")}`), {\n      data: a,\n      cacheControl: n.headers.get(\"Cache-Control\"),\n      expires: n.headers.get(\"Expires\")\n    };\n  }), Nr(Wt, async (r, e) => {\n    if (!r.url) throw new Error(\"\");\n    r.url = r.url.replace(`${Wt}://`, \"https://\");\n    const t = new URL(r.url),\n      n = new URL(t);\n    n.searchParams.delete(\"mtsid\"), n.searchParams.delete(\"key\");\n    const a = n.toString(),\n      o = new URL(t);\n    o.searchParams.delete(\"last-modified\");\n    const i = o.toString(),\n      s = async m => ({\n        data: await m.arrayBuffer(),\n        cacheControl: m.headers.get(\"Cache-Control\"),\n        expires: m.headers.get(\"Expires\")\n      }),\n      l = await xn(),\n      u = await l.match(a);\n    if (u) return s(u);\n    const c = r;\n    c.signal = e.signal;\n    const p = await fetch(i, c);\n    return p.status >= 200 && p.status < 300 && (l.put(a, p.clone()).catch(() => {}), ++Br > Va && (Ha(), Br = 0)), s(p);\n  });\n}\nfunction Wa() {\n  if (typeof window > \"u\") return;\n  const r = S.getRTLTextPluginStatus();\n  if (r === \"unavailable\" || r === \"requested\") try {\n    S.setRTLTextPlugin(V.rtlPluginURL, !0);\n  } catch {}\n}\nfunction Za(r, e) {\n  for (const t of r) typeof e[t] == \"function\" && (e[t] = e[t].bind(e));\n}\nfunction Ur(r, e) {\n  let t = null;\n  try {\n    t = new URL(r);\n  } catch {\n    return {\n      url: r\n    };\n  }\n  return t.host === V.maptilerApiHost && (t.searchParams.has(\"key\") || t.searchParams.append(\"key\", O.apiKey), O.session && t.searchParams.append(\"mtsid\", ur)), {\n    url: Ga(t, e)\n  };\n}\nfunction Vr(r) {\n  return (e, t) => {\n    if (r != null) {\n      const n = r(e, t),\n        a = Ur((n == null ? void 0 : n.url) ?? \"\", t);\n      return {\n        ...n,\n        ...a\n      };\n    }\n    return Ur(e, t);\n  };\n}\nfunction kn() {\n  return Math.random().toString(36).substring(2);\n}\nfunction vt(r) {\n  return /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/gi.test(r);\n}\nfunction Ja(r) {\n  try {\n    return JSON.parse(r);\n  } catch {}\n  return null;\n}\nfunction Ya() {\n  return document.createElement(\"canvas\").getContext(\"webgl2\") ? null : typeof WebGL2RenderingContext < \"u\" ? \"Graphic rendering with WebGL2 has been disabled or is not supported by your graphic card. The map cannot be displayed.\" : \"Your browser does not support graphic rendering with WebGL2. The map cannot be displayed.\";\n}\nfunction Xa(r) {\n  const e = Ya();\n  if (!e) return;\n  let t = null;\n  if (typeof r == \"string\" ? t = document.getElementById(r) : r instanceof HTMLElement && (t = r), !t) throw new Error(\"The Map container must be provided.\");\n  const n = document.createElement(\"div\");\n  throw n.innerHTML = e, n.classList.add(\"webgl-warning-div\"), t.appendChild(n), new Error(e);\n}\nfunction ml(r) {\n  const e = \"The WebGL context was lost.\",\n    t = r.getContainer(),\n    n = document.createElement(\"div\");\n  n.innerHTML = e, n.classList.add(\"webgl-warning-div\"), t.appendChild(n);\n}\nfunction Gr(r, e) {\n  return !(!Array.isArray(r) || r.length !== 2 || r[0] !== \"get\" || typeof r[1] != \"string\" || e && !r[1].startsWith(\"name:\") || !e && r[1] !== \"name\");\n}\nfunction Qa(r, e, t) {\n  const n = structuredClone(r),\n    a = o => {\n      if (typeof o != \"string\") for (let i = 0; i < o.length; i += 1) Gr(o[i], t) ? o[i] = structuredClone(e) : a(o[i]);\n    };\n  return Gr(n, t) ? e : (a(n), n);\n}\nfunction eo(r, e) {\n  const t = e ? /\\{name:\\S+\\}/ : /\\{name\\}/;\n  return {\n    contains: t.test(r),\n    exactMatch: new RegExp(`^${t.source}$`).test(r)\n  };\n}\nfunction to(r, e, t) {\n  const n = t ? /\\{name:\\S+\\}/ : /\\{name\\}/,\n    a = r.split(n);\n  return [\"concat\", ...a.flatMap((s, l) => l === a.length - 1 ? [s] : [s, e])];\n}\nfunction ro(r) {\n  var n;\n  const e = /\\{name(?:\\:(?<language>\\S+))?\\}/g,\n    t = [];\n  for (;;) {\n    const a = e.exec(r);\n    if (!a) break;\n    const o = ((n = a.groups) == null ? void 0 : n.language) ?? null;\n    t.push(o);\n  }\n  return t;\n}\nfunction no(r) {\n  return !Array.isArray(r) || r.length !== 2 || r[0] !== \"get\" || typeof r[1] != \"string\" ? null : r[1].trim() === \"name\" ? {\n    isLanguage: !0,\n    localization: null\n  } : r[1].trim().startsWith(\"name:\") ? {\n    isLanguage: !0,\n    localization: r[1].trim().split(\":\").pop()\n  } : null;\n}\nfunction ao(r) {\n  const e = [],\n    t = structuredClone(r),\n    n = a => {\n      if (typeof a != \"string\") for (let o = 0; o < a.length; o += 1) {\n        const i = no(a[o]);\n        i ? e.push(i.localization) : n(a[o]);\n      }\n    };\n  return n([t]), e;\n}\nfunction oo(r, e) {\n  const t = [];\n  for (const o of r) {\n    if (o.type !== \"symbol\") continue;\n    const i = o,\n      {\n        id: s,\n        layout: l\n      } = i;\n    if (!l || !(\"text-field\" in l)) continue;\n    const u = e.getLayoutProperty(s, \"text-field\");\n    if (u) if (typeof u == \"string\") {\n      const c = ro(u);\n      t.push(c);\n    } else {\n      const c = ao(u);\n      t.push(c);\n    }\n  }\n  const n = t.flat(),\n    a = {\n      unlocalized: 0,\n      localized: {}\n    };\n  for (const o of n) o === null ? a.unlocalized += 1 : (o in a.localized || (a.localized[o] = 0), a.localized[o] += 1);\n  return a;\n}\nlet hl = class extends S.Marker {\n  addTo(e) {\n    return super.addTo(e);\n  }\n};\nclass vl extends S.Popup {\n  addTo(e) {\n    return super.addTo(e);\n  }\n}\nclass bl extends S.Style {\n  constructor(e, t = {}) {\n    super(e, t);\n  }\n}\nclass wl extends S.CanvasSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass Sl extends S.GeoJSONSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass xl extends S.ImageSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass kl extends S.RasterTileSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass Ll extends S.RasterDEMTileSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass Cl extends S.VectorTileSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass Al extends S.VideoSource {\n  onAdd(e) {\n    super.onAdd(e);\n  }\n}\nclass io extends S.NavigationControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass so extends S.GeolocateControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass Tl extends S.AttributionControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass lo extends S.LogoControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass uo extends S.ScaleControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass co extends S.FullscreenControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass Il extends S.TerrainControl {\n  onAdd(e) {\n    return super.onAdd(e);\n  }\n}\nclass El extends S.BoxZoomHandler {\n  constructor(e, t) {\n    super(e, t);\n  }\n}\nclass Ml extends S.ScrollZoomHandler {\n  constructor(e, t) {\n    super(e, t);\n  }\n}\nclass _l extends S.CooperativeGesturesHandler {\n  constructor(e, t) {\n    super(e, t);\n  }\n}\nclass zl extends S.KeyboardHandler {\n  constructor(e) {\n    super(e);\n  }\n}\nclass Pl extends S.TwoFingersTouchPitchHandler {\n  constructor(e) {\n    super(e);\n  }\n}\nclass Rl extends S.MapWheelEvent {\n  constructor(e, t, n) {\n    super(e, t, n);\n  }\n}\nclass $l extends S.MapTouchEvent {\n  constructor(e, t, n) {\n    super(e, t, n);\n  }\n}\nclass jl extends S.MapMouseEvent {\n  constructor(e, t, n, a = {}) {\n    super(e, t, n, a);\n  }\n}\nclass Hr extends lo {\n  constructor(t = {}) {\n    super(t);\n    L(this, \"logoURL\", \"\");\n    L(this, \"linkURL\", \"\");\n    this.logoURL = t.logoURL ?? V.maptilerLogoURL, this.linkURL = t.linkURL ?? V.maptilerURL;\n  }\n  onAdd(t) {\n    this._map = t, this._compact = this.options.compact ?? !1, this._container = window.document.createElement(\"div\"), this._container.className = \"maplibregl-ctrl\";\n    const n = window.document.createElement(\"a\");\n    return n.style.backgroundRepeat = \"no-repeat\", n.style.cursor = \"pointer\", n.style.display = \"block\", n.style.height = \"23px\", n.style.margin = \"0 0 -4px -4px\", n.style.overflow = \"hidden\", n.style.width = \"88px\", n.style.backgroundImage = `url(${this.logoURL})`, n.style.backgroundSize = \"100px 30px\", n.style.width = \"100px\", n.style.height = \"30px\", n.target = \"_blank\", n.rel = \"noopener\", n.href = this.linkURL, n.setAttribute(\"aria-label\", \"MapTiler logo\"), n.setAttribute(\"rel\", \"noopener\"), this._container.appendChild(n), this._container.style.display = \"block\", this._map.on(\"resize\", this._updateCompact), this._updateCompact(), this._container;\n  }\n}\nvar po = 8,\n  fo = {\n    version: {\n      required: !0,\n      type: \"enum\",\n      values: [8]\n    },\n    name: {\n      type: \"string\"\n    },\n    metadata: {\n      type: \"*\"\n    },\n    center: {\n      type: \"array\",\n      value: \"number\"\n    },\n    centerAltitude: {\n      type: \"number\"\n    },\n    zoom: {\n      type: \"number\"\n    },\n    bearing: {\n      type: \"number\",\n      default: 0,\n      period: 360,\n      units: \"degrees\"\n    },\n    pitch: {\n      type: \"number\",\n      default: 0,\n      units: \"degrees\"\n    },\n    roll: {\n      type: \"number\",\n      default: 0,\n      units: \"degrees\"\n    },\n    light: {\n      type: \"light\"\n    },\n    sky: {\n      type: \"sky\"\n    },\n    projection: {\n      type: \"projection\"\n    },\n    terrain: {\n      type: \"terrain\"\n    },\n    sources: {\n      required: !0,\n      type: \"sources\"\n    },\n    sprite: {\n      type: \"sprite\"\n    },\n    glyphs: {\n      type: \"string\"\n    },\n    transition: {\n      type: \"transition\"\n    },\n    layers: {\n      required: !0,\n      type: \"array\",\n      value: \"layer\"\n    }\n  },\n  yo = {\n    \"*\": {\n      type: \"source\"\n    }\n  },\n  mo = [\"source_vector\", \"source_raster\", \"source_raster_dem\", \"source_geojson\", \"source_video\", \"source_image\"],\n  ho = {\n    type: {\n      required: !0,\n      type: \"enum\",\n      values: {\n        vector: {}\n      }\n    },\n    url: {\n      type: \"string\"\n    },\n    tiles: {\n      type: \"array\",\n      value: \"string\"\n    },\n    bounds: {\n      type: \"array\",\n      value: \"number\",\n      length: 4,\n      default: [-180, -85.051129, 180, 85.051129]\n    },\n    scheme: {\n      type: \"enum\",\n      values: {\n        xyz: {},\n        tms: {}\n      },\n      default: \"xyz\"\n    },\n    minzoom: {\n      type: \"number\",\n      default: 0\n    },\n    maxzoom: {\n      type: \"number\",\n      default: 22\n    },\n    attribution: {\n      type: \"string\"\n    },\n    promoteId: {\n      type: \"promoteId\"\n    },\n    volatile: {\n      type: \"boolean\",\n      default: !1\n    },\n    \"*\": {\n      type: \"*\"\n    }\n  },\n  go = {\n    type: {\n      required: !0,\n      type: \"enum\",\n      values: {\n        raster: {}\n      }\n    },\n    url: {\n      type: \"string\"\n    },\n    tiles: {\n      type: \"array\",\n      value: \"string\"\n    },\n    bounds: {\n      type: \"array\",\n      value: \"number\",\n      length: 4,\n      default: [-180, -85.051129, 180, 85.051129]\n    },\n    minzoom: {\n      type: \"number\",\n      default: 0\n    },\n    maxzoom: {\n      type: \"number\",\n      default: 22\n    },\n    tileSize: {\n      type: \"number\",\n      default: 512,\n      units: \"pixels\"\n    },\n    scheme: {\n      type: \"enum\",\n      values: {\n        xyz: {},\n        tms: {}\n      },\n      default: \"xyz\"\n    },\n    attribution: {\n      type: \"string\"\n    },\n    volatile: {\n      type: \"boolean\",\n      default: !1\n    },\n    \"*\": {\n      type: \"*\"\n    }\n  },\n  vo = {\n    type: {\n      required: !0,\n      type: \"enum\",\n      values: {\n        \"raster-dem\": {}\n      }\n    },\n    url: {\n      type: \"string\"\n    },\n    tiles: {\n      type: \"array\",\n      value: \"string\"\n    },\n    bounds: {\n      type: \"array\",\n      value: \"number\",\n      length: 4,\n      default: [-180, -85.051129, 180, 85.051129]\n    },\n    minzoom: {\n      type: \"number\",\n      default: 0\n    },\n    maxzoom: {\n      type: \"number\",\n      default: 22\n    },\n    tileSize: {\n      type: \"number\",\n      default: 512,\n      units: \"pixels\"\n    },\n    attribution: {\n      type: \"string\"\n    },\n    encoding: {\n      type: \"enum\",\n      values: {\n        terrarium: {},\n        mapbox: {},\n        custom: {}\n      },\n      default: \"mapbox\"\n    },\n    redFactor: {\n      type: \"number\",\n      default: 1\n    },\n    blueFactor: {\n      type: \"number\",\n      default: 1\n    },\n    greenFactor: {\n      type: \"number\",\n      default: 1\n    },\n    baseShift: {\n      type: \"number\",\n      default: 0\n    },\n    volatile: {\n      type: \"boolean\",\n      default: !1\n    },\n    \"*\": {\n      type: \"*\"\n    }\n  },\n  bo = {\n    type: {\n      required: !0,\n      type: \"enum\",\n      values: {\n        geojson: {}\n      }\n    },\n    data: {\n      required: !0,\n      type: \"*\"\n    },\n    maxzoom: {\n      type: \"number\",\n      default: 18\n    },\n    attribution: {\n      type: \"string\"\n    },\n    buffer: {\n      type: \"number\",\n      default: 128,\n      maximum: 512,\n      minimum: 0\n    },\n    filter: {\n      type: \"*\"\n    },\n    tolerance: {\n      type: \"number\",\n      default: 0.375\n    },\n    cluster: {\n      type: \"boolean\",\n      default: !1\n    },\n    clusterRadius: {\n      type: \"number\",\n      default: 50,\n      minimum: 0\n    },\n    clusterMaxZoom: {\n      type: \"number\"\n    },\n    clusterMinPoints: {\n      type: \"number\"\n    },\n    clusterProperties: {\n      type: \"*\"\n    },\n    lineMetrics: {\n      type: \"boolean\",\n      default: !1\n    },\n    generateId: {\n      type: \"boolean\",\n      default: !1\n    },\n    promoteId: {\n      type: \"promoteId\"\n    }\n  },\n  wo = {\n    type: {\n      required: !0,\n      type: \"enum\",\n      values: {\n        video: {}\n      }\n    },\n    urls: {\n      required: !0,\n      type: \"array\",\n      value: \"string\"\n    },\n    coordinates: {\n      required: !0,\n      type: \"array\",\n      length: 4,\n      value: {\n        type: \"array\",\n        length: 2,\n        value: \"number\"\n      }\n    }\n  },\n  So = {\n    type: {\n      required: !0,\n      type: \"enum\",\n      values: {\n        image: {}\n      }\n    },\n    url: {\n      required: !0,\n      type: \"string\"\n    },\n    coordinates: {\n      required: !0,\n      type: \"array\",\n      length: 4,\n      value: {\n        type: \"array\",\n        length: 2,\n        value: \"number\"\n      }\n    }\n  },\n  xo = {\n    id: {\n      type: \"string\",\n      required: !0\n    },\n    type: {\n      type: \"enum\",\n      values: {\n        fill: {},\n        line: {},\n        symbol: {},\n        circle: {},\n        heatmap: {},\n        \"fill-extrusion\": {},\n        raster: {},\n        hillshade: {},\n        background: {}\n      },\n      required: !0\n    },\n    metadata: {\n      type: \"*\"\n    },\n    source: {\n      type: \"string\"\n    },\n    \"source-layer\": {\n      type: \"string\"\n    },\n    minzoom: {\n      type: \"number\",\n      minimum: 0,\n      maximum: 24\n    },\n    maxzoom: {\n      type: \"number\",\n      minimum: 0,\n      maximum: 24\n    },\n    filter: {\n      type: \"filter\"\n    },\n    layout: {\n      type: \"layout\"\n    },\n    paint: {\n      type: \"paint\"\n    }\n  },\n  ko = [\"layout_fill\", \"layout_line\", \"layout_circle\", \"layout_heatmap\", \"layout_fill-extrusion\", \"layout_symbol\", \"layout_raster\", \"layout_hillshade\", \"layout_background\"],\n  Lo = {\n    visibility: {\n      type: \"enum\",\n      values: {\n        visible: {},\n        none: {}\n      },\n      default: \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  Co = {\n    \"fill-sort-key\": {\n      type: \"number\",\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    visibility: {\n      type: \"enum\",\n      values: {\n        visible: {},\n        none: {}\n      },\n      default: \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  Ao = {\n    \"circle-sort-key\": {\n      type: \"number\",\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    visibility: {\n      type: \"enum\",\n      values: {\n        visible: {},\n        none: {}\n      },\n      default: \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  To = {\n    visibility: {\n      type: \"enum\",\n      values: {\n        visible: {},\n        none: {}\n      },\n      default: \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  Io = {\n    \"line-cap\": {\n      type: \"enum\",\n      values: {\n        butt: {},\n        round: {},\n        square: {}\n      },\n      default: \"butt\",\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"line-join\": {\n      type: \"enum\",\n      values: {\n        bevel: {},\n        round: {},\n        miter: {}\n      },\n      default: \"miter\",\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"line-miter-limit\": {\n      type: \"number\",\n      default: 2,\n      requires: [{\n        \"line-join\": \"miter\"\n      }],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"line-round-limit\": {\n      type: \"number\",\n      default: 1.05,\n      requires: [{\n        \"line-join\": \"round\"\n      }],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"line-sort-key\": {\n      type: \"number\",\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    visibility: {\n      type: \"enum\",\n      values: {\n        visible: {},\n        none: {}\n      },\n      default: \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  Eo = {\n    \"symbol-placement\": {\n      type: \"enum\",\n      values: {\n        point: {},\n        line: {},\n        \"line-center\": {}\n      },\n      default: \"point\",\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"symbol-spacing\": {\n      type: \"number\",\n      default: 250,\n      minimum: 1,\n      units: \"pixels\",\n      requires: [{\n        \"symbol-placement\": \"line\"\n      }],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"symbol-avoid-edges\": {\n      type: \"boolean\",\n      default: !1,\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"symbol-sort-key\": {\n      type: \"number\",\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"symbol-z-order\": {\n      type: \"enum\",\n      values: {\n        auto: {},\n        \"viewport-y\": {},\n        source: {}\n      },\n      default: \"auto\",\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-allow-overlap\": {\n      type: \"boolean\",\n      default: !1,\n      requires: [\"icon-image\", {\n        \"!\": \"icon-overlap\"\n      }],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-overlap\": {\n      type: \"enum\",\n      values: {\n        never: {},\n        always: {},\n        cooperative: {}\n      },\n      requires: [\"icon-image\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-ignore-placement\": {\n      type: \"boolean\",\n      default: !1,\n      requires: [\"icon-image\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-optional\": {\n      type: \"boolean\",\n      default: !1,\n      requires: [\"icon-image\", \"text-field\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-rotation-alignment\": {\n      type: \"enum\",\n      values: {\n        map: {},\n        viewport: {},\n        auto: {}\n      },\n      default: \"auto\",\n      requires: [\"icon-image\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-size\": {\n      type: \"number\",\n      default: 1,\n      minimum: 0,\n      units: \"factor of the original icon size\",\n      requires: [\"icon-image\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-text-fit\": {\n      type: \"enum\",\n      values: {\n        none: {},\n        width: {},\n        height: {},\n        both: {}\n      },\n      default: \"none\",\n      requires: [\"icon-image\", \"text-field\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-text-fit-padding\": {\n      type: \"array\",\n      value: \"number\",\n      length: 4,\n      default: [0, 0, 0, 0],\n      units: \"pixels\",\n      requires: [\"icon-image\", \"text-field\", {\n        \"icon-text-fit\": [\"both\", \"width\", \"height\"]\n      }],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-image\": {\n      type: \"resolvedImage\",\n      tokens: !0,\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-rotate\": {\n      type: \"number\",\n      default: 0,\n      period: 360,\n      units: \"degrees\",\n      requires: [\"icon-image\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-padding\": {\n      type: \"padding\",\n      default: [2],\n      units: \"pixels\",\n      requires: [\"icon-image\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-keep-upright\": {\n      type: \"boolean\",\n      default: !1,\n      requires: [\"icon-image\", {\n        \"icon-rotation-alignment\": \"map\"\n      }, {\n        \"symbol-placement\": [\"line\", \"line-center\"]\n      }],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-offset\": {\n      type: \"array\",\n      value: \"number\",\n      length: 2,\n      default: [0, 0],\n      requires: [\"icon-image\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-anchor\": {\n      type: \"enum\",\n      values: {\n        center: {},\n        left: {},\n        right: {},\n        top: {},\n        bottom: {},\n        \"top-left\": {},\n        \"top-right\": {},\n        \"bottom-left\": {},\n        \"bottom-right\": {}\n      },\n      default: \"center\",\n      requires: [\"icon-image\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-pitch-alignment\": {\n      type: \"enum\",\n      values: {\n        map: {},\n        viewport: {},\n        auto: {}\n      },\n      default: \"auto\",\n      requires: [\"icon-image\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-pitch-alignment\": {\n      type: \"enum\",\n      values: {\n        map: {},\n        viewport: {},\n        auto: {}\n      },\n      default: \"auto\",\n      requires: [\"text-field\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-rotation-alignment\": {\n      type: \"enum\",\n      values: {\n        map: {},\n        viewport: {},\n        \"viewport-glyph\": {},\n        auto: {}\n      },\n      default: \"auto\",\n      requires: [\"text-field\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-field\": {\n      type: \"formatted\",\n      default: \"\",\n      tokens: !0,\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-font\": {\n      type: \"array\",\n      value: \"string\",\n      default: [\"Open Sans Regular\", \"Arial Unicode MS Regular\"],\n      requires: [\"text-field\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-size\": {\n      type: \"number\",\n      default: 16,\n      minimum: 0,\n      units: \"pixels\",\n      requires: [\"text-field\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-max-width\": {\n      type: \"number\",\n      default: 10,\n      minimum: 0,\n      units: \"ems\",\n      requires: [\"text-field\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-line-height\": {\n      type: \"number\",\n      default: 1.2,\n      units: \"ems\",\n      requires: [\"text-field\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-letter-spacing\": {\n      type: \"number\",\n      default: 0,\n      units: \"ems\",\n      requires: [\"text-field\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-justify\": {\n      type: \"enum\",\n      values: {\n        auto: {},\n        left: {},\n        center: {},\n        right: {}\n      },\n      default: \"center\",\n      requires: [\"text-field\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-radial-offset\": {\n      type: \"number\",\n      units: \"ems\",\n      default: 0,\n      requires: [\"text-field\"],\n      \"property-type\": \"data-driven\",\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\"]\n      }\n    },\n    \"text-variable-anchor\": {\n      type: \"array\",\n      value: \"enum\",\n      values: {\n        center: {},\n        left: {},\n        right: {},\n        top: {},\n        bottom: {},\n        \"top-left\": {},\n        \"top-right\": {},\n        \"bottom-left\": {},\n        \"bottom-right\": {}\n      },\n      requires: [\"text-field\", {\n        \"symbol-placement\": [\"point\"]\n      }],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-variable-anchor-offset\": {\n      type: \"variableAnchorOffsetCollection\",\n      requires: [\"text-field\", {\n        \"symbol-placement\": [\"point\"]\n      }],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-anchor\": {\n      type: \"enum\",\n      values: {\n        center: {},\n        left: {},\n        right: {},\n        top: {},\n        bottom: {},\n        \"top-left\": {},\n        \"top-right\": {},\n        \"bottom-left\": {},\n        \"bottom-right\": {}\n      },\n      default: \"center\",\n      requires: [\"text-field\", {\n        \"!\": \"text-variable-anchor\"\n      }],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-max-angle\": {\n      type: \"number\",\n      default: 45,\n      units: \"degrees\",\n      requires: [\"text-field\", {\n        \"symbol-placement\": [\"line\", \"line-center\"]\n      }],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-writing-mode\": {\n      type: \"array\",\n      value: \"enum\",\n      values: {\n        horizontal: {},\n        vertical: {}\n      },\n      requires: [\"text-field\", {\n        \"symbol-placement\": [\"point\"]\n      }],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-rotate\": {\n      type: \"number\",\n      default: 0,\n      period: 360,\n      units: \"degrees\",\n      requires: [\"text-field\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-padding\": {\n      type: \"number\",\n      default: 2,\n      minimum: 0,\n      units: \"pixels\",\n      requires: [\"text-field\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-keep-upright\": {\n      type: \"boolean\",\n      default: !0,\n      requires: [\"text-field\", {\n        \"text-rotation-alignment\": \"map\"\n      }, {\n        \"symbol-placement\": [\"line\", \"line-center\"]\n      }],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-transform\": {\n      type: \"enum\",\n      values: {\n        none: {},\n        uppercase: {},\n        lowercase: {}\n      },\n      default: \"none\",\n      requires: [\"text-field\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-offset\": {\n      type: \"array\",\n      value: \"number\",\n      units: \"ems\",\n      length: 2,\n      default: [0, 0],\n      requires: [\"text-field\", {\n        \"!\": \"text-radial-offset\"\n      }],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-allow-overlap\": {\n      type: \"boolean\",\n      default: !1,\n      requires: [\"text-field\", {\n        \"!\": \"text-overlap\"\n      }],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-overlap\": {\n      type: \"enum\",\n      values: {\n        never: {},\n        always: {},\n        cooperative: {}\n      },\n      requires: [\"text-field\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-ignore-placement\": {\n      type: \"boolean\",\n      default: !1,\n      requires: [\"text-field\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-optional\": {\n      type: \"boolean\",\n      default: !1,\n      requires: [\"text-field\", \"icon-image\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    visibility: {\n      type: \"enum\",\n      values: {\n        visible: {},\n        none: {}\n      },\n      default: \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  Mo = {\n    visibility: {\n      type: \"enum\",\n      values: {\n        visible: {},\n        none: {}\n      },\n      default: \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  _o = {\n    visibility: {\n      type: \"enum\",\n      values: {\n        visible: {},\n        none: {}\n      },\n      default: \"visible\",\n      \"property-type\": \"constant\"\n    }\n  },\n  zo = {\n    type: \"array\",\n    value: \"*\"\n  },\n  Po = {\n    type: \"enum\",\n    values: {\n      \"==\": {},\n      \"!=\": {},\n      \">\": {},\n      \">=\": {},\n      \"<\": {},\n      \"<=\": {},\n      in: {},\n      \"!in\": {},\n      all: {},\n      any: {},\n      none: {},\n      has: {},\n      \"!has\": {}\n    }\n  },\n  Ro = {\n    type: \"enum\",\n    values: {\n      Point: {},\n      LineString: {},\n      Polygon: {}\n    }\n  },\n  $o = {\n    type: \"array\",\n    minimum: 0,\n    maximum: 24,\n    value: [\"number\", \"color\"],\n    length: 2\n  },\n  jo = {\n    type: \"array\",\n    value: \"*\",\n    minimum: 1\n  },\n  No = {\n    anchor: {\n      type: \"enum\",\n      default: \"viewport\",\n      values: {\n        map: {},\n        viewport: {}\n      },\n      \"property-type\": \"data-constant\",\n      transition: !1,\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      }\n    },\n    position: {\n      type: \"array\",\n      default: [1.15, 210, 30],\n      length: 3,\n      value: \"number\",\n      \"property-type\": \"data-constant\",\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      }\n    },\n    color: {\n      type: \"color\",\n      \"property-type\": \"data-constant\",\n      default: \"#ffffff\",\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      transition: !0\n    },\n    intensity: {\n      type: \"number\",\n      \"property-type\": \"data-constant\",\n      default: 0.5,\n      minimum: 0,\n      maximum: 1,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      transition: !0\n    }\n  },\n  Oo = {\n    \"sky-color\": {\n      type: \"color\",\n      \"property-type\": \"data-constant\",\n      default: \"#88C6FC\",\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      transition: !0\n    },\n    \"horizon-color\": {\n      type: \"color\",\n      \"property-type\": \"data-constant\",\n      default: \"#ffffff\",\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      transition: !0\n    },\n    \"fog-color\": {\n      type: \"color\",\n      \"property-type\": \"data-constant\",\n      default: \"#ffffff\",\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      transition: !0\n    },\n    \"fog-ground-blend\": {\n      type: \"number\",\n      \"property-type\": \"data-constant\",\n      default: 0.5,\n      minimum: 0,\n      maximum: 1,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      transition: !0\n    },\n    \"horizon-fog-blend\": {\n      type: \"number\",\n      \"property-type\": \"data-constant\",\n      default: 0.8,\n      minimum: 0,\n      maximum: 1,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      transition: !0\n    },\n    \"sky-horizon-blend\": {\n      type: \"number\",\n      \"property-type\": \"data-constant\",\n      default: 0.8,\n      minimum: 0,\n      maximum: 1,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      transition: !0\n    },\n    \"atmosphere-blend\": {\n      type: \"number\",\n      \"property-type\": \"data-constant\",\n      default: 0.8,\n      minimum: 0,\n      maximum: 1,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      transition: !0\n    }\n  },\n  Fo = {\n    source: {\n      type: \"string\",\n      required: !0\n    },\n    exaggeration: {\n      type: \"number\",\n      minimum: 0,\n      default: 1\n    }\n  },\n  Do = {\n    type: {\n      type: \"projectionDefinition\",\n      default: \"mercator\",\n      \"property-type\": \"data-constant\",\n      transition: !1,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      }\n    }\n  },\n  qo = [\"paint_fill\", \"paint_line\", \"paint_circle\", \"paint_heatmap\", \"paint_fill-extrusion\", \"paint_symbol\", \"paint_raster\", \"paint_hillshade\", \"paint_background\"],\n  Bo = {\n    \"fill-antialias\": {\n      type: \"boolean\",\n      default: !0,\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"fill-opacity\": {\n      type: \"number\",\n      default: 1,\n      minimum: 0,\n      maximum: 1,\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"fill-color\": {\n      type: \"color\",\n      default: \"#000000\",\n      transition: !0,\n      requires: [{\n        \"!\": \"fill-pattern\"\n      }],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"fill-outline-color\": {\n      type: \"color\",\n      transition: !0,\n      requires: [{\n        \"!\": \"fill-pattern\"\n      }, {\n        \"fill-antialias\": !0\n      }],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"fill-translate\": {\n      type: \"array\",\n      value: \"number\",\n      length: 2,\n      default: [0, 0],\n      transition: !0,\n      units: \"pixels\",\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"fill-translate-anchor\": {\n      type: \"enum\",\n      values: {\n        map: {},\n        viewport: {}\n      },\n      default: \"map\",\n      requires: [\"fill-translate\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"fill-pattern\": {\n      type: \"resolvedImage\",\n      transition: !0,\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"cross-faded-data-driven\"\n    }\n  },\n  Uo = {\n    \"line-opacity\": {\n      type: \"number\",\n      default: 1,\n      minimum: 0,\n      maximum: 1,\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"line-color\": {\n      type: \"color\",\n      default: \"#000000\",\n      transition: !0,\n      requires: [{\n        \"!\": \"line-pattern\"\n      }],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"line-translate\": {\n      type: \"array\",\n      value: \"number\",\n      length: 2,\n      default: [0, 0],\n      transition: !0,\n      units: \"pixels\",\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"line-translate-anchor\": {\n      type: \"enum\",\n      values: {\n        map: {},\n        viewport: {}\n      },\n      default: \"map\",\n      requires: [\"line-translate\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"line-width\": {\n      type: \"number\",\n      default: 1,\n      minimum: 0,\n      transition: !0,\n      units: \"pixels\",\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"line-gap-width\": {\n      type: \"number\",\n      default: 0,\n      minimum: 0,\n      transition: !0,\n      units: \"pixels\",\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"line-offset\": {\n      type: \"number\",\n      default: 0,\n      transition: !0,\n      units: \"pixels\",\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"line-blur\": {\n      type: \"number\",\n      default: 0,\n      minimum: 0,\n      transition: !0,\n      units: \"pixels\",\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"line-dasharray\": {\n      type: \"array\",\n      value: \"number\",\n      minimum: 0,\n      transition: !0,\n      units: \"line widths\",\n      requires: [{\n        \"!\": \"line-pattern\"\n      }],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"cross-faded\"\n    },\n    \"line-pattern\": {\n      type: \"resolvedImage\",\n      transition: !0,\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\", \"feature\"]\n      },\n      \"property-type\": \"cross-faded-data-driven\"\n    },\n    \"line-gradient\": {\n      type: \"color\",\n      transition: !1,\n      requires: [{\n        \"!\": \"line-dasharray\"\n      }, {\n        \"!\": \"line-pattern\"\n      }, {\n        source: \"geojson\",\n        has: {\n          lineMetrics: !0\n        }\n      }],\n      expression: {\n        interpolated: !0,\n        parameters: [\"line-progress\"]\n      },\n      \"property-type\": \"color-ramp\"\n    }\n  },\n  Vo = {\n    \"circle-radius\": {\n      type: \"number\",\n      default: 5,\n      minimum: 0,\n      transition: !0,\n      units: \"pixels\",\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"circle-color\": {\n      type: \"color\",\n      default: \"#000000\",\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"circle-blur\": {\n      type: \"number\",\n      default: 0,\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"circle-opacity\": {\n      type: \"number\",\n      default: 1,\n      minimum: 0,\n      maximum: 1,\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"circle-translate\": {\n      type: \"array\",\n      value: \"number\",\n      length: 2,\n      default: [0, 0],\n      transition: !0,\n      units: \"pixels\",\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"circle-translate-anchor\": {\n      type: \"enum\",\n      values: {\n        map: {},\n        viewport: {}\n      },\n      default: \"map\",\n      requires: [\"circle-translate\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"circle-pitch-scale\": {\n      type: \"enum\",\n      values: {\n        map: {},\n        viewport: {}\n      },\n      default: \"map\",\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"circle-pitch-alignment\": {\n      type: \"enum\",\n      values: {\n        map: {},\n        viewport: {}\n      },\n      default: \"viewport\",\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"circle-stroke-width\": {\n      type: \"number\",\n      default: 0,\n      minimum: 0,\n      transition: !0,\n      units: \"pixels\",\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"circle-stroke-color\": {\n      type: \"color\",\n      default: \"#000000\",\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"circle-stroke-opacity\": {\n      type: \"number\",\n      default: 1,\n      minimum: 0,\n      maximum: 1,\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    }\n  },\n  Go = {\n    \"heatmap-radius\": {\n      type: \"number\",\n      default: 30,\n      minimum: 1,\n      transition: !0,\n      units: \"pixels\",\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"heatmap-weight\": {\n      type: \"number\",\n      default: 1,\n      minimum: 0,\n      transition: !1,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"heatmap-intensity\": {\n      type: \"number\",\n      default: 1,\n      minimum: 0,\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"heatmap-color\": {\n      type: \"color\",\n      default: [\"interpolate\", [\"linear\"], [\"heatmap-density\"], 0, \"rgba(0, 0, 255, 0)\", 0.1, \"royalblue\", 0.3, \"cyan\", 0.5, \"lime\", 0.7, \"yellow\", 1, \"red\"],\n      transition: !1,\n      expression: {\n        interpolated: !0,\n        parameters: [\"heatmap-density\"]\n      },\n      \"property-type\": \"color-ramp\"\n    },\n    \"heatmap-opacity\": {\n      type: \"number\",\n      default: 1,\n      minimum: 0,\n      maximum: 1,\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    }\n  },\n  Ho = {\n    \"icon-opacity\": {\n      type: \"number\",\n      default: 1,\n      minimum: 0,\n      maximum: 1,\n      transition: !0,\n      requires: [\"icon-image\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-color\": {\n      type: \"color\",\n      default: \"#000000\",\n      transition: !0,\n      requires: [\"icon-image\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-halo-color\": {\n      type: \"color\",\n      default: \"rgba(0, 0, 0, 0)\",\n      transition: !0,\n      requires: [\"icon-image\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-halo-width\": {\n      type: \"number\",\n      default: 0,\n      minimum: 0,\n      transition: !0,\n      units: \"pixels\",\n      requires: [\"icon-image\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-halo-blur\": {\n      type: \"number\",\n      default: 0,\n      minimum: 0,\n      transition: !0,\n      units: \"pixels\",\n      requires: [\"icon-image\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"icon-translate\": {\n      type: \"array\",\n      value: \"number\",\n      length: 2,\n      default: [0, 0],\n      transition: !0,\n      units: \"pixels\",\n      requires: [\"icon-image\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"icon-translate-anchor\": {\n      type: \"enum\",\n      values: {\n        map: {},\n        viewport: {}\n      },\n      default: \"map\",\n      requires: [\"icon-image\", \"icon-translate\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-opacity\": {\n      type: \"number\",\n      default: 1,\n      minimum: 0,\n      maximum: 1,\n      transition: !0,\n      requires: [\"text-field\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-color\": {\n      type: \"color\",\n      default: \"#000000\",\n      transition: !0,\n      overridable: !0,\n      requires: [\"text-field\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-halo-color\": {\n      type: \"color\",\n      default: \"rgba(0, 0, 0, 0)\",\n      transition: !0,\n      requires: [\"text-field\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-halo-width\": {\n      type: \"number\",\n      default: 0,\n      minimum: 0,\n      transition: !0,\n      units: \"pixels\",\n      requires: [\"text-field\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-halo-blur\": {\n      type: \"number\",\n      default: 0,\n      minimum: 0,\n      transition: !0,\n      units: \"pixels\",\n      requires: [\"text-field\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\", \"feature\", \"feature-state\"]\n      },\n      \"property-type\": \"data-driven\"\n    },\n    \"text-translate\": {\n      type: \"array\",\n      value: \"number\",\n      length: 2,\n      default: [0, 0],\n      transition: !0,\n      units: \"pixels\",\n      requires: [\"text-field\"],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"text-translate-anchor\": {\n      type: \"enum\",\n      values: {\n        map: {},\n        viewport: {}\n      },\n      default: \"map\",\n      requires: [\"text-field\", \"text-translate\"],\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    }\n  },\n  Ko = {\n    \"raster-opacity\": {\n      type: \"number\",\n      default: 1,\n      minimum: 0,\n      maximum: 1,\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"raster-hue-rotate\": {\n      type: \"number\",\n      default: 0,\n      period: 360,\n      transition: !0,\n      units: \"degrees\",\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"raster-brightness-min\": {\n      type: \"number\",\n      default: 0,\n      minimum: 0,\n      maximum: 1,\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"raster-brightness-max\": {\n      type: \"number\",\n      default: 1,\n      minimum: 0,\n      maximum: 1,\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"raster-saturation\": {\n      type: \"number\",\n      default: 0,\n      minimum: -1,\n      maximum: 1,\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"raster-contrast\": {\n      type: \"number\",\n      default: 0,\n      minimum: -1,\n      maximum: 1,\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"raster-resampling\": {\n      type: \"enum\",\n      values: {\n        linear: {},\n        nearest: {}\n      },\n      default: \"linear\",\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"raster-fade-duration\": {\n      type: \"number\",\n      default: 300,\n      minimum: 0,\n      transition: !1,\n      units: \"milliseconds\",\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    }\n  },\n  Wo = {\n    \"hillshade-illumination-direction\": {\n      type: \"number\",\n      default: 335,\n      minimum: 0,\n      maximum: 359,\n      transition: !1,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"hillshade-illumination-anchor\": {\n      type: \"enum\",\n      values: {\n        map: {},\n        viewport: {}\n      },\n      default: \"viewport\",\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"hillshade-exaggeration\": {\n      type: \"number\",\n      default: 0.5,\n      minimum: 0,\n      maximum: 1,\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"hillshade-shadow-color\": {\n      type: \"color\",\n      default: \"#000000\",\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"hillshade-highlight-color\": {\n      type: \"color\",\n      default: \"#FFFFFF\",\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"hillshade-accent-color\": {\n      type: \"color\",\n      default: \"#000000\",\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    }\n  },\n  Zo = {\n    \"background-color\": {\n      type: \"color\",\n      default: \"#000000\",\n      transition: !0,\n      requires: [{\n        \"!\": \"background-pattern\"\n      }],\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    },\n    \"background-pattern\": {\n      type: \"resolvedImage\",\n      transition: !0,\n      expression: {\n        interpolated: !1,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"cross-faded\"\n    },\n    \"background-opacity\": {\n      type: \"number\",\n      default: 1,\n      minimum: 0,\n      maximum: 1,\n      transition: !0,\n      expression: {\n        interpolated: !0,\n        parameters: [\"zoom\"]\n      },\n      \"property-type\": \"data-constant\"\n    }\n  },\n  Jo = {\n    duration: {\n      type: \"number\",\n      default: 300,\n      minimum: 0,\n      units: \"milliseconds\"\n    },\n    delay: {\n      type: \"number\",\n      default: 0,\n      minimum: 0,\n      units: \"milliseconds\"\n    }\n  },\n  Yo = {\n    \"*\": {\n      type: \"string\"\n    }\n  },\n  Xo = {\n    $version: po,\n    $root: fo,\n    sources: yo,\n    source: mo,\n    source_vector: ho,\n    source_raster: go,\n    source_raster_dem: vo,\n    source_geojson: bo,\n    source_video: wo,\n    source_image: So,\n    layer: xo,\n    layout: ko,\n    layout_background: Lo,\n    layout_fill: Co,\n    layout_circle: Ao,\n    layout_heatmap: To,\n    \"layout_fill-extrusion\": {\n      visibility: {\n        type: \"enum\",\n        values: {\n          visible: {},\n          none: {}\n        },\n        default: \"visible\",\n        \"property-type\": \"constant\"\n      }\n    },\n    layout_line: Io,\n    layout_symbol: Eo,\n    layout_raster: Mo,\n    layout_hillshade: _o,\n    filter: zo,\n    filter_operator: Po,\n    geometry_type: Ro,\n    function: {\n      expression: {\n        type: \"expression\"\n      },\n      stops: {\n        type: \"array\",\n        value: \"function_stop\"\n      },\n      base: {\n        type: \"number\",\n        default: 1,\n        minimum: 0\n      },\n      property: {\n        type: \"string\",\n        default: \"$zoom\"\n      },\n      type: {\n        type: \"enum\",\n        values: {\n          identity: {},\n          exponential: {},\n          interval: {},\n          categorical: {}\n        },\n        default: \"exponential\"\n      },\n      colorSpace: {\n        type: \"enum\",\n        values: {\n          rgb: {},\n          lab: {},\n          hcl: {}\n        },\n        default: \"rgb\"\n      },\n      default: {\n        type: \"*\",\n        required: !1\n      }\n    },\n    function_stop: $o,\n    expression: jo,\n    light: No,\n    sky: Oo,\n    terrain: Fo,\n    projection: Do,\n    paint: qo,\n    paint_fill: Bo,\n    \"paint_fill-extrusion\": {\n      \"fill-extrusion-opacity\": {\n        type: \"number\",\n        default: 1,\n        minimum: 0,\n        maximum: 1,\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"fill-extrusion-color\": {\n        type: \"color\",\n        default: \"#000000\",\n        transition: !0,\n        requires: [{\n          \"!\": \"fill-extrusion-pattern\"\n        }],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"fill-extrusion-translate\": {\n        type: \"array\",\n        value: \"number\",\n        length: 2,\n        default: [0, 0],\n        transition: !0,\n        units: \"pixels\",\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"fill-extrusion-translate-anchor\": {\n        type: \"enum\",\n        values: {\n          map: {},\n          viewport: {}\n        },\n        default: \"map\",\n        requires: [\"fill-extrusion-translate\"],\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      },\n      \"fill-extrusion-pattern\": {\n        type: \"resolvedImage\",\n        transition: !0,\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\", \"feature\"]\n        },\n        \"property-type\": \"cross-faded-data-driven\"\n      },\n      \"fill-extrusion-height\": {\n        type: \"number\",\n        default: 0,\n        minimum: 0,\n        units: \"meters\",\n        transition: !0,\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"fill-extrusion-base\": {\n        type: \"number\",\n        default: 0,\n        minimum: 0,\n        units: \"meters\",\n        transition: !0,\n        requires: [\"fill-extrusion-height\"],\n        expression: {\n          interpolated: !0,\n          parameters: [\"zoom\", \"feature\", \"feature-state\"]\n        },\n        \"property-type\": \"data-driven\"\n      },\n      \"fill-extrusion-vertical-gradient\": {\n        type: \"boolean\",\n        default: !0,\n        transition: !1,\n        expression: {\n          interpolated: !1,\n          parameters: [\"zoom\"]\n        },\n        \"property-type\": \"data-constant\"\n      }\n    },\n    paint_line: Uo,\n    paint_circle: Vo,\n    paint_heatmap: Go,\n    paint_symbol: Ho,\n    paint_raster: Ko,\n    paint_hillshade: Wo,\n    paint_background: Zo,\n    transition: Jo,\n    \"property-type\": {\n      \"data-driven\": {\n        type: \"property-type\"\n      },\n      \"cross-faded\": {\n        type: \"property-type\"\n      },\n      \"cross-faded-data-driven\": {\n        type: \"property-type\"\n      },\n      \"color-ramp\": {\n        type: \"property-type\"\n      },\n      \"data-constant\": {\n        type: \"property-type\"\n      },\n      constant: {\n        type: \"property-type\"\n      }\n    },\n    promoteId: Yo\n  };\nclass h {\n  constructor(e, t, n, a) {\n    this.message = (e ? `${e}: ` : \"\") + n, a && (this.identifier = a), t != null && t.__line__ && (this.line = t.__line__);\n  }\n}\nfunction ct(r, ...e) {\n  for (const t of e) for (const n in t) r[n] = t[n];\n  return r;\n}\nclass oe extends Error {\n  constructor(e, t) {\n    super(t), this.message = t, this.key = e;\n  }\n}\nclass cr {\n  constructor(e, t = []) {\n    this.parent = e, this.bindings = {};\n    for (const [n, a] of t) this.bindings[n] = a;\n  }\n  concat(e) {\n    return new cr(this, e);\n  }\n  get(e) {\n    if (this.bindings[e]) return this.bindings[e];\n    if (this.parent) return this.parent.get(e);\n    throw new Error(`${e} not found in scope.`);\n  }\n  has(e) {\n    return this.bindings[e] ? !0 : this.parent ? this.parent.has(e) : !1;\n  }\n}\nconst bt = {\n    kind: \"null\"\n  },\n  g = {\n    kind: \"number\"\n  },\n  I = {\n    kind: \"string\"\n  },\n  C = {\n    kind: \"boolean\"\n  },\n  ie = {\n    kind: \"color\"\n  },\n  wt = {\n    kind: \"projectionDefinition\"\n  },\n  Re = {\n    kind: \"object\"\n  },\n  A = {\n    kind: \"value\"\n  },\n  Qo = {\n    kind: \"error\"\n  },\n  St = {\n    kind: \"collator\"\n  },\n  xt = {\n    kind: \"formatted\"\n  },\n  kt = {\n    kind: \"padding\"\n  },\n  Xe = {\n    kind: \"resolvedImage\"\n  },\n  Lt = {\n    kind: \"variableAnchorOffsetCollection\"\n  };\nfunction W(r, e) {\n  return {\n    kind: \"array\",\n    itemType: r,\n    N: e\n  };\n}\nfunction N(r) {\n  if (r.kind === \"array\") {\n    const e = N(r.itemType);\n    return typeof r.N == \"number\" ? `array<${e}, ${r.N}>` : r.itemType.kind === \"value\" ? \"array\" : `array<${e}>`;\n  } else return r.kind;\n}\nconst ei = [bt, g, I, C, ie, wt, xt, Re, W(A), kt, Xe, Lt];\nfunction Ve(r, e) {\n  if (e.kind === \"error\") return null;\n  if (r.kind === \"array\") {\n    if (e.kind === \"array\" && (e.N === 0 && e.itemType.kind === \"value\" || !Ve(r.itemType, e.itemType)) && (typeof r.N != \"number\" || r.N === e.N)) return null;\n  } else {\n    if (r.kind === e.kind) return null;\n    if (r.kind === \"value\") {\n      for (const t of ei) if (!Ve(t, e)) return null;\n    }\n  }\n  return `Expected ${N(r)} but found ${N(e)} instead.`;\n}\nfunction pr(r, e) {\n  return e.some(t => t.kind === r.kind);\n}\nfunction Ce(r, e) {\n  return e.some(t => t === \"null\" ? r === null : t === \"array\" ? Array.isArray(r) : t === \"object\" ? r && !Array.isArray(r) && typeof r == \"object\" : t === typeof r);\n}\nfunction _e(r, e) {\n  return r.kind === \"array\" && e.kind === \"array\" ? r.itemType.kind === e.itemType.kind && typeof r.N == \"number\" : r.kind === e.kind;\n}\nconst Ln = 0.96422,\n  Cn = 1,\n  An = 0.82521,\n  Tn = 4 / 29,\n  $e = 6 / 29,\n  In = 3 * $e * $e,\n  ti = $e * $e * $e,\n  ri = Math.PI / 180,\n  ni = 180 / Math.PI;\nfunction En(r) {\n  return r = r % 360, r < 0 && (r += 360), r;\n}\nfunction Mn([r, e, t, n]) {\n  r = Ot(r), e = Ot(e), t = Ot(t);\n  let a, o;\n  const i = Ft((0.2225045 * r + 0.7168786 * e + 0.0606169 * t) / Cn);\n  r === e && e === t ? a = o = i : (a = Ft((0.4360747 * r + 0.3850649 * e + 0.1430804 * t) / Ln), o = Ft((0.0139322 * r + 0.0971045 * e + 0.7141733 * t) / An));\n  const s = 116 * i - 16;\n  return [s < 0 ? 0 : s, 500 * (a - i), 200 * (i - o), n];\n}\nfunction Ot(r) {\n  return r <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);\n}\nfunction Ft(r) {\n  return r > ti ? Math.pow(r, 1 / 3) : r / In + Tn;\n}\nfunction _n([r, e, t, n]) {\n  let a = (r + 16) / 116,\n    o = isNaN(e) ? a : a + e / 500,\n    i = isNaN(t) ? a : a - t / 200;\n  return a = Cn * qt(a), o = Ln * qt(o), i = An * qt(i), [Dt(3.1338561 * o - 1.6168667 * a - 0.4906146 * i),\n  // D50 -> sRGB\n  Dt(-0.9787684 * o + 1.9161415 * a + 0.033454 * i), Dt(0.0719453 * o - 0.2289914 * a + 1.4052427 * i), n];\n}\nfunction Dt(r) {\n  return r = r <= 304e-5 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055, r < 0 ? 0 : r > 1 ? 1 : r;\n}\nfunction qt(r) {\n  return r > $e ? r * r * r : In * (r - Tn);\n}\nfunction ai(r) {\n  const [e, t, n, a] = Mn(r),\n    o = Math.sqrt(t * t + n * n);\n  return [Math.round(o * 1e4) ? En(Math.atan2(n, t) * ni) : NaN, o, e, a];\n}\nfunction oi([r, e, t, n]) {\n  return r = isNaN(r) ? 0 : r * ri, _n([t, Math.cos(r) * e, Math.sin(r) * e, n]);\n}\nfunction ii([r, e, t, n]) {\n  r = En(r), e /= 100, t /= 100;\n  function a(o) {\n    const i = (o + r / 30) % 12,\n      s = e * Math.min(t, 1 - t);\n    return t - s * Math.max(-1, Math.min(i - 3, 9 - i, 1));\n  }\n  return [a(0), a(8), a(4), n];\n}\nfunction si(r) {\n  if (r = r.toLowerCase().trim(), r === \"transparent\") return [0, 0, 0, 0];\n  const e = li[r];\n  if (e) {\n    const [a, o, i] = e;\n    return [a / 255, o / 255, i / 255, 1];\n  }\n  if (r.startsWith(\"#\") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(r)) {\n    const o = r.length < 6 ? 1 : 2;\n    let i = 1;\n    return [at(r.slice(i, i += o)), at(r.slice(i, i += o)), at(r.slice(i, i += o)), at(r.slice(i, i + o) || \"ff\")];\n  }\n  if (r.startsWith(\"rgb\")) {\n    const a = /^rgba?\\(\\s*([\\de.+-]+)(%)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)(%)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)(%)?(?:\\s*([,\\/])\\s*([\\de.+-]+)(%)?)?\\s*\\)$/,\n      o = r.match(a);\n    if (o) {\n      const [i,\n        // eslint-disable-line @typescript-eslint/no-unused-vars\n        s,\n        // <numeric>\n        l,\n        // %         (optional)\n        u,\n        // ,         (optional)\n        c,\n        // <numeric>\n        p,\n        // %         (optional)\n        m,\n        // ,         (optional)\n        f,\n        // <numeric>\n        d,\n        // %         (optional)\n        y,\n        // ,|/       (optional)\n        v,\n        // <numeric> (optional)\n        w\n        // %         (optional)\n        ] = o,\n        b = [u || \" \", m || \" \", y].join(\"\");\n      if (b === \"  \" || b === \"  /\" || b === \",,\" || b === \",,,\") {\n        const T = [l, p, d].join(\"\"),\n          j = T === \"%%%\" ? 100 : T === \"\" ? 255 : 0;\n        if (j) {\n          const R = [ze(+s / j, 0, 1), ze(+c / j, 0, 1), ze(+f / j, 0, 1), v ? Kr(+v, w) : 1];\n          if (Wr(R)) return R;\n        }\n      }\n      return;\n    }\n  }\n  const t = /^hsla?\\(\\s*([\\de.+-]+)(?:deg)?(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)%(?:\\s+|\\s*(,)\\s*)([\\de.+-]+)%(?:\\s*([,\\/])\\s*([\\de.+-]+)(%)?)?\\s*\\)$/,\n    n = r.match(t);\n  if (n) {\n    const [a,\n      // eslint-disable-line @typescript-eslint/no-unused-vars\n      o,\n      // <numeric>\n      i,\n      // ,         (optional)\n      s,\n      // <numeric>\n      l,\n      // ,         (optional)\n      u,\n      // <numeric>\n      c,\n      // ,|/       (optional)\n      p,\n      // <numeric> (optional)\n      m\n      // %         (optional)\n      ] = n,\n      f = [i || \" \", l || \" \", c].join(\"\");\n    if (f === \"  \" || f === \"  /\" || f === \",,\" || f === \",,,\") {\n      const d = [+o, ze(+s, 0, 100), ze(+u, 0, 100), p ? Kr(+p, m) : 1];\n      if (Wr(d)) return ii(d);\n    }\n  }\n}\nfunction at(r) {\n  return parseInt(r.padEnd(2, r), 16) / 255;\n}\nfunction Kr(r, e) {\n  return ze(e ? r / 100 : r, 0, 1);\n}\nfunction ze(r, e, t) {\n  return Math.min(Math.max(e, r), t);\n}\nfunction Wr(r) {\n  return !r.some(Number.isNaN);\n}\nconst li = {\n  aliceblue: [240, 248, 255],\n  antiquewhite: [250, 235, 215],\n  aqua: [0, 255, 255],\n  aquamarine: [127, 255, 212],\n  azure: [240, 255, 255],\n  beige: [245, 245, 220],\n  bisque: [255, 228, 196],\n  black: [0, 0, 0],\n  blanchedalmond: [255, 235, 205],\n  blue: [0, 0, 255],\n  blueviolet: [138, 43, 226],\n  brown: [165, 42, 42],\n  burlywood: [222, 184, 135],\n  cadetblue: [95, 158, 160],\n  chartreuse: [127, 255, 0],\n  chocolate: [210, 105, 30],\n  coral: [255, 127, 80],\n  cornflowerblue: [100, 149, 237],\n  cornsilk: [255, 248, 220],\n  crimson: [220, 20, 60],\n  cyan: [0, 255, 255],\n  darkblue: [0, 0, 139],\n  darkcyan: [0, 139, 139],\n  darkgoldenrod: [184, 134, 11],\n  darkgray: [169, 169, 169],\n  darkgreen: [0, 100, 0],\n  darkgrey: [169, 169, 169],\n  darkkhaki: [189, 183, 107],\n  darkmagenta: [139, 0, 139],\n  darkolivegreen: [85, 107, 47],\n  darkorange: [255, 140, 0],\n  darkorchid: [153, 50, 204],\n  darkred: [139, 0, 0],\n  darksalmon: [233, 150, 122],\n  darkseagreen: [143, 188, 143],\n  darkslateblue: [72, 61, 139],\n  darkslategray: [47, 79, 79],\n  darkslategrey: [47, 79, 79],\n  darkturquoise: [0, 206, 209],\n  darkviolet: [148, 0, 211],\n  deeppink: [255, 20, 147],\n  deepskyblue: [0, 191, 255],\n  dimgray: [105, 105, 105],\n  dimgrey: [105, 105, 105],\n  dodgerblue: [30, 144, 255],\n  firebrick: [178, 34, 34],\n  floralwhite: [255, 250, 240],\n  forestgreen: [34, 139, 34],\n  fuchsia: [255, 0, 255],\n  gainsboro: [220, 220, 220],\n  ghostwhite: [248, 248, 255],\n  gold: [255, 215, 0],\n  goldenrod: [218, 165, 32],\n  gray: [128, 128, 128],\n  green: [0, 128, 0],\n  greenyellow: [173, 255, 47],\n  grey: [128, 128, 128],\n  honeydew: [240, 255, 240],\n  hotpink: [255, 105, 180],\n  indianred: [205, 92, 92],\n  indigo: [75, 0, 130],\n  ivory: [255, 255, 240],\n  khaki: [240, 230, 140],\n  lavender: [230, 230, 250],\n  lavenderblush: [255, 240, 245],\n  lawngreen: [124, 252, 0],\n  lemonchiffon: [255, 250, 205],\n  lightblue: [173, 216, 230],\n  lightcoral: [240, 128, 128],\n  lightcyan: [224, 255, 255],\n  lightgoldenrodyellow: [250, 250, 210],\n  lightgray: [211, 211, 211],\n  lightgreen: [144, 238, 144],\n  lightgrey: [211, 211, 211],\n  lightpink: [255, 182, 193],\n  lightsalmon: [255, 160, 122],\n  lightseagreen: [32, 178, 170],\n  lightskyblue: [135, 206, 250],\n  lightslategray: [119, 136, 153],\n  lightslategrey: [119, 136, 153],\n  lightsteelblue: [176, 196, 222],\n  lightyellow: [255, 255, 224],\n  lime: [0, 255, 0],\n  limegreen: [50, 205, 50],\n  linen: [250, 240, 230],\n  magenta: [255, 0, 255],\n  maroon: [128, 0, 0],\n  mediumaquamarine: [102, 205, 170],\n  mediumblue: [0, 0, 205],\n  mediumorchid: [186, 85, 211],\n  mediumpurple: [147, 112, 219],\n  mediumseagreen: [60, 179, 113],\n  mediumslateblue: [123, 104, 238],\n  mediumspringgreen: [0, 250, 154],\n  mediumturquoise: [72, 209, 204],\n  mediumvioletred: [199, 21, 133],\n  midnightblue: [25, 25, 112],\n  mintcream: [245, 255, 250],\n  mistyrose: [255, 228, 225],\n  moccasin: [255, 228, 181],\n  navajowhite: [255, 222, 173],\n  navy: [0, 0, 128],\n  oldlace: [253, 245, 230],\n  olive: [128, 128, 0],\n  olivedrab: [107, 142, 35],\n  orange: [255, 165, 0],\n  orangered: [255, 69, 0],\n  orchid: [218, 112, 214],\n  palegoldenrod: [238, 232, 170],\n  palegreen: [152, 251, 152],\n  paleturquoise: [175, 238, 238],\n  palevioletred: [219, 112, 147],\n  papayawhip: [255, 239, 213],\n  peachpuff: [255, 218, 185],\n  peru: [205, 133, 63],\n  pink: [255, 192, 203],\n  plum: [221, 160, 221],\n  powderblue: [176, 224, 230],\n  purple: [128, 0, 128],\n  rebeccapurple: [102, 51, 153],\n  red: [255, 0, 0],\n  rosybrown: [188, 143, 143],\n  royalblue: [65, 105, 225],\n  saddlebrown: [139, 69, 19],\n  salmon: [250, 128, 114],\n  sandybrown: [244, 164, 96],\n  seagreen: [46, 139, 87],\n  seashell: [255, 245, 238],\n  sienna: [160, 82, 45],\n  silver: [192, 192, 192],\n  skyblue: [135, 206, 235],\n  slateblue: [106, 90, 205],\n  slategray: [112, 128, 144],\n  slategrey: [112, 128, 144],\n  snow: [255, 250, 250],\n  springgreen: [0, 255, 127],\n  steelblue: [70, 130, 180],\n  tan: [210, 180, 140],\n  teal: [0, 128, 128],\n  thistle: [216, 191, 216],\n  tomato: [255, 99, 71],\n  turquoise: [64, 224, 208],\n  violet: [238, 130, 238],\n  wheat: [245, 222, 179],\n  white: [255, 255, 255],\n  whitesmoke: [245, 245, 245],\n  yellow: [255, 255, 0],\n  yellowgreen: [154, 205, 50]\n};\nfunction ve(r, e, t) {\n  return r + t * (e - r);\n}\nfunction Ge(r, e, t) {\n  return r.map((n, a) => ve(n, e[a], t));\n}\nclass $ {\n  /**\n   * @param r Red component premultiplied by `alpha` 0..1\n   * @param g Green component premultiplied by `alpha` 0..1\n   * @param b Blue component premultiplied by `alpha` 0..1\n   * @param [alpha=1] Alpha component 0..1\n   * @param [premultiplied=true] Whether the `r`, `g` and `b` values have already\n   * been multiplied by alpha. If `true` nothing happens if `false` then they will\n   * be multiplied automatically.\n   */\n  constructor(e, t, n, a = 1, o = !0) {\n    this.r = e, this.g = t, this.b = n, this.a = a, o || (this.r *= a, this.g *= a, this.b *= a, a || this.overwriteGetter(\"rgb\", [e, t, n, a]));\n  }\n  /**\n   * Parses CSS color strings and converts colors to sRGB color space if needed.\n   * Officially supported color formats:\n   * - keyword, e.g. 'aquamarine' or 'steelblue'\n   * - hex (with 3, 4, 6 or 8 digits), e.g. '#f0f' or '#e9bebea9'\n   * - rgb and rgba, e.g. 'rgb(0,240,120)' or 'rgba(0%,94%,47%,0.1)' or 'rgb(0 240 120 / .3)'\n   * - hsl and hsla, e.g. 'hsl(0,0%,83%)' or 'hsla(0,0%,83%,.5)' or 'hsl(0 0% 83% / 20%)'\n   *\n   * @param input CSS color string to parse.\n   * @returns A `Color` instance, or `undefined` if the input is not a valid color string.\n   */\n  static parse(e) {\n    if (e instanceof $) return e;\n    if (typeof e != \"string\") return;\n    const t = si(e);\n    if (t) return new $(...t, !1);\n  }\n  /**\n   * Used in color interpolation and by 'to-rgba' expression.\n   *\n   * @returns Gien color, with reversed alpha blending, in sRGB color space.\n   */\n  get rgb() {\n    const {\n        r: e,\n        g: t,\n        b: n,\n        a\n      } = this,\n      o = a || 1 / 0;\n    return this.overwriteGetter(\"rgb\", [e / o, t / o, n / o, a]);\n  }\n  /**\n   * Used in color interpolation.\n   *\n   * @returns Gien color, with reversed alpha blending, in HCL color space.\n   */\n  get hcl() {\n    return this.overwriteGetter(\"hcl\", ai(this.rgb));\n  }\n  /**\n   * Used in color interpolation.\n   *\n   * @returns Gien color, with reversed alpha blending, in LAB color space.\n   */\n  get lab() {\n    return this.overwriteGetter(\"lab\", Mn(this.rgb));\n  }\n  /**\n   * Lazy getter pattern. When getter is called for the first time lazy value\n   * is calculated and then overwrites getter function in given object instance.\n   *\n   * @example:\n   * const redColor = Color.parse('red');\n   * let x = redColor.hcl; // this will invoke `get hcl()`, which will calculate\n   * // the value of red in HCL space and invoke this `overwriteGetter` function\n   * // which in turn will set a field with a key 'hcl' in the `redColor` object.\n   * // In other words it will override `get hcl()` from its `Color` prototype\n   * // with its own property: hcl = [calculated red value in hcl].\n   * let y = redColor.hcl; // next call will no longer invoke getter but simply\n   * // return the previously calculated value\n   * x === y; // true - `x` is exactly the same object as `y`\n   *\n   * @param getterKey Getter key\n   * @param lazyValue Lazily calculated value to be memoized by current instance\n   * @private\n   */\n  overwriteGetter(e, t) {\n    return Object.defineProperty(this, e, {\n      value: t\n    }), t;\n  }\n  /**\n   * Used by 'to-string' expression.\n   *\n   * @returns Serialized color in format `rgba(r,g,b,a)`\n   * where r,g,b are numbers within 0..255 and alpha is number within 1..0\n   *\n   * @example\n   * var purple = new Color.parse('purple');\n   * purple.toString; // = \"rgba(128,0,128,1)\"\n   * var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');\n   * translucentGreen.toString(); // = \"rgba(26,207,26,0.73)\"\n   */\n  toString() {\n    const [e, t, n, a] = this.rgb;\n    return `rgba(${[e, t, n].map(o => Math.round(o * 255)).join(\",\")},${a})`;\n  }\n  static interpolate(e, t, n, a = \"rgb\") {\n    switch (a) {\n      case \"rgb\":\n        {\n          const [o, i, s, l] = Ge(e.rgb, t.rgb, n);\n          return new $(o, i, s, l, !1);\n        }\n      case \"hcl\":\n        {\n          const [o, i, s, l] = e.hcl,\n            [u, c, p, m] = t.hcl;\n          let f, d;\n          if (!isNaN(o) && !isNaN(u)) {\n            let T = u - o;\n            u > o && T > 180 ? T -= 360 : u < o && o - u > 180 && (T += 360), f = o + n * T;\n          } else isNaN(o) ? isNaN(u) ? f = NaN : (f = u, (s === 1 || s === 0) && (d = c)) : (f = o, (p === 1 || p === 0) && (d = i));\n          const [y, v, w, b] = oi([f, d ?? ve(i, c, n), ve(s, p, n), ve(l, m, n)]);\n          return new $(y, v, w, b, !1);\n        }\n      case \"lab\":\n        {\n          const [o, i, s, l] = _n(Ge(e.lab, t.lab, n));\n          return new $(o, i, s, l, !1);\n        }\n    }\n  }\n}\n$.black = new $(0, 0, 0, 1);\n$.white = new $(1, 1, 1, 1);\n$.transparent = new $(0, 0, 0, 0);\n$.red = new $(1, 0, 0, 1);\nclass fr {\n  constructor(e, t, n) {\n    e ? this.sensitivity = t ? \"variant\" : \"case\" : this.sensitivity = t ? \"accent\" : \"base\", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], {\n      sensitivity: this.sensitivity,\n      usage: \"search\"\n    });\n  }\n  compare(e, t) {\n    return this.collator.compare(e, t);\n  }\n  resolvedLocale() {\n    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;\n  }\n}\nclass Jt {\n  constructor(e, t, n, a, o) {\n    this.text = e, this.image = t, this.scale = n, this.fontStack = a, this.textColor = o;\n  }\n}\nclass pe {\n  constructor(e) {\n    this.sections = e;\n  }\n  static fromString(e) {\n    return new pe([new Jt(e, null, null, null, null)]);\n  }\n  isEmpty() {\n    return this.sections.length === 0 ? !0 : !this.sections.some(e => e.text.length !== 0 || e.image && e.image.name.length !== 0);\n  }\n  static factory(e) {\n    return e instanceof pe ? e : pe.fromString(e);\n  }\n  toString() {\n    return this.sections.length === 0 ? \"\" : this.sections.map(e => e.text).join(\"\");\n  }\n}\nclass J {\n  constructor(e) {\n    this.values = e.slice();\n  }\n  /**\n   * Numeric padding values\n   * @param input A padding value\n   * @returns A `Padding` instance, or `undefined` if the input is not a valid padding value.\n   */\n  static parse(e) {\n    if (e instanceof J) return e;\n    if (typeof e == \"number\") return new J([e, e, e, e]);\n    if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {\n      for (const t of e) if (typeof t != \"number\") return;\n      switch (e.length) {\n        case 1:\n          e = [e[0], e[0], e[0], e[0]];\n          break;\n        case 2:\n          e = [e[0], e[1], e[0], e[1]];\n          break;\n        case 3:\n          e = [e[0], e[1], e[2], e[1]];\n          break;\n      }\n      return new J(e);\n    }\n  }\n  toString() {\n    return JSON.stringify(this.values);\n  }\n  static interpolate(e, t, n) {\n    return new J(Ge(e.values, t.values, n));\n  }\n}\nclass D {\n  constructor(e) {\n    this.name = \"ExpressionEvaluationError\", this.message = e;\n  }\n  toJSON() {\n    return this.message;\n  }\n}\nconst ui = /* @__PURE__ */new Set([\"center\", \"left\", \"right\", \"top\", \"bottom\", \"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"]);\nclass ne {\n  constructor(e) {\n    this.values = e.slice();\n  }\n  static parse(e) {\n    if (e instanceof ne) return e;\n    if (!(!Array.isArray(e) || e.length < 1 || e.length % 2 !== 0)) {\n      for (let t = 0; t < e.length; t += 2) {\n        const n = e[t],\n          a = e[t + 1];\n        if (typeof n != \"string\" || !ui.has(n) || !Array.isArray(a) || a.length !== 2 || typeof a[0] != \"number\" || typeof a[1] != \"number\") return;\n      }\n      return new ne(e);\n    }\n  }\n  toString() {\n    return JSON.stringify(this.values);\n  }\n  static interpolate(e, t, n) {\n    const a = e.values,\n      o = t.values;\n    if (a.length !== o.length) throw new D(`Cannot interpolate values of different length. from: ${e.toString()}, to: ${t.toString()}`);\n    const i = [];\n    for (let s = 0; s < a.length; s += 2) {\n      if (a[s] !== o[s]) throw new D(`Cannot interpolate values containing mismatched anchors. from[${s}]: ${a[s]}, to[${s}]: ${o[s]}`);\n      i.push(a[s]);\n      const [l, u] = a[s + 1],\n        [c, p] = o[s + 1];\n      i.push([ve(l, c, n), ve(u, p, n)]);\n    }\n    return new ne(i);\n  }\n}\nclass we {\n  constructor(e) {\n    this.name = e.name, this.available = e.available;\n  }\n  toString() {\n    return this.name;\n  }\n  static fromString(e) {\n    return e ? new we({\n      name: e,\n      available: !1\n    }) : null;\n  }\n}\nclass ee {\n  constructor(e, t, n) {\n    this.from = e, this.to = t, this.transition = n;\n  }\n  static interpolate(e, t, n) {\n    return new ee(e, t, n);\n  }\n  static parse(e) {\n    if (e instanceof ee) return e;\n    if (Array.isArray(e) && e.length === 3 && typeof e[0] == \"string\" && typeof e[1] == \"string\" && typeof e[2] == \"number\") return new ee(e[0], e[1], e[2]);\n    if (typeof e == \"object\" && typeof e.from == \"string\" && typeof e.to == \"string\" && typeof e.transition == \"number\") return new ee(e.from, e.to, e.transition);\n    if (typeof e == \"string\") return new ee(e, e, 1);\n  }\n}\nfunction zn(r, e, t, n) {\n  return typeof r == \"number\" && r >= 0 && r <= 255 && typeof e == \"number\" && e >= 0 && e <= 255 && typeof t == \"number\" && t >= 0 && t <= 255 ? typeof n > \"u\" || typeof n == \"number\" && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[r, e, t, n].join(\", \")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n == \"number\" ? [r, e, t, n] : [r, e, t]).join(\", \")}]: 'r', 'g', and 'b' must be between 0 and 255.`;\n}\nfunction He(r) {\n  if (r === null || typeof r == \"string\" || typeof r == \"boolean\" || typeof r == \"number\" || r instanceof ee || r instanceof $ || r instanceof fr || r instanceof pe || r instanceof J || r instanceof ne || r instanceof we) return !0;\n  if (Array.isArray(r)) {\n    for (const e of r) if (!He(e)) return !1;\n    return !0;\n  } else if (typeof r == \"object\") {\n    for (const e in r) if (!He(r[e])) return !1;\n    return !0;\n  } else return !1;\n}\nfunction q(r) {\n  if (r === null) return bt;\n  if (typeof r == \"string\") return I;\n  if (typeof r == \"boolean\") return C;\n  if (typeof r == \"number\") return g;\n  if (r instanceof $) return ie;\n  if (r instanceof ee) return wt;\n  if (r instanceof fr) return St;\n  if (r instanceof pe) return xt;\n  if (r instanceof J) return kt;\n  if (r instanceof ne) return Lt;\n  if (r instanceof we) return Xe;\n  if (Array.isArray(r)) {\n    const e = r.length;\n    let t;\n    for (const n of r) {\n      const a = q(n);\n      if (!t) t = a;else {\n        if (t === a) continue;\n        t = A;\n        break;\n      }\n    }\n    return W(t || A, e);\n  } else return Re;\n}\nfunction Be(r) {\n  const e = typeof r;\n  return r === null ? \"\" : e === \"string\" || e === \"number\" || e === \"boolean\" ? String(r) : r instanceof $ || r instanceof ee || r instanceof pe || r instanceof J || r instanceof ne || r instanceof we ? r.toString() : JSON.stringify(r);\n}\nclass je {\n  constructor(e, t) {\n    this.type = e, this.value = t;\n  }\n  static parse(e, t) {\n    if (e.length !== 2) return t.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);\n    if (!He(e[1])) return t.error(\"invalid value\");\n    const n = e[1];\n    let a = q(n);\n    const o = t.expectedType;\n    return a.kind === \"array\" && a.N === 0 && o && o.kind === \"array\" && (typeof o.N != \"number\" || o.N === 0) && (a = o), new je(a, n);\n  }\n  evaluate() {\n    return this.value;\n  }\n  eachChild() {}\n  outputDefined() {\n    return !0;\n  }\n}\nconst ot = {\n  string: I,\n  number: g,\n  boolean: C,\n  object: Re\n};\nclass te {\n  constructor(e, t) {\n    this.type = e, this.args = t;\n  }\n  static parse(e, t) {\n    if (e.length < 2) return t.error(\"Expected at least one argument.\");\n    let n = 1,\n      a;\n    const o = e[0];\n    if (o === \"array\") {\n      let s;\n      if (e.length > 2) {\n        const u = e[1];\n        if (typeof u != \"string\" || !(u in ot) || u === \"object\") return t.error('The item type argument of \"array\" must be one of string, number, boolean', 1);\n        s = ot[u], n++;\n      } else s = A;\n      let l;\n      if (e.length > 3) {\n        if (e[2] !== null && (typeof e[2] != \"number\" || e[2] < 0 || e[2] !== Math.floor(e[2]))) return t.error('The length argument to \"array\" must be a positive integer literal', 2);\n        l = e[2], n++;\n      }\n      a = W(s, l);\n    } else {\n      if (!ot[o]) throw new Error(`Types doesn't contain name = ${o}`);\n      a = ot[o];\n    }\n    const i = [];\n    for (; n < e.length; n++) {\n      const s = t.parse(e[n], n, A);\n      if (!s) return null;\n      i.push(s);\n    }\n    return new te(a, i);\n  }\n  evaluate(e) {\n    for (let t = 0; t < this.args.length; t++) {\n      const n = this.args[t].evaluate(e);\n      if (Ve(this.type, q(n))) {\n        if (t === this.args.length - 1) throw new D(`Expected value to be of type ${N(this.type)}, but found ${N(q(n))} instead.`);\n      } else return n;\n    }\n    throw new Error();\n  }\n  eachChild(e) {\n    this.args.forEach(e);\n  }\n  outputDefined() {\n    return this.args.every(e => e.outputDefined());\n  }\n}\nconst Zr = {\n  \"to-boolean\": C,\n  \"to-color\": ie,\n  \"to-number\": g,\n  \"to-string\": I\n};\nclass ge {\n  constructor(e, t) {\n    this.type = e, this.args = t;\n  }\n  static parse(e, t) {\n    if (e.length < 2) return t.error(\"Expected at least one argument.\");\n    const n = e[0];\n    if (!Zr[n]) throw new Error(`Can't parse ${n} as it is not part of the known types`);\n    if ((n === \"to-boolean\" || n === \"to-string\") && e.length !== 2) return t.error(\"Expected one argument.\");\n    const a = Zr[n],\n      o = [];\n    for (let i = 1; i < e.length; i++) {\n      const s = t.parse(e[i], i, A);\n      if (!s) return null;\n      o.push(s);\n    }\n    return new ge(a, o);\n  }\n  evaluate(e) {\n    switch (this.type.kind) {\n      case \"boolean\":\n        return !!this.args[0].evaluate(e);\n      case \"color\":\n        {\n          let t, n;\n          for (const a of this.args) {\n            if (t = a.evaluate(e), n = null, t instanceof $) return t;\n            if (typeof t == \"string\") {\n              const o = e.parseColor(t);\n              if (o) return o;\n            } else if (Array.isArray(t) && (t.length < 3 || t.length > 4 ? n = `Invalid rgba value ${JSON.stringify(t)}: expected an array containing either three or four numeric values.` : n = zn(t[0], t[1], t[2], t[3]), !n)) return new $(t[0] / 255, t[1] / 255, t[2] / 255, t[3]);\n          }\n          throw new D(n || `Could not parse color from value '${typeof t == \"string\" ? t : JSON.stringify(t)}'`);\n        }\n      case \"padding\":\n        {\n          let t;\n          for (const n of this.args) {\n            t = n.evaluate(e);\n            const a = J.parse(t);\n            if (a) return a;\n          }\n          throw new D(`Could not parse padding from value '${typeof t == \"string\" ? t : JSON.stringify(t)}'`);\n        }\n      case \"variableAnchorOffsetCollection\":\n        {\n          let t;\n          for (const n of this.args) {\n            t = n.evaluate(e);\n            const a = ne.parse(t);\n            if (a) return a;\n          }\n          throw new D(`Could not parse variableAnchorOffsetCollection from value '${typeof t == \"string\" ? t : JSON.stringify(t)}'`);\n        }\n      case \"number\":\n        {\n          let t = null;\n          for (const n of this.args) {\n            if (t = n.evaluate(e), t === null) return 0;\n            const a = Number(t);\n            if (!isNaN(a)) return a;\n          }\n          throw new D(`Could not convert ${JSON.stringify(t)} to number.`);\n        }\n      case \"formatted\":\n        return pe.fromString(Be(this.args[0].evaluate(e)));\n      case \"resolvedImage\":\n        return we.fromString(Be(this.args[0].evaluate(e)));\n      case \"projectionDefinition\":\n        return this.args[0].evaluate(e);\n      default:\n        return Be(this.args[0].evaluate(e));\n    }\n  }\n  eachChild(e) {\n    this.args.forEach(e);\n  }\n  outputDefined() {\n    return this.args.every(e => e.outputDefined());\n  }\n}\nconst ci = [\"Unknown\", \"Point\", \"LineString\", \"Polygon\"];\nclass Pn {\n  constructor() {\n    this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;\n  }\n  id() {\n    return this.feature && \"id\" in this.feature ? this.feature.id : null;\n  }\n  geometryType() {\n    return this.feature ? typeof this.feature.type == \"number\" ? ci[this.feature.type] : this.feature.type : null;\n  }\n  geometry() {\n    return this.feature && \"geometry\" in this.feature ? this.feature.geometry : null;\n  }\n  canonicalID() {\n    return this.canonical;\n  }\n  properties() {\n    return this.feature && this.feature.properties || {};\n  }\n  parseColor(e) {\n    let t = this._parseColorCache[e];\n    return t || (t = this._parseColorCache[e] = $.parse(e)), t;\n  }\n}\nclass Ct {\n  constructor(e, t, n = [], a, o = new cr(), i = []) {\n    this.registry = e, this.path = n, this.key = n.map(s => `[${s}]`).join(\"\"), this.scope = o, this.errors = i, this.expectedType = a, this._isConstant = t;\n  }\n  /**\n   * @param expr the JSON expression to parse\n   * @param index the optional argument index if this expression is an argument of a parent expression that's being parsed\n   * @param options\n   * @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.\n   * @private\n   */\n  parse(e, t, n, a, o = {}) {\n    return t ? this.concat(t, n, a)._parse(e, o) : this._parse(e, o);\n  }\n  _parse(e, t) {\n    (e === null || typeof e == \"string\" || typeof e == \"boolean\" || typeof e == \"number\") && (e = [\"literal\", e]);\n    function n(a, o, i) {\n      return i === \"assert\" ? new te(o, [a]) : i === \"coerce\" ? new ge(o, [a]) : a;\n    }\n    if (Array.isArray(e)) {\n      if (e.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].');\n      const a = e[0];\n      if (typeof a != \"string\") return this.error(`Expression name must be a string, but found ${typeof a} instead. If you wanted a literal array, use [\"literal\", [...]].`, 0), null;\n      const o = this.registry[a];\n      if (o) {\n        let i = o.parse(e, this);\n        if (!i) return null;\n        if (this.expectedType) {\n          const s = this.expectedType,\n            l = i.type;\n          if ((s.kind === \"string\" || s.kind === \"number\" || s.kind === \"boolean\" || s.kind === \"object\" || s.kind === \"array\") && l.kind === \"value\") i = n(i, s, t.typeAnnotation || \"assert\");else if (s.kind === \"projectionDefinition\" && (l.kind === \"string\" || l.kind === \"array\")) i = n(i, s, t.typeAnnotation || \"coerce\");else if ((s.kind === \"color\" || s.kind === \"formatted\" || s.kind === \"resolvedImage\") && (l.kind === \"value\" || l.kind === \"string\")) i = n(i, s, t.typeAnnotation || \"coerce\");else if (s.kind === \"padding\" && (l.kind === \"value\" || l.kind === \"number\" || l.kind === \"array\")) i = n(i, s, t.typeAnnotation || \"coerce\");else if (s.kind === \"variableAnchorOffsetCollection\" && (l.kind === \"value\" || l.kind === \"array\")) i = n(i, s, t.typeAnnotation || \"coerce\");else if (this.checkSubtype(s, l)) return null;\n        }\n        if (!(i instanceof je) && i.type.kind !== \"resolvedImage\" && this._isConstant(i)) {\n          const s = new Pn();\n          try {\n            i = new je(i.type, i.evaluate(s));\n          } catch (l) {\n            return this.error(l.message), null;\n          }\n        }\n        return i;\n      }\n      return this.error(`Unknown expression \"${a}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n    } else return typeof e > \"u\" ? this.error(\"'undefined' value invalid. Use null instead.\") : typeof e == \"object\" ? this.error('Bare objects invalid. Use [\"literal\", {...}] instead.') : this.error(`Expected an array, but found ${typeof e} instead.`);\n  }\n  /**\n   * Returns a copy of this context suitable for parsing the subexpression at\n   * index `index`, optionally appending to 'let' binding map.\n   *\n   * Note that `errors` property, intended for collecting errors while\n   * parsing, is copied by reference rather than cloned.\n   * @private\n   */\n  concat(e, t, n) {\n    const a = typeof e == \"number\" ? this.path.concat(e) : this.path,\n      o = n ? this.scope.concat(n) : this.scope;\n    return new Ct(this.registry, this._isConstant, a, t || null, o, this.errors);\n  }\n  /**\n   * Push a parsing (or type checking) error into the `this.errors`\n   * @param error The message\n   * @param keys Optionally specify the source of the error at a child\n   * of the current expression at `this.key`.\n   * @private\n   */\n  error(e, ...t) {\n    const n = `${this.key}${t.map(a => `[${a}]`).join(\"\")}`;\n    this.errors.push(new oe(n, e));\n  }\n  /**\n   * Returns null if `t` is a subtype of `expected`; otherwise returns an\n   * error message and also pushes it to `this.errors`.\n   * @param expected The expected type\n   * @param t The actual type\n   * @returns null if `t` is a subtype of `expected`; otherwise returns an error message\n   */\n  checkSubtype(e, t) {\n    const n = Ve(e, t);\n    return n && this.error(n), n;\n  }\n}\nclass At {\n  constructor(e, t) {\n    this.type = t.type, this.bindings = [].concat(e), this.result = t;\n  }\n  evaluate(e) {\n    return this.result.evaluate(e);\n  }\n  eachChild(e) {\n    for (const t of this.bindings) e(t[1]);\n    e(this.result);\n  }\n  static parse(e, t) {\n    if (e.length < 4) return t.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);\n    const n = [];\n    for (let o = 1; o < e.length - 1; o += 2) {\n      const i = e[o];\n      if (typeof i != \"string\") return t.error(`Expected string, but found ${typeof i} instead.`, o);\n      if (/[^a-zA-Z0-9_]/.test(i)) return t.error(\"Variable names must contain only alphanumeric characters or '_'.\", o);\n      const s = t.parse(e[o + 1], o + 1);\n      if (!s) return null;\n      n.push([i, s]);\n    }\n    const a = t.parse(e[e.length - 1], e.length - 1, t.expectedType, n);\n    return a ? new At(n, a) : null;\n  }\n  outputDefined() {\n    return this.result.outputDefined();\n  }\n}\nclass Tt {\n  constructor(e, t) {\n    this.type = t.type, this.name = e, this.boundExpression = t;\n  }\n  static parse(e, t) {\n    if (e.length !== 2 || typeof e[1] != \"string\") return t.error(\"'var' expression requires exactly one string literal argument.\");\n    const n = e[1];\n    return t.scope.has(n) ? new Tt(n, t.scope.get(n)) : t.error(`Unknown variable \"${n}\". Make sure \"${n}\" has been bound in an enclosing \"let\" expression before using it.`, 1);\n  }\n  evaluate(e) {\n    return this.boundExpression.evaluate(e);\n  }\n  eachChild() {}\n  outputDefined() {\n    return !1;\n  }\n}\nclass dr {\n  constructor(e, t, n) {\n    this.type = e, this.index = t, this.input = n;\n  }\n  static parse(e, t) {\n    if (e.length !== 3) return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);\n    const n = t.parse(e[1], 1, g),\n      a = t.parse(e[2], 2, W(t.expectedType || A));\n    if (!n || !a) return null;\n    const o = a.type;\n    return new dr(o.itemType, n, a);\n  }\n  evaluate(e) {\n    const t = this.index.evaluate(e),\n      n = this.input.evaluate(e);\n    if (t < 0) throw new D(`Array index out of bounds: ${t} < 0.`);\n    if (t >= n.length) throw new D(`Array index out of bounds: ${t} > ${n.length - 1}.`);\n    if (t !== Math.floor(t)) throw new D(`Array index must be an integer, but found ${t} instead.`);\n    return n[t];\n  }\n  eachChild(e) {\n    e(this.index), e(this.input);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass yr {\n  constructor(e, t) {\n    this.type = C, this.needle = e, this.haystack = t;\n  }\n  static parse(e, t) {\n    if (e.length !== 3) return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);\n    const n = t.parse(e[1], 1, A),\n      a = t.parse(e[2], 2, A);\n    return !n || !a ? null : pr(n.type, [C, I, g, bt, A]) ? new yr(n, a) : t.error(`Expected first argument to be of type boolean, string, number or null, but found ${N(n.type)} instead`);\n  }\n  evaluate(e) {\n    const t = this.needle.evaluate(e),\n      n = this.haystack.evaluate(e);\n    if (!n) return !1;\n    if (!Ce(t, [\"boolean\", \"string\", \"number\", \"null\"])) throw new D(`Expected first argument to be of type boolean, string, number or null, but found ${N(q(t))} instead.`);\n    if (!Ce(n, [\"string\", \"array\"])) throw new D(`Expected second argument to be of type array or string, but found ${N(q(n))} instead.`);\n    return n.indexOf(t) >= 0;\n  }\n  eachChild(e) {\n    e(this.needle), e(this.haystack);\n  }\n  outputDefined() {\n    return !0;\n  }\n}\nclass pt {\n  constructor(e, t, n) {\n    this.type = g, this.needle = e, this.haystack = t, this.fromIndex = n;\n  }\n  static parse(e, t) {\n    if (e.length <= 2 || e.length >= 5) return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);\n    const n = t.parse(e[1], 1, A),\n      a = t.parse(e[2], 2, A);\n    if (!n || !a) return null;\n    if (!pr(n.type, [C, I, g, bt, A])) return t.error(`Expected first argument to be of type boolean, string, number or null, but found ${N(n.type)} instead`);\n    if (e.length === 4) {\n      const o = t.parse(e[3], 3, g);\n      return o ? new pt(n, a, o) : null;\n    } else return new pt(n, a);\n  }\n  evaluate(e) {\n    const t = this.needle.evaluate(e),\n      n = this.haystack.evaluate(e);\n    if (!Ce(t, [\"boolean\", \"string\", \"number\", \"null\"])) throw new D(`Expected first argument to be of type boolean, string, number or null, but found ${N(q(t))} instead.`);\n    let a;\n    if (this.fromIndex && (a = this.fromIndex.evaluate(e)), Ce(n, [\"string\"])) {\n      const o = n.indexOf(t, a);\n      return o === -1 ? -1 : [...n.slice(0, o)].length;\n    } else {\n      if (Ce(n, [\"array\"])) return n.indexOf(t, a);\n      throw new D(`Expected second argument to be of type array or string, but found ${N(q(n))} instead.`);\n    }\n  }\n  eachChild(e) {\n    e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass mr {\n  constructor(e, t, n, a, o, i) {\n    this.inputType = e, this.type = t, this.input = n, this.cases = a, this.outputs = o, this.otherwise = i;\n  }\n  static parse(e, t) {\n    if (e.length < 5) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);\n    if (e.length % 2 !== 1) return t.error(\"Expected an even number of arguments.\");\n    let n, a;\n    t.expectedType && t.expectedType.kind !== \"value\" && (a = t.expectedType);\n    const o = {},\n      i = [];\n    for (let u = 2; u < e.length - 1; u += 2) {\n      let c = e[u];\n      const p = e[u + 1];\n      Array.isArray(c) || (c = [c]);\n      const m = t.concat(u);\n      if (c.length === 0) return m.error(\"Expected at least one branch label.\");\n      for (const d of c) {\n        if (typeof d != \"number\" && typeof d != \"string\") return m.error(\"Branch labels must be numbers or strings.\");\n        if (typeof d == \"number\" && Math.abs(d) > Number.MAX_SAFE_INTEGER) return m.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);\n        if (typeof d == \"number\" && Math.floor(d) !== d) return m.error(\"Numeric branch labels must be integer values.\");\n        if (!n) n = q(d);else if (m.checkSubtype(n, q(d))) return null;\n        if (typeof o[String(d)] < \"u\") return m.error(\"Branch labels must be unique.\");\n        o[String(d)] = i.length;\n      }\n      const f = t.parse(p, u, a);\n      if (!f) return null;\n      a = a || f.type, i.push(f);\n    }\n    const s = t.parse(e[1], 1, A);\n    if (!s) return null;\n    const l = t.parse(e[e.length - 1], e.length - 1, a);\n    return !l || s.type.kind !== \"value\" && t.concat(1).checkSubtype(n, s.type) ? null : new mr(n, a, s, o, i, l);\n  }\n  evaluate(e) {\n    const t = this.input.evaluate(e);\n    return (q(t) === this.inputType && this.outputs[this.cases[t]] || this.otherwise).evaluate(e);\n  }\n  eachChild(e) {\n    e(this.input), this.outputs.forEach(e), e(this.otherwise);\n  }\n  outputDefined() {\n    return this.outputs.every(e => e.outputDefined()) && this.otherwise.outputDefined();\n  }\n}\nclass hr {\n  constructor(e, t, n) {\n    this.type = e, this.branches = t, this.otherwise = n;\n  }\n  static parse(e, t) {\n    if (e.length < 4) return t.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);\n    if (e.length % 2 !== 0) return t.error(\"Expected an odd number of arguments.\");\n    let n;\n    t.expectedType && t.expectedType.kind !== \"value\" && (n = t.expectedType);\n    const a = [];\n    for (let i = 1; i < e.length - 1; i += 2) {\n      const s = t.parse(e[i], i, C);\n      if (!s) return null;\n      const l = t.parse(e[i + 1], i + 1, n);\n      if (!l) return null;\n      a.push([s, l]), n = n || l.type;\n    }\n    const o = t.parse(e[e.length - 1], e.length - 1, n);\n    if (!o) return null;\n    if (!n) throw new Error(\"Can't infer output type\");\n    return new hr(n, a, o);\n  }\n  evaluate(e) {\n    for (const [t, n] of this.branches) if (t.evaluate(e)) return n.evaluate(e);\n    return this.otherwise.evaluate(e);\n  }\n  eachChild(e) {\n    for (const [t, n] of this.branches) e(t), e(n);\n    e(this.otherwise);\n  }\n  outputDefined() {\n    return this.branches.every(([e, t]) => t.outputDefined()) && this.otherwise.outputDefined();\n  }\n}\nclass ft {\n  constructor(e, t, n, a) {\n    this.type = e, this.input = t, this.beginIndex = n, this.endIndex = a;\n  }\n  static parse(e, t) {\n    if (e.length <= 2 || e.length >= 5) return t.error(`Expected 3 or 4 arguments, but found ${e.length - 1} instead.`);\n    const n = t.parse(e[1], 1, A),\n      a = t.parse(e[2], 2, g);\n    if (!n || !a) return null;\n    if (!pr(n.type, [W(A), I, A])) return t.error(`Expected first argument to be of type array or string, but found ${N(n.type)} instead`);\n    if (e.length === 4) {\n      const o = t.parse(e[3], 3, g);\n      return o ? new ft(n.type, n, a, o) : null;\n    } else return new ft(n.type, n, a);\n  }\n  evaluate(e) {\n    const t = this.input.evaluate(e),\n      n = this.beginIndex.evaluate(e);\n    let a;\n    if (this.endIndex && (a = this.endIndex.evaluate(e)), Ce(t, [\"string\"])) return [...t].slice(n, a).join(\"\");\n    if (Ce(t, [\"array\"])) return t.slice(n, a);\n    throw new D(`Expected first argument to be of type array or string, but found ${N(q(t))} instead.`);\n  }\n  eachChild(e) {\n    e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nfunction Rn(r, e) {\n  const t = r.length - 1;\n  let n = 0,\n    a = t,\n    o = 0,\n    i,\n    s;\n  for (; n <= a;) if (o = Math.floor((n + a) / 2), i = r[o], s = r[o + 1], i <= e) {\n    if (o === t || e < s) return o;\n    n = o + 1;\n  } else if (i > e) a = o - 1;else throw new D(\"Input is not a number.\");\n  return 0;\n}\nclass It {\n  constructor(e, t, n) {\n    this.type = e, this.input = t, this.labels = [], this.outputs = [];\n    for (const [a, o] of n) this.labels.push(a), this.outputs.push(o);\n  }\n  static parse(e, t) {\n    if (e.length - 1 < 4) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);\n    if ((e.length - 1) % 2 !== 0) return t.error(\"Expected an even number of arguments.\");\n    const n = t.parse(e[1], 1, g);\n    if (!n) return null;\n    const a = [];\n    let o = null;\n    t.expectedType && t.expectedType.kind !== \"value\" && (o = t.expectedType);\n    for (let i = 1; i < e.length; i += 2) {\n      const s = i === 1 ? -1 / 0 : e[i],\n        l = e[i + 1],\n        u = i,\n        c = i + 1;\n      if (typeof s != \"number\") return t.error('Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', u);\n      if (a.length && a[a.length - 1][0] >= s) return t.error('Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.', u);\n      const p = t.parse(l, c, o);\n      if (!p) return null;\n      o = o || p.type, a.push([s, p]);\n    }\n    return new It(o, n, a);\n  }\n  evaluate(e) {\n    const t = this.labels,\n      n = this.outputs;\n    if (t.length === 1) return n[0].evaluate(e);\n    const a = this.input.evaluate(e);\n    if (a <= t[0]) return n[0].evaluate(e);\n    const o = t.length;\n    if (a >= t[o - 1]) return n[o - 1].evaluate(e);\n    const i = Rn(t, a);\n    return n[i].evaluate(e);\n  }\n  eachChild(e) {\n    e(this.input);\n    for (const t of this.outputs) e(t);\n  }\n  outputDefined() {\n    return this.outputs.every(e => e.outputDefined());\n  }\n}\nfunction pi(r) {\n  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, \"default\") ? r.default : r;\n}\nvar Bt, Jr;\nfunction fi() {\n  if (Jr) return Bt;\n  Jr = 1, Bt = r;\n  function r(e, t, n, a) {\n    this.cx = 3 * e, this.bx = 3 * (n - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (a - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = t, this.p2x = n, this.p2y = a;\n  }\n  return r.prototype = {\n    sampleCurveX: function (e) {\n      return ((this.ax * e + this.bx) * e + this.cx) * e;\n    },\n    sampleCurveY: function (e) {\n      return ((this.ay * e + this.by) * e + this.cy) * e;\n    },\n    sampleCurveDerivativeX: function (e) {\n      return (3 * this.ax * e + 2 * this.bx) * e + this.cx;\n    },\n    solveCurveX: function (e, t) {\n      if (t === void 0 && (t = 1e-6), e < 0) return 0;\n      if (e > 1) return 1;\n      for (var n = e, a = 0; a < 8; a++) {\n        var o = this.sampleCurveX(n) - e;\n        if (Math.abs(o) < t) return n;\n        var i = this.sampleCurveDerivativeX(n);\n        if (Math.abs(i) < 1e-6) break;\n        n = n - o / i;\n      }\n      var s = 0,\n        l = 1;\n      for (n = e, a = 0; a < 20 && (o = this.sampleCurveX(n), !(Math.abs(o - e) < t)); a++) e > o ? s = n : l = n, n = (l - s) * 0.5 + s;\n      return n;\n    },\n    solve: function (e, t) {\n      return this.sampleCurveY(this.solveCurveX(e, t));\n    }\n  }, Bt;\n}\nvar di = fi(),\n  yi = /* @__PURE__ */pi(di);\nclass se {\n  constructor(e, t, n, a, o) {\n    this.type = e, this.operator = t, this.interpolation = n, this.input = a, this.labels = [], this.outputs = [];\n    for (const [i, s] of o) this.labels.push(i), this.outputs.push(s);\n  }\n  static interpolationFactor(e, t, n, a) {\n    let o = 0;\n    if (e.name === \"exponential\") o = Ut(t, e.base, n, a);else if (e.name === \"linear\") o = Ut(t, 1, n, a);else if (e.name === \"cubic-bezier\") {\n      const i = e.controlPoints;\n      o = new yi(i[0], i[1], i[2], i[3]).solve(Ut(t, 1, n, a));\n    }\n    return o;\n  }\n  static parse(e, t) {\n    let [n, a, o, ...i] = e;\n    if (!Array.isArray(a) || a.length === 0) return t.error(\"Expected an interpolation type expression.\", 1);\n    if (a[0] === \"linear\") a = {\n      name: \"linear\"\n    };else if (a[0] === \"exponential\") {\n      const u = a[1];\n      if (typeof u != \"number\") return t.error(\"Exponential interpolation requires a numeric base.\", 1, 1);\n      a = {\n        name: \"exponential\",\n        base: u\n      };\n    } else if (a[0] === \"cubic-bezier\") {\n      const u = a.slice(1);\n      if (u.length !== 4 || u.some(c => typeof c != \"number\" || c < 0 || c > 1)) return t.error(\"Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.\", 1);\n      a = {\n        name: \"cubic-bezier\",\n        controlPoints: u\n      };\n    } else return t.error(`Unknown interpolation type ${String(a[0])}`, 1, 0);\n    if (e.length - 1 < 4) return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);\n    if ((e.length - 1) % 2 !== 0) return t.error(\"Expected an even number of arguments.\");\n    if (o = t.parse(o, 2, g), !o) return null;\n    const s = [];\n    let l = null;\n    n === \"interpolate-hcl\" || n === \"interpolate-lab\" ? l = ie : t.expectedType && t.expectedType.kind !== \"value\" && (l = t.expectedType);\n    for (let u = 0; u < i.length; u += 2) {\n      const c = i[u],\n        p = i[u + 1],\n        m = u + 3,\n        f = u + 4;\n      if (typeof c != \"number\") return t.error('Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', m);\n      if (s.length && s[s.length - 1][0] >= c) return t.error('Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.', m);\n      const d = t.parse(p, f, l);\n      if (!d) return null;\n      l = l || d.type, s.push([c, d]);\n    }\n    return !_e(l, g) && !_e(l, wt) && !_e(l, ie) && !_e(l, kt) && !_e(l, Lt) && !_e(l, W(g)) ? t.error(`Type ${N(l)} is not interpolatable.`) : new se(l, n, a, o, s);\n  }\n  evaluate(e) {\n    const t = this.labels,\n      n = this.outputs;\n    if (t.length === 1) return n[0].evaluate(e);\n    const a = this.input.evaluate(e);\n    if (a <= t[0]) return n[0].evaluate(e);\n    const o = t.length;\n    if (a >= t[o - 1]) return n[o - 1].evaluate(e);\n    const i = Rn(t, a),\n      s = t[i],\n      l = t[i + 1],\n      u = se.interpolationFactor(this.interpolation, a, s, l),\n      c = n[i].evaluate(e),\n      p = n[i + 1].evaluate(e);\n    switch (this.operator) {\n      case \"interpolate\":\n        switch (this.type.kind) {\n          case \"number\":\n            return ve(c, p, u);\n          case \"color\":\n            return $.interpolate(c, p, u);\n          case \"padding\":\n            return J.interpolate(c, p, u);\n          case \"variableAnchorOffsetCollection\":\n            return ne.interpolate(c, p, u);\n          case \"array\":\n            return Ge(c, p, u);\n          case \"projectionDefinition\":\n            return ee.interpolate(c, p, u);\n        }\n      case \"interpolate-hcl\":\n        return $.interpolate(c, p, u, \"hcl\");\n      case \"interpolate-lab\":\n        return $.interpolate(c, p, u, \"lab\");\n    }\n  }\n  eachChild(e) {\n    e(this.input);\n    for (const t of this.outputs) e(t);\n  }\n  outputDefined() {\n    return this.outputs.every(e => e.outputDefined());\n  }\n}\nfunction Ut(r, e, t, n) {\n  const a = n - t,\n    o = r - t;\n  return a === 0 ? 0 : e === 1 ? o / a : (Math.pow(e, o) - 1) / (Math.pow(e, a) - 1);\n}\n$.interpolate, J.interpolate, ne.interpolate;\nclass Ke {\n  constructor(e, t) {\n    this.type = e, this.args = t;\n  }\n  static parse(e, t) {\n    if (e.length < 2) return t.error(\"Expected at least one argument.\");\n    let n = null;\n    const a = t.expectedType;\n    a && a.kind !== \"value\" && (n = a);\n    const o = [];\n    for (const s of e.slice(1)) {\n      const l = t.parse(s, 1 + o.length, n, void 0, {\n        typeAnnotation: \"omit\"\n      });\n      if (!l) return null;\n      n = n || l.type, o.push(l);\n    }\n    if (!n) throw new Error(\"No output type\");\n    return a && o.some(s => Ve(a, s.type)) ? new Ke(A, o) : new Ke(n, o);\n  }\n  evaluate(e) {\n    let t = null,\n      n = 0,\n      a;\n    for (const o of this.args) if (n++, t = o.evaluate(e), t && t instanceof we && !t.available && (a || (a = t.name), t = null, n === this.args.length && (t = a)), t !== null) break;\n    return t;\n  }\n  eachChild(e) {\n    this.args.forEach(e);\n  }\n  outputDefined() {\n    return this.args.every(e => e.outputDefined());\n  }\n}\nfunction Yr(r, e) {\n  return r === \"==\" || r === \"!=\" ? e.kind === \"boolean\" || e.kind === \"string\" || e.kind === \"number\" || e.kind === \"null\" || e.kind === \"value\" : e.kind === \"string\" || e.kind === \"number\" || e.kind === \"value\";\n}\nfunction mi(r, e, t) {\n  return e === t;\n}\nfunction hi(r, e, t) {\n  return e !== t;\n}\nfunction gi(r, e, t) {\n  return e < t;\n}\nfunction vi(r, e, t) {\n  return e > t;\n}\nfunction bi(r, e, t) {\n  return e <= t;\n}\nfunction wi(r, e, t) {\n  return e >= t;\n}\nfunction $n(r, e, t, n) {\n  return n.compare(e, t) === 0;\n}\nfunction Si(r, e, t, n) {\n  return !$n(r, e, t, n);\n}\nfunction xi(r, e, t, n) {\n  return n.compare(e, t) < 0;\n}\nfunction ki(r, e, t, n) {\n  return n.compare(e, t) > 0;\n}\nfunction Li(r, e, t, n) {\n  return n.compare(e, t) <= 0;\n}\nfunction Ci(r, e, t, n) {\n  return n.compare(e, t) >= 0;\n}\nfunction Oe(r, e, t) {\n  const n = r !== \"==\" && r !== \"!=\";\n  return class jn {\n    constructor(o, i, s) {\n      this.type = C, this.lhs = o, this.rhs = i, this.collator = s, this.hasUntypedArgument = o.type.kind === \"value\" || i.type.kind === \"value\";\n    }\n    static parse(o, i) {\n      if (o.length !== 3 && o.length !== 4) return i.error(\"Expected two or three arguments.\");\n      const s = o[0];\n      let l = i.parse(o[1], 1, A);\n      if (!l) return null;\n      if (!Yr(s, l.type)) return i.concat(1).error(`\"${s}\" comparisons are not supported for type '${N(l.type)}'.`);\n      let u = i.parse(o[2], 2, A);\n      if (!u) return null;\n      if (!Yr(s, u.type)) return i.concat(2).error(`\"${s}\" comparisons are not supported for type '${N(u.type)}'.`);\n      if (l.type.kind !== u.type.kind && l.type.kind !== \"value\" && u.type.kind !== \"value\") return i.error(`Cannot compare types '${N(l.type)}' and '${N(u.type)}'.`);\n      n && (l.type.kind === \"value\" && u.type.kind !== \"value\" ? l = new te(u.type, [l]) : l.type.kind !== \"value\" && u.type.kind === \"value\" && (u = new te(l.type, [u])));\n      let c = null;\n      if (o.length === 4) {\n        if (l.type.kind !== \"string\" && u.type.kind !== \"string\" && l.type.kind !== \"value\" && u.type.kind !== \"value\") return i.error(\"Cannot use collator to compare non-string types.\");\n        if (c = i.parse(o[3], 3, St), !c) return null;\n      }\n      return new jn(l, u, c);\n    }\n    evaluate(o) {\n      const i = this.lhs.evaluate(o),\n        s = this.rhs.evaluate(o);\n      if (n && this.hasUntypedArgument) {\n        const l = q(i),\n          u = q(s);\n        if (l.kind !== u.kind || !(l.kind === \"string\" || l.kind === \"number\")) throw new D(`Expected arguments for \"${r}\" to be (string, string) or (number, number), but found (${l.kind}, ${u.kind}) instead.`);\n      }\n      if (this.collator && !n && this.hasUntypedArgument) {\n        const l = q(i),\n          u = q(s);\n        if (l.kind !== \"string\" || u.kind !== \"string\") return e(o, i, s);\n      }\n      return this.collator ? t(o, i, s, this.collator.evaluate(o)) : e(o, i, s);\n    }\n    eachChild(o) {\n      o(this.lhs), o(this.rhs), this.collator && o(this.collator);\n    }\n    outputDefined() {\n      return !0;\n    }\n  };\n}\nconst Ai = Oe(\"==\", mi, $n),\n  Ti = Oe(\"!=\", hi, Si),\n  Ii = Oe(\"<\", gi, xi),\n  Ei = Oe(\">\", vi, ki),\n  Mi = Oe(\"<=\", bi, Li),\n  _i = Oe(\">=\", wi, Ci);\nclass Et {\n  constructor(e, t, n) {\n    this.type = St, this.locale = n, this.caseSensitive = e, this.diacriticSensitive = t;\n  }\n  static parse(e, t) {\n    if (e.length !== 2) return t.error(\"Expected one argument.\");\n    const n = e[1];\n    if (typeof n != \"object\" || Array.isArray(n)) return t.error(\"Collator options argument must be an object.\");\n    const a = t.parse(n[\"case-sensitive\"] === void 0 ? !1 : n[\"case-sensitive\"], 1, C);\n    if (!a) return null;\n    const o = t.parse(n[\"diacritic-sensitive\"] === void 0 ? !1 : n[\"diacritic-sensitive\"], 1, C);\n    if (!o) return null;\n    let i = null;\n    return n.locale && (i = t.parse(n.locale, 1, I), !i) ? null : new Et(a, o, i);\n  }\n  evaluate(e) {\n    return new fr(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);\n  }\n  eachChild(e) {\n    e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass gr {\n  constructor(e, t, n, a, o) {\n    this.type = I, this.number = e, this.locale = t, this.currency = n, this.minFractionDigits = a, this.maxFractionDigits = o;\n  }\n  static parse(e, t) {\n    if (e.length !== 3) return t.error(\"Expected two arguments.\");\n    const n = t.parse(e[1], 1, g);\n    if (!n) return null;\n    const a = e[2];\n    if (typeof a != \"object\" || Array.isArray(a)) return t.error(\"NumberFormat options argument must be an object.\");\n    let o = null;\n    if (a.locale && (o = t.parse(a.locale, 1, I), !o)) return null;\n    let i = null;\n    if (a.currency && (i = t.parse(a.currency, 1, I), !i)) return null;\n    let s = null;\n    if (a[\"min-fraction-digits\"] && (s = t.parse(a[\"min-fraction-digits\"], 1, g), !s)) return null;\n    let l = null;\n    return a[\"max-fraction-digits\"] && (l = t.parse(a[\"max-fraction-digits\"], 1, g), !l) ? null : new gr(n, o, i, s, l);\n  }\n  evaluate(e) {\n    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], {\n      style: this.currency ? \"currency\" : \"decimal\",\n      currency: this.currency ? this.currency.evaluate(e) : void 0,\n      minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0,\n      maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0\n    }).format(this.number.evaluate(e));\n  }\n  eachChild(e) {\n    e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass vr {\n  constructor(e) {\n    this.type = xt, this.sections = e;\n  }\n  static parse(e, t) {\n    if (e.length < 2) return t.error(\"Expected at least one argument.\");\n    const n = e[1];\n    if (!Array.isArray(n) && typeof n == \"object\") return t.error(\"First argument must be an image or text section.\");\n    const a = [];\n    let o = !1;\n    for (let i = 1; i <= e.length - 1; ++i) {\n      const s = e[i];\n      if (o && typeof s == \"object\" && !Array.isArray(s)) {\n        o = !1;\n        let l = null;\n        if (s[\"font-scale\"] && (l = t.parse(s[\"font-scale\"], 1, g), !l)) return null;\n        let u = null;\n        if (s[\"text-font\"] && (u = t.parse(s[\"text-font\"], 1, W(I)), !u)) return null;\n        let c = null;\n        if (s[\"text-color\"] && (c = t.parse(s[\"text-color\"], 1, ie), !c)) return null;\n        const p = a[a.length - 1];\n        p.scale = l, p.font = u, p.textColor = c;\n      } else {\n        const l = t.parse(e[i], 1, A);\n        if (!l) return null;\n        const u = l.type.kind;\n        if (u !== \"string\" && u !== \"value\" && u !== \"null\" && u !== \"resolvedImage\") return t.error(\"Formatted text type must be 'string', 'value', 'image' or 'null'.\");\n        o = !0, a.push({\n          content: l,\n          scale: null,\n          font: null,\n          textColor: null\n        });\n      }\n    }\n    return new vr(a);\n  }\n  evaluate(e) {\n    const t = n => {\n      const a = n.content.evaluate(e);\n      return q(a) === Xe ? new Jt(\"\", a, null, null, null) : new Jt(Be(a), null, n.scale ? n.scale.evaluate(e) : null, n.font ? n.font.evaluate(e).join(\",\") : null, n.textColor ? n.textColor.evaluate(e) : null);\n    };\n    return new pe(this.sections.map(t));\n  }\n  eachChild(e) {\n    for (const t of this.sections) e(t.content), t.scale && e(t.scale), t.font && e(t.font), t.textColor && e(t.textColor);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass br {\n  constructor(e) {\n    this.type = Xe, this.input = e;\n  }\n  static parse(e, t) {\n    if (e.length !== 2) return t.error(\"Expected two arguments.\");\n    const n = t.parse(e[1], 1, I);\n    return n ? new br(n) : t.error(\"No image name provided.\");\n  }\n  evaluate(e) {\n    const t = this.input.evaluate(e),\n      n = we.fromString(t);\n    return n && e.availableImages && (n.available = e.availableImages.indexOf(t) > -1), n;\n  }\n  eachChild(e) {\n    e(this.input);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nclass wr {\n  constructor(e) {\n    this.type = g, this.input = e;\n  }\n  static parse(e, t) {\n    if (e.length !== 2) return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);\n    const n = t.parse(e[1], 1);\n    return n ? n.type.kind !== \"array\" && n.type.kind !== \"string\" && n.type.kind !== \"value\" ? t.error(`Expected argument of type string or array, but found ${N(n.type)} instead.`) : new wr(n) : null;\n  }\n  evaluate(e) {\n    const t = this.input.evaluate(e);\n    if (typeof t == \"string\") return [...t].length;\n    if (Array.isArray(t)) return t.length;\n    throw new D(`Expected value to be of type string or array, but found ${N(q(t))} instead.`);\n  }\n  eachChild(e) {\n    e(this.input);\n  }\n  outputDefined() {\n    return !1;\n  }\n}\nconst le = 8192;\nfunction zi(r, e) {\n  const t = Pi(r[0]),\n    n = $i(r[1]),\n    a = Math.pow(2, e.z);\n  return [Math.round(t * a * le), Math.round(n * a * le)];\n}\nfunction Sr(r, e) {\n  const t = Math.pow(2, e.z),\n    n = (r[0] / le + e.x) / t,\n    a = (r[1] / le + e.y) / t;\n  return [Ri(n), ji(a)];\n}\nfunction Pi(r) {\n  return (180 + r) / 360;\n}\nfunction Ri(r) {\n  return r * 360 - 180;\n}\nfunction $i(r) {\n  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;\n}\nfunction ji(r) {\n  return 360 / Math.PI * Math.atan(Math.exp((180 - r * 360) * Math.PI / 180)) - 90;\n}\nfunction Qe(r, e) {\n  r[0] = Math.min(r[0], e[0]), r[1] = Math.min(r[1], e[1]), r[2] = Math.max(r[2], e[0]), r[3] = Math.max(r[3], e[1]);\n}\nfunction We(r, e) {\n  return !(r[0] <= e[0] || r[2] >= e[2] || r[1] <= e[1] || r[3] >= e[3]);\n}\nfunction Ni(r, e, t) {\n  return e[1] > r[1] != t[1] > r[1] && r[0] < (t[0] - e[0]) * (r[1] - e[1]) / (t[1] - e[1]) + e[0];\n}\nfunction Oi(r, e, t) {\n  const n = r[0] - e[0],\n    a = r[1] - e[1],\n    o = r[0] - t[0],\n    i = r[1] - t[1];\n  return n * i - o * a === 0 && n * o <= 0 && a * i <= 0;\n}\nfunction Mt(r, e, t, n) {\n  const a = [e[0] - r[0], e[1] - r[1]],\n    o = [n[0] - t[0], n[1] - t[1]];\n  return Bi(o, a) === 0 ? !1 : !!(Xr(r, e, t, n) && Xr(t, n, r, e));\n}\nfunction Fi(r, e, t) {\n  for (const n of t) for (let a = 0; a < n.length - 1; ++a) if (Mt(r, e, n[a], n[a + 1])) return !0;\n  return !1;\n}\nfunction Fe(r, e, t = !1) {\n  let n = !1;\n  for (const a of e) for (let o = 0; o < a.length - 1; o++) {\n    if (Oi(r, a[o], a[o + 1])) return t;\n    Ni(r, a[o], a[o + 1]) && (n = !n);\n  }\n  return n;\n}\nfunction Di(r, e) {\n  for (const t of e) if (Fe(r, t)) return !0;\n  return !1;\n}\nfunction Nn(r, e) {\n  for (const t of r) if (!Fe(t, e)) return !1;\n  for (let t = 0; t < r.length - 1; ++t) if (Fi(r[t], r[t + 1], e)) return !1;\n  return !0;\n}\nfunction qi(r, e) {\n  for (const t of e) if (Nn(r, t)) return !0;\n  return !1;\n}\nfunction Bi(r, e) {\n  return r[0] * e[1] - r[1] * e[0];\n}\nfunction Xr(r, e, t, n) {\n  const a = r[0] - t[0],\n    o = r[1] - t[1],\n    i = e[0] - t[0],\n    s = e[1] - t[1],\n    l = n[0] - t[0],\n    u = n[1] - t[1],\n    c = a * u - l * o,\n    p = i * u - l * s;\n  return c > 0 && p < 0 || c < 0 && p > 0;\n}\nfunction xr(r, e, t) {\n  const n = [];\n  for (let a = 0; a < r.length; a++) {\n    const o = [];\n    for (let i = 0; i < r[a].length; i++) {\n      const s = zi(r[a][i], t);\n      Qe(e, s), o.push(s);\n    }\n    n.push(o);\n  }\n  return n;\n}\nfunction On(r, e, t) {\n  const n = [];\n  for (let a = 0; a < r.length; a++) {\n    const o = xr(r[a], e, t);\n    n.push(o);\n  }\n  return n;\n}\nfunction Fn(r, e, t, n) {\n  if (r[0] < t[0] || r[0] > t[2]) {\n    const a = n * 0.5;\n    let o = r[0] - t[0] > a ? -n : t[0] - r[0] > a ? n : 0;\n    o === 0 && (o = r[0] - t[2] > a ? -n : t[2] - r[0] > a ? n : 0), r[0] += o;\n  }\n  Qe(e, r);\n}\nfunction Ui(r) {\n  r[0] = r[1] = 1 / 0, r[2] = r[3] = -1 / 0;\n}\nfunction Qr(r, e, t, n) {\n  const a = Math.pow(2, n.z) * le,\n    o = [n.x * le, n.y * le],\n    i = [];\n  for (const s of r) for (const l of s) {\n    const u = [l.x + o[0], l.y + o[1]];\n    Fn(u, e, t, a), i.push(u);\n  }\n  return i;\n}\nfunction en(r, e, t, n) {\n  const a = Math.pow(2, n.z) * le,\n    o = [n.x * le, n.y * le],\n    i = [];\n  for (const s of r) {\n    const l = [];\n    for (const u of s) {\n      const c = [u.x + o[0], u.y + o[1]];\n      Qe(e, c), l.push(c);\n    }\n    i.push(l);\n  }\n  if (e[2] - e[0] <= a / 2) {\n    Ui(e);\n    for (const s of i) for (const l of s) Fn(l, e, t, a);\n  }\n  return i;\n}\nfunction Vi(r, e) {\n  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n    n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n    a = r.canonicalID();\n  if (e.type === \"Polygon\") {\n    const o = xr(e.coordinates, n, a),\n      i = Qr(r.geometry(), t, n, a);\n    if (!We(t, n)) return !1;\n    for (const s of i) if (!Fe(s, o)) return !1;\n  }\n  if (e.type === \"MultiPolygon\") {\n    const o = On(e.coordinates, n, a),\n      i = Qr(r.geometry(), t, n, a);\n    if (!We(t, n)) return !1;\n    for (const s of i) if (!Di(s, o)) return !1;\n  }\n  return !0;\n}\nfunction Gi(r, e) {\n  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n    n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n    a = r.canonicalID();\n  if (e.type === \"Polygon\") {\n    const o = xr(e.coordinates, n, a),\n      i = en(r.geometry(), t, n, a);\n    if (!We(t, n)) return !1;\n    for (const s of i) if (!Nn(s, o)) return !1;\n  }\n  if (e.type === \"MultiPolygon\") {\n    const o = On(e.coordinates, n, a),\n      i = en(r.geometry(), t, n, a);\n    if (!We(t, n)) return !1;\n    for (const s of i) if (!qi(s, o)) return !1;\n  }\n  return !0;\n}\nclass Ae {\n  constructor(e, t) {\n    this.type = C, this.geojson = e, this.geometries = t;\n  }\n  static parse(e, t) {\n    if (e.length !== 2) return t.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);\n    if (He(e[1])) {\n      const n = e[1];\n      if (n.type === \"FeatureCollection\") {\n        const a = [];\n        for (const o of n.features) {\n          const {\n            type: i,\n            coordinates: s\n          } = o.geometry;\n          i === \"Polygon\" && a.push(s), i === \"MultiPolygon\" && a.push(...s);\n        }\n        if (a.length) {\n          const o = {\n            type: \"MultiPolygon\",\n            coordinates: a\n          };\n          return new Ae(n, o);\n        }\n      } else if (n.type === \"Feature\") {\n        const a = n.geometry.type;\n        if (a === \"Polygon\" || a === \"MultiPolygon\") return new Ae(n, n.geometry);\n      } else if (n.type === \"Polygon\" || n.type === \"MultiPolygon\") return new Ae(n, n);\n    }\n    return t.error(\"'within' expression requires valid geojson object that contains polygon geometry type.\");\n  }\n  evaluate(e) {\n    if (e.geometry() != null && e.canonicalID() != null) {\n      if (e.geometryType() === \"Point\") return Vi(e, this.geometries);\n      if (e.geometryType() === \"LineString\") return Gi(e, this.geometries);\n    }\n    return !1;\n  }\n  eachChild() {}\n  outputDefined() {\n    return !0;\n  }\n}\nclass Dn {\n  constructor(e = [], t = (n, a) => n < a ? -1 : n > a ? 1 : 0) {\n    if (this.data = e, this.length = this.data.length, this.compare = t, this.length > 0) for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);\n  }\n  push(e) {\n    this.data.push(e), this._up(this.length++);\n  }\n  pop() {\n    if (this.length === 0) return;\n    const e = this.data[0],\n      t = this.data.pop();\n    return --this.length > 0 && (this.data[0] = t, this._down(0)), e;\n  }\n  peek() {\n    return this.data[0];\n  }\n  _up(e) {\n    const {\n        data: t,\n        compare: n\n      } = this,\n      a = t[e];\n    for (; e > 0;) {\n      const o = e - 1 >> 1,\n        i = t[o];\n      if (n(a, i) >= 0) break;\n      t[e] = i, e = o;\n    }\n    t[e] = a;\n  }\n  _down(e) {\n    const {\n        data: t,\n        compare: n\n      } = this,\n      a = this.length >> 1,\n      o = t[e];\n    for (; e < a;) {\n      let i = (e << 1) + 1;\n      const s = i + 1;\n      if (s < this.length && n(t[s], t[i]) < 0 && (i = s), n(t[i], o) >= 0) break;\n      t[e] = t[i], e = i;\n    }\n    t[e] = o;\n  }\n}\nfunction Hi(r, e) {\n  if (r.length <= 1) return [r];\n  const n = [];\n  let a, o;\n  for (const i of r) {\n    const s = Ki(i);\n    s !== 0 && (i.area = Math.abs(s), o === void 0 && (o = s < 0), o === s < 0 ? (a && n.push(a), a = [i]) : a.push(i));\n  }\n  return a && n.push(a), n;\n}\nfunction Ki(r) {\n  let e = 0;\n  for (let t = 0, n = r.length, a = n - 1, o, i; t < n; a = t++) o = r[t], i = r[a], e += (i.x - o.x) * (o.y + i.y);\n  return e;\n}\nconst Wi = 6378.137,\n  tn = 1 / 298.257223563,\n  rn = tn * (2 - tn),\n  nn = Math.PI / 180;\nclass kr {\n  constructor(e) {\n    const t = nn * Wi * 1e3,\n      n = Math.cos(e * nn),\n      a = 1 / (1 - rn * (1 - n * n)),\n      o = Math.sqrt(a);\n    this.kx = t * o * n, this.ky = t * o * a * (1 - rn);\n  }\n  /**\n   * Given two points of the form [longitude, latitude], returns the distance.\n   *\n   * @param a - point [longitude, latitude]\n   * @param b - point [longitude, latitude]\n   * @returns distance\n   * @example\n   * const distance = ruler.distance([30.5, 50.5], [30.51, 50.49]);\n   * //=distance\n   */\n  distance(e, t) {\n    const n = this.wrap(e[0] - t[0]) * this.kx,\n      a = (e[1] - t[1]) * this.ky;\n    return Math.sqrt(n * n + a * a);\n  }\n  /**\n   * Returns an object of the form {point, index, t}, where point is closest point on the line\n   * from the given point, index is the start index of the segment with the closest point,\n   * and t is a parameter from 0 to 1 that indicates where the closest point is on that segment.\n   *\n   * @param line - an array of points that form the line\n   * @param p - point [longitude, latitude]\n   * @returns the nearest point, its index in the array and the proportion along the line\n   * @example\n   * const point = ruler.pointOnLine(line, [-67.04, 50.5]).point;\n   * //=point\n   */\n  pointOnLine(e, t) {\n    let n = 1 / 0,\n      a,\n      o,\n      i,\n      s;\n    for (let l = 0; l < e.length - 1; l++) {\n      let u = e[l][0],\n        c = e[l][1],\n        p = this.wrap(e[l + 1][0] - u) * this.kx,\n        m = (e[l + 1][1] - c) * this.ky,\n        f = 0;\n      (p !== 0 || m !== 0) && (f = (this.wrap(t[0] - u) * this.kx * p + (t[1] - c) * this.ky * m) / (p * p + m * m), f > 1 ? (u = e[l + 1][0], c = e[l + 1][1]) : f > 0 && (u += p / this.kx * f, c += m / this.ky * f)), p = this.wrap(t[0] - u) * this.kx, m = (t[1] - c) * this.ky;\n      const d = p * p + m * m;\n      d < n && (n = d, a = u, o = c, i = l, s = f);\n    }\n    return {\n      point: [a, o],\n      index: i,\n      t: Math.max(0, Math.min(1, s))\n    };\n  }\n  wrap(e) {\n    for (; e < -180;) e += 360;\n    for (; e > 180;) e -= 360;\n    return e;\n  }\n}\nconst Yt = 100,\n  Xt = 50;\nfunction qn(r, e) {\n  return e[0] - r[0];\n}\nfunction dt(r) {\n  return r[1] - r[0] + 1;\n}\nfunction de(r, e) {\n  return r[1] >= r[0] && r[1] < e;\n}\nfunction Qt(r, e) {\n  if (r[0] > r[1]) return [null, null];\n  const t = dt(r);\n  if (e) {\n    if (t === 2) return [r, null];\n    const a = Math.floor(t / 2);\n    return [[r[0], r[0] + a], [r[0] + a, r[1]]];\n  }\n  if (t === 1) return [r, null];\n  const n = Math.floor(t / 2) - 1;\n  return [[r[0], r[0] + n], [r[0] + n + 1, r[1]]];\n}\nfunction er(r, e) {\n  if (!de(e, r.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n  for (let n = e[0]; n <= e[1]; ++n) Qe(t, r[n]);\n  return t;\n}\nfunction tr(r) {\n  const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n  for (const t of r) for (const n of t) Qe(e, n);\n  return e;\n}\nfunction an(r) {\n  return r[0] !== -1 / 0 && r[1] !== -1 / 0 && r[2] !== 1 / 0 && r[3] !== 1 / 0;\n}\nfunction Lr(r, e, t) {\n  if (!an(r) || !an(e)) return NaN;\n  let n = 0,\n    a = 0;\n  return r[2] < e[0] && (n = e[0] - r[2]), r[0] > e[2] && (n = r[0] - e[2]), r[1] > e[3] && (a = r[1] - e[3]), r[3] < e[1] && (a = e[1] - r[3]), t.distance([0, 0], [n, a]);\n}\nfunction Le(r, e, t) {\n  const n = t.pointOnLine(e, r);\n  return t.distance(r, n.point);\n}\nfunction Cr(r, e, t, n, a) {\n  const o = Math.min(Le(r, [t, n], a), Le(e, [t, n], a)),\n    i = Math.min(Le(t, [r, e], a), Le(n, [r, e], a));\n  return Math.min(o, i);\n}\nfunction Zi(r, e, t, n, a) {\n  if (!(de(e, r.length) && de(n, t.length))) return 1 / 0;\n  let i = 1 / 0;\n  for (let s = e[0]; s < e[1]; ++s) {\n    const l = r[s],\n      u = r[s + 1];\n    for (let c = n[0]; c < n[1]; ++c) {\n      const p = t[c],\n        m = t[c + 1];\n      if (Mt(l, u, p, m)) return 0;\n      i = Math.min(i, Cr(l, u, p, m, a));\n    }\n  }\n  return i;\n}\nfunction Ji(r, e, t, n, a) {\n  if (!(de(e, r.length) && de(n, t.length))) return NaN;\n  let i = 1 / 0;\n  for (let s = e[0]; s <= e[1]; ++s) for (let l = n[0]; l <= n[1]; ++l) if (i = Math.min(i, a.distance(r[s], t[l])), i === 0) return i;\n  return i;\n}\nfunction Yi(r, e, t) {\n  if (Fe(r, e, !0)) return 0;\n  let n = 1 / 0;\n  for (const a of e) {\n    const o = a[0],\n      i = a[a.length - 1];\n    if (o !== i && (n = Math.min(n, Le(r, [i, o], t)), n === 0)) return n;\n    const s = t.pointOnLine(a, r);\n    if (n = Math.min(n, t.distance(r, s.point)), n === 0) return n;\n  }\n  return n;\n}\nfunction Xi(r, e, t, n) {\n  if (!de(e, r.length)) return NaN;\n  for (let o = e[0]; o <= e[1]; ++o) if (Fe(r[o], t, !0)) return 0;\n  let a = 1 / 0;\n  for (let o = e[0]; o < e[1]; ++o) {\n    const i = r[o],\n      s = r[o + 1];\n    for (const l of t) for (let u = 0, c = l.length, p = c - 1; u < c; p = u++) {\n      const m = l[p],\n        f = l[u];\n      if (Mt(i, s, m, f)) return 0;\n      a = Math.min(a, Cr(i, s, m, f, n));\n    }\n  }\n  return a;\n}\nfunction on(r, e) {\n  for (const t of r) for (const n of t) if (Fe(n, e, !0)) return !0;\n  return !1;\n}\nfunction Qi(r, e, t, n = 1 / 0) {\n  const a = tr(r),\n    o = tr(e);\n  if (n !== 1 / 0 && Lr(a, o, t) >= n) return n;\n  if (We(a, o)) {\n    if (on(r, e)) return 0;\n  } else if (on(e, r)) return 0;\n  let i = 1 / 0;\n  for (const s of r) for (let l = 0, u = s.length, c = u - 1; l < u; c = l++) {\n    const p = s[c],\n      m = s[l];\n    for (const f of e) for (let d = 0, y = f.length, v = y - 1; d < y; v = d++) {\n      const w = f[v],\n        b = f[d];\n      if (Mt(p, m, w, b)) return 0;\n      i = Math.min(i, Cr(p, m, w, b, t));\n    }\n  }\n  return i;\n}\nfunction sn(r, e, t, n, a, o) {\n  if (!o) return;\n  const i = Lr(er(n, o), a, t);\n  i < e && r.push([i, o, [0, 0]]);\n}\nfunction it(r, e, t, n, a, o, i) {\n  if (!o || !i) return;\n  const s = Lr(er(n, o), er(a, i), t);\n  s < e && r.push([s, o, i]);\n}\nfunction yt(r, e, t, n, a = 1 / 0) {\n  let o = Math.min(n.distance(r[0], t[0][0]), a);\n  if (o === 0) return o;\n  const i = new Dn([[0, [0, r.length - 1], [0, 0]]], qn),\n    s = tr(t);\n  for (; i.length > 0;) {\n    const l = i.pop();\n    if (l[0] >= o) continue;\n    const u = l[1],\n      c = e ? Xt : Yt;\n    if (dt(u) <= c) {\n      if (!de(u, r.length)) return NaN;\n      if (e) {\n        const p = Xi(r, u, t, n);\n        if (isNaN(p) || p === 0) return p;\n        o = Math.min(o, p);\n      } else for (let p = u[0]; p <= u[1]; ++p) {\n        const m = Yi(r[p], t, n);\n        if (o = Math.min(o, m), o === 0) return 0;\n      }\n    } else {\n      const p = Qt(u, e);\n      sn(i, o, n, r, s, p[0]), sn(i, o, n, r, s, p[1]);\n    }\n  }\n  return o;\n}\nfunction mt(r, e, t, n, a, o = 1 / 0) {\n  let i = Math.min(o, a.distance(r[0], t[0]));\n  if (i === 0) return i;\n  const s = new Dn([[0, [0, r.length - 1], [0, t.length - 1]]], qn);\n  for (; s.length > 0;) {\n    const l = s.pop();\n    if (l[0] >= i) continue;\n    const u = l[1],\n      c = l[2],\n      p = e ? Xt : Yt,\n      m = n ? Xt : Yt;\n    if (dt(u) <= p && dt(c) <= m) {\n      if (!de(u, r.length) && de(c, t.length)) return NaN;\n      let f;\n      if (e && n) f = Zi(r, u, t, c, a), i = Math.min(i, f);else if (e && !n) {\n        const d = r.slice(u[0], u[1] + 1);\n        for (let y = c[0]; y <= c[1]; ++y) if (f = Le(t[y], d, a), i = Math.min(i, f), i === 0) return i;\n      } else if (!e && n) {\n        const d = t.slice(c[0], c[1] + 1);\n        for (let y = u[0]; y <= u[1]; ++y) if (f = Le(r[y], d, a), i = Math.min(i, f), i === 0) return i;\n      } else f = Ji(r, u, t, c, a), i = Math.min(i, f);\n    } else {\n      const f = Qt(u, e),\n        d = Qt(c, n);\n      it(s, i, a, r, t, f[0], d[0]), it(s, i, a, r, t, f[0], d[1]), it(s, i, a, r, t, f[1], d[0]), it(s, i, a, r, t, f[1], d[1]);\n    }\n  }\n  return i;\n}\nfunction es(r, e) {\n  const t = r.geometry(),\n    n = t.flat().map(i => Sr([i.x, i.y], r.canonical));\n  if (t.length === 0) return NaN;\n  const a = new kr(n[0][1]);\n  let o = 1 / 0;\n  for (const i of e) {\n    switch (i.type) {\n      case \"Point\":\n        o = Math.min(o, mt(n, !1, [i.coordinates], !1, a, o));\n        break;\n      case \"LineString\":\n        o = Math.min(o, mt(n, !1, i.coordinates, !0, a, o));\n        break;\n      case \"Polygon\":\n        o = Math.min(o, yt(n, !1, i.coordinates, a, o));\n        break;\n    }\n    if (o === 0) return o;\n  }\n  return o;\n}\nfunction ts(r, e) {\n  const t = r.geometry(),\n    n = t.flat().map(i => Sr([i.x, i.y], r.canonical));\n  if (t.length === 0) return NaN;\n  const a = new kr(n[0][1]);\n  let o = 1 / 0;\n  for (const i of e) {\n    switch (i.type) {\n      case \"Point\":\n        o = Math.min(o, mt(n, !0, [i.coordinates], !1, a, o));\n        break;\n      case \"LineString\":\n        o = Math.min(o, mt(n, !0, i.coordinates, !0, a, o));\n        break;\n      case \"Polygon\":\n        o = Math.min(o, yt(n, !0, i.coordinates, a, o));\n        break;\n    }\n    if (o === 0) return o;\n  }\n  return o;\n}\nfunction rs(r, e) {\n  const t = r.geometry();\n  if (t.length === 0 || t[0].length === 0) return NaN;\n  const n = Hi(t).map(i => i.map(s => s.map(l => Sr([l.x, l.y], r.canonical)))),\n    a = new kr(n[0][0][0][1]);\n  let o = 1 / 0;\n  for (const i of e) for (const s of n) {\n    switch (i.type) {\n      case \"Point\":\n        o = Math.min(o, yt([i.coordinates], !1, s, a, o));\n        break;\n      case \"LineString\":\n        o = Math.min(o, yt(i.coordinates, !0, s, a, o));\n        break;\n      case \"Polygon\":\n        o = Math.min(o, Qi(s, i.coordinates, a, o));\n        break;\n    }\n    if (o === 0) return o;\n  }\n  return o;\n}\nfunction Vt(r) {\n  return r.type === \"MultiPolygon\" ? r.coordinates.map(e => ({\n    type: \"Polygon\",\n    coordinates: e\n  })) : r.type === \"MultiLineString\" ? r.coordinates.map(e => ({\n    type: \"LineString\",\n    coordinates: e\n  })) : r.type === \"MultiPoint\" ? r.coordinates.map(e => ({\n    type: \"Point\",\n    coordinates: e\n  })) : [r];\n}\nclass Te {\n  constructor(e, t) {\n    this.type = g, this.geojson = e, this.geometries = t;\n  }\n  static parse(e, t) {\n    if (e.length !== 2) return t.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);\n    if (He(e[1])) {\n      const n = e[1];\n      if (n.type === \"FeatureCollection\") return new Te(n, n.features.map(a => Vt(a.geometry)).flat());\n      if (n.type === \"Feature\") return new Te(n, Vt(n.geometry));\n      if (\"type\" in n && \"coordinates\" in n) return new Te(n, Vt(n));\n    }\n    return t.error(\"'distance' expression requires valid geojson object that contains polygon geometry type.\");\n  }\n  evaluate(e) {\n    if (e.geometry() != null && e.canonicalID() != null) {\n      if (e.geometryType() === \"Point\") return es(e, this.geometries);\n      if (e.geometryType() === \"LineString\") return ts(e, this.geometries);\n      if (e.geometryType() === \"Polygon\") return rs(e, this.geometries);\n    }\n    return NaN;\n  }\n  eachChild() {}\n  outputDefined() {\n    return !0;\n  }\n}\nconst Ar = {\n  // special forms\n  \"==\": Ai,\n  \"!=\": Ti,\n  \">\": Ei,\n  \"<\": Ii,\n  \">=\": _i,\n  \"<=\": Mi,\n  array: te,\n  at: dr,\n  boolean: te,\n  case: hr,\n  coalesce: Ke,\n  collator: Et,\n  format: vr,\n  image: br,\n  in: yr,\n  \"index-of\": pt,\n  interpolate: se,\n  \"interpolate-hcl\": se,\n  \"interpolate-lab\": se,\n  length: wr,\n  let: At,\n  literal: je,\n  match: mr,\n  number: te,\n  \"number-format\": gr,\n  object: te,\n  slice: ft,\n  step: It,\n  string: te,\n  \"to-boolean\": ge,\n  \"to-color\": ge,\n  \"to-number\": ge,\n  \"to-string\": ge,\n  var: Tt,\n  within: Ae,\n  distance: Te\n};\nclass re {\n  constructor(e, t, n, a) {\n    this.name = e, this.type = t, this._evaluate = n, this.args = a;\n  }\n  evaluate(e) {\n    return this._evaluate(e, this.args);\n  }\n  eachChild(e) {\n    this.args.forEach(e);\n  }\n  outputDefined() {\n    return !1;\n  }\n  static parse(e, t) {\n    const n = e[0],\n      a = re.definitions[n];\n    if (!a) return t.error(`Unknown expression \"${n}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n    const o = Array.isArray(a) ? a[0] : a.type,\n      i = Array.isArray(a) ? [[a[1], a[2]]] : a.overloads,\n      s = i.filter(([u]) => !Array.isArray(u) ||\n      // varags\n      u.length === e.length - 1);\n    let l = null;\n    for (const [u, c] of s) {\n      l = new Ct(t.registry, ht, t.path, null, t.scope);\n      const p = [];\n      let m = !1;\n      for (let f = 1; f < e.length; f++) {\n        const d = e[f],\n          y = Array.isArray(u) ? u[f - 1] : u.type,\n          v = l.parse(d, 1 + p.length, y);\n        if (!v) {\n          m = !0;\n          break;\n        }\n        p.push(v);\n      }\n      if (!m) {\n        if (Array.isArray(u) && u.length !== p.length) {\n          l.error(`Expected ${u.length} arguments, but found ${p.length} instead.`);\n          continue;\n        }\n        for (let f = 0; f < p.length; f++) {\n          const d = Array.isArray(u) ? u[f] : u.type,\n            y = p[f];\n          l.concat(f + 1).checkSubtype(d, y.type);\n        }\n        if (l.errors.length === 0) return new re(n, o, c, p);\n      }\n    }\n    if (s.length === 1) t.errors.push(...l.errors);else {\n      const c = (s.length ? s : i).map(([m]) => as(m)).join(\" | \"),\n        p = [];\n      for (let m = 1; m < e.length; m++) {\n        const f = t.parse(e[m], 1 + p.length);\n        if (!f) return null;\n        p.push(N(f.type));\n      }\n      t.error(`Expected arguments of type ${c}, but found (${p.join(\", \")}) instead.`);\n    }\n    return null;\n  }\n  static register(e, t) {\n    re.definitions = t;\n    for (const n in t) e[n] = re;\n  }\n}\nfunction ln(r, [e, t, n, a]) {\n  e = e.evaluate(r), t = t.evaluate(r), n = n.evaluate(r);\n  const o = a ? a.evaluate(r) : 1,\n    i = zn(e, t, n, o);\n  if (i) throw new D(i);\n  return new $(e / 255, t / 255, n / 255, o, !1);\n}\nfunction un(r, e) {\n  return r in e;\n}\nfunction Gt(r, e) {\n  const t = e[r];\n  return typeof t > \"u\" ? null : t;\n}\nfunction ns(r, e, t, n) {\n  for (; t <= n;) {\n    const a = t + n >> 1;\n    if (e[a] === r) return !0;\n    e[a] > r ? n = a - 1 : t = a + 1;\n  }\n  return !1;\n}\nfunction ke(r) {\n  return {\n    type: r\n  };\n}\nre.register(Ar, {\n  error: [Qo, [I], (r, [e]) => {\n    throw new D(e.evaluate(r));\n  }],\n  typeof: [I, [A], (r, [e]) => N(q(e.evaluate(r)))],\n  \"to-rgba\": [W(g, 4), [ie], (r, [e]) => {\n    const [t, n, a, o] = e.evaluate(r).rgb;\n    return [t * 255, n * 255, a * 255, o];\n  }],\n  rgb: [ie, [g, g, g], ln],\n  rgba: [ie, [g, g, g, g], ln],\n  has: {\n    type: C,\n    overloads: [[[I], (r, [e]) => un(e.evaluate(r), r.properties())], [[I, Re], (r, [e, t]) => un(e.evaluate(r), t.evaluate(r))]]\n  },\n  get: {\n    type: A,\n    overloads: [[[I], (r, [e]) => Gt(e.evaluate(r), r.properties())], [[I, Re], (r, [e, t]) => Gt(e.evaluate(r), t.evaluate(r))]]\n  },\n  \"feature-state\": [A, [I], (r, [e]) => Gt(e.evaluate(r), r.featureState || {})],\n  properties: [Re, [], r => r.properties()],\n  \"geometry-type\": [I, [], r => r.geometryType()],\n  id: [A, [], r => r.id()],\n  zoom: [g, [], r => r.globals.zoom],\n  \"heatmap-density\": [g, [], r => r.globals.heatmapDensity || 0],\n  \"line-progress\": [g, [], r => r.globals.lineProgress || 0],\n  accumulated: [A, [], r => r.globals.accumulated === void 0 ? null : r.globals.accumulated],\n  \"+\": [g, ke(g), (r, e) => {\n    let t = 0;\n    for (const n of e) t += n.evaluate(r);\n    return t;\n  }],\n  \"*\": [g, ke(g), (r, e) => {\n    let t = 1;\n    for (const n of e) t *= n.evaluate(r);\n    return t;\n  }],\n  \"-\": {\n    type: g,\n    overloads: [[[g, g], (r, [e, t]) => e.evaluate(r) - t.evaluate(r)], [[g], (r, [e]) => -e.evaluate(r)]]\n  },\n  \"/\": [g, [g, g], (r, [e, t]) => e.evaluate(r) / t.evaluate(r)],\n  \"%\": [g, [g, g], (r, [e, t]) => e.evaluate(r) % t.evaluate(r)],\n  ln2: [g, [], () => Math.LN2],\n  pi: [g, [], () => Math.PI],\n  e: [g, [], () => Math.E],\n  \"^\": [g, [g, g], (r, [e, t]) => Math.pow(e.evaluate(r), t.evaluate(r))],\n  sqrt: [g, [g], (r, [e]) => Math.sqrt(e.evaluate(r))],\n  log10: [g, [g], (r, [e]) => Math.log(e.evaluate(r)) / Math.LN10],\n  ln: [g, [g], (r, [e]) => Math.log(e.evaluate(r))],\n  log2: [g, [g], (r, [e]) => Math.log(e.evaluate(r)) / Math.LN2],\n  sin: [g, [g], (r, [e]) => Math.sin(e.evaluate(r))],\n  cos: [g, [g], (r, [e]) => Math.cos(e.evaluate(r))],\n  tan: [g, [g], (r, [e]) => Math.tan(e.evaluate(r))],\n  asin: [g, [g], (r, [e]) => Math.asin(e.evaluate(r))],\n  acos: [g, [g], (r, [e]) => Math.acos(e.evaluate(r))],\n  atan: [g, [g], (r, [e]) => Math.atan(e.evaluate(r))],\n  min: [g, ke(g), (r, e) => Math.min(...e.map(t => t.evaluate(r)))],\n  max: [g, ke(g), (r, e) => Math.max(...e.map(t => t.evaluate(r)))],\n  abs: [g, [g], (r, [e]) => Math.abs(e.evaluate(r))],\n  round: [g, [g], (r, [e]) => {\n    const t = e.evaluate(r);\n    return t < 0 ? -Math.round(-t) : Math.round(t);\n  }],\n  floor: [g, [g], (r, [e]) => Math.floor(e.evaluate(r))],\n  ceil: [g, [g], (r, [e]) => Math.ceil(e.evaluate(r))],\n  \"filter-==\": [C, [I, A], (r, [e, t]) => r.properties()[e.value] === t.value],\n  \"filter-id-==\": [C, [A], (r, [e]) => r.id() === e.value],\n  \"filter-type-==\": [C, [I], (r, [e]) => r.geometryType() === e.value],\n  \"filter-<\": [C, [I, A], (r, [e, t]) => {\n    const n = r.properties()[e.value],\n      a = t.value;\n    return typeof n == typeof a && n < a;\n  }],\n  \"filter-id-<\": [C, [A], (r, [e]) => {\n    const t = r.id(),\n      n = e.value;\n    return typeof t == typeof n && t < n;\n  }],\n  \"filter->\": [C, [I, A], (r, [e, t]) => {\n    const n = r.properties()[e.value],\n      a = t.value;\n    return typeof n == typeof a && n > a;\n  }],\n  \"filter-id->\": [C, [A], (r, [e]) => {\n    const t = r.id(),\n      n = e.value;\n    return typeof t == typeof n && t > n;\n  }],\n  \"filter-<=\": [C, [I, A], (r, [e, t]) => {\n    const n = r.properties()[e.value],\n      a = t.value;\n    return typeof n == typeof a && n <= a;\n  }],\n  \"filter-id-<=\": [C, [A], (r, [e]) => {\n    const t = r.id(),\n      n = e.value;\n    return typeof t == typeof n && t <= n;\n  }],\n  \"filter->=\": [C, [I, A], (r, [e, t]) => {\n    const n = r.properties()[e.value],\n      a = t.value;\n    return typeof n == typeof a && n >= a;\n  }],\n  \"filter-id->=\": [C, [A], (r, [e]) => {\n    const t = r.id(),\n      n = e.value;\n    return typeof t == typeof n && t >= n;\n  }],\n  \"filter-has\": [C, [A], (r, [e]) => e.value in r.properties()],\n  \"filter-has-id\": [C, [], r => r.id() !== null && r.id() !== void 0],\n  \"filter-type-in\": [C, [W(I)], (r, [e]) => e.value.indexOf(r.geometryType()) >= 0],\n  \"filter-id-in\": [C, [W(A)], (r, [e]) => e.value.indexOf(r.id()) >= 0],\n  \"filter-in-small\": [C, [I, W(A)],\n  // assumes v is an array literal\n  (r, [e, t]) => t.value.indexOf(r.properties()[e.value]) >= 0],\n  \"filter-in-large\": [C, [I, W(A)],\n  // assumes v is a array literal with values sorted in ascending order and of a single type\n  (r, [e, t]) => ns(r.properties()[e.value], t.value, 0, t.value.length - 1)],\n  all: {\n    type: C,\n    overloads: [[[C, C], (r, [e, t]) => e.evaluate(r) && t.evaluate(r)], [ke(C), (r, e) => {\n      for (const t of e) if (!t.evaluate(r)) return !1;\n      return !0;\n    }]]\n  },\n  any: {\n    type: C,\n    overloads: [[[C, C], (r, [e, t]) => e.evaluate(r) || t.evaluate(r)], [ke(C), (r, e) => {\n      for (const t of e) if (t.evaluate(r)) return !0;\n      return !1;\n    }]]\n  },\n  \"!\": [C, [C], (r, [e]) => !e.evaluate(r)],\n  \"is-supported-script\": [C, [I],\n  // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant\n  (r, [e]) => {\n    const t = r.globals && r.globals.isSupportedScript;\n    return t ? t(e.evaluate(r)) : !0;\n  }],\n  upcase: [I, [I], (r, [e]) => e.evaluate(r).toUpperCase()],\n  downcase: [I, [I], (r, [e]) => e.evaluate(r).toLowerCase()],\n  concat: [I, ke(A), (r, e) => e.map(t => Be(t.evaluate(r))).join(\"\")],\n  \"resolved-locale\": [I, [St], (r, [e]) => e.evaluate(r).resolvedLocale()]\n});\nfunction as(r) {\n  return Array.isArray(r) ? `(${r.map(N).join(\", \")})` : `(${N(r.type)}...)`;\n}\nfunction ht(r) {\n  if (r instanceof Tt) return ht(r.boundExpression);\n  if (r instanceof re && r.name === \"error\") return !1;\n  if (r instanceof Et) return !1;\n  if (r instanceof Ae) return !1;\n  if (r instanceof Te) return !1;\n  const e = r instanceof ge || r instanceof te;\n  let t = !0;\n  return r.eachChild(n => {\n    e ? t = t && ht(n) : t = t && n instanceof je;\n  }), t ? _t(r) && zt(r, [\"zoom\", \"heatmap-density\", \"line-progress\", \"accumulated\", \"is-supported-script\"]) : !1;\n}\nfunction _t(r) {\n  if (r instanceof re) {\n    if (r.name === \"get\" && r.args.length === 1) return !1;\n    if (r.name === \"feature-state\") return !1;\n    if (r.name === \"has\" && r.args.length === 1) return !1;\n    if (r.name === \"properties\" || r.name === \"geometry-type\" || r.name === \"id\") return !1;\n    if (/^filter-/.test(r.name)) return !1;\n  }\n  if (r instanceof Ae || r instanceof Te) return !1;\n  let e = !0;\n  return r.eachChild(t => {\n    e && !_t(t) && (e = !1);\n  }), e;\n}\nfunction Ze(r) {\n  if (r instanceof re && r.name === \"feature-state\") return !1;\n  let e = !0;\n  return r.eachChild(t => {\n    e && !Ze(t) && (e = !1);\n  }), e;\n}\nfunction zt(r, e) {\n  if (r instanceof re && e.indexOf(r.name) >= 0) return !1;\n  let t = !0;\n  return r.eachChild(n => {\n    t && !zt(n, e) && (t = !1);\n  }), t;\n}\nfunction rr(r) {\n  return {\n    result: \"success\",\n    value: r\n  };\n}\nfunction Pe(r) {\n  return {\n    result: \"error\",\n    value: r\n  };\n}\nfunction gt(r) {\n  return r[\"property-type\"] === \"data-driven\" || r[\"property-type\"] === \"cross-faded-data-driven\";\n}\nfunction Bn(r) {\n  return !!r.expression && r.expression.parameters.indexOf(\"zoom\") > -1;\n}\nfunction Un(r) {\n  return !!r.expression && r.expression.interpolated;\n}\nfunction _(r) {\n  return r instanceof Number ? \"number\" : r instanceof String ? \"string\" : r instanceof Boolean ? \"boolean\" : Array.isArray(r) ? \"array\" : r === null ? \"null\" : typeof r;\n}\nfunction Tr(r) {\n  return typeof r == \"object\" && r !== null && !Array.isArray(r);\n}\nclass os {\n  constructor(e, t) {\n    this.expression = e, this._warningHistory = {}, this._evaluator = new Pn(), this._defaultValue = t ? ls(t) : null, this._enumValues = t && t.type === \"enum\" ? t.values : null;\n  }\n  evaluateWithoutErrorHandling(e, t, n, a, o, i) {\n    return this._evaluator.globals = e, this._evaluator.feature = t, this._evaluator.featureState = n, this._evaluator.canonical = a, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = i, this.expression.evaluate(this._evaluator);\n  }\n  evaluate(e, t, n, a, o, i) {\n    this._evaluator.globals = e, this._evaluator.feature = t || null, this._evaluator.featureState = n || null, this._evaluator.canonical = a, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = i || null;\n    try {\n      const s = this.expression.evaluate(this._evaluator);\n      if (s == null || typeof s == \"number\" && s !== s) return this._defaultValue;\n      if (this._enumValues && !(s in this._enumValues)) throw new D(`Expected value to be one of ${Object.keys(this._enumValues).map(l => JSON.stringify(l)).join(\", \")}, but found ${JSON.stringify(s)} instead.`);\n      return s;\n    } catch (s) {\n      return this._warningHistory[s.message] || (this._warningHistory[s.message] = !0, typeof console < \"u\" && console.warn(s.message)), this._defaultValue;\n    }\n  }\n}\nfunction Vn(r) {\n  return Array.isArray(r) && r.length > 0 && typeof r[0] == \"string\" && r[0] in Ar;\n}\nfunction Gn(r, e) {\n  const t = new Ct(Ar, ht, [], e ? ss(e) : void 0),\n    n = t.parse(r, void 0, void 0, void 0, e && e.type === \"string\" ? {\n      typeAnnotation: \"coerce\"\n    } : void 0);\n  return n ? rr(new os(n, e)) : Pe(t.errors);\n}\nclass cn {\n  constructor(e, t) {\n    this.kind = e, this._styleExpression = t, this.isStateDependent = e !== \"constant\" && !Ze(t.expression);\n  }\n  evaluateWithoutErrorHandling(e, t, n, a, o, i) {\n    return this._styleExpression.evaluateWithoutErrorHandling(e, t, n, a, o, i);\n  }\n  evaluate(e, t, n, a, o, i) {\n    return this._styleExpression.evaluate(e, t, n, a, o, i);\n  }\n}\nclass pn {\n  constructor(e, t, n, a) {\n    this.kind = e, this.zoomStops = n, this._styleExpression = t, this.isStateDependent = e !== \"camera\" && !Ze(t.expression), this.interpolationType = a;\n  }\n  evaluateWithoutErrorHandling(e, t, n, a, o, i) {\n    return this._styleExpression.evaluateWithoutErrorHandling(e, t, n, a, o, i);\n  }\n  evaluate(e, t, n, a, o, i) {\n    return this._styleExpression.evaluate(e, t, n, a, o, i);\n  }\n  interpolationFactor(e, t, n) {\n    return this.interpolationType ? se.interpolationFactor(this.interpolationType, e, t, n) : 0;\n  }\n}\nfunction is(r, e) {\n  const t = Gn(r, e);\n  if (t.result === \"error\") return t;\n  const n = t.value.expression,\n    a = _t(n);\n  if (!a && !gt(e)) return Pe([new oe(\"\", \"data expressions not supported\")]);\n  const o = zt(n, [\"zoom\"]);\n  if (!o && !Bn(e)) return Pe([new oe(\"\", \"zoom expressions not supported\")]);\n  const i = lt(n);\n  if (!i && !o) return Pe([new oe(\"\", '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.')]);\n  if (i instanceof oe) return Pe([i]);\n  if (i instanceof se && !Un(e)) return Pe([new oe(\"\", '\"interpolate\" expressions cannot be used with this property')]);\n  if (!i) return rr(a ? new cn(\"constant\", t.value) : new cn(\"source\", t.value));\n  const s = i instanceof se ? i.interpolation : void 0;\n  return rr(a ? new pn(\"camera\", t.value, i.labels, s) : new pn(\"composite\", t.value, i.labels, s));\n}\nfunction lt(r) {\n  let e = null;\n  if (r instanceof At) e = lt(r.result);else if (r instanceof Ke) {\n    for (const t of r.args) if (e = lt(t), e) break;\n  } else (r instanceof It || r instanceof se) && r.input instanceof re && r.input.name === \"zoom\" && (e = r);\n  return e instanceof oe || r.eachChild(t => {\n    const n = lt(t);\n    n instanceof oe ? e = n : !e && n ? e = new oe(\"\", '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.') : e && n && e !== n && (e = new oe(\"\", 'Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression.'));\n  }), e;\n}\nfunction ss(r) {\n  const e = {\n    color: ie,\n    string: I,\n    number: g,\n    enum: I,\n    boolean: C,\n    formatted: xt,\n    padding: kt,\n    projectionDefinition: wt,\n    resolvedImage: Xe,\n    variableAnchorOffsetCollection: Lt\n  };\n  return r.type === \"array\" ? W(e[r.value] || A, r.length) : e[r.type];\n}\nfunction ls(r) {\n  return r.type === \"color\" && Tr(r.default) ? new $(0, 0, 0, 0) : r.type === \"color\" ? $.parse(r.default) || null : r.type === \"padding\" ? J.parse(r.default) || null : r.type === \"variableAnchorOffsetCollection\" ? ne.parse(r.default) || null : r.type === \"projectionDefinition\" ? ee.parse(r.default) || null : r.default === void 0 ? null : r.default;\n}\nfunction Hn(r) {\n  if (r === !0 || r === !1) return !0;\n  if (!Array.isArray(r) || r.length === 0) return !1;\n  switch (r[0]) {\n    case \"has\":\n      return r.length >= 2 && r[1] !== \"$id\" && r[1] !== \"$type\";\n    case \"in\":\n      return r.length >= 3 && (typeof r[1] != \"string\" || Array.isArray(r[2]));\n    case \"!in\":\n    case \"!has\":\n    case \"none\":\n      return !1;\n    case \"==\":\n    case \"!=\":\n    case \">\":\n    case \">=\":\n    case \"<\":\n    case \"<=\":\n      return r.length !== 3 || Array.isArray(r[1]) || Array.isArray(r[2]);\n    case \"any\":\n    case \"all\":\n      for (const e of r.slice(1)) if (!Hn(e) && typeof e != \"boolean\") return !1;\n      return !0;\n    default:\n      return !0;\n  }\n}\nfunction Kn(r) {\n  const e = r.key,\n    t = r.value;\n  return t ? [new h(e, t, \"constants have been deprecated as of v8\")] : [];\n}\nfunction F(r) {\n  return r instanceof Number || r instanceof String || r instanceof Boolean ? r.valueOf() : r;\n}\nfunction Ee(r) {\n  if (Array.isArray(r)) return r.map(Ee);\n  if (r instanceof Object && !(r instanceof Number || r instanceof String || r instanceof Boolean)) {\n    const e = {};\n    for (const t in r) e[t] = Ee(r[t]);\n    return e;\n  }\n  return F(r);\n}\nfunction Y(r) {\n  const e = r.key,\n    t = r.value,\n    n = r.valueSpec || {},\n    a = r.objectElementValidators || {},\n    o = r.style,\n    i = r.styleSpec,\n    s = r.validateSpec;\n  let l = [];\n  const u = _(t);\n  if (u !== \"object\") return [new h(e, t, `object expected, ${u} found`)];\n  for (const c in t) {\n    const p = c.split(\".\")[0],\n      m = n[p] || n[\"*\"];\n    let f;\n    if (a[p]) f = a[p];else if (n[p]) f = s;else if (a[\"*\"]) f = a[\"*\"];else if (n[\"*\"]) f = s;else {\n      l.push(new h(e, t[c], `unknown property \"${c}\"`));\n      continue;\n    }\n    l = l.concat(f({\n      key: (e && `${e}.`) + c,\n      value: t[c],\n      valueSpec: m,\n      style: o,\n      styleSpec: i,\n      object: t,\n      objectKey: c,\n      validateSpec: s\n    }, t));\n  }\n  for (const c in n) a[c] || n[c].required && n[c].default === void 0 && t[c] === void 0 && l.push(new h(e, t, `missing required property \"${c}\"`));\n  return l;\n}\nfunction Ir(r) {\n  const e = r.value,\n    t = r.valueSpec,\n    n = r.validateSpec,\n    a = r.style,\n    o = r.styleSpec,\n    i = r.key,\n    s = r.arrayElementValidator || n;\n  if (_(e) !== \"array\") return [new h(i, e, `array expected, ${_(e)} found`)];\n  if (t.length && e.length !== t.length) return [new h(i, e, `array length ${t.length} expected, length ${e.length} found`)];\n  if (t[\"min-length\"] && e.length < t[\"min-length\"]) return [new h(i, e, `array length at least ${t[\"min-length\"]} expected, length ${e.length} found`)];\n  let l = {\n    type: t.value,\n    values: t.values\n  };\n  o.$version < 7 && (l.function = t.function), _(t.value) === \"object\" && (l = t.value);\n  let u = [];\n  for (let c = 0; c < e.length; c++) u = u.concat(s({\n    array: e,\n    arrayIndex: c,\n    value: e[c],\n    valueSpec: l,\n    validateSpec: r.validateSpec,\n    style: a,\n    styleSpec: o,\n    key: `${i}[${c}]`\n  }));\n  return u;\n}\nfunction Er(r) {\n  const e = r.key,\n    t = r.value,\n    n = r.valueSpec;\n  let a = _(t);\n  return a === \"number\" && t !== t && (a = \"NaN\"), a !== \"number\" ? [new h(e, t, `number expected, ${a} found`)] : \"minimum\" in n && t < n.minimum ? [new h(e, t, `${t} is less than the minimum value ${n.minimum}`)] : \"maximum\" in n && t > n.maximum ? [new h(e, t, `${t} is greater than the maximum value ${n.maximum}`)] : [];\n}\nfunction Wn(r) {\n  const e = r.valueSpec,\n    t = F(r.value.type);\n  let n,\n    a = {},\n    o,\n    i;\n  const s = t !== \"categorical\" && r.value.property === void 0,\n    l = !s,\n    u = _(r.value.stops) === \"array\" && _(r.value.stops[0]) === \"array\" && _(r.value.stops[0][0]) === \"object\",\n    c = Y({\n      key: r.key,\n      value: r.value,\n      valueSpec: r.styleSpec.function,\n      validateSpec: r.validateSpec,\n      style: r.style,\n      styleSpec: r.styleSpec,\n      objectElementValidators: {\n        stops: p,\n        default: d\n      }\n    });\n  return t === \"identity\" && s && c.push(new h(r.key, r.value, 'missing required property \"property\"')), t !== \"identity\" && !r.value.stops && c.push(new h(r.key, r.value, 'missing required property \"stops\"')), t === \"exponential\" && r.valueSpec.expression && !Un(r.valueSpec) && c.push(new h(r.key, r.value, \"exponential functions not supported\")), r.styleSpec.$version >= 8 && (l && !gt(r.valueSpec) ? c.push(new h(r.key, r.value, \"property functions not supported\")) : s && !Bn(r.valueSpec) && c.push(new h(r.key, r.value, \"zoom functions not supported\"))), (t === \"categorical\" || u) && r.value.property === void 0 && c.push(new h(r.key, r.value, '\"property\" property is required')), c;\n  function p(y) {\n    if (t === \"identity\") return [new h(y.key, y.value, 'identity function may not have a \"stops\" property')];\n    let v = [];\n    const w = y.value;\n    return v = v.concat(Ir({\n      key: y.key,\n      value: w,\n      valueSpec: y.valueSpec,\n      validateSpec: y.validateSpec,\n      style: y.style,\n      styleSpec: y.styleSpec,\n      arrayElementValidator: m\n    })), _(w) === \"array\" && w.length === 0 && v.push(new h(y.key, w, \"array must have at least one stop\")), v;\n  }\n  function m(y) {\n    let v = [];\n    const w = y.value,\n      b = y.key;\n    if (_(w) !== \"array\") return [new h(b, w, `array expected, ${_(w)} found`)];\n    if (w.length !== 2) return [new h(b, w, `array length 2 expected, length ${w.length} found`)];\n    if (u) {\n      if (_(w[0]) !== \"object\") return [new h(b, w, `object expected, ${_(w[0])} found`)];\n      if (w[0].zoom === void 0) return [new h(b, w, \"object stop key must have zoom\")];\n      if (w[0].value === void 0) return [new h(b, w, \"object stop key must have value\")];\n      if (i && i > F(w[0].zoom)) return [new h(b, w[0].zoom, \"stop zoom values must appear in ascending order\")];\n      F(w[0].zoom) !== i && (i = F(w[0].zoom), o = void 0, a = {}), v = v.concat(Y({\n        key: `${b}[0]`,\n        value: w[0],\n        valueSpec: {\n          zoom: {}\n        },\n        validateSpec: y.validateSpec,\n        style: y.style,\n        styleSpec: y.styleSpec,\n        objectElementValidators: {\n          zoom: Er,\n          value: f\n        }\n      }));\n    } else v = v.concat(f({\n      key: `${b}[0]`,\n      value: w[0],\n      valueSpec: {},\n      validateSpec: y.validateSpec,\n      style: y.style,\n      styleSpec: y.styleSpec\n    }, w));\n    return Vn(Ee(w[1])) ? v.concat([new h(`${b}[1]`, w[1], \"expressions are not allowed in function stops.\")]) : v.concat(y.validateSpec({\n      key: `${b}[1]`,\n      value: w[1],\n      valueSpec: e,\n      validateSpec: y.validateSpec,\n      style: y.style,\n      styleSpec: y.styleSpec\n    }));\n  }\n  function f(y, v) {\n    const w = _(y.value),\n      b = F(y.value),\n      T = y.value !== null ? y.value : v;\n    if (!n) n = w;else if (w !== n) return [new h(y.key, T, `${w} stop domain type must match previous stop domain type ${n}`)];\n    if (w !== \"number\" && w !== \"string\" && w !== \"boolean\") return [new h(y.key, T, \"stop domain value must be a number, string, or boolean\")];\n    if (w !== \"number\" && t !== \"categorical\") {\n      let j = `number expected, ${w} found`;\n      return gt(e) && t === void 0 && (j += '\\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`.'), [new h(y.key, T, j)];\n    }\n    return t === \"categorical\" && w === \"number\" && (!isFinite(b) || Math.floor(b) !== b) ? [new h(y.key, T, `integer expected, found ${b}`)] : t !== \"categorical\" && w === \"number\" && o !== void 0 && b < o ? [new h(y.key, T, \"stop domain values must appear in ascending order\")] : (o = b, t === \"categorical\" && b in a ? [new h(y.key, T, \"stop domain values must be unique\")] : (a[b] = !0, []));\n  }\n  function d(y) {\n    return y.validateSpec({\n      key: y.key,\n      value: y.value,\n      valueSpec: e,\n      validateSpec: y.validateSpec,\n      style: y.style,\n      styleSpec: y.styleSpec\n    });\n  }\n}\nfunction Ne(r) {\n  const e = (r.expressionContext === \"property\" ? is : Gn)(Ee(r.value), r.valueSpec);\n  if (e.result === \"error\") return e.value.map(n => new h(`${r.key}${n.key}`, r.value, n.message));\n  const t = e.value.expression || e.value._styleExpression.expression;\n  if (r.expressionContext === \"property\" && r.propertyKey === \"text-font\" && !t.outputDefined()) return [new h(r.key, r.value, `Invalid data expression for \"${r.propertyKey}\". Output values must be contained as literals within the expression.`)];\n  if (r.expressionContext === \"property\" && r.propertyType === \"layout\" && !Ze(t)) return [new h(r.key, r.value, '\"feature-state\" data expressions are not supported with layout properties.')];\n  if (r.expressionContext === \"filter\" && !Ze(t)) return [new h(r.key, r.value, '\"feature-state\" data expressions are not supported with filters.')];\n  if (r.expressionContext && r.expressionContext.indexOf(\"cluster\") === 0) {\n    if (!zt(t, [\"zoom\", \"feature-state\"])) return [new h(r.key, r.value, '\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.')];\n    if (r.expressionContext === \"cluster-initial\" && !_t(t)) return [new h(r.key, r.value, \"Feature data expressions are not supported with initial expression part of cluster properties.\")];\n  }\n  return [];\n}\nfunction us(r) {\n  const e = r.value,\n    t = r.key,\n    n = _(e);\n  return n !== \"boolean\" ? [new h(t, e, `boolean expected, ${n} found`)] : [];\n}\nfunction cs(r) {\n  const e = r.key,\n    t = r.value,\n    n = _(t);\n  return n !== \"string\" ? [new h(e, t, `color expected, ${n} found`)] : $.parse(String(t)) ? [] : [new h(e, t, `color expected, \"${t}\" found`)];\n}\nfunction Je(r) {\n  const e = r.key,\n    t = r.value,\n    n = r.valueSpec,\n    a = [];\n  return Array.isArray(n.values) ? n.values.indexOf(F(t)) === -1 && a.push(new h(e, t, `expected one of [${n.values.join(\", \")}], ${JSON.stringify(t)} found`)) : Object.keys(n.values).indexOf(F(t)) === -1 && a.push(new h(e, t, `expected one of [${Object.keys(n.values).join(\", \")}], ${JSON.stringify(t)} found`)), a;\n}\nfunction Mr(r) {\n  return Hn(Ee(r.value)) ? Ne(ct({}, r, {\n    expressionContext: \"filter\",\n    valueSpec: {\n      value: \"boolean\"\n    }\n  })) : Zn(r);\n}\nfunction Zn(r) {\n  const e = r.value,\n    t = r.key;\n  if (_(e) !== \"array\") return [new h(t, e, `array expected, ${_(e)} found`)];\n  const n = r.styleSpec;\n  let a,\n    o = [];\n  if (e.length < 1) return [new h(t, e, \"filter array must have at least 1 element\")];\n  switch (o = o.concat(Je({\n    key: `${t}[0]`,\n    value: e[0],\n    valueSpec: n.filter_operator,\n    style: r.style,\n    styleSpec: r.styleSpec\n  })), F(e[0])) {\n    case \"<\":\n    case \"<=\":\n    case \">\":\n    case \">=\":\n      e.length >= 2 && F(e[1]) === \"$type\" && o.push(new h(t, e, `\"$type\" cannot be use with operator \"${e[0]}\"`));\n    /* falls through */\n    case \"==\":\n    case \"!=\":\n      e.length !== 3 && o.push(new h(t, e, `filter array for operator \"${e[0]}\" must have 3 elements`));\n    /* falls through */\n    case \"in\":\n    case \"!in\":\n      e.length >= 2 && (a = _(e[1]), a !== \"string\" && o.push(new h(`${t}[1]`, e[1], `string expected, ${a} found`)));\n      for (let i = 2; i < e.length; i++) a = _(e[i]), F(e[1]) === \"$type\" ? o = o.concat(Je({\n        key: `${t}[${i}]`,\n        value: e[i],\n        valueSpec: n.geometry_type,\n        style: r.style,\n        styleSpec: r.styleSpec\n      })) : a !== \"string\" && a !== \"number\" && a !== \"boolean\" && o.push(new h(`${t}[${i}]`, e[i], `string, number, or boolean expected, ${a} found`));\n      break;\n    case \"any\":\n    case \"all\":\n    case \"none\":\n      for (let i = 1; i < e.length; i++) o = o.concat(Zn({\n        key: `${t}[${i}]`,\n        value: e[i],\n        style: r.style,\n        styleSpec: r.styleSpec\n      }));\n      break;\n    case \"has\":\n    case \"!has\":\n      a = _(e[1]), e.length !== 2 ? o.push(new h(t, e, `filter array for \"${e[0]}\" operator must have 2 elements`)) : a !== \"string\" && o.push(new h(`${t}[1]`, e[1], `string expected, ${a} found`));\n      break;\n  }\n  return o;\n}\nfunction Jn(r, e) {\n  const t = r.key,\n    n = r.validateSpec,\n    a = r.style,\n    o = r.styleSpec,\n    i = r.value,\n    s = r.objectKey,\n    l = o[`${e}_${r.layerType}`];\n  if (!l) return [];\n  const u = s.match(/^(.*)-transition$/);\n  if (e === \"paint\" && u && l[u[1]] && l[u[1]].transition) return n({\n    key: t,\n    value: i,\n    valueSpec: o.transition,\n    style: a,\n    styleSpec: o\n  });\n  const c = r.valueSpec || l[s];\n  if (!c) return [new h(t, i, `unknown property \"${s}\"`)];\n  let p;\n  if (_(i) === \"string\" && gt(c) && !c.tokens && (p = /^{([^}]+)}$/.exec(i))) return [new h(t, i, `\"${s}\" does not support interpolation syntax\nUse an identity property function instead: \\`{ \"type\": \"identity\", \"property\": ${JSON.stringify(p[1])} }\\`.`)];\n  const m = [];\n  return r.layerType === \"symbol\" && (s === \"text-field\" && a && !a.glyphs && m.push(new h(t, i, 'use of \"text-field\" requires a style \"glyphs\" property')), s === \"text-font\" && Tr(Ee(i)) && F(i.type) === \"identity\" && m.push(new h(t, i, '\"text-font\" does not support identity functions'))), m.concat(n({\n    key: r.key,\n    value: i,\n    valueSpec: c,\n    style: a,\n    styleSpec: o,\n    expressionContext: \"property\",\n    propertyType: e,\n    propertyKey: s\n  }));\n}\nfunction Yn(r) {\n  return Jn(r, \"paint\");\n}\nfunction Xn(r) {\n  return Jn(r, \"layout\");\n}\nfunction Qn(r) {\n  let e = [];\n  const t = r.value,\n    n = r.key,\n    a = r.style,\n    o = r.styleSpec;\n  !t.type && !t.ref && e.push(new h(n, t, 'either \"type\" or \"ref\" is required'));\n  let i = F(t.type);\n  const s = F(t.ref);\n  if (t.id) {\n    const l = F(t.id);\n    for (let u = 0; u < r.arrayIndex; u++) {\n      const c = a.layers[u];\n      F(c.id) === l && e.push(new h(n, t.id, `duplicate layer id \"${t.id}\", previously used at line ${c.id.__line__}`));\n    }\n  }\n  if (\"ref\" in t) {\n    [\"type\", \"source\", \"source-layer\", \"filter\", \"layout\"].forEach(u => {\n      u in t && e.push(new h(n, t[u], `\"${u}\" is prohibited for ref layers`));\n    });\n    let l;\n    a.layers.forEach(u => {\n      F(u.id) === s && (l = u);\n    }), l ? l.ref ? e.push(new h(n, t.ref, \"ref cannot reference another ref layer\")) : i = F(l.type) : e.push(new h(n, t.ref, `ref layer \"${s}\" not found`));\n  } else if (i !== \"background\") if (!t.source) e.push(new h(n, t, 'missing required property \"source\"'));else {\n    const l = a.sources && a.sources[t.source],\n      u = l && F(l.type);\n    l ? u === \"vector\" && i === \"raster\" ? e.push(new h(n, t.source, `layer \"${t.id}\" requires a raster source`)) : u !== \"raster-dem\" && i === \"hillshade\" ? e.push(new h(n, t.source, `layer \"${t.id}\" requires a raster-dem source`)) : u === \"raster\" && i !== \"raster\" ? e.push(new h(n, t.source, `layer \"${t.id}\" requires a vector source`)) : u === \"vector\" && !t[\"source-layer\"] ? e.push(new h(n, t, `layer \"${t.id}\" must specify a \"source-layer\"`)) : u === \"raster-dem\" && i !== \"hillshade\" ? e.push(new h(n, t.source, \"raster-dem source can only be used with layer type 'hillshade'.\")) : i === \"line\" && t.paint && t.paint[\"line-gradient\"] && (u !== \"geojson\" || !l.lineMetrics) && e.push(new h(n, t, `layer \"${t.id}\" specifies a line-gradient, which requires a GeoJSON source with \\`lineMetrics\\` enabled.`)) : e.push(new h(n, t.source, `source \"${t.source}\" not found`));\n  }\n  return e = e.concat(Y({\n    key: n,\n    value: t,\n    valueSpec: o.layer,\n    style: r.style,\n    styleSpec: r.styleSpec,\n    validateSpec: r.validateSpec,\n    objectElementValidators: {\n      \"*\"() {\n        return [];\n      },\n      // We don't want to enforce the spec's `\"requires\": true` for backward compatibility with refs;\n      // the actual requirement is validated above. See https://github.com/mapbox/mapbox-gl-js/issues/5772.\n      type() {\n        return r.validateSpec({\n          key: `${n}.type`,\n          value: t.type,\n          valueSpec: o.layer.type,\n          style: r.style,\n          styleSpec: r.styleSpec,\n          validateSpec: r.validateSpec,\n          object: t,\n          objectKey: \"type\"\n        });\n      },\n      filter: Mr,\n      layout(l) {\n        return Y({\n          layer: t,\n          key: l.key,\n          value: l.value,\n          style: l.style,\n          styleSpec: l.styleSpec,\n          validateSpec: l.validateSpec,\n          objectElementValidators: {\n            \"*\"(u) {\n              return Xn(ct({\n                layerType: i\n              }, u));\n            }\n          }\n        });\n      },\n      paint(l) {\n        return Y({\n          layer: t,\n          key: l.key,\n          value: l.value,\n          style: l.style,\n          styleSpec: l.styleSpec,\n          validateSpec: l.validateSpec,\n          objectElementValidators: {\n            \"*\"(u) {\n              return Yn(ct({\n                layerType: i\n              }, u));\n            }\n          }\n        });\n      }\n    }\n  })), e;\n}\nfunction Me(r) {\n  const e = r.value,\n    t = r.key,\n    n = _(e);\n  return n !== \"string\" ? [new h(t, e, `string expected, ${n} found`)] : [];\n}\nfunction ps(r) {\n  var e;\n  const t = (e = r.sourceName) !== null && e !== void 0 ? e : \"\",\n    n = r.value,\n    a = r.styleSpec,\n    o = a.source_raster_dem,\n    i = r.style;\n  let s = [];\n  const l = _(n);\n  if (n === void 0) return s;\n  if (l !== \"object\") return s.push(new h(\"source_raster_dem\", n, `object expected, ${l} found`)), s;\n  const c = F(n.encoding) === \"custom\",\n    p = [\"redFactor\", \"greenFactor\", \"blueFactor\", \"baseShift\"],\n    m = r.value.encoding ? `\"${r.value.encoding}\"` : \"Default\";\n  for (const f in n) !c && p.includes(f) ? s.push(new h(f, n[f], `In \"${t}\": \"${f}\" is only valid when \"encoding\" is set to \"custom\". ${m} encoding found`)) : o[f] ? s = s.concat(r.validateSpec({\n    key: f,\n    value: n[f],\n    valueSpec: o[f],\n    validateSpec: r.validateSpec,\n    style: i,\n    styleSpec: a\n  })) : s.push(new h(f, n[f], `unknown property \"${f}\"`));\n  return s;\n}\nconst fn = {\n  promoteId: fs\n};\nfunction ea(r) {\n  const e = r.value,\n    t = r.key,\n    n = r.styleSpec,\n    a = r.style,\n    o = r.validateSpec;\n  if (!e.type) return [new h(t, e, '\"type\" is required')];\n  const i = F(e.type);\n  let s;\n  switch (i) {\n    case \"vector\":\n    case \"raster\":\n      return s = Y({\n        key: t,\n        value: e,\n        valueSpec: n[`source_${i.replace(\"-\", \"_\")}`],\n        style: r.style,\n        styleSpec: n,\n        objectElementValidators: fn,\n        validateSpec: o\n      }), s;\n    case \"raster-dem\":\n      return s = ps({\n        sourceName: t,\n        value: e,\n        style: r.style,\n        styleSpec: n,\n        validateSpec: o\n      }), s;\n    case \"geojson\":\n      if (s = Y({\n        key: t,\n        value: e,\n        valueSpec: n.source_geojson,\n        style: a,\n        styleSpec: n,\n        validateSpec: o,\n        objectElementValidators: fn\n      }), e.cluster) for (const l in e.clusterProperties) {\n        const [u, c] = e.clusterProperties[l],\n          p = typeof u == \"string\" ? [u, [\"accumulated\"], [\"get\", l]] : u;\n        s.push(...Ne({\n          key: `${t}.${l}.map`,\n          value: c,\n          validateSpec: o,\n          expressionContext: \"cluster-map\"\n        })), s.push(...Ne({\n          key: `${t}.${l}.reduce`,\n          value: p,\n          validateSpec: o,\n          expressionContext: \"cluster-reduce\"\n        }));\n      }\n      return s;\n    case \"video\":\n      return Y({\n        key: t,\n        value: e,\n        valueSpec: n.source_video,\n        style: a,\n        validateSpec: o,\n        styleSpec: n\n      });\n    case \"image\":\n      return Y({\n        key: t,\n        value: e,\n        valueSpec: n.source_image,\n        style: a,\n        validateSpec: o,\n        styleSpec: n\n      });\n    case \"canvas\":\n      return [new h(t, null, \"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.\", \"source.canvas\")];\n    default:\n      return Je({\n        key: `${t}.type`,\n        value: e.type,\n        valueSpec: {\n          values: [\"vector\", \"raster\", \"raster-dem\", \"geojson\", \"video\", \"image\"]\n        },\n        style: a,\n        validateSpec: o,\n        styleSpec: n\n      });\n  }\n}\nfunction fs({\n  key: r,\n  value: e\n}) {\n  if (_(e) === \"string\") return Me({\n    key: r,\n    value: e\n  });\n  {\n    const t = [];\n    for (const n in e) t.push(...Me({\n      key: `${r}.${n}`,\n      value: e[n]\n    }));\n    return t;\n  }\n}\nfunction ta(r) {\n  const e = r.value,\n    t = r.styleSpec,\n    n = t.light,\n    a = r.style;\n  let o = [];\n  const i = _(e);\n  if (e === void 0) return o;\n  if (i !== \"object\") return o = o.concat([new h(\"light\", e, `object expected, ${i} found`)]), o;\n  for (const s in e) {\n    const l = s.match(/^(.*)-transition$/);\n    l && n[l[1]] && n[l[1]].transition ? o = o.concat(r.validateSpec({\n      key: s,\n      value: e[s],\n      valueSpec: t.transition,\n      validateSpec: r.validateSpec,\n      style: a,\n      styleSpec: t\n    })) : n[s] ? o = o.concat(r.validateSpec({\n      key: s,\n      value: e[s],\n      valueSpec: n[s],\n      validateSpec: r.validateSpec,\n      style: a,\n      styleSpec: t\n    })) : o = o.concat([new h(s, e[s], `unknown property \"${s}\"`)]);\n  }\n  return o;\n}\nfunction ra(r) {\n  const e = r.value,\n    t = r.styleSpec,\n    n = t.sky,\n    a = r.style,\n    o = _(e);\n  if (e === void 0) return [];\n  if (o !== \"object\") return [new h(\"sky\", e, `object expected, ${o} found`)];\n  let i = [];\n  for (const s in e) n[s] ? i = i.concat(r.validateSpec({\n    key: s,\n    value: e[s],\n    valueSpec: n[s],\n    style: a,\n    styleSpec: t\n  })) : i = i.concat([new h(s, e[s], `unknown property \"${s}\"`)]);\n  return i;\n}\nfunction na(r) {\n  const e = r.value,\n    t = r.styleSpec,\n    n = t.terrain,\n    a = r.style;\n  let o = [];\n  const i = _(e);\n  if (e === void 0) return o;\n  if (i !== \"object\") return o = o.concat([new h(\"terrain\", e, `object expected, ${i} found`)]), o;\n  for (const s in e) n[s] ? o = o.concat(r.validateSpec({\n    key: s,\n    value: e[s],\n    valueSpec: n[s],\n    validateSpec: r.validateSpec,\n    style: a,\n    styleSpec: t\n  })) : o = o.concat([new h(s, e[s], `unknown property \"${s}\"`)]);\n  return o;\n}\nfunction ds(r) {\n  return Me(r).length === 0 ? [] : Ne(r);\n}\nfunction ys(r) {\n  return Me(r).length === 0 ? [] : Ne(r);\n}\nfunction ms(r) {\n  const e = r.key,\n    t = r.value;\n  if (_(t) === \"array\") {\n    if (t.length < 1 || t.length > 4) return [new h(e, t, `padding requires 1 to 4 values; ${t.length} values found`)];\n    const a = {\n      type: \"number\"\n    };\n    let o = [];\n    for (let i = 0; i < t.length; i++) o = o.concat(r.validateSpec({\n      key: `${e}[${i}]`,\n      value: t[i],\n      validateSpec: r.validateSpec,\n      valueSpec: a\n    }));\n    return o;\n  } else return Er({\n    key: e,\n    value: t,\n    valueSpec: {}\n  });\n}\nfunction hs(r) {\n  const e = r.key,\n    t = r.value,\n    n = _(t),\n    a = r.styleSpec;\n  if (n !== \"array\" || t.length < 1 || t.length % 2 !== 0) return [new h(e, t, \"variableAnchorOffsetCollection requires a non-empty array of even length\")];\n  let o = [];\n  for (let i = 0; i < t.length; i += 2) o = o.concat(Je({\n    key: `${e}[${i}]`,\n    value: t[i],\n    valueSpec: a.layout_symbol[\"text-anchor\"]\n  })), o = o.concat(Ir({\n    key: `${e}[${i + 1}]`,\n    value: t[i + 1],\n    valueSpec: {\n      length: 2,\n      value: \"number\"\n    },\n    validateSpec: r.validateSpec,\n    style: r.style,\n    styleSpec: a\n  }));\n  return o;\n}\nfunction aa(r) {\n  let e = [];\n  const t = r.value,\n    n = r.key;\n  if (Array.isArray(t)) {\n    const a = [],\n      o = [];\n    for (const i in t) {\n      t[i].id && a.includes(t[i].id) && e.push(new h(n, t, `all the sprites' ids must be unique, but ${t[i].id} is duplicated`)), a.push(t[i].id), t[i].url && o.includes(t[i].url) && e.push(new h(n, t, `all the sprites' URLs must be unique, but ${t[i].url} is duplicated`)), o.push(t[i].url);\n      const s = {\n        id: {\n          type: \"string\",\n          required: !0\n        },\n        url: {\n          type: \"string\",\n          required: !0\n        }\n      };\n      e = e.concat(Y({\n        key: `${n}[${i}]`,\n        value: t[i],\n        valueSpec: s,\n        validateSpec: r.validateSpec\n      }));\n    }\n    return e;\n  } else return Me({\n    key: n,\n    value: t\n  });\n}\nfunction gs(r) {\n  const e = r.value,\n    t = r.styleSpec,\n    n = t.projection,\n    a = r.style,\n    o = _(e);\n  if (e === void 0) return [];\n  if (o !== \"object\") return [new h(\"projection\", e, `object expected, ${o} found`)];\n  let i = [];\n  for (const s in e) n[s] ? i = i.concat(r.validateSpec({\n    key: s,\n    value: e[s],\n    valueSpec: n[s],\n    style: a,\n    styleSpec: t\n  })) : i = i.concat([new h(s, e[s], `unknown property \"${s}\"`)]);\n  return i;\n}\nfunction vs(r) {\n  const e = r.key;\n  let t = r.value;\n  t = t instanceof String ? t.valueOf() : t;\n  const n = _(t);\n  return n === \"array\" && !ws(t) && !bs(t) ? [new h(e, t, `projection expected, invalid array ${JSON.stringify(t)} found`)] : [\"array\", \"string\"].includes(n) ? [] : [new h(e, t, `projection expected, invalid type \"${n}\" found`)];\n}\nfunction bs(r) {\n  return !![\"interpolate\", \"step\", \"literal\"].includes(r[0]);\n}\nfunction ws(r) {\n  return Array.isArray(r) && r.length === 3 && typeof r[0] == \"string\" && typeof r[1] == \"string\" && typeof r[2] == \"number\";\n}\nconst dn = {\n  \"*\"() {\n    return [];\n  },\n  array: Ir,\n  boolean: us,\n  number: Er,\n  color: cs,\n  constants: Kn,\n  enum: Je,\n  filter: Mr,\n  function: Wn,\n  layer: Qn,\n  object: Y,\n  source: ea,\n  light: ta,\n  sky: ra,\n  terrain: na,\n  projection: gs,\n  projectionDefinition: vs,\n  string: Me,\n  formatted: ds,\n  resolvedImage: ys,\n  padding: ms,\n  variableAnchorOffsetCollection: hs,\n  sprite: aa\n};\nfunction Ue(r) {\n  const e = r.value,\n    t = r.valueSpec,\n    n = r.styleSpec;\n  return r.validateSpec = Ue, t.expression && Tr(F(e)) ? Wn(r) : t.expression && Vn(Ee(e)) ? Ne(r) : t.type && dn[t.type] ? dn[t.type](r) : Y(ct({}, r, {\n    valueSpec: t.type ? n[t.type] : t\n  }));\n}\nfunction oa(r) {\n  const e = r.value,\n    t = r.key,\n    n = Me(r);\n  return n.length || (e.indexOf(\"{fontstack}\") === -1 && n.push(new h(t, e, '\"glyphs\" url must include a \"{fontstack}\" token')), e.indexOf(\"{range}\") === -1 && n.push(new h(t, e, '\"glyphs\" url must include a \"{range}\" token'))), n;\n}\nfunction X(r, e = Xo) {\n  let t = [];\n  return t = t.concat(Ue({\n    key: \"\",\n    value: r,\n    valueSpec: e.$root,\n    styleSpec: e,\n    style: r,\n    validateSpec: Ue,\n    objectElementValidators: {\n      glyphs: oa,\n      \"*\"() {\n        return [];\n      }\n    }\n  })), r.constants && (t = t.concat(Kn({\n    key: \"constants\",\n    value: r.constants,\n    style: r,\n    styleSpec: e,\n    validateSpec: Ue\n  }))), ia(t);\n}\nX.source = ce(ue(ea));\nX.sprite = ce(ue(aa));\nX.glyphs = ce(ue(oa));\nX.light = ce(ue(ta));\nX.sky = ce(ue(ra));\nX.terrain = ce(ue(na));\nX.layer = ce(ue(Qn));\nX.filter = ce(ue(Mr));\nX.paintProperty = ce(ue(Yn));\nX.layoutProperty = ce(ue(Xn));\nfunction ue(r) {\n  return function (e) {\n    return r({\n      ...e,\n      validateSpec: Ue\n    });\n  };\n}\nfunction ia(r) {\n  return [].concat(r).sort((e, t) => e.line - t.line);\n}\nfunction ce(r) {\n  return function (...e) {\n    return ia(r.apply(this, e));\n  };\n}\nfunction yn(r) {\n  if (!r) return {\n    style: qe[jt[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),\n    requiresUrlMonitoring: !1,\n    // default styles don't require URL monitoring\n    isFallback: !0\n  };\n  if (typeof r == \"string\") {\n    const t = xs(r);\n    return t.isValidStyle ? {\n      style: t.styleObject,\n      requiresUrlMonitoring: !1,\n      isFallback: !1\n    } : t.isValidJSON ? {\n      style: qe[jt[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),\n      requiresUrlMonitoring: !1,\n      // default styles don't require URL monitoring\n      isFallback: !0\n    } : r.startsWith(\"http\") ? {\n      style: r,\n      requiresUrlMonitoring: !0,\n      isFallback: !1\n    } : r.toLowerCase().includes(\".json\") ? {\n      style: Ss(r),\n      requiresUrlMonitoring: !0,\n      isFallback: !1\n    } : {\n      style: Ra(r),\n      requiresUrlMonitoring: !0,\n      isFallback: !1\n    };\n  }\n  return r instanceof $a ? {\n    style: r.getExpandedStyleURL(),\n    requiresUrlMonitoring: !1,\n    isFallback: !1\n  } : r instanceof ja ? {\n    style: r.getDefaultVariant().getExpandedStyleURL(),\n    requiresUrlMonitoring: !1,\n    isFallback: !1\n  } : X(r).length === 0 ? {\n    style: r,\n    requiresUrlMonitoring: !1,\n    isFallback: !1\n  } : {\n    style: qe[jt[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),\n    requiresUrlMonitoring: !1,\n    // default styles don't require URL monitoring\n    isFallback: !0\n  };\n}\nfunction Ss(r) {\n  try {\n    return new URL(r).href;\n  } catch {}\n  return new URL(r, location.origin).href;\n}\nfunction xs(r) {\n  try {\n    const e = JSON.parse(r),\n      t = X(e);\n    return {\n      isValidJSON: !0,\n      isValidStyle: t.length === 0,\n      styleObject: t.length === 0 ? e : null\n    };\n  } catch {\n    return {\n      isValidJSON: !1,\n      isValidStyle: !1,\n      styleObject: null\n    };\n  }\n}\nfunction fe(r, e, t) {\n  const n = window.document.createElement(r);\n  return e !== void 0 && (n.className = e), t && t.appendChild(n), n;\n}\nfunction _r(r) {\n  r.parentNode && r.parentNode.removeChild(r);\n}\nclass ks {\n  constructor() {\n    L(this, \"_map\");\n    L(this, \"_container\");\n    L(this, \"_terrainButton\");\n    Za([\"_toggleTerrain\", \"_updateTerrainIcon\"], this);\n  }\n  onAdd(e) {\n    return this._map = e, this._container = fe(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\"), this._terrainButton = fe(\"button\", \"maplibregl-ctrl-terrain\", this._container), fe(\"span\", \"maplibregl-ctrl-icon\", this._terrainButton).setAttribute(\"aria-hidden\", \"true\"), this._terrainButton.type = \"button\", this._terrainButton.addEventListener(\"click\", this._toggleTerrain), this._updateTerrainIcon(), this._map.on(\"terrain\", this._updateTerrainIcon), this._container;\n  }\n  onRemove() {\n    _r(this._container), this._map.off(\"terrain\", this._updateTerrainIcon), this._map = void 0;\n  }\n  _toggleTerrain() {\n    this._map.hasTerrain() ? this._map.disableTerrain() : this._map.enableTerrain(), this._updateTerrainIcon();\n  }\n  _updateTerrainIcon() {\n    this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain\"), this._terrainButton.classList.remove(\"maplibregl-ctrl-terrain-enabled\"), this._map.hasTerrain() ? (this._terrainButton.classList.add(\"maplibregl-ctrl-terrain-enabled\"), this._terrainButton.title = this._map._getUIString(\"TerrainControl.Disable\")) : (this._terrainButton.classList.add(\"maplibregl-ctrl-terrain\"), this._terrainButton.title = this._map._getUIString(\"TerrainControl.Enable\"));\n  }\n}\nclass Ls extends io {\n  constructor(t = {}) {\n    super({\n      showCompass: t.showCompass ?? !0,\n      showZoom: t.showZoom ?? !0,\n      visualizePitch: t.visualizePitch ?? !0\n    });\n    /**\n     * Overloading: Limit how flat the compass icon can get\n     */\n    L(this, \"_rotateCompassArrow\", () => {\n      const t = this._map.getBearing(),\n        n = this._map.getPitch(),\n        a = this.options.visualizePitch ? `scale(${Math.min(1.5, 1 / Math.cos(n * (Math.PI / 180)) ** 0.5)}) rotateX(${Math.min(70, n)}deg) rotateZ(${-t}deg)` : `rotate(${-t}deg)`;\n      this._compassIcon.style.transform = a;\n    });\n    this._compass && (this._compass.removeEventListener(\"click\", this._compass.clickFunction), this._compass.addEventListener(\"click\", n => {\n      this._map.getPitch() === 0 ? this._map.easeTo({\n        pitch: Math.min(this._map.getMaxPitch(), 80)\n      }) : this.options.visualizePitch ? this._map.resetNorthPitch({}, {\n        originalEvent: n\n      }) : this._map.resetNorth({}, {\n        originalEvent: n\n      });\n    }));\n  }\n  /**\n   * Overloading: the button now stores its click callback so that we can later on delete it and replace it\n   */\n  _createButton(t, n) {\n    const a = super._createButton(t, n);\n    return a.clickFunction = n, a;\n  }\n}\nconst mn = S.Marker,\n  hn = S.LngLat,\n  Cs = S.LngLatBounds;\nclass As extends so {\n  constructor() {\n    super(...arguments);\n    L(this, \"lastUpdatedCenter\", new hn(0, 0));\n    /**\n     * Update the camera location to center on the current position\n     *\n     * @param {Position} position the Geolocation API Position\n     * @private\n     */\n    L(this, \"_updateCamera\", t => {\n      var c;\n      const n = new hn(t.coords.longitude, t.coords.latitude),\n        a = t.coords.accuracy,\n        i = {\n          bearing: this._map.getBearing(),\n          ...this.options.fitBoundsOptions,\n          linear: !0\n        },\n        s = this._map.getZoom();\n      s > (((c = this.options.fitBoundsOptions) == null ? void 0 : c.maxZoom) ?? 30) && (i.zoom = s), this._map.fitBounds(Cs.fromLngLat(n, a), i, {\n        geolocateSource: !0\n        // tag this camera change so it won't cause the control to change to background state\n      });\n      let l = !1;\n      const u = () => {\n        l = !0;\n      };\n      this._map.once(\"click\", u), this._map.once(\"dblclick\", u), this._map.once(\"dragstart\", u), this._map.once(\"mousedown\", u), this._map.once(\"touchstart\", u), this._map.once(\"wheel\", u), this._map.once(\"moveend\", () => {\n        this._map.off(\"click\", u), this._map.off(\"dblclick\", u), this._map.off(\"dragstart\", u), this._map.off(\"mousedown\", u), this._map.off(\"touchstart\", u), this._map.off(\"wheel\", u), !l && (this.lastUpdatedCenter = this._map.getCenter());\n      });\n    });\n    L(this, \"_finishSetupUI\", t => {\n      if (this._map) {\n        if (t === !1) {\n          const n = this._map._getUIString(\"GeolocateControl.LocationNotAvailable\");\n          this._geolocateButton.disabled = !0, this._geolocateButton.title = n, this._geolocateButton.setAttribute(\"aria-label\", n);\n        } else {\n          const n = this._map._getUIString(\"GeolocateControl.FindMyLocation\");\n          this._geolocateButton.disabled = !1, this._geolocateButton.title = n, this._geolocateButton.setAttribute(\"aria-label\", n);\n        }\n        this.options.trackUserLocation && (this._geolocateButton.setAttribute(\"aria-pressed\", \"false\"), this._watchState = \"OFF\"), this.options.showUserLocation && (this._dotElement = fe(\"div\", \"maplibregl-user-location-dot\"), this._userLocationDotMarker = new mn({\n          element: this._dotElement\n        }), this._circleElement = fe(\"div\", \"maplibregl-user-location-accuracy-circle\"), this._accuracyCircleMarker = new mn({\n          element: this._circleElement,\n          pitchAlignment: \"map\"\n        }), this.options.trackUserLocation && (this._watchState = \"OFF\"), this._map.on(\"move\", this._onZoom)), this._geolocateButton.addEventListener(\"click\", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on(\"moveend\", n => {\n          const a = n.originalEvent && n.originalEvent.type === \"resize\",\n            o = this.lastUpdatedCenter.distanceTo(this._map.getCenter());\n          !n.geolocateSource && this._watchState === \"ACTIVE_LOCK\" && !a && o > 1 && (this._watchState = \"BACKGROUND\", this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active\"), this.fire(new Event(\"trackuserlocationend\")));\n        });\n      }\n    });\n    L(this, \"_onZoom\", () => {\n      this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n    });\n  }\n  _updateCircleRadius() {\n    if (this._watchState !== \"BACKGROUND\" && this._watchState !== \"ACTIVE_LOCK\") return;\n    const t = [this._lastKnownPosition.coords.longitude, this._lastKnownPosition.coords.latitude],\n      n = this._map.project(t),\n      a = this._map.unproject([n.x, n.y]),\n      o = this._map.unproject([n.x + 20, n.y]),\n      i = a.distanceTo(o) / 20,\n      s = Math.ceil(2 * this._accuracy / i);\n    this._circleElement.style.width = `${s}px`, this._circleElement.style.height = `${s}px`;\n  }\n  // We are overwriting the method _setErrorState from Maplibre's GeolocateControl because the\n  // case BACKGROUND_ERROR is not dealt with in the original function and yields an error.\n  // Related issue: https://github.com/maplibre/maplibre-gl-js/issues/2294\n  _setErrorState() {\n    switch (this._watchState) {\n      case \"WAITING_ACTIVE\":\n        this._watchState = \"ACTIVE_ERROR\", this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-active-error\");\n        break;\n      case \"ACTIVE_LOCK\":\n        this._watchState = \"ACTIVE_ERROR\", this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-active\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-waiting\");\n        break;\n      case \"BACKGROUND\":\n        this._watchState = \"BACKGROUND_ERROR\", this._geolocateButton.classList.remove(\"maplibregl-ctrl-geolocate-background\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-background-error\"), this._geolocateButton.classList.add(\"maplibregl-ctrl-geolocate-waiting\");\n        break;\n      case \"ACTIVE_ERROR\":\n        break;\n      case \"BACKGROUND_ERROR\":\n        break;\n      default:\n        throw new Error(`Unexpected watchState ${this._watchState}`);\n    }\n  }\n}\nvar H, Q, me, he, K, Ye, B, sa, Z, la;\nclass Ht {\n  constructor(e, t) {\n    ye(this, B);\n    ye(this, H);\n    L(this, \"map\");\n    ye(this, Q);\n    ye(this, me);\n    ye(this, he);\n    ye(this, K, !1);\n    ye(this, Ye);\n    e.style !== void 0 && xe(this, K, !0), xe(this, H, {\n      // set defaults\n      zoomAdjust: -4,\n      position: \"top-right\",\n      // inherit map options\n      ...t,\n      // override any lingering control options\n      forceNoAttributionControl: !0,\n      attributionControl: !1,\n      navigationControl: !1,\n      geolocateControl: !1,\n      maptilerLogo: !1,\n      minimap: !1,\n      hash: !1,\n      pitchAdjust: !1,\n      // override map options with new user defined minimap options\n      ...e,\n      containerStyle: {\n        border: \"1px solid #000\",\n        width: \"400px\",\n        height: \"300px\",\n        ...(e.containerStyle ?? {})\n      }\n    }), e.lockZoom !== void 0 && (E(this, H).minZoom = e.lockZoom, E(this, H).maxZoom = e.lockZoom);\n  }\n  setStyle(e, t) {\n    E(this, K) || this.map.setStyle(e, t), G(this, B, Z).call(this);\n  }\n  addLayer(e, t) {\n    return E(this, K) || this.map.addLayer(e, t), G(this, B, Z).call(this), this.map;\n  }\n  moveLayer(e, t) {\n    return E(this, K) || this.map.moveLayer(e, t), G(this, B, Z).call(this), this.map;\n  }\n  removeLayer(e) {\n    return E(this, K) || this.map.removeLayer(e), G(this, B, Z).call(this), this;\n  }\n  setLayerZoomRange(e, t, n) {\n    return E(this, K) || this.map.setLayerZoomRange(e, t, n), G(this, B, Z).call(this), this;\n  }\n  setFilter(e, t, n) {\n    return E(this, K) || this.map.setFilter(e, t, n), G(this, B, Z).call(this), this;\n  }\n  setPaintProperty(e, t, n, a) {\n    return E(this, K) || this.map.setPaintProperty(e, t, n, a), G(this, B, Z).call(this), this;\n  }\n  setLayoutProperty(e, t, n, a) {\n    return E(this, K) || this.map.setLayoutProperty(e, t, n, a), G(this, B, Z).call(this), this;\n  }\n  setGlyphs(e, t) {\n    return E(this, K) || this.map.setGlyphs(e, t), G(this, B, Z).call(this), this;\n  }\n  onAdd(e) {\n    xe(this, Q, e), xe(this, me, fe(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\"));\n    for (const [t, n] of Object.entries(E(this, H).containerStyle)) E(this, me).style.setProperty(t, n);\n    return E(this, H).container = E(this, me), E(this, H).zoom = e.getZoom() + E(this, H).zoomAdjust, this.map = new zr(E(this, H)), this.map.once(\"style.load\", () => {\n      this.map.resize();\n    }), this.map.once(\"load\", () => {\n      G(this, B, sa).call(this, E(this, H).parentRect), xe(this, Ye, G(this, B, la).call(this));\n    }), E(this, me);\n  }\n  onRemove() {\n    var e;\n    (e = E(this, Ye)) == null || e.call(this), _r(E(this, me));\n  }\n}\nH = new WeakMap(), Q = new WeakMap(), me = new WeakMap(), he = new WeakMap(), K = new WeakMap(), Ye = new WeakMap(), B = new WeakSet(), sa = function (e) {\n  e === void 0 || e.linePaint === void 0 && e.fillPaint === void 0 || (xe(this, he, {\n    type: \"Feature\",\n    properties: {\n      name: \"parentRect\"\n    },\n    geometry: {\n      type: \"Polygon\",\n      coordinates: [[[], [], [], [], []]]\n    }\n  }), this.map.addSource(\"parentRect\", {\n    type: \"geojson\",\n    data: E(this, he)\n  }), (e.lineLayout !== void 0 || e.linePaint !== void 0) && this.map.addLayer({\n    id: \"parentRectOutline\",\n    type: \"line\",\n    source: \"parentRect\",\n    layout: {\n      ...e.lineLayout\n    },\n    paint: {\n      \"line-color\": \"#FFF\",\n      \"line-width\": 1,\n      \"line-opacity\": 0.85,\n      ...e.linePaint\n    }\n  }), e.fillPaint !== void 0 && this.map.addLayer({\n    id: \"parentRectFill\",\n    type: \"fill\",\n    source: \"parentRect\",\n    layout: {},\n    paint: {\n      \"fill-color\": \"#08F\",\n      \"fill-opacity\": 0.135,\n      ...e.fillPaint\n    }\n  }), G(this, B, Z).call(this));\n}, Z = function () {\n  if (E(this, he) === void 0) return;\n  const {\n      devicePixelRatio: e\n    } = window,\n    t = E(this, Q).getCanvas(),\n    n = t.width / e,\n    a = t.height / e,\n    o = E(this, Q).unproject.bind(E(this, Q)),\n    i = o([0, 0]),\n    s = o([n, 0]),\n    l = o([0, a]),\n    u = o([n, a]);\n  E(this, he).geometry.coordinates = [[l.toArray(), u.toArray(), s.toArray(), i.toArray(), l.toArray()]];\n  const c = this.map.getSource(\"parentRect\");\n  c !== void 0 && c.setData(E(this, he));\n}, la = function () {\n  const {\n      pitchAdjust: e\n    } = E(this, H),\n    t = () => {\n      i(\"parent\");\n    },\n    n = () => {\n      i(\"minimap\");\n    },\n    a = () => {\n      E(this, Q).on(\"move\", t), this.map.on(\"move\", n);\n    },\n    o = () => {\n      E(this, Q).off(\"move\", t), this.map.off(\"move\", n);\n    },\n    i = s => {\n      o();\n      const l = s === \"parent\" ? E(this, Q) : this.map,\n        u = s === \"parent\" ? this.map : E(this, Q),\n        c = l.getCenter(),\n        p = l.getZoom() + E(this, H).zoomAdjust * (s === \"parent\" ? 1 : -1),\n        m = l.getBearing(),\n        f = l.getPitch();\n      u.jumpTo({\n        center: c,\n        zoom: p,\n        bearing: m,\n        pitch: e ? f : 0\n      }), G(this, B, Z).call(this), a();\n    };\n  return a(), () => {\n    o();\n  };\n};\nclass Ts {\n  constructor() {\n    L(this, \"map\");\n    L(this, \"container\");\n    L(this, \"projectionButton\");\n  }\n  onAdd(e) {\n    return this.map = e, this.container = fe(\"div\", \"maplibregl-ctrl maplibregl-ctrl-group\"), this.projectionButton = fe(\"button\", \"maplibregl-ctrl-projection\", this.container), fe(\"span\", \"maplibregl-ctrl-icon\", this.projectionButton).setAttribute(\"aria-hidden\", \"true\"), this.projectionButton.type = \"button\", this.projectionButton.addEventListener(\"click\", this.toggleProjection.bind(this)), e.on(\"projectiontransition\", this.updateProjectionIcon.bind(this)), this.updateProjectionIcon(), this.container;\n  }\n  onRemove() {\n    _r(this.container), this.map.off(\"projectiontransition\", this.updateProjectionIcon), this.map = void 0;\n  }\n  toggleProjection() {\n    this.map.getProjection() === void 0 && this.map.setProjection({\n      type: \"mercator\"\n    }), this.map.isGlobeProjection() ? this.map.enableMercatorProjection() : this.map.enableGlobeProjection(), this.updateProjectionIcon();\n  }\n  updateProjectionIcon() {\n    this.projectionButton.classList.remove(\"maplibregl-ctrl-projection-globe\"), this.projectionButton.classList.remove(\"maplibregl-ctrl-projection-mercator\"), this.map.isGlobeProjection() ? (this.projectionButton.classList.add(\"maplibregl-ctrl-projection-mercator\"), this.projectionButton.title = \"Enable Mercator projection\") : (this.projectionButton.classList.add(\"maplibregl-ctrl-projection-globe\"), this.projectionButton.title = \"Enable Globe projection\");\n  }\n}\nconst Is = \"@maptiler/sdk\",\n  Es = \"3.0.3\",\n  Ms = \"The Javascript & TypeScript map SDK tailored for MapTiler Cloud\",\n  _s = \"MapTiler\",\n  zs = \"dist/maptiler-sdk.mjs\",\n  Ps = \"dist/maptiler-sdk.d.ts\",\n  Rs = \"dist/maptiler-sdk.css\",\n  $s = \"module\",\n  js = {\n    \".\": {\n      import: \"./dist/maptiler-sdk.mjs\",\n      types: \"./dist/maptiler-sdk.d.ts\"\n    },\n    \"./dist/maptiler-sdk.css\": {\n      import: \"./dist/maptiler-sdk.css\"\n    },\n    \"./style.css\": {\n      import: \"./dist/maptiler-sdk.css\"\n    }\n  },\n  Ns = [\"maptiler\", \"map\", \"sdk\", \"webmap\", \"cloud\", \"webGL\", \"maplibre\"],\n  Os = \"https://docs.maptiler.com/sdk-js/\",\n  Fs = \"BSD-3-Clause\",\n  Ds = {\n    type: \"git\",\n    url: \"https://github.com/maptiler/maptiler-sdk-js.git\"\n  },\n  qs = {\n    prepare: \"husky\",\n    doc: \"rm -rf docs/* && typedoc --out docs && cp -r images docs/\",\n    ncu: \"npx npm-check-updates\",\n    lint: \"eslint src\",\n    \"lint:fix\": \"eslint src --fix\",\n    \"test:watch\": \"vitest watch -c vite.config-test.ts --dom\",\n    test: \"vitest run -c vite.config-test.ts --dom\",\n    \"install:clean\": \"rm -rf build/ dist/ node_modules/ && npm ci\",\n    dev: 'concurrently \"vite -c vite.config-dev.ts\" \"npm run dev-umd\"',\n    \"dev-umd\": \"npm run build-css && tsc && NODE_ENV=development vite build -w -c vite.config-umd.ts\",\n    \"build-css\": \"mkdir -p dist build && node scripts/replace-path-with-content.js src/style/style_template.css dist/tmp_maptiler-sdk.css && cat node_modules/maplibre-gl/dist/maplibre-gl.css dist/tmp_maptiler-sdk.css > dist/maptiler-sdk.css && rm dist/tmp_maptiler-sdk.css && cp dist/maptiler-sdk.css build/maptiler-sdk.css\",\n    \"build-umd\": \"tsc && NODE_ENV=production vite build -c vite.config-umd.ts\",\n    \"build-es\": \"tsc && NODE_ENV=production vite build -c vite.config-es.ts\",\n    build: \"npm run build-es; npm run build-umd; npm run build-css\",\n    make: \"npm run install:clean && npm run build\"\n  },\n  Bs = {\n    \"@canvas/image-data\": \"^1.0.0\",\n    \"@eslint/js\": \"^9.21.0\",\n    \"@types/uuid\": \"^10.0.0\",\n    \"@types/xmldom\": \"^0.1.31\",\n    \"@vitest/web-worker\": \"^3.0.9\",\n    \"@xmldom/xmldom\": \"^0.8.10\",\n    concurrently: \"^9.1.2\",\n    eslint: \"^9.21.0\",\n    \"eslint-config-prettier\": \"^10.0.2\",\n    \"eslint-plugin-prettier\": \"^5.2.3\",\n    \"happy-dom\": \"^17.4.4\",\n    husky: \"^8.0.0\",\n    \"lint-staged\": \"^15.4.3\",\n    prettier: \"3.5.2\",\n    typedoc: \"^0.27.6\",\n    typescript: \"^5.7.3\",\n    \"typescript-eslint\": \"^8.25.0\",\n    vite: \"^6.0.7\",\n    \"vite-plugin-dts\": \"^4.5.0\",\n    vitest: \"^3.0.9\"\n  },\n  Us = {\n    \"@maplibre/maplibre-gl-style-spec\": \"^23.0.0\",\n    \"@maptiler/client\": \"^2.2.0\",\n    events: \"^3.3.0\",\n    \"js-base64\": \"^3.7.7\",\n    \"maplibre-gl\": \"^5.0.1\",\n    uuid: \"^11.0.5\"\n  },\n  Vs = {\n    name: Is,\n    version: Es,\n    description: Ms,\n    author: _s,\n    module: zs,\n    types: Ps,\n    style: Rs,\n    type: $s,\n    exports: js,\n    keywords: Ns,\n    homepage: Os,\n    license: Fs,\n    repository: Ds,\n    scripts: qs,\n    \"lint-staged\": {\n      \"*.ts\": \"npm run lint:fix\"\n    },\n    devDependencies: Bs,\n    dependencies: Us\n  };\nclass Gs {\n  /**\n   *\n   * @param map : a Map instance\n   * @param delay : a delay in milliseconds after which the payload is sent to MapTiler cloud (cannot be less than 1000ms)\n   */\n  constructor(e, t = 2e3) {\n    L(this, \"map\");\n    L(this, \"registeredModules\", /* @__PURE__ */new Set());\n    this.map = e, setTimeout(async () => {\n      if (!O.telemetry) return;\n      const n = this.preparePayload();\n      try {\n        (await fetch(n, {\n          method: \"POST\"\n        })).ok || console.warn(\"The metrics could not be sent to MapTiler Cloud\");\n      } catch (a) {\n        console.warn(\"The metrics could not be sent to MapTiler Cloud\", a);\n      }\n    }, Math.max(1e3, t));\n  }\n  /**\n   * Register a module to the telemetry system of the SDK.\n   * The arguments `name` and `version` likely come from the package.json\n   * of each module.\n   */\n  registerModule(e, t) {\n    this.registeredModules.add(`${e}:${t}`);\n  }\n  preparePayload() {\n    const e = new URL(V.telemetryURL);\n    return e.searchParams.append(\"sdk\", Vs.version), e.searchParams.append(\"key\", O.apiKey), e.searchParams.append(\"mtsid\", ur), e.searchParams.append(\"session\", O.session ? \"1\" : \"0\"), e.searchParams.append(\"caching\", O.caching ? \"1\" : \"0\"), e.searchParams.append(\"lang-updated\", this.map.isLanguageUpdated() ? \"1\" : \"0\"), e.searchParams.append(\"terrain\", this.map.getTerrain() ? \"1\" : \"0\"), e.searchParams.append(\"globe\", this.map.isGlobeProjection() ? \"1\" : \"0\"), this.registeredModules.size > 0 && e.searchParams.append(\"modules\", Array.from(this.registeredModules).join(\"|\")), e.href;\n  }\n}\nconst Hs = {\n  POINT: \"POINT\",\n  COUNTRY: \"COUNTRY\"\n};\nclass zr extends S.Map {\n  constructor(t) {\n    Xa(t.container), t.apiKey && (O.apiKey = t.apiKey);\n    const {\n      style: n,\n      requiresUrlMonitoring: a,\n      isFallback: o\n    } = yn(t.style);\n    o && console.warn(\"Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style.\"), O.apiKey || console.warn(\"MapTiler Cloud API key is not set. Visit https://maptiler.com and try Cloud for free!\");\n    const i = location.hash;\n    let s = {\n      compact: !1\n    };\n    t.customAttribution ? s.customAttribution = t.customAttribution : t.attributionControl && typeof t.attributionControl == \"object\" && (s = {\n      ...s,\n      ...t.attributionControl\n    });\n    const l = {\n      ...t,\n      style: n,\n      maplibreLogo: !1,\n      transformRequest: Vr(t.transformRequest),\n      attributionControl: t.forceNoAttributionControl === !0 ? !1 : s\n    };\n    delete l.style;\n    super(l);\n    L(this, \"options\");\n    L(this, \"telemetry\");\n    L(this, \"isTerrainEnabled\", !1);\n    L(this, \"terrainExaggeration\", 1);\n    L(this, \"primaryLanguage\");\n    L(this, \"terrainGrowing\", !1);\n    L(this, \"terrainFlattening\", !1);\n    L(this, \"minimap\");\n    L(this, \"forceLanguageUpdate\");\n    L(this, \"languageAlwaysBeenStyle\");\n    L(this, \"isReady\", !1);\n    L(this, \"terrainAnimationDuration\", 1e3);\n    L(this, \"monitoredStyleUrls\");\n    L(this, \"styleInProcess\", !1);\n    L(this, \"curentProjection\");\n    L(this, \"originalLabelStyle\", new window.Map());\n    L(this, \"isStyleLocalized\", !1);\n    L(this, \"languageIsUpdated\", !1);\n    this.options = t, this.setStyle(n), a && this.monitorStyleUrl(n);\n    const u = () => {\n      let d = \"The distant style could not be loaded.\";\n      this.getStyle() ? d += \"Leaving the style as is.\" : (this.setStyle(qe.STREETS), d += `Loading default MapTiler Cloud style \"${qe.STREETS.getDefaultVariant().getId()}\" as a fallback.`), console.warn(d);\n    };\n    if (this.on(\"style.load\", () => {\n      this.styleInProcess = !1;\n    }), this.on(\"error\", d => {\n      if (d.error instanceof S.AJAXError) {\n        const v = d.error.url,\n          w = new URL(v);\n        w.search = \"\";\n        const b = w.href;\n        this.monitoredStyleUrls && this.monitoredStyleUrls.has(b) && (this.monitoredStyleUrls.delete(b), u());\n        return;\n      }\n      if (this.styleInProcess) {\n        u();\n        return;\n      }\n    }), O.caching && !Zt && console.warn(\"The cache API is only available in secure contexts. More info at https://developer.mozilla.org/en-US/docs/Web/API/Cache\"), O.caching && Zt && Ka(), typeof t.language > \"u\") this.primaryLanguage = O.primaryLanguage;else {\n      const d = Fr(t.language, M);\n      this.primaryLanguage = d ?? O.primaryLanguage;\n    }\n    this.forceLanguageUpdate = !(this.primaryLanguage === M.STYLE || this.primaryLanguage === M.STYLE_LOCK), this.languageAlwaysBeenStyle = this.primaryLanguage === M.STYLE, this.terrainExaggeration = t.terrainExaggeration ?? this.terrainExaggeration, this.curentProjection = t.projection, this.on(\"styledata\", () => {\n      this.curentProjection === \"mercator\" ? this.setProjection({\n        type: \"mercator\"\n      }) : this.curentProjection === \"globe\" && this.setProjection({\n        type: \"globe\"\n      });\n    }), this.once(\"styledata\", async () => {\n      if (!t.geolocate || t.center || t.hash && i) return;\n      try {\n        if (t.geolocate === Hs.COUNTRY) {\n          await this.fitToIpBounds();\n          return;\n        }\n      } catch (v) {\n        console.warn(v.message);\n      }\n      let d;\n      try {\n        await this.centerOnIpPoint(t.zoom), d = this.getCameraHash();\n      } catch (v) {\n        console.warn(v.message);\n      }\n      (await navigator.permissions.query({\n        name: \"geolocation\"\n      })).state === \"granted\" && navigator.geolocation.getCurrentPosition(\n      // success callback\n      v => {\n        d === this.getCameraHash() && (this.terrain ? this.easeTo({\n          center: [v.coords.longitude, v.coords.latitude],\n          zoom: t.zoom || 12,\n          duration: 2e3\n        }) : this.once(\"terrain\", () => {\n          this.easeTo({\n            center: [v.coords.longitude, v.coords.latitude],\n            zoom: t.zoom || 12,\n            duration: 2e3\n          });\n        }));\n      },\n      // error callback\n      null,\n      // options\n      {\n        maximumAge: 24 * 3600 * 1e3,\n        // a day in millisec\n        timeout: 5e3,\n        // milliseconds\n        enableHighAccuracy: !1\n      });\n    }), this.on(\"styledata\", () => {\n      this.setPrimaryLanguage(this.primaryLanguage);\n    }), this.on(\"styledata\", () => {\n      this.getTerrain() === null && this.isTerrainEnabled && this.enableTerrain(this.terrainExaggeration);\n    }), this.once(\"load\", async () => {\n      let d = {\n        logo: null\n      };\n      try {\n        const y = Object.keys(this.style.sourceCaches).map(b => this.getSource(b)).filter(b => b && \"url\" in b && typeof b.url == \"string\" && b.url.includes(\"tiles.json\")),\n          v = new URL(y[0].url);\n        v.searchParams.has(\"key\") || v.searchParams.append(\"key\", O.apiKey), d = await (await fetch(v.href)).json();\n      } catch {}\n      if (t.forceNoAttributionControl !== !0) if (\"logo\" in d && d.logo) {\n        const y = d.logo;\n        this.addControl(new Hr({\n          logoURL: y\n        }), t.logoPosition);\n      } else t.maptilerLogo && this.addControl(new Hr(), t.logoPosition);\n      if (t.scaleControl) {\n        const y = t.scaleControl === !0 || t.scaleControl === void 0 ? \"bottom-right\" : t.scaleControl,\n          v = new uo({\n            unit: O.unit\n          });\n        this.addControl(v, y), O.on(\"unit\", w => {\n          v.setUnit(w);\n        });\n      }\n      if (t.navigationControl !== !1) {\n        const y = t.navigationControl === !0 || t.navigationControl === void 0 ? \"top-right\" : t.navigationControl;\n        this.addControl(new Ls(), y);\n      }\n      if (t.geolocateControl !== !1) {\n        const y = t.geolocateControl === !0 || t.geolocateControl === void 0 ? \"top-right\" : t.geolocateControl;\n        this.addControl(\n        // new maplibregl.GeolocateControl({\n        new As({\n          positionOptions: {\n            enableHighAccuracy: !0,\n            maximumAge: 0,\n            timeout: 6e3\n          },\n          fitBoundsOptions: {\n            maxZoom: 15\n          },\n          trackUserLocation: !0,\n          showAccuracyCircle: !0,\n          showUserLocation: !0\n        }), y);\n      }\n      if (t.terrainControl) {\n        const y = t.terrainControl === !0 || t.terrainControl === void 0 ? \"top-right\" : t.terrainControl;\n        this.addControl(new ks(), y);\n      }\n      if (t.projectionControl) {\n        const y = t.projectionControl === !0 || t.projectionControl === void 0 ? \"top-right\" : t.projectionControl;\n        this.addControl(new Ts(), y);\n      }\n      if (t.fullscreenControl) {\n        const y = t.fullscreenControl === !0 || t.fullscreenControl === void 0 ? \"top-right\" : t.fullscreenControl;\n        this.addControl(new co({}), y);\n      }\n      this.isReady = !0, this.fire(\"ready\", {\n        target: this\n      });\n    });\n    let c = !1,\n      p = !1,\n      m;\n    this.once(\"ready\", () => {\n      c = !0, p && this.fire(\"loadWithTerrain\", m);\n    }), this.once(\"style.load\", () => {\n      const {\n        minimap: d\n      } = t;\n      if (typeof d == \"object\") {\n        const {\n          zoom: y,\n          center: v,\n          style: w,\n          language: b,\n          apiKey: T,\n          maptilerLogo: j,\n          canvasContextAttributes: R,\n          refreshExpiredTiles: ae,\n          maxBounds: Se,\n          scrollZoom: De,\n          minZoom: rt,\n          maxZoom: nt,\n          boxZoom: xa,\n          locale: ka,\n          fadeDuration: La,\n          crossSourceCollisions: Ca,\n          clickTolerance: Aa,\n          bounds: Ta,\n          fitBoundsOptions: Ia,\n          pixelRatio: Ea,\n          validateStyle: Ma\n        } = t;\n        this.minimap = new Ht(d, {\n          zoom: y,\n          center: v,\n          style: w,\n          language: b,\n          apiKey: T,\n          container: \"null\",\n          maptilerLogo: j,\n          canvasContextAttributes: R,\n          refreshExpiredTiles: ae,\n          maxBounds: Se,\n          scrollZoom: De,\n          minZoom: rt,\n          maxZoom: nt,\n          boxZoom: xa,\n          locale: ka,\n          fadeDuration: La,\n          crossSourceCollisions: Ca,\n          clickTolerance: Aa,\n          bounds: Ta,\n          fitBoundsOptions: Ia,\n          pixelRatio: Ea,\n          validateStyle: Ma\n        }), this.addControl(this.minimap, d.position ?? \"bottom-left\");\n      } else d === !0 ? (this.minimap = new Ht({}, t), this.addControl(this.minimap, \"bottom-left\")) : d !== void 0 && d !== !1 && (this.minimap = new Ht({}, t), this.addControl(this.minimap, d));\n    });\n    const f = d => {\n      d.terrain && (p = !0, m = {\n        type: \"loadWithTerrain\",\n        target: this,\n        terrain: d.terrain\n      }, this.off(\"terrain\", f), c && this.fire(\"loadWithTerrain\", m));\n    };\n    this.on(\"terrain\", f), t.terrain && this.enableTerrain(t.terrainExaggeration ?? this.terrainExaggeration), this.once(\"load\", () => {\n      this.getCanvas().addEventListener(\"webglcontextlost\", d => {\n        if (this._removed === !0) {\n          console.warn(\"[webglcontextlost]\", \"WebGL context lost after map removal. This is harmless.\");\n          return;\n        }\n        console.warn(\"[webglcontextlost]\", \"Unexpected loss of WebGL context!\"), this.fire(\"webglContextLost\", d);\n      });\n    }), this.telemetry = new Gs(this);\n  }\n  /**\n   * Recreates the map instance with the same options.\n   * Useful for WebGL context loss.\n   */\n  recreate() {\n    const t = {\n      center: this.getCenter(),\n      zoom: this.getZoom(),\n      bearing: this.getBearing(),\n      pitch: this.getPitch()\n    };\n    this.remove(), Object.assign(this, new zr({\n      ...this.options\n    })), this.once(\"load\", () => {\n      this.jumpTo(t);\n    });\n  }\n  /**\n   * Set the duration (millisec) of the terrain animation for growing or flattening.\n   * Must be positive. (Built-in default: `1000` milliseconds)\n   */\n  setTerrainAnimationDuration(t) {\n    this.terrainAnimationDuration = Math.max(t, 0);\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"load\" event.\n   * @returns\n   */\n  async onLoadAsync() {\n    return new Promise(t => {\n      if (this.loaded()) {\n        t(this);\n        return;\n      }\n      this.once(\"load\", () => {\n        t(this);\n      });\n    });\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"ready\" and returns a Promise to the Map.\n   * If _this_ Map instance is already ready, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"ready\" event.\n   * A map instance is \"ready\" when all the controls that can be managed by the contructor are\n   * dealt with. This happens after the \"load\" event, due to the asynchronous nature\n   * of some built-in controls.\n   */\n  async onReadyAsync() {\n    return new Promise(t => {\n      if (this.isReady) {\n        t(this);\n        return;\n      }\n      this.once(\"ready\", () => {\n        t(this);\n      });\n    });\n  }\n  /**\n   * Awaits for _this_ Map instance to be \"loaded\" as well as with terrain being non-null for the first time\n   * and returns a Promise to the Map.\n   * If _this_ Map instance is already loaded with terrain, the Promise is resolved directly,\n   * otherwise, it is resolved as a result of the \"loadWithTerrain\" event.\n   * @returns\n   */\n  async onLoadWithTerrainAsync() {\n    return new Promise(t => {\n      if (this.isReady && this.terrain) {\n        t(this);\n        return;\n      }\n      this.once(\"loadWithTerrain\", () => {\n        t(this);\n      });\n    });\n  }\n  monitorStyleUrl(t) {\n    typeof this.monitoredStyleUrls > \"u\" && (this.monitoredStyleUrls = /* @__PURE__ */new Set());\n    const n = new URL(t);\n    n.search = \"\", this.monitoredStyleUrls.add(n.href);\n  }\n  /**\n   * Update the style of the map.\n   * Can be:\n   * - a full style URL (possibly with API key)\n   * - a shorthand with only the MapTIler style name (eg. `\"streets-v2\"`)\n   * - a longer form with the prefix `\"maptiler://\"` (eg. `\"maptiler://streets-v2\"`)\n   */\n  setStyle(t, n) {\n    var o;\n    this.originalLabelStyle.clear(), (o = this.minimap) == null || o.setStyle(t), this.forceLanguageUpdate = !0, this.once(\"idle\", () => {\n      this.forceLanguageUpdate = !1;\n    });\n    const a = yn(t);\n    if (a.requiresUrlMonitoring && this.monitorStyleUrl(a.style), a.isFallback) {\n      if (this.getStyle()) return console.warn(\"Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Keeping the curent style instead.\"), this;\n      console.warn(\"Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style.\");\n    }\n    return this.styleInProcess = !0, super.setStyle(a.style, n), this;\n  }\n  /**\n   * Adds a [MapLibre style layer](https://maplibre.org/maplibre-style-spec/layers)\n   * to the map's style.\n   *\n   * A layer defines how data from a specified source will be styled. Read more about layer types\n   * and available paint and layout properties in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/layers).\n   *\n   * @param layer - The layer to add,\n   * conforming to either the MapLibre Style Specification's [layer definition](https://maplibre.org/maplibre-style-spec/layers) or,\n   * less commonly, the {@link CustomLayerInterface} specification.\n   * The MapLibre Style Specification's layer definition is appropriate for most layers.\n   *\n   * @param beforeId - The ID of an existing layer to insert the new layer before,\n   * resulting in the new layer appearing visually beneath the existing layer.\n   * If this argument is not specified, the layer will be appended to the end of the layers array\n   * and appear visually above all other layers.\n   *\n   * @returns `this`\n   */\n  addLayer(t, n) {\n    var a;\n    return (a = this.minimap) == null || a.addLayer(t, n), super.addLayer(t, n);\n  }\n  /**\n   * Moves a layer to a different z-position.\n   *\n   * @param id - The ID of the layer to move.\n   * @param beforeId - The ID of an existing layer to insert the new layer before. When viewing the map, the `id` layer will appear beneath the `beforeId` layer. If `beforeId` is omitted, the layer will be appended to the end of the layers array and appear above all other layers on the map.\n   * @returns `this`\n   *\n   * @example\n   * Move a layer with ID 'polygon' before the layer with ID 'country-label'. The `polygon` layer will appear beneath the `country-label` layer on the map.\n   * ```ts\n   * map.moveLayer('polygon', 'country-label');\n   * ```\n   */\n  moveLayer(t, n) {\n    var a;\n    return (a = this.minimap) == null || a.moveLayer(t, n), super.moveLayer(t, n);\n  }\n  /**\n   * Removes the layer with the given ID from the map's style.\n   *\n   * An {@link ErrorEvent} will be fired if the image parameter is invald.\n   *\n   * @param id - The ID of the layer to remove\n   * @returns `this`\n   *\n   * @example\n   * If a layer with ID 'state-data' exists, remove it.\n   * ```ts\n   * if (map.getLayer('state-data')) map.removeLayer('state-data');\n   * ```\n   */\n  removeLayer(t) {\n    var n;\n    return (n = this.minimap) == null || n.removeLayer(t), super.removeLayer(t);\n  }\n  /**\n   * Sets the zoom extent for the specified style layer. The zoom extent includes the\n   * [minimum zoom level](https://maplibre.org/maplibre-style-spec/layers/#minzoom)\n   * and [maximum zoom level](https://maplibre.org/maplibre-style-spec/layers/#maxzoom))\n   * at which the layer will be rendered.\n   *\n   * Note: For style layers using vector sources, style layers cannot be rendered at zoom levels lower than the\n   * minimum zoom level of the _source layer_ because the data does not exist at those zoom levels. If the minimum\n   * zoom level of the source layer is higher than the minimum zoom level defined in the style layer, the style\n   * layer will not be rendered at all zoom levels in the zoom range.\n   */\n  setLayerZoomRange(t, n, a) {\n    var o;\n    return (o = this.minimap) == null || o.setLayerZoomRange(t, n, a), super.setLayerZoomRange(t, n, a);\n  }\n  /**\n   * Sets the filter for the specified style layer.\n   *\n   * Filters control which features a style layer renders from its source.\n   * Any feature for which the filter expression evaluates to `true` will be\n   * rendered on the map. Those that are false will be hidden.\n   *\n   * Use `setFilter` to show a subset of your source data.\n   *\n   * To clear the filter, pass `null` or `undefined` as the second parameter.\n   */\n  setFilter(t, n, a) {\n    var o;\n    return (o = this.minimap) == null || o.setFilter(t, n, a), super.setFilter(t, n, a);\n  }\n  /**\n   * Sets the value of a paint property in the specified style layer.\n   *\n   * @param layerId - The ID of the layer to set the paint property in.\n   * @param name - The name of the paint property to set.\n   * @param value - The value of the paint property to set.\n   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).\n   * @param options - Options object.\n   * @returns `this`\n   * @example\n   * ```ts\n   * map.setPaintProperty('my-layer', 'fill-color', '#faafee');\n   * ```\n   */\n  setPaintProperty(t, n, a, o) {\n    var i;\n    return (i = this.minimap) == null || i.setPaintProperty(t, n, a, o), super.setPaintProperty(t, n, a, o);\n  }\n  /**\n   * Sets the value of a layout property in the specified style layer.\n   * Layout properties define how the layer is styled.\n   * Layout properties for layers of the same type are documented together.\n   * Layers of different types have different layout properties.\n   * See the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/) for the complete list of layout properties.\n   * @param layerId - The ID of the layer to set the layout property in.\n   * @param name - The name of the layout property to set.\n   * @param value - The value of the layout property to set.\n   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).\n   * @param options - Options object.\n   * @returns `this`\n   */\n  setLayoutProperty(t, n, a, o) {\n    var i;\n    return (i = this.minimap) == null || i.setLayoutProperty(t, n, a, o), super.setLayoutProperty(t, n, a, o);\n  }\n  /**\n   * Sets the value of the style's glyphs property.\n   *\n   * @param glyphsUrl - Glyph URL to set. Must conform to the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/glyphs/).\n   * @param options - Options object.\n   * @returns `this`\n   * @example\n   * ```ts\n   * map.setGlyphs('https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf');\n   * ```\n   */\n  setGlyphs(t, n) {\n    var a;\n    return (a = this.minimap) == null || a.setGlyphs(t, n), super.setGlyphs(t, n);\n  }\n  getStyleLanguage() {\n    return !this.style || !this.style.stylesheet || !this.style.stylesheet.metadata || typeof this.style.stylesheet.metadata != \"object\" ? null : \"maptiler:language\" in this.style.stylesheet.metadata && typeof this.style.stylesheet.metadata[\"maptiler:language\"] == \"string\" ? Na(this.style.stylesheet.metadata[\"maptiler:language\"]) : null;\n  }\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   */\n  setLanguage(t) {\n    var n;\n    (n = this.minimap) == null || n.map.setLanguage(t), this.onStyleReady(() => {\n      this.setPrimaryLanguage(t);\n    });\n  }\n  /**\n   * Define the primary language of the map. Note that not all the languages shorthands provided are available.\n   */\n  setPrimaryLanguage(t) {\n    const n = this.getStyleLanguage(),\n      a = Fr(t, M);\n    if (!a) {\n      console.warn(`The language \"${a}\" is not supported.`);\n      return;\n    }\n    if (!(a.flag === M.STYLE.flag && n && (n.flag === M.AUTO.flag || n.flag === M.VISITOR.flag)) && (a.flag !== M.STYLE.flag && (this.languageAlwaysBeenStyle = !1), this.languageAlwaysBeenStyle || this.primaryLanguage === a && !this.forceLanguageUpdate)) return;\n    if (this.primaryLanguage.flag === M.STYLE_LOCK.flag) {\n      console.warn(\"The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag.\");\n      return;\n    }\n    this.primaryLanguage = a;\n    let o = a;\n    if (a.flag === M.STYLE.flag) {\n      if (!n) {\n        console.warn(\"The style has no default languages or has an invalid one.\");\n        return;\n      }\n      o = n;\n    }\n    let i = M.LOCAL.flag,\n      s = [\"get\", i];\n    o.flag === M.VISITOR.flag ? (i = qr().flag, s = [\"case\", [\"all\", [\"has\", i], [\"has\", M.LOCAL.flag]], [\"case\", [\"==\", [\"get\", i], [\"get\", M.LOCAL.flag]], [\"get\", M.LOCAL.flag], [\"format\", [\"get\", i], {\n      \"font-scale\": 0.8\n    }, `\n`, [\"get\", M.LOCAL.flag], {\n      \"font-scale\": 1.1\n    }]], [\"get\", M.LOCAL.flag]]) : o.flag === M.VISITOR_ENGLISH.flag ? (i = M.ENGLISH.flag, s = [\"case\", [\"all\", [\"has\", i], [\"has\", M.LOCAL.flag]], [\"case\", [\"==\", [\"get\", i], [\"get\", M.LOCAL.flag]], [\"get\", M.LOCAL.flag], [\"format\", [\"get\", i], {\n      \"font-scale\": 0.8\n    }, `\n`, [\"get\", M.LOCAL.flag], {\n      \"font-scale\": 1.1\n    }]], [\"get\", M.LOCAL.flag]]) : o.flag === M.AUTO.flag ? (i = qr().flag, s = [\"coalesce\", [\"get\", i], [\"get\", M.LOCAL.flag]]) : o === M.LOCAL ? (i = M.LOCAL.flag, s = [\"get\", i]) : (i = o.flag, s = [\"coalesce\", [\"get\", i], [\"get\", M.LOCAL.flag]]);\n    const {\n        layers: l\n      } = this.getStyle(),\n      u = this.originalLabelStyle.size === 0;\n    if (u) {\n      const c = oo(l, this);\n      this.isStyleLocalized = Object.keys(c.localized).length > 0;\n    }\n    for (const c of l) {\n      if (c.type !== \"symbol\") continue;\n      const p = c,\n        m = this.getSource(p.source);\n      if (!m || !(\"url\" in m && typeof m.url == \"string\") || new URL(m.url).host !== V.maptilerApiHost) continue;\n      const {\n        id: d,\n        layout: y\n      } = p;\n      if (!y || !(\"text-field\" in y)) continue;\n      let v;\n      if (u ? (v = this.getLayoutProperty(d, \"text-field\"), this.originalLabelStyle.set(d, v)) : v = this.originalLabelStyle.get(d), typeof v == \"string\") {\n        const {\n          contains: w,\n          exactMatch: b\n        } = eo(v, this.isStyleLocalized);\n        if (!w) continue;\n        if (b) this.setLayoutProperty(d, \"text-field\", s);else {\n          const T = to(v, s, this.isStyleLocalized);\n          this.setLayoutProperty(d, \"text-field\", T);\n        }\n      } else {\n        const w = Qa(v, s, this.isStyleLocalized);\n        this.setLayoutProperty(d, \"text-field\", w);\n      }\n    }\n    this.languageIsUpdated = !0;\n  }\n  /**\n   * Get the primary language\n   * @returns\n   */\n  getPrimaryLanguage() {\n    return this.primaryLanguage;\n  }\n  /**\n   * Get the exaggeration factor applied to the terrain\n   * @returns\n   */\n  getTerrainExaggeration() {\n    return this.terrainExaggeration;\n  }\n  /**\n   * Know if terrian is enabled or not\n   * @returns\n   */\n  hasTerrain() {\n    return this.isTerrainEnabled;\n  }\n  growTerrain(t) {\n    if (!this.terrain) return;\n    const n = performance.now(),\n      a = this.terrain.exaggeration,\n      o = t - a,\n      i = () => {\n        if (!this.terrain || this.terrainFlattening) return;\n        const s = (performance.now() - n) / this.terrainAnimationDuration;\n        if (s < 0.99) {\n          const l = 1 - (1 - s) ** 4,\n            u = a + l * o;\n          this.terrain.exaggeration = u, requestAnimationFrame(i);\n        } else this.terrainGrowing = !1, this.terrainFlattening = !1, this.terrain.exaggeration = t, this.fire(\"terrainAnimationStop\", {\n          terrain: this.terrain\n        });\n        this._elevationFreeze = !1, this.triggerRepaint();\n      };\n    !this.terrainGrowing && !this.terrainFlattening && this.fire(\"terrainAnimationStart\", {\n      terrain: this.terrain\n    }), this.terrainGrowing = !0, this.terrainFlattening = !1, requestAnimationFrame(i);\n  }\n  /**\n   * Enables the 3D terrain visualization\n   */\n  enableTerrain(t = this.terrainExaggeration) {\n    if (t < 0) {\n      console.warn(\"Terrain exaggeration cannot be negative.\");\n      return;\n    }\n    const n = o => {\n        !this.terrain || o.type !== \"data\" || o.dataType !== \"source\" || !(\"source\" in o) || o.sourceId !== \"maptiler-terrain\" || o.source.type !== \"raster-dem\" || o.isSourceLoaded && (this.off(\"data\", n), this.growTerrain(t));\n      },\n      a = () => {\n        this.isTerrainEnabled = !0, this.terrainExaggeration = t, this.on(\"data\", n), this.addSource(V.terrainSourceId, {\n          type: \"raster-dem\",\n          url: V.terrainSourceURL\n        }), this.setTerrain({\n          source: V.terrainSourceId,\n          exaggeration: 0\n        });\n      };\n    if (this.getTerrain()) {\n      this.isTerrainEnabled = !0, this.growTerrain(t);\n      return;\n    }\n    this.loaded() || this.isTerrainEnabled ? a() : this.once(\"load\", () => {\n      this.getTerrain() && this.getSource(V.terrainSourceId) || a();\n    });\n  }\n  /**\n   * Disable the 3D terrain visualization\n   */\n  disableTerrain() {\n    if (!this.terrain) return;\n    this.isTerrainEnabled = !1;\n    const t = performance.now(),\n      n = this.terrain.exaggeration,\n      a = () => {\n        if (!this.terrain || this.terrainGrowing) return;\n        const o = (performance.now() - t) / this.terrainAnimationDuration;\n        if (this._elevationFreeze = !1, o < 0.99) {\n          const i = (1 - o) ** 4,\n            s = n * i;\n          this.terrain.exaggeration = s, requestAnimationFrame(a);\n        } else this.terrain.exaggeration = 0, this.terrainGrowing = !1, this.terrainFlattening = !1, this.setTerrain(), this.getSource(V.terrainSourceId) && this.removeSource(V.terrainSourceId), this.fire(\"terrainAnimationStop\", {\n          terrain: null\n        });\n        this.triggerRepaint();\n      };\n    !this.terrainGrowing && !this.terrainFlattening && this.fire(\"terrainAnimationStart\", {\n      terrain: this.terrain\n    }), this.terrainGrowing = !1, this.terrainFlattening = !0, requestAnimationFrame(a);\n  }\n  /**\n   * Sets the 3D terrain exageration factor.\n   * If the terrain was not enabled prior to the call of this method,\n   * the method `.enableTerrain()` will be called.\n   * If `animate` is `true`, the terrain transformation will be animated in the span of 1 second.\n   * If `animate` is `false`, no animated transition to the newly defined exaggeration.\n   */\n  setTerrainExaggeration(t, n = !0) {\n    !n && this.terrain ? (this.terrainExaggeration = t, this.terrain.exaggeration = t, this.triggerRepaint()) : this.enableTerrain(t);\n  }\n  /**\n   * Perform an action when the style is ready. It could be at the moment of calling this method\n   * or later.\n   */\n  onStyleReady(t) {\n    this.isStyleLoaded() ? t() : this.once(\"styledata\", () => {\n      t();\n    });\n  }\n  async fitToIpBounds() {\n    const t = await Dr.info();\n    this.fitBounds(t.country_bounds, {\n      duration: 0,\n      padding: 100\n    });\n  }\n  async centerOnIpPoint(t) {\n    const n = await Dr.info();\n    this.jumpTo({\n      center: [n.longitude ?? 0, n.latitude ?? 0],\n      zoom: t || 11\n    });\n  }\n  getCameraHash() {\n    const t = new Float32Array(5),\n      n = this.getCenter();\n    return t[0] = n.lng, t[1] = n.lat, t[2] = this.getZoom(), t[3] = this.getPitch(), t[4] = this.getBearing(), Da.fromUint8Array(new Uint8Array(t.buffer));\n  }\n  /**\n   * Get the SDK config object.\n   * This is convenient to dispatch the SDK configuration to externally built layers\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   */\n  getSdkConfig() {\n    return O;\n  }\n  /**\n   * Get the MapTiler session ID. Convenient to dispatch to externaly built component\n   * that do not directly have access to the SDK configuration but do have access to a Map instance.\n   * @returns\n   */\n  getMaptilerSessionId() {\n    return ur;\n  }\n  /**\n   *  Updates the requestManager's transform request with a new function.\n   *\n   * @param transformRequest A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.\n   *    Expected to return an object with a `url` property and optionally `headers` and `credentials` properties\n   *\n   * @returns {Map} `this`\n   *\n   *  @example\n   *  map.setTransformRequest((url: string, resourceType: string) => {});\n   */\n  setTransformRequest(t) {\n    return super.setTransformRequest(Vr(t)), this;\n  }\n  /**\n   * Returns whether a globe projection is currently being used\n   */\n  isGlobeProjection() {\n    const t = this.getProjection();\n    return t ? t.type === \"globe\" : !1;\n  }\n  /**\n   * Activate the globe projection.\n   */\n  enableGlobeProjection() {\n    this.isGlobeProjection() !== !0 && (this.setProjection({\n      type: \"globe\"\n    }), this.curentProjection = \"globe\");\n  }\n  /**\n   * Activate the mercator projection.\n   */\n  enableMercatorProjection() {\n    this.isGlobeProjection() !== !1 && (this.setProjection({\n      type: \"mercator\"\n    }), this.curentProjection = \"mercator\");\n  }\n  /**\n   * Returns `true` is the language was ever updated, meaning changed\n   * from what is delivered in the style.\n   * Returns `false` if language in use is the language from the style\n   * and has never been changed.\n   */\n  isLanguageUpdated() {\n    return this.languageIsUpdated;\n  }\n}\nfunction Pr(r) {\n  if (typeof DOMParser < \"u\") {\n    const e = new DOMParser().parseFromString(r, \"application/xml\");\n    if (e.querySelector(\"parsererror\")) throw new Error(\"The provided string is not valid XML\");\n    return e;\n  }\n  throw new Error(\"No XML parser found\");\n}\nfunction ua(r, e) {\n  if (!r.hasChildNodes()) return !1;\n  for (const t of Array.from(r.childNodes)) {\n    const n = t.nodeName;\n    if (typeof n == \"string\" && n.trim().toLowerCase() === e.toLowerCase()) return !0;\n  }\n  return !1;\n}\nfunction gn(r) {\n  if (typeof XMLSerializer < \"u\") return new XMLSerializer().serializeToString(r);\n  throw new Error(\"No XML serializer found\");\n}\nfunction ca(r) {\n  const e = typeof r == \"string\" ? Pr(r) : r;\n  if (!ua(e, \"gpx\")) throw new Error(\"The XML document is not valid GPX\");\n  const t = U(e, \"trk\"),\n    n = U(e, \"rte\"),\n    a = U(e, \"wpt\"),\n    o = {\n      type: \"FeatureCollection\",\n      features: []\n    };\n  for (const i of Array.from(t)) {\n    const s = Js(i);\n    s && o.features.push(s);\n  }\n  for (const i of Array.from(n)) {\n    const s = Ys(i);\n    s && o.features.push(s);\n  }\n  for (const i of Array.from(a)) o.features.push(Xs(i));\n  return o;\n}\nfunction pa(r, e) {\n  let t = r;\n  if (typeof t == \"string\" && (t = Pr(t)), !ua(t, \"kml\")) throw new Error(\"The XML document is not valid KML\");\n  const n = {\n      type: \"FeatureCollection\",\n      features: []\n    },\n    a = {},\n    o = {},\n    i = {},\n    s = U(t, \"Placemark\"),\n    l = U(t, \"Style\"),\n    u = U(t, \"StyleMap\");\n  for (const c of Array.from(l)) {\n    const p = bn(e !== void 0 ? e(c) : gn(c)).toString(16);\n    a[`#${Ie(c, \"id\")}`] = p, o[p] = c;\n  }\n  for (const c of Array.from(u)) {\n    a[`#${Ie(c, \"id\")}`] = bn(e !== void 0 ? e(c) : gn(c)).toString(16);\n    const p = U(c, \"Pair\"),\n      m = {};\n    for (const f of Array.from(p)) m[P(k(f, \"key\")) ?? \"\"] = P(k(f, \"styleUrl\"));\n    i[`#${Ie(c, \"id\")}`] = m;\n  }\n  for (const c of Array.from(s)) n.features = n.features.concat(Zs(c, a, o, i));\n  return n;\n}\nfunction vn(r) {\n  if (r === null) return [\"#000000\", 1];\n  let e = \"\",\n    t = 1,\n    n = r;\n  return n.startsWith(\"#\") && (n = n.substring(1)), (n.length === 6 || n.length === 3) && (e = n), n.length === 8 && (t = Number.parseInt(n.substring(0, 2), 16) / 255, e = `#${n.substring(6, 8)}${n.substring(4, 6)}${n.substring(2, 4)}`), [e ?? \"#000000\", t ?? 1];\n}\nfunction Ks(r) {\n  return ya(r.split(\" \"));\n}\nfunction Ws(r) {\n  let e = U(r, \"coord\");\n  const t = [],\n    n = [];\n  e.length === 0 && (e = U(r, \"gx:coord\"));\n  for (const o of Array.from(e)) t.push(Ks(P(o) ?? \"\"));\n  const a = U(r, \"when\");\n  for (const o of Array.from(a)) n.push(P(o));\n  return {\n    coords: t,\n    times: n\n  };\n}\nfunction ut(r) {\n  const e = [\"Polygon\", \"LineString\", \"Point\", \"Track\", \"gx:Track\"];\n  let t, n, a, o, i;\n  const s = [],\n    l = [];\n  if (k(r, \"MultiGeometry\") !== null) return ut(k(r, \"MultiGeometry\"));\n  if (k(r, \"MultiTrack\") !== null) return ut(k(r, \"MultiTrack\"));\n  if (k(r, \"gx:MultiTrack\") !== null) return ut(k(r, \"gx:MultiTrack\"));\n  for (a = 0; a < e.length; a++) if (n = U(r, e[a]), n) {\n    for (o = 0; o < n.length; o++) if (t = n[o], e[a] === \"Point\") s.push({\n      type: \"Point\",\n      coordinates: ma(P(k(t, \"coordinates\")) ?? \"\")\n    });else if (e[a] === \"LineString\") s.push({\n      type: \"LineString\",\n      coordinates: Sn(P(k(t, \"coordinates\")) ?? \"\")\n    });else if (e[a] === \"Polygon\") {\n      const u = U(t, \"LinearRing\"),\n        c = [];\n      for (i = 0; i < u.length; i++) c.push(Sn(P(k(u[i], \"coordinates\")) ?? \"\"));\n      s.push({\n        type: \"Polygon\",\n        coordinates: c\n      });\n    } else if (e[a] === \"Track\" || e[a] === \"gx:Track\") {\n      const u = Ws(t);\n      s.push({\n        type: \"LineString\",\n        coordinates: u.coords\n      }), u.times.length && l.push(u.times);\n    }\n  }\n  return {\n    geoms: s,\n    coordTimes: l\n  };\n}\nfunction Zs(r, e, t, n) {\n  const a = ut(r),\n    o = {},\n    i = P(k(r, \"name\")),\n    s = P(k(r, \"address\")),\n    l = P(k(r, \"description\")),\n    u = k(r, \"TimeSpan\"),\n    c = k(r, \"TimeStamp\"),\n    p = k(r, \"ExtendedData\"),\n    m = k(r, \"visibility\");\n  let f,\n    d = P(k(r, \"styleUrl\")),\n    y = k(r, \"LineStyle\"),\n    v = k(r, \"PolyStyle\");\n  if (!a.geoms.length) return [];\n  if (i && (o.name = i), s && (o.address = s), d) {\n    d.startsWith(\"#\") || (d = `#${d}`), o.styleUrl = d, e[d] && (o.styleHash = e[d]), n[d] && (o.styleMapHash = n[d], o.styleHash = e[n[d].normal ?? \"\"]);\n    const b = t[o.styleHash ?? \"\"];\n    if (b) {\n      y || (y = k(b, \"LineStyle\")), v || (v = k(b, \"PolyStyle\"));\n      const T = k(b, \"IconStyle\");\n      if (T) {\n        const j = k(T, \"Icon\");\n        if (j) {\n          const R = P(k(j, \"href\"));\n          R && (o.icon = R);\n        }\n      }\n    }\n  }\n  if (l && (o.description = l), u) {\n    const b = P(k(u, \"begin\")),\n      T = P(k(u, \"end\"));\n    b && T && (o.timespan = {\n      begin: b,\n      end: T\n    });\n  }\n  if (c !== null && (o.timestamp = P(k(c, \"when\")) ?? (/* @__PURE__ */new Date()).toISOString()), y !== null) {\n    const b = vn(P(k(y, \"color\"))),\n      T = b[0],\n      j = b[1],\n      R = Number.parseFloat(P(k(y, \"width\")) ?? \"\");\n    T && (o.stroke = T), Number.isNaN(j) || (o[\"stroke-opacity\"] = j), Number.isNaN(R) || (o[\"stroke-width\"] = R);\n  }\n  if (v) {\n    const b = vn(P(k(v, \"color\"))),\n      T = b[0],\n      j = b[1],\n      R = P(k(v, \"fill\")),\n      ae = P(k(v, \"outline\"));\n    T && (o.fill = T), Number.isNaN(j) || (o[\"fill-opacity\"] = j), R && (o[\"fill-opacity\"] = R === \"1\" ? o[\"fill-opacity\"] || 1 : 0), ae && (o[\"stroke-opacity\"] = ae === \"1\" ? o[\"stroke-opacity\"] || 1 : 0);\n  }\n  if (p) {\n    const b = U(p, \"Data\"),\n      T = U(p, \"SimpleData\");\n    for (f = 0; f < b.length; f++) o[b[f].getAttribute(\"name\") ?? \"\"] = P(k(b[f], \"value\")) ?? \"\";\n    for (f = 0; f < T.length; f++) o[T[f].getAttribute(\"name\") ?? \"\"] = P(T[f]) ?? \"\";\n  }\n  m !== null && (o.visibility = P(m) ?? \"\"), a.coordTimes.length !== 0 && (o.coordTimes = a.coordTimes.length === 1 ? a.coordTimes[0] : a.coordTimes);\n  const w = {\n    type: \"Feature\",\n    geometry: a.geoms.length === 1 ? a.geoms[0] : {\n      type: \"GeometryCollection\",\n      geometries: a.geoms\n    },\n    properties: o\n  };\n  return Ie(r, \"id\") && (w.id = Ie(r, \"id\") ?? void 0), [w];\n}\nfunction fa(r, e) {\n  const t = U(r, e),\n    n = [],\n    a = [];\n  let o = [];\n  const i = t.length;\n  if (!(i < 2)) {\n    for (let s = 0; s < i; s++) {\n      const l = ha(t[s]);\n      n.push(l.coordinates), l.time && a.push(l.time), (l.heartRate || o.length) && (o.length === 0 && (o = new Array(s).fill(null)), o.push(l.heartRate));\n    }\n    return {\n      line: n,\n      times: a,\n      heartRates: o\n    };\n  }\n}\nfunction Js(r) {\n  const e = U(r, \"trkseg\"),\n    t = [],\n    n = [],\n    a = [];\n  let o;\n  for (let s = 0; s < e.length; s++) if (o = fa(e[s], \"trkpt\"), o !== void 0 && (o.line && t.push(o.line), o.times && o.times.length && n.push(o.times), a.length || o.heartRates && o.heartRates.length)) {\n    if (!a.length) for (let l = 0; l < s; l++) a.push(new Array(t[l].length).fill(null));\n    o.heartRates && o.heartRates.length ? a.push(o.heartRates) : a.push(new Array(o.line.length).fill(null));\n  }\n  if (t.length === 0) return;\n  const i = {\n    ...Rr(r),\n    ...da(k(r, \"extensions\"))\n  };\n  return n.length !== 0 && (i.coordTimes = t.length === 1 ? n[0] : n), a.length !== 0 && (i.heartRates = t.length === 1 ? a[0] : a), t.length === 1 ? {\n    type: \"Feature\",\n    properties: i,\n    geometry: {\n      type: \"LineString\",\n      coordinates: t[0]\n    }\n  } : {\n    type: \"Feature\",\n    properties: i,\n    geometry: {\n      type: \"MultiLineString\",\n      coordinates: t\n    }\n  };\n}\nfunction Ys(r) {\n  const e = fa(r, \"rtept\");\n  return e === void 0 ? void 0 : {\n    type: \"Feature\",\n    properties: {\n      ...Rr(r),\n      ...da(k(r, \"extensions\"))\n    },\n    geometry: {\n      type: \"LineString\",\n      coordinates: e.line\n    }\n  };\n}\nfunction Xs(r) {\n  return {\n    type: \"Feature\",\n    properties: {\n      ...Rr(r),\n      ...nr(r, [\"sym\"])\n    },\n    geometry: {\n      type: \"Point\",\n      coordinates: ha(r).coordinates\n    }\n  };\n}\nfunction da(r) {\n  const e = {};\n  if (r) {\n    const t = k(r, \"line\");\n    if (t) {\n      const n = P(k(t, \"color\")),\n        a = Number.parseFloat(P(k(t, \"opacity\")) ?? \"0\"),\n        o = Number.parseFloat(P(k(t, \"width\")) ?? \"0\");\n      n && (e.stroke = n), Number.isNaN(a) || (e[\"stroke-opacity\"] = a), Number.isNaN(o) || (e[\"stroke-width\"] = o * 96 / 25.4);\n    }\n  }\n  return e;\n}\nfunction Rr(r) {\n  const e = nr(r, [\"name\", \"cmt\", \"desc\", \"type\", \"time\", \"keywords\"]),\n    t = U(r, \"link\");\n  if (t.length !== 0) {\n    e.links = [];\n    for (const n of Array.from(t)) {\n      const a = {\n        href: Ie(n, \"href\"),\n        ...nr(n, [\"text\", \"type\"])\n      };\n      e.links.push(a);\n    }\n  }\n  return e;\n}\nfunction bn(r) {\n  let e = 0;\n  if (!r || !r.length) return e;\n  for (let t = 0; t < r.length; t++) e = (e << 5) - e + r.charCodeAt(t) | 0;\n  return e;\n}\nfunction U(r, e) {\n  return r.getElementsByTagName(e);\n}\nfunction Ie(r, e) {\n  return r.getAttribute(e);\n}\nfunction wn(r, e) {\n  return Number.parseFloat(Ie(r, e) ?? \"0\");\n}\nfunction k(r, e) {\n  const t = U(r, e);\n  return t.length ? t[0] : null;\n}\nfunction Qs(r) {\n  return r.normalize && r.normalize(), r;\n}\nfunction ya(r) {\n  return r.map(Number.parseFloat).map(e => Number.isNaN(e) ? null : e);\n}\nfunction P(r) {\n  return r && Qs(r), r && r.textContent;\n}\nfunction nr(r, e) {\n  const t = {};\n  let n, a;\n  for (a = 0; a < e.length; a++) n = k(r, e[a]), n && (t[e[a]] = P(n) ?? \"\");\n  return t;\n}\nfunction ma(r) {\n  return ya(r.replace(/\\s*/g, \"\").split(\",\"));\n}\nfunction Sn(r) {\n  const e = r.replace(/^\\s*|\\s*$/g, \"\").split(/\\s+/),\n    t = [];\n  for (const n of e) t.push(ma(n));\n  return t;\n}\nfunction ha(r) {\n  const e = [wn(r, \"lon\"), wn(r, \"lat\")],\n    t = k(r, \"ele\"),\n    n = k(r, \"gpxtpx:hr\") || k(r, \"hr\"),\n    a = k(r, \"time\");\n  let o;\n  return t && (o = Number.parseFloat(P(t) ?? \"0\"), Number.isNaN(o) || e.push(o)), {\n    coordinates: e,\n    time: a ? P(a) : null,\n    heartRate: n !== null ? Number.parseFloat(P(n) ?? \"0\") : null\n  };\n}\nfunction el(r) {\n  let e = r;\n  try {\n    typeof e == \"string\" && (e = Pr(e));\n  } catch {\n    return null;\n  }\n  try {\n    return ca(e);\n  } catch {}\n  try {\n    return pa(e);\n  } catch {}\n  return null;\n}\nasync function tl(r, e = {}) {\n  const t = e.download ?? !1,\n    n = await rl(r);\n  if (t) {\n    const a = e.filename ?? \"maptiler_screenshot.png\",\n      o = document.createElement(\"a\");\n    o.style.display = \"none\", document.body.appendChild(o), o.href = URL.createObjectURL(n), o.download = a, o.click(), setTimeout(() => {\n      document.body.removeChild(o), URL.revokeObjectURL(o.href);\n    }, 0);\n  }\n  return n;\n}\nfunction rl(r) {\n  return new Promise((e, t) => {\n    r.redraw(), r.once(\"idle\", () => {\n      r.getCanvas().toBlob(n => {\n        if (!n) {\n          t(Error(\"Screenshot could not be created.\"));\n          return;\n        }\n        e(n);\n      }, \"image/png\");\n    });\n  });\n}\nconst ar = [\n// https://colorhunt.co/palette/1d5b79468b97ef6262f3aa60\n[\"#1D5B79\", \"#468B97\", \"#EF6262\", \"#F3AA60\"],\n// https://colorhunt.co/palette/614bc333bbc585e6c5c8ffe0\n[\"#614BC3\", \"#33BBC5\", \"#85E6C5\", \"#C8FFE0\"],\n// https://colorhunt.co/palette/4619597a316fcd6688aed8cc\n[\"#461959\", \"#7A316F\", \"#CD6688\", \"#AED8CC\"],\n// https://colorhunt.co/palette/0079ff00dfa2f6fa70ff0060\n[\"#0079FF\", \"#00DFA2\", \"#F6FA70\", \"#FF0060\"],\n//https://colorhunt.co/palette/39b5e0a31acbff78f0f5ea5a\n[\"#39B5E0\", \"#A31ACB\", \"#FF78F0\", \"#F5EA5A\"],\n// https://colorhunt.co/palette/37e2d5590696c70a80fbcb0a\n[\"#37E2D5\", \"#590696\", \"#C70A80\", \"#FBCB0A\"],\n// https://colorhunt.co/palette/ffd36efff56d99ffcd9fb4ff\n[\"#FFD36E\", \"#FFF56D\", \"#99FFCD\", \"#9FB4FF\"],\n// https://colorhunt.co/palette/00ead3fff5b7ff449f005f99\n[\"#00EAD3\", \"#FFF5B7\", \"#FF449F\", \"#005F99\"],\n// https://colorhunt.co/palette/10a19d540375ff7000ffbf00\n[\"#10A19D\", \"#540375\", \"#FF7000\", \"#FFBF00\"]];\nfunction Pt() {\n  return ar[~~(Math.random() * ar.length)][~~(Math.random() * 4)];\n}\nfunction et() {\n  return `maptiler_source_${kn()}`;\n}\nfunction tt() {\n  return `maptiler_layer_${kn()}`;\n}\nfunction or(r, e) {\n  if (e <= r[0].zoom) return r[0].value;\n  if (e >= r[r.length - 1].zoom) return r[r.length - 1].value;\n  for (let t = 0; t < r.length - 1; t += 1) if (e >= r[t].zoom && e < r[t + 1].zoom) {\n    const n = r[t + 1].zoom - r[t].zoom,\n      a = (e - r[t].zoom) / n;\n    return a * r[t + 1].value + (1 - a) * r[t].value;\n  }\n  return 0;\n}\nfunction be(r) {\n  return [\"interpolate\", [\"linear\"], [\"zoom\"], ...r.flatMap(e => [e.zoom, e.value])];\n}\nfunction z(r) {\n  return [\"interpolate\", [\"linear\"], [\"zoom\"], ...r.flatMap(e => [e.zoom, e.value])];\n}\nfunction ga(r, e) {\n  if (typeof e == \"number\" && typeof r == \"number\") return 2 * e + r;\n  if (typeof e == \"number\" && Array.isArray(r)) return [\"interpolate\", [\"linear\"], [\"zoom\"], ...r.flatMap(t => [t.zoom, 2 * e + t.value])];\n  if (typeof r == \"number\" && Array.isArray(e)) return [\"interpolate\", [\"linear\"], [\"zoom\"], ...e.flatMap(t => [t.zoom, 2 * t.value + r])];\n  if (Array.isArray(r) && Array.isArray(e)) {\n    const t = Array.from(/* @__PURE__ */new Set([...r.map(n => n.zoom), ...e.map(n => n.zoom)])).sort((n, a) => n < a ? -1 : 1);\n    return [\"interpolate\", [\"linear\"], [\"zoom\"], ...t.flatMap(n => [n, 2 * or(e, n) + or(r, n)])];\n  }\n  return 0;\n}\nfunction va(r, e) {\n  return [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap(t => [t.propertyValue, t.value])];\n}\nfunction $r(r) {\n  const e = r.trimStart(),\n    t = `${e}${\" \".repeat(r.length - e.length)}`,\n    n = Array.from(t);\n  if (!n.every(s => s === \" \" || s === \"_\")) throw new Error(\"A dash pattern must be composed only of whitespace and underscore characters.\");\n  if (!(n.some(s => s === \"_\") && n.some(s => s === \" \"))) throw new Error(\"A dash pattern must contain at least one underscore and one whitespace character\");\n  const i = [1];\n  for (let s = 1; s < n.length; s += 1) {\n    const l = n[s - 1],\n      u = n[s];\n    l === u ? i[i.length - 1] += 1 : i.push(1);\n  }\n  return i;\n}\nfunction ir(r, e) {\n  return [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap(t => [t.value, t.color])];\n}\nfunction sr(r, e, t = !0) {\n  return t ? [\"interpolate\", [\"linear\"], [\"zoom\"], 0, [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap(n => [n.value, n.pointRadius * 0.025])], 2, [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap(n => [n.value, n.pointRadius * 0.05])], 4, [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap(n => [n.value, n.pointRadius * 0.1])], 8, [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap(n => [n.value, n.pointRadius * 0.25])], 16, [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap(n => [n.value, n.pointRadius])]] : [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap(n => [n.value, n.pointRadius])];\n}\nfunction ba(r, e, t = !0) {\n  return t ? [\"interpolate\", [\"linear\"], [\"zoom\"], 0, [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap(n => [n.propertyValue, n.value * 0.025])], 2, [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap(n => [n.propertyValue, n.value * 0.05])], 4, [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap(n => [n.propertyValue, n.value * 0.1])], 8, [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap(n => [n.propertyValue, n.value * 0.25])], 16, [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap(n => [n.propertyValue, n.value])]] : [\"interpolate\", [\"linear\"], [\"get\", e], ...r.flatMap(n => [n.propertyValue, n.value])];\n}\nfunction lr(r, e) {\n  return r.every(t => t.color[3] === r[0].color[3]) ? r[0].color[3] ? r[0].color[3] / 255 : 1 : [\"interpolate\", [\"linear\"], [\"get\", e], ...r.getRawColorStops().flatMap(t => {\n    const n = t.value,\n      a = t.color;\n    return [n, a.length === 4 ? a[3] / 255 : 1];\n  })];\n}\nfunction wa(r, e = 10) {\n  return [\"interpolate\", [\"linear\"], [\"heatmap-density\"], ...Array.from({\n    length: e + 1\n  }, (t, n) => {\n    const a = n / e;\n    return [a, r.getColorHex(a)];\n  }).flat()];\n}\nfunction st(r) {\n  const e = r.toString(16);\n  return e.length === 1 ? `0${e}` : e;\n}\nfunction nl(r) {\n  return `#${st(r[0])}${st(r[1])}${st(r[2])}${r.length === 4 ? st(r[3]) : \"\"}`;\n}\nclass x extends Array {\n  constructor(t = {}) {\n    super();\n    L(this, \"min\", 0);\n    L(this, \"max\", 1);\n    \"min\" in t && (this.min = t.min), \"max\" in t && (this.max = t.max), \"stops\" in t && this.setStops(t.stops, {\n      clone: !1\n    });\n  }\n  /**\n   * Converts a array-definition color ramp definition into a usable ColorRamp instance.\n   * Note: units are not converted and may need to to be converted beforehand (eg. kelvin to centigrade)\n   * @param cr\n   * @returns\n   */\n  static fromArrayDefinition(t) {\n    return new x({\n      stops: t.map(n => ({\n        value: n[0],\n        color: n[1]\n      }))\n    });\n  }\n  setStops(t, n = {\n    clone: !0\n  }) {\n    const a = n.clone ? this.clone() : this;\n    a.length = 0;\n    let o = Number.POSITIVE_INFINITY,\n      i = Number.NEGATIVE_INFINITY;\n    for (let s = 0; s < t.length; s += 1) o = Math.min(o, t[s].value), i = Math.max(i, t[s].value), a.push({\n      value: t[s].value,\n      color: t[s].color.slice()\n      // we want to make sure we do a deep copy and not a reference\n    });\n    return a.sort((s, l) => s.value < l.value ? -1 : 1), this.min = o, this.max = i, a;\n  }\n  scale(t, n, a = {\n    clone: !0\n  }) {\n    const o = a.clone,\n      i = this[0].value,\n      l = this.at(-1).value - i,\n      u = n - t,\n      c = [];\n    for (let p = 0; p < this.length; p += 1) {\n      const d = (this[p].value - i) / l * u + t;\n      o ? c.push({\n        value: d,\n        color: this[p].color.slice()\n      }) : this[p].value = d;\n    }\n    return o ? new x({\n      stops: c\n    }) : this;\n  }\n  // for some reason, I had to reimplement this\n  at(t) {\n    return t < 0 ? this[this.length + t] : this[t];\n  }\n  clone() {\n    return new x({\n      stops: this.getRawColorStops()\n    });\n  }\n  getRawColorStops() {\n    const t = [];\n    for (let n = 0; n < this.length; n += 1) t.push({\n      value: this[n].value,\n      color: this[n].color\n    });\n    return t;\n  }\n  reverse(t = {\n    clone: !0\n  }) {\n    const n = t.clone ? this.clone() : this;\n    for (let a = 0; a < ~~(n.length / 2); a += 1) {\n      const o = n[a].color;\n      n[a].color = n.at(-(a + 1)).color, n.at(-(a + 1)).color = o;\n    }\n    return n;\n  }\n  getBounds() {\n    return {\n      min: this.min,\n      max: this.max\n    };\n  }\n  getColor(t, n = {\n    smooth: !0\n  }) {\n    if (t <= this[0].value) return this[0].color;\n    if (t >= this.at(-1).value) return this.at(-1).color;\n    for (let a = 0; a < this.length - 1; a += 1) {\n      if (t > this[a + 1].value) continue;\n      const o = this[a].color;\n      if (!n.smooth) return o.slice();\n      const i = this[a].value,\n        s = this[a + 1].value,\n        l = this[a + 1].color,\n        u = (s - t) / (s - i);\n      return o.map((c, p) => Math.round(c * u + l[p] * (1 - u)));\n    }\n    return [0, 0, 0];\n  }\n  /**\n   * Get the color as an hexadecimal string\n   */\n  getColorHex(t, n = {\n    smooth: !0,\n    withAlpha: !1\n  }) {\n    return nl(this.getColor(t, n));\n  }\n  /**\n   * Get the color of the color ramp at a relative position in [0, 1]\n   */\n  getColorRelative(t, n = {\n    smooth: !0\n  }) {\n    const a = this.getBounds();\n    return this.getColor(a.min + t * (a.max - a.min), n);\n  }\n  getCanvasStrip(t = {\n    horizontal: !0,\n    size: 512,\n    smooth: !0\n  }) {\n    const n = document.createElement(\"canvas\");\n    n.width = t.horizontal ? t.size : 1, n.height = t.horizontal ? 1 : t.size;\n    const a = n.getContext(\"2d\");\n    if (!a) throw new Error(\"Canvs context is missing\");\n    const o = a.getImageData(0, 0, n.width, n.height),\n      i = o.data,\n      s = t.size,\n      l = this[0].value,\n      p = (this.at(-1).value - l) / s;\n    for (let m = 0; m < s; m += 1) {\n      const f = this.getColor(l + m * p, {\n        smooth: t.smooth\n      });\n      i[m * 4] = f[0], i[m * 4 + 1] = f[1], i[m * 4 + 2] = f[2], i[m * 4 + 3] = f.length > 3 ? f[3] : 255;\n    }\n    return a.putImageData(o, 0, 0), n;\n  }\n  /**\n   * Apply a non-linear ressampling. This will create a new instance of ColorRamp with the same bounds.\n   */\n  resample(t, n = 15) {\n    const a = this.getBounds(),\n      o = this.scale(0, 1),\n      i = 1 / (n - 1);\n    let s;\n    if (t === \"ease-in-square\") s = Array.from({\n      length: n\n    }, (c, p) => {\n      const m = p * i,\n        f = m ** 2,\n        d = o.getColor(f);\n      return {\n        value: m,\n        color: d\n      };\n    });else if (t === \"ease-out-square\") s = Array.from({\n      length: n\n    }, (c, p) => {\n      const m = p * i,\n        f = 1 - (1 - m) ** 2,\n        d = o.getColor(f);\n      return {\n        value: m,\n        color: d\n      };\n    });else if (t === \"ease-out-sqrt\") s = Array.from({\n      length: n\n    }, (c, p) => {\n      const m = p * i,\n        f = m ** 0.5,\n        d = o.getColor(f);\n      return {\n        value: m,\n        color: d\n      };\n    });else if (t === \"ease-in-sqrt\") s = Array.from({\n      length: n\n    }, (c, p) => {\n      const m = p * i,\n        f = 1 - (1 - m) ** 0.5,\n        d = o.getColor(f);\n      return {\n        value: m,\n        color: d\n      };\n    });else if (t === \"ease-out-exp\") s = Array.from({\n      length: n\n    }, (c, p) => {\n      const m = p * i,\n        f = 1 - 2 ** (-10 * m),\n        d = o.getColor(f);\n      return {\n        value: m,\n        color: d\n      };\n    });else if (t === \"ease-in-exp\") s = Array.from({\n      length: n\n    }, (c, p) => {\n      const m = p * i,\n        f = 2 ** (10 * m - 10),\n        d = o.getColor(f);\n      return {\n        value: m,\n        color: d\n      };\n    });else throw new Error(\"Invalid ressampling method.\");\n    return new x({\n      stops: s\n    }).scale(a.min, a.max);\n  }\n  /**\n   * Makes a clone of this color ramp that is fully transparant at the begining of their range\n   */\n  transparentStart() {\n    const t = this.getRawColorStops();\n    t.unshift({\n      value: t[0].value,\n      color: t[0].color.slice()\n    }), t[1].value += 1e-3;\n    for (const n of t) n.color.length === 3 && n.color.push(255);\n    return t[0].color[3] = 0, new x({\n      stops: t\n    });\n  }\n  /**\n   * Check if this color ramp has a transparent start\n   */\n  hasTransparentStart() {\n    return this[0].color.length === 4 && this[0].color[3] === 0;\n  }\n}\nconst Sa = {\n  /**\n   * A fully transparent [0, 0, 0, 0] colorramp to hide data.\n   * Defined in interval [0, 1], without unit.\n   */\n  NULL: new x({\n    stops: [{\n      value: 0,\n      color: [0, 0, 0, 0]\n    }, {\n      value: 1,\n      color: [0, 0, 0, 0]\n    }]\n  }),\n  GRAY: new x({\n    stops: [{\n      value: 0,\n      color: [0, 0, 0]\n    }, {\n      value: 1,\n      color: [255, 255, 255]\n    }]\n  }),\n  /**\n   * Classic jet color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  JET: new x({\n    stops: [{\n      value: 0,\n      color: [0, 0, 131]\n    }, {\n      value: 0.125,\n      color: [0, 60, 170]\n    }, {\n      value: 0.375,\n      color: [5, 255, 255]\n    }, {\n      value: 0.625,\n      color: [255, 255, 0]\n    }, {\n      value: 0.875,\n      color: [250, 0, 0]\n    }, {\n      value: 1,\n      color: [128, 0, 0]\n    }]\n  }),\n  /**\n   * Classic HSV color ramp (hue, saturation, value).\n   * Defined in interval [0, 1], without unit.\n   */\n  HSV: new x({\n    stops: [{\n      value: 0,\n      color: [255, 0, 0]\n    }, {\n      value: 0.169,\n      color: [253, 255, 2]\n    }, {\n      value: 0.173,\n      color: [247, 255, 2]\n    }, {\n      value: 0.337,\n      color: [0, 252, 4]\n    }, {\n      value: 0.341,\n      color: [0, 252, 10]\n    }, {\n      value: 0.506,\n      color: [1, 249, 255]\n    }, {\n      value: 0.671,\n      color: [2, 0, 253]\n    }, {\n      value: 0.675,\n      color: [8, 0, 253]\n    }, {\n      value: 0.839,\n      color: [255, 0, 251]\n    }, {\n      value: 0.843,\n      color: [255, 0, 245]\n    }, {\n      value: 1,\n      color: [255, 0, 6]\n    }]\n  }),\n  /**\n   * Classic hot color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  HOT: new x({\n    stops: [{\n      value: 0,\n      color: [0, 0, 0]\n    }, {\n      value: 0.3,\n      color: [230, 0, 0]\n    }, {\n      value: 0.6,\n      color: [255, 210, 0]\n    }, {\n      value: 1,\n      color: [255, 255, 255]\n    }]\n  }),\n  /**\n   * Classic spring color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SPRING: new x({\n    stops: [{\n      value: 0,\n      color: [255, 0, 255]\n    }, {\n      value: 1,\n      color: [255, 255, 0]\n    }]\n  }),\n  /**\n   * Classic summer color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SUMMER: new x({\n    stops: [{\n      value: 0,\n      color: [0, 128, 102]\n    }, {\n      value: 1,\n      color: [255, 255, 102]\n    }]\n  }),\n  /**\n   * Classic autommn color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  AUTOMN: new x({\n    stops: [{\n      value: 0,\n      color: [255, 0, 0]\n    }, {\n      value: 1,\n      color: [255, 255, 0]\n    }]\n  }),\n  /**\n   * Classic winter color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  WINTER: new x({\n    stops: [{\n      value: 0,\n      color: [0, 0, 255]\n    }, {\n      value: 1,\n      color: [0, 255, 128]\n    }]\n  }),\n  /**\n   * Classic bone color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BONE: new x({\n    stops: [{\n      value: 0,\n      color: [0, 0, 0]\n    }, {\n      value: 0.376,\n      color: [84, 84, 116]\n    }, {\n      value: 0.753,\n      color: [169, 200, 200]\n    }, {\n      value: 1,\n      color: [255, 255, 255]\n    }]\n  }),\n  /**\n   * Classic copper color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  COPPER: new x({\n    stops: [{\n      value: 0,\n      color: [0, 0, 0]\n    }, {\n      value: 0.804,\n      color: [255, 160, 102]\n    }, {\n      value: 1,\n      color: [255, 199, 127]\n    }]\n  }),\n  /**\n   * Classic greys color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  GREYS: new x({\n    stops: [{\n      value: 0,\n      color: [0, 0, 0]\n    }, {\n      value: 1,\n      color: [255, 255, 255]\n    }]\n  }),\n  /**\n   * Classic yignbu color ramp (blue to light yellow).\n   * Defined in interval [0, 1], without unit.\n   */\n  YIGNBU: new x({\n    stops: [{\n      value: 0,\n      color: [8, 29, 88]\n    }, {\n      value: 0.125,\n      color: [37, 52, 148]\n    }, {\n      value: 0.25,\n      color: [34, 94, 168]\n    }, {\n      value: 0.375,\n      color: [29, 145, 192]\n    }, {\n      value: 0.5,\n      color: [65, 182, 196]\n    }, {\n      value: 0.625,\n      color: [127, 205, 187]\n    }, {\n      value: 0.75,\n      color: [199, 233, 180]\n    }, {\n      value: 0.875,\n      color: [237, 248, 217]\n    }, {\n      value: 1,\n      color: [255, 255, 217]\n    }]\n  }),\n  /**\n   * Classic greens color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  GREENS: new x({\n    stops: [{\n      value: 0,\n      color: [0, 68, 27]\n    }, {\n      value: 0.125,\n      color: [0, 109, 44]\n    }, {\n      value: 0.25,\n      color: [35, 139, 69]\n    }, {\n      value: 0.375,\n      color: [65, 171, 93]\n    }, {\n      value: 0.5,\n      color: [116, 196, 118]\n    }, {\n      value: 0.625,\n      color: [161, 217, 155]\n    }, {\n      value: 0.75,\n      color: [199, 233, 192]\n    }, {\n      value: 0.875,\n      color: [229, 245, 224]\n    }, {\n      value: 1,\n      color: [247, 252, 245]\n    }]\n  }),\n  /**\n   * Classic yiorrd color ramp (red to light yellow).\n   * Defined in interval [0, 1], without unit.\n   */\n  YIORRD: new x({\n    stops: [{\n      value: 0,\n      color: [128, 0, 38]\n    }, {\n      value: 0.125,\n      color: [189, 0, 38]\n    }, {\n      value: 0.25,\n      color: [227, 26, 28]\n    }, {\n      value: 0.375,\n      color: [252, 78, 42]\n    }, {\n      value: 0.5,\n      color: [253, 141, 60]\n    }, {\n      value: 0.625,\n      color: [254, 178, 76]\n    }, {\n      value: 0.75,\n      color: [254, 217, 118]\n    }, {\n      value: 0.875,\n      color: [255, 237, 160]\n    }, {\n      value: 1,\n      color: [255, 255, 204]\n    }]\n  }),\n  /**\n   * Classic blue-red color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BLUERED: new x({\n    stops: [{\n      value: 0,\n      color: [0, 0, 255]\n    }, {\n      value: 1,\n      color: [255, 0, 0]\n    }]\n  }),\n  /**\n   * Classic rdbu color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RDBU: new x({\n    stops: [{\n      value: 0,\n      color: [5, 10, 172]\n    }, {\n      value: 0.35,\n      color: [106, 137, 247]\n    }, {\n      value: 0.5,\n      color: [190, 190, 190]\n    }, {\n      value: 0.6,\n      color: [220, 170, 132]\n    }, {\n      value: 0.7,\n      color: [230, 145, 90]\n    }, {\n      value: 1,\n      color: [178, 10, 28]\n    }]\n  }),\n  /**\n   * Classic picnic color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PICNIC: new x({\n    stops: [{\n      value: 0,\n      color: [0, 0, 255]\n    }, {\n      value: 0.1,\n      color: [51, 153, 255]\n    }, {\n      value: 0.2,\n      color: [102, 204, 255]\n    }, {\n      value: 0.3,\n      color: [153, 204, 255]\n    }, {\n      value: 0.4,\n      color: [204, 204, 255]\n    }, {\n      value: 0.5,\n      color: [255, 255, 255]\n    }, {\n      value: 0.6,\n      color: [255, 204, 255]\n    }, {\n      value: 0.7,\n      color: [255, 153, 255]\n    }, {\n      value: 0.8,\n      color: [255, 102, 204]\n    }, {\n      value: 0.9,\n      color: [255, 102, 102]\n    }, {\n      value: 1,\n      color: [255, 0, 0]\n    }]\n  }),\n  /**\n   * Classic rainbow color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RAINBOW: new x({\n    stops: [{\n      value: 0,\n      color: [150, 0, 90]\n    }, {\n      value: 0.125,\n      color: [0, 0, 200]\n    }, {\n      value: 0.25,\n      color: [0, 25, 255]\n    }, {\n      value: 0.375,\n      color: [0, 152, 255]\n    }, {\n      value: 0.5,\n      color: [44, 255, 150]\n    }, {\n      value: 0.625,\n      color: [151, 255, 0]\n    }, {\n      value: 0.75,\n      color: [255, 234, 0]\n    }, {\n      value: 0.875,\n      color: [255, 111, 0]\n    }, {\n      value: 1,\n      color: [255, 0, 0]\n    }]\n  }),\n  /**\n   * Classic Portland color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PORTLAND: new x({\n    stops: [{\n      value: 0,\n      color: [12, 51, 131]\n    }, {\n      value: 0.25,\n      color: [10, 136, 186]\n    }, {\n      value: 0.5,\n      color: [242, 211, 56]\n    }, {\n      value: 0.75,\n      color: [242, 143, 56]\n    }, {\n      value: 1,\n      color: [217, 30, 30]\n    }]\n  }),\n  /**\n   * Classic blackbody color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BLACKBODY: new x({\n    stops: [{\n      value: 0,\n      color: [0, 0, 0]\n    }, {\n      value: 0.2,\n      color: [230, 0, 0]\n    }, {\n      value: 0.4,\n      color: [230, 210, 0]\n    }, {\n      value: 0.7,\n      color: [255, 255, 255]\n    }, {\n      value: 1,\n      color: [160, 200, 255]\n    }]\n  }),\n  /**\n   * Classic earth color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  EARTH: new x({\n    stops: [{\n      value: 0,\n      color: [0, 0, 130]\n    }, {\n      value: 0.1,\n      color: [0, 180, 180]\n    }, {\n      value: 0.2,\n      color: [40, 210, 40]\n    }, {\n      value: 0.4,\n      color: [230, 230, 50]\n    }, {\n      value: 0.6,\n      color: [120, 70, 20]\n    }, {\n      value: 1,\n      color: [255, 255, 255]\n    }]\n  }),\n  /**\n   * Classic electric color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  ELECTRIC: new x({\n    stops: [{\n      value: 0,\n      color: [0, 0, 0]\n    }, {\n      value: 0.15,\n      color: [30, 0, 100]\n    }, {\n      value: 0.4,\n      color: [120, 0, 100]\n    }, {\n      value: 0.6,\n      color: [160, 90, 0]\n    }, {\n      value: 0.8,\n      color: [230, 200, 0]\n    }, {\n      value: 1,\n      color: [255, 250, 220]\n    }]\n  }),\n  /**\n   * Classic viridis color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VIRIDIS: new x({\n    stops: [{\n      value: 0,\n      color: [68, 1, 84]\n    }, {\n      value: 0.13,\n      color: [71, 44, 122]\n    }, {\n      value: 0.25,\n      color: [59, 81, 139]\n    }, {\n      value: 0.38,\n      color: [44, 113, 142]\n    }, {\n      value: 0.5,\n      color: [33, 144, 141]\n    }, {\n      value: 0.63,\n      color: [39, 173, 129]\n    }, {\n      value: 0.75,\n      color: [92, 200, 99]\n    }, {\n      value: 0.88,\n      color: [170, 220, 50]\n    }, {\n      value: 1,\n      color: [253, 231, 37]\n    }]\n  }),\n  /**\n   * Classic inferno color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  INFERNO: new x({\n    stops: [{\n      value: 0,\n      color: [0, 0, 4]\n    }, {\n      value: 0.13,\n      color: [31, 12, 72]\n    }, {\n      value: 0.25,\n      color: [85, 15, 109]\n    }, {\n      value: 0.38,\n      color: [136, 34, 106]\n    }, {\n      value: 0.5,\n      color: [186, 54, 85]\n    }, {\n      value: 0.63,\n      color: [227, 89, 51]\n    }, {\n      value: 0.75,\n      color: [249, 140, 10]\n    }, {\n      value: 0.88,\n      color: [249, 201, 50]\n    }, {\n      value: 1,\n      color: [252, 255, 164]\n    }]\n  }),\n  /**\n   * Classic magma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  MAGMA: new x({\n    stops: [{\n      value: 0,\n      color: [0, 0, 4]\n    }, {\n      value: 0.13,\n      color: [28, 16, 68]\n    }, {\n      value: 0.25,\n      color: [79, 18, 123]\n    }, {\n      value: 0.38,\n      color: [129, 37, 129]\n    }, {\n      value: 0.5,\n      color: [181, 54, 122]\n    }, {\n      value: 0.63,\n      color: [229, 80, 100]\n    }, {\n      value: 0.75,\n      color: [251, 135, 97]\n    }, {\n      value: 0.88,\n      color: [254, 194, 135]\n    }, {\n      value: 1,\n      color: [252, 253, 191]\n    }]\n  }),\n  /**\n   * Classic plasma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PLASMA: new x({\n    stops: [{\n      value: 0,\n      color: [13, 8, 135]\n    }, {\n      value: 0.13,\n      color: [75, 3, 161]\n    }, {\n      value: 0.25,\n      color: [125, 3, 168]\n    }, {\n      value: 0.38,\n      color: [168, 34, 150]\n    }, {\n      value: 0.5,\n      color: [203, 70, 121]\n    }, {\n      value: 0.63,\n      color: [229, 107, 93]\n    }, {\n      value: 0.75,\n      color: [248, 148, 65]\n    }, {\n      value: 0.88,\n      color: [253, 195, 40]\n    }, {\n      value: 1,\n      color: [240, 249, 33]\n    }]\n  }),\n  /**\n   * Classic warm color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  WARM: new x({\n    stops: [{\n      value: 0,\n      color: [125, 0, 179]\n    }, {\n      value: 0.13,\n      color: [172, 0, 187]\n    }, {\n      value: 0.25,\n      color: [219, 0, 170]\n    }, {\n      value: 0.38,\n      color: [255, 0, 130]\n    }, {\n      value: 0.5,\n      color: [255, 63, 74]\n    }, {\n      value: 0.63,\n      color: [255, 123, 0]\n    }, {\n      value: 0.75,\n      color: [234, 176, 0]\n    }, {\n      value: 0.88,\n      color: [190, 228, 0]\n    }, {\n      value: 1,\n      color: [147, 255, 0]\n    }]\n  }),\n  /**\n   * Classic cool color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  COOL: new x({\n    stops: [{\n      value: 0,\n      color: [125, 0, 179]\n    }, {\n      value: 0.13,\n      color: [116, 0, 218]\n    }, {\n      value: 0.25,\n      color: [98, 74, 237]\n    }, {\n      value: 0.38,\n      color: [68, 146, 231]\n    }, {\n      value: 0.5,\n      color: [0, 204, 197]\n    }, {\n      value: 0.63,\n      color: [0, 247, 146]\n    }, {\n      value: 0.75,\n      color: [0, 255, 88]\n    }, {\n      value: 0.88,\n      color: [40, 255, 8]\n    }, {\n      value: 1,\n      color: [147, 255, 0]\n    }]\n  }),\n  /**\n   * Classic rainboz soft color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  RAINBOW_SOFT: new x({\n    stops: [{\n      value: 0,\n      color: [125, 0, 179]\n    }, {\n      value: 0.1,\n      color: [199, 0, 180]\n    }, {\n      value: 0.2,\n      color: [255, 0, 121]\n    }, {\n      value: 0.3,\n      color: [255, 108, 0]\n    }, {\n      value: 0.4,\n      color: [222, 194, 0]\n    }, {\n      value: 0.5,\n      color: [150, 255, 0]\n    }, {\n      value: 0.6,\n      color: [0, 255, 55]\n    }, {\n      value: 0.7,\n      color: [0, 246, 150]\n    }, {\n      value: 0.8,\n      color: [50, 167, 222]\n    }, {\n      value: 0.9,\n      color: [103, 51, 235]\n    }, {\n      value: 1,\n      color: [124, 0, 186]\n    }]\n  }),\n  /**\n   * Classic bathymetry color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  BATHYMETRY: new x({\n    stops: [{\n      value: 0,\n      color: [40, 26, 44]\n    }, {\n      value: 0.13,\n      color: [59, 49, 90]\n    }, {\n      value: 0.25,\n      color: [64, 76, 139]\n    }, {\n      value: 0.38,\n      color: [63, 110, 151]\n    }, {\n      value: 0.5,\n      color: [72, 142, 158]\n    }, {\n      value: 0.63,\n      color: [85, 174, 163]\n    }, {\n      value: 0.75,\n      color: [120, 206, 163]\n    }, {\n      value: 0.88,\n      color: [187, 230, 172]\n    }, {\n      value: 1,\n      color: [253, 254, 204]\n    }]\n  }),\n  /**\n   * Classic cdom color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CDOM: new x({\n    stops: [{\n      value: 0,\n      color: [47, 15, 62]\n    }, {\n      value: 0.13,\n      color: [87, 23, 86]\n    }, {\n      value: 0.25,\n      color: [130, 28, 99]\n    }, {\n      value: 0.38,\n      color: [171, 41, 96]\n    }, {\n      value: 0.5,\n      color: [206, 67, 86]\n    }, {\n      value: 0.63,\n      color: [230, 106, 84]\n    }, {\n      value: 0.75,\n      color: [242, 149, 103]\n    }, {\n      value: 0.88,\n      color: [249, 193, 135]\n    }, {\n      value: 1,\n      color: [254, 237, 176]\n    }]\n  }),\n  /**\n   * Classic chlorophyll color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CHLOROPHYLL: new x({\n    stops: [{\n      value: 0,\n      color: [18, 36, 20]\n    }, {\n      value: 0.13,\n      color: [25, 63, 41]\n    }, {\n      value: 0.25,\n      color: [24, 91, 59]\n    }, {\n      value: 0.38,\n      color: [13, 119, 72]\n    }, {\n      value: 0.5,\n      color: [18, 148, 80]\n    }, {\n      value: 0.63,\n      color: [80, 173, 89]\n    }, {\n      value: 0.75,\n      color: [132, 196, 122]\n    }, {\n      value: 0.88,\n      color: [175, 221, 162]\n    }, {\n      value: 1,\n      color: [215, 249, 208]\n    }]\n  }),\n  /**\n   * Classic density color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  DENSITY: new x({\n    stops: [{\n      value: 0,\n      color: [54, 14, 36]\n    }, {\n      value: 0.13,\n      color: [89, 23, 80]\n    }, {\n      value: 0.25,\n      color: [110, 45, 132]\n    }, {\n      value: 0.38,\n      color: [120, 77, 178]\n    }, {\n      value: 0.5,\n      color: [120, 113, 213]\n    }, {\n      value: 0.63,\n      color: [115, 151, 228]\n    }, {\n      value: 0.75,\n      color: [134, 185, 227]\n    }, {\n      value: 0.88,\n      color: [177, 214, 227]\n    }, {\n      value: 1,\n      color: [230, 241, 241]\n    }]\n  }),\n  /**\n   * Classic freesurface blue color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  FREESURFACE_BLUE: new x({\n    stops: [{\n      value: 0,\n      color: [30, 4, 110]\n    }, {\n      value: 0.13,\n      color: [47, 14, 176]\n    }, {\n      value: 0.25,\n      color: [41, 45, 236]\n    }, {\n      value: 0.38,\n      color: [25, 99, 212]\n    }, {\n      value: 0.5,\n      color: [68, 131, 200]\n    }, {\n      value: 0.63,\n      color: [114, 156, 197]\n    }, {\n      value: 0.75,\n      color: [157, 181, 203]\n    }, {\n      value: 0.88,\n      color: [200, 208, 216]\n    }, {\n      value: 1,\n      color: [241, 237, 236]\n    }]\n  }),\n  /**\n   * Classic freesurface red color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  FREESURFACE_RED: new x({\n    stops: [{\n      value: 0,\n      color: [60, 9, 18]\n    }, {\n      value: 0.13,\n      color: [100, 17, 27]\n    }, {\n      value: 0.25,\n      color: [142, 20, 29]\n    }, {\n      value: 0.38,\n      color: [177, 43, 27]\n    }, {\n      value: 0.5,\n      color: [192, 87, 63]\n    }, {\n      value: 0.63,\n      color: [205, 125, 105]\n    }, {\n      value: 0.75,\n      color: [216, 162, 148]\n    }, {\n      value: 0.88,\n      color: [227, 199, 193]\n    }, {\n      value: 1,\n      color: [241, 237, 236]\n    }]\n  }),\n  /**\n   * Classic oxygen color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  OXYGEN: new x({\n    stops: [{\n      value: 0,\n      color: [64, 5, 5]\n    }, {\n      value: 0.13,\n      color: [106, 6, 15]\n    }, {\n      value: 0.25,\n      color: [144, 26, 7]\n    }, {\n      value: 0.38,\n      color: [168, 64, 3]\n    }, {\n      value: 0.5,\n      color: [188, 100, 4]\n    }, {\n      value: 0.63,\n      color: [206, 136, 11]\n    }, {\n      value: 0.75,\n      color: [220, 174, 25]\n    }, {\n      value: 0.88,\n      color: [231, 215, 44]\n    }, {\n      value: 1,\n      color: [248, 254, 105]\n    }]\n  }),\n  /**\n   * Classic par color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PAR: new x({\n    stops: [{\n      value: 0,\n      color: [51, 20, 24]\n    }, {\n      value: 0.13,\n      color: [90, 32, 35]\n    }, {\n      value: 0.25,\n      color: [129, 44, 34]\n    }, {\n      value: 0.38,\n      color: [159, 68, 25]\n    }, {\n      value: 0.5,\n      color: [182, 99, 19]\n    }, {\n      value: 0.63,\n      color: [199, 134, 22]\n    }, {\n      value: 0.75,\n      color: [212, 171, 35]\n    }, {\n      value: 0.88,\n      color: [221, 210, 54]\n    }, {\n      value: 1,\n      color: [225, 253, 75]\n    }]\n  }),\n  /**\n   * Classic phase color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  PHASE: new x({\n    stops: [{\n      value: 0,\n      color: [145, 105, 18]\n    }, {\n      value: 0.13,\n      color: [184, 71, 38]\n    }, {\n      value: 0.25,\n      color: [186, 58, 115]\n    }, {\n      value: 0.38,\n      color: [160, 71, 185]\n    }, {\n      value: 0.5,\n      color: [110, 97, 218]\n    }, {\n      value: 0.63,\n      color: [50, 123, 164]\n    }, {\n      value: 0.75,\n      color: [31, 131, 110]\n    }, {\n      value: 0.88,\n      color: [77, 129, 34]\n    }, {\n      value: 1,\n      color: [145, 105, 18]\n    }]\n  }),\n  /**\n   * Classic salinity color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  SALINITY: new x({\n    stops: [{\n      value: 0,\n      color: [42, 24, 108]\n    }, {\n      value: 0.13,\n      color: [33, 50, 162]\n    }, {\n      value: 0.25,\n      color: [15, 90, 145]\n    }, {\n      value: 0.38,\n      color: [40, 118, 137]\n    }, {\n      value: 0.5,\n      color: [59, 146, 135]\n    }, {\n      value: 0.63,\n      color: [79, 175, 126]\n    }, {\n      value: 0.75,\n      color: [120, 203, 104]\n    }, {\n      value: 0.88,\n      color: [193, 221, 100]\n    }, {\n      value: 1,\n      color: [253, 239, 154]\n    }]\n  }),\n  /**\n   * Classic temperature color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  TEMPERATURE: new x({\n    stops: [{\n      value: 0,\n      color: [4, 35, 51]\n    }, {\n      value: 0.13,\n      color: [23, 51, 122]\n    }, {\n      value: 0.25,\n      color: [85, 59, 157]\n    }, {\n      value: 0.38,\n      color: [129, 79, 143]\n    }, {\n      value: 0.5,\n      color: [175, 95, 130]\n    }, {\n      value: 0.63,\n      color: [222, 112, 101]\n    }, {\n      value: 0.75,\n      color: [249, 146, 66]\n    }, {\n      value: 0.88,\n      color: [249, 196, 65]\n    }, {\n      value: 1,\n      color: [232, 250, 91]\n    }]\n  }),\n  /**\n   * Classic turbidity color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  TURBIDITY: new x({\n    stops: [{\n      value: 0,\n      color: [34, 31, 27]\n    }, {\n      value: 0.13,\n      color: [65, 50, 41]\n    }, {\n      value: 0.25,\n      color: [98, 69, 52]\n    }, {\n      value: 0.38,\n      color: [131, 89, 57]\n    }, {\n      value: 0.5,\n      color: [161, 112, 59]\n    }, {\n      value: 0.63,\n      color: [185, 140, 66]\n    }, {\n      value: 0.75,\n      color: [202, 174, 88]\n    }, {\n      value: 0.88,\n      color: [216, 209, 126]\n    }, {\n      value: 1,\n      color: [233, 246, 171]\n    }]\n  }),\n  /**\n   * Classic velocity blue color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VELOCITY_BLUE: new x({\n    stops: [{\n      value: 0,\n      color: [17, 32, 64]\n    }, {\n      value: 0.13,\n      color: [35, 52, 116]\n    }, {\n      value: 0.25,\n      color: [29, 81, 156]\n    }, {\n      value: 0.38,\n      color: [31, 113, 162]\n    }, {\n      value: 0.5,\n      color: [50, 144, 169]\n    }, {\n      value: 0.63,\n      color: [87, 173, 176]\n    }, {\n      value: 0.75,\n      color: [149, 196, 189]\n    }, {\n      value: 0.88,\n      color: [203, 221, 211]\n    }, {\n      value: 1,\n      color: [254, 251, 230]\n    }]\n  }),\n  /**\n   * Classic velocity green color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  VELOCITY_GREEN: new x({\n    stops: [{\n      value: 0,\n      color: [23, 35, 19]\n    }, {\n      value: 0.13,\n      color: [24, 64, 38]\n    }, {\n      value: 0.25,\n      color: [11, 95, 45]\n    }, {\n      value: 0.38,\n      color: [39, 123, 35]\n    }, {\n      value: 0.5,\n      color: [95, 146, 12]\n    }, {\n      value: 0.63,\n      color: [152, 165, 18]\n    }, {\n      value: 0.75,\n      color: [201, 186, 69]\n    }, {\n      value: 0.88,\n      color: [233, 216, 137]\n    }, {\n      value: 1,\n      color: [255, 253, 205]\n    }]\n  }),\n  /**\n   * Classic cube helix color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  CUBEHELIX: new x({\n    stops: [{\n      value: 0,\n      color: [0, 0, 0]\n    }, {\n      value: 0.07,\n      color: [22, 5, 59]\n    }, {\n      value: 0.13,\n      color: [60, 4, 105]\n    }, {\n      value: 0.2,\n      color: [109, 1, 135]\n    }, {\n      value: 0.27,\n      color: [161, 0, 147]\n    }, {\n      value: 0.33,\n      color: [210, 2, 142]\n    }, {\n      value: 0.4,\n      color: [251, 11, 123]\n    }, {\n      value: 0.47,\n      color: [255, 29, 97]\n    }, {\n      value: 0.53,\n      color: [255, 54, 69]\n    }, {\n      value: 0.6,\n      color: [255, 85, 46]\n    }, {\n      value: 0.67,\n      color: [255, 120, 34]\n    }, {\n      value: 0.73,\n      color: [255, 157, 37]\n    }, {\n      value: 0.8,\n      color: [241, 191, 57]\n    }, {\n      value: 0.87,\n      color: [224, 220, 93]\n    }, {\n      value: 0.93,\n      color: [218, 241, 142]\n    }, {\n      value: 1,\n      color: [227, 253, 198]\n    }]\n  }),\n  /**\n   * The cividis color ramp is color blind friendly.\n   * Read more here https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0199239\n   * Defined in interval [0, 1], without unit.\n   */\n  CIVIDIS: new x({\n    stops: [{\n      value: 0,\n      color: [0, 32, 77, 255]\n    }, {\n      value: 0.125,\n      color: [5, 54, 110, 255]\n    }, {\n      value: 0.25,\n      color: [65, 77, 108, 255]\n    }, {\n      value: 0.375,\n      color: [97, 100, 111, 255]\n    }, {\n      value: 0.5,\n      color: [125, 124, 121, 255]\n    }, {\n      value: 0.625,\n      color: [156, 149, 120, 255]\n    }, {\n      value: 0.75,\n      color: [190, 175, 111, 255]\n    }, {\n      value: 0.875,\n      color: [225, 204, 94, 255]\n    }, {\n      value: 1,\n      color: [255, 235, 70, 255]\n    }]\n  }),\n  /**\n   * Classic turbo color ramp.\n   * This is a luminance-constant alternative to the jet, making it more\n   * clor-blind friendly.\n   * Defined in interval [0, 1], without unit.\n   */\n  TURBO: new x({\n    stops: [{\n      value: 0,\n      color: [48, 18, 59, 255]\n    }, {\n      value: 0.125,\n      color: [70, 107, 227, 255]\n    }, {\n      value: 0.25,\n      color: [40, 187, 236, 255]\n    }, {\n      value: 0.375,\n      color: [49, 242, 153, 255]\n    }, {\n      value: 0.5,\n      color: [162, 252, 60, 255]\n    }, {\n      value: 0.625,\n      color: [237, 208, 58, 255]\n    }, {\n      value: 0.75,\n      color: [251, 128, 34, 255]\n    }, {\n      value: 0.875,\n      color: [210, 49, 5, 255]\n    }, {\n      value: 1,\n      color: [122, 4, 3, 255]\n    }]\n  }),\n  /**\n   * The rocket color ramp is perceptually uniform, which makes it more\n   * color bliend friendly than the classic magma color ramp.\n   * Defined in interval [0, 1], without unit.\n   */\n  ROCKET: new x({\n    stops: [{\n      value: 0,\n      color: [250, 235, 221, 0]\n    }, {\n      value: 0.133,\n      color: [250, 235, 221, 255]\n    }, {\n      value: 0.266,\n      color: [246, 170, 130, 255]\n    }, {\n      value: 0.4,\n      color: [240, 96, 67, 255]\n    }, {\n      value: 0.533,\n      color: [203, 27, 79, 255]\n    }, {\n      value: 0.666,\n      color: [132, 30, 90, 255]\n    }, {\n      value: 0.8,\n      color: [63, 27, 68, 255]\n    }, {\n      value: 1,\n      color: [3, 5, 26, 255]\n    }]\n  }),\n  /**\n   * The mako color ramp is perceptually uniform and can be seen as\n   * a color blind friendly alternative to bathymetry or yignbu.\n   * Defined in interval [0, 1], without unit.\n   */\n  MAKO: new x({\n    stops: [{\n      value: 0,\n      color: [11, 4, 5, 255]\n    }, {\n      value: 0.125,\n      color: [43, 28, 53, 255]\n    }, {\n      value: 0.25,\n      color: [62, 53, 107, 255]\n    }, {\n      value: 0.375,\n      color: [59, 86, 152, 255]\n    }, {\n      value: 0.5,\n      color: [53, 123, 162, 255]\n    }, {\n      value: 0.625,\n      color: [53, 158, 170, 255]\n    }, {\n      value: 0.75,\n      color: [73, 193, 173, 255]\n    }, {\n      value: 0.875,\n      color: [150, 221, 181, 255]\n    }, {\n      value: 1,\n      color: [222, 245, 229, 255]\n    }]\n  })\n};\nasync function al(r, e, t = {}) {\n  var a, o;\n  if (!e.sourceId && !e.data) throw new Error(\"Creating a polyline layer requires an existing .sourceId or a valid .data property\");\n  let n = e.data;\n  if (typeof n == \"string\") {\n    if (vt(n)) n = `https://api.maptiler.com/data/${e.data}/features.json?key=${O.apiKey}`;else if (((a = n.split(\".\").pop()) == null ? void 0 : a.toLowerCase().trim()) === \"gpx\") {\n      const s = await (await fetch(n, t)).text();\n      n = ca(s);\n    } else if (((o = n.split(\".\").pop()) == null ? void 0 : o.toLowerCase().trim()) === \"kml\") {\n      const s = await (await fetch(n, t)).text();\n      n = pa(s);\n    } else {\n      const i = Ja(n) ?? el(n);\n      i && (n = i);\n    }\n    if (!n) throw new Error(\"Polyline data was provided as string but is incompatible with valid formats.\");\n  }\n  return ol(r, {\n    ...e,\n    data: n\n  });\n}\nfunction ol(r, e) {\n  if (e.layerId && r.getLayer(e.layerId)) throw new Error(`A layer already exists with the layer id: ${e.layerId}`);\n  const t = e.sourceId ?? et(),\n    n = e.layerId ?? tt(),\n    a = {\n      polylineLayerId: n,\n      polylineOutlineLayerId: \"\",\n      polylineSourceId: t\n    };\n  e.data && !r.getSource(t) && r.addSource(t, {\n    type: \"geojson\",\n    data: e.data\n  });\n  const o = e.lineWidth ?? 3,\n    i = e.lineColor ?? Pt(),\n    s = e.lineOpacity ?? 1,\n    l = e.lineBlur ?? 0,\n    u = e.lineGapWidth ?? 0;\n  let c = e.lineDashArray ?? null;\n  const p = e.outlineWidth ?? 1,\n    m = e.outlineColor ?? \"#FFFFFF\",\n    f = e.outlineOpacity ?? 1,\n    d = e.outlineBlur ?? 0;\n  if (typeof c == \"string\" && (c = $r(c)), e.outline === !0) {\n    const y = `${n}_outline`;\n    a.polylineOutlineLayerId = y, r.addLayer({\n      id: y,\n      type: \"line\",\n      source: t,\n      layout: {\n        \"line-join\": e.lineJoin ?? \"round\",\n        \"line-cap\": e.lineCap ?? \"round\"\n      },\n      minzoom: e.minzoom ?? 0,\n      maxzoom: e.maxzoom ?? 23,\n      paint: {\n        \"line-opacity\": typeof f == \"number\" ? f : z(f),\n        \"line-color\": typeof m == \"string\" ? m : be(m),\n        \"line-width\": ga(o, p),\n        \"line-blur\": typeof d == \"number\" ? d : z(d)\n      }\n    }, e.beforeId);\n  }\n  return r.addLayer({\n    id: n,\n    type: \"line\",\n    source: t,\n    layout: {\n      \"line-join\": e.lineJoin ?? \"round\",\n      \"line-cap\": e.lineCap ?? \"round\"\n    },\n    minzoom: e.minzoom ?? 0,\n    maxzoom: e.maxzoom ?? 23,\n    paint: {\n      \"line-opacity\": typeof s == \"number\" ? s : z(s),\n      \"line-color\": typeof i == \"string\" ? i : be(i),\n      \"line-width\": typeof o == \"number\" ? o : z(o),\n      \"line-blur\": typeof l == \"number\" ? l : z(l),\n      \"line-gap-width\": typeof u == \"number\" ? u : z(u),\n      // For some reasons passing \"line-dasharray\" with the value \"undefined\"\n      // results in no showing the line while it should have the same behavior\n      // of not adding the property \"line-dasharray\" as all.\n      // As a workaround, we are inlining the addition of the prop with a conditional\n      // which is less readable.\n      ...(c && {\n        \"line-dasharray\": c\n      })\n    }\n  }, e.beforeId), a;\n}\nfunction il(r, e) {\n  if (e.layerId && r.getLayer(e.layerId)) throw new Error(`A layer already exists with the layer id: ${e.layerId}`);\n  const t = e.sourceId ?? et(),\n    n = e.layerId ?? tt(),\n    a = {\n      polygonLayerId: n,\n      polygonOutlineLayerId: e.outline ? `${n}_outline` : \"\",\n      polygonSourceId: t\n    };\n  if (e.data && !r.getSource(t)) {\n    let y = e.data;\n    typeof y == \"string\" && vt(y) && (y = `https://api.maptiler.com/data/${y}/features.json?key=${O.apiKey}`), r.addSource(t, {\n      type: \"geojson\",\n      data: y\n    });\n  }\n  let o = e.outlineDashArray ?? null;\n  const i = e.outlineWidth ?? 1,\n    s = e.outlineColor ?? \"#FFFFFF\",\n    l = e.outlineOpacity ?? 1,\n    u = e.outlineBlur ?? 0,\n    c = e.fillColor ?? Pt(),\n    p = e.fillOpacity ?? 1,\n    m = e.outlinePosition ?? \"center\",\n    f = e.pattern ?? null;\n  typeof o == \"string\" && (o = $r(o));\n  const d = (y = null) => {\n    if (r.addLayer({\n      id: n,\n      type: \"fill\",\n      source: t,\n      minzoom: e.minzoom ?? 0,\n      maxzoom: e.maxzoom ?? 23,\n      paint: {\n        \"fill-color\": typeof c == \"string\" ? c : be(c),\n        \"fill-opacity\": typeof p == \"number\" ? p : z(p),\n        // Adding a pattern if provided\n        ...(y && {\n          \"fill-pattern\": y\n        })\n      }\n    }, e.beforeId), e.outline === !0) {\n      let v;\n      m === \"inside\" ? typeof i == \"number\" ? v = 0.5 * i : v = z(i.map(({\n        zoom: w,\n        value: b\n      }) => ({\n        zoom: w,\n        value: 0.5 * b\n      }))) : m === \"outside\" ? typeof i == \"number\" ? v = -0.5 * i : v = z(i.map(w => ({\n        zoom: w.zoom,\n        value: -0.5 * w.value\n      }))) : v = 0, r.addLayer({\n        id: a.polygonOutlineLayerId,\n        type: \"line\",\n        source: t,\n        layout: {\n          \"line-join\": e.outlineJoin ?? \"round\",\n          \"line-cap\": e.outlineCap ?? \"butt\"\n        },\n        minzoom: e.minzoom ?? 0,\n        maxzoom: e.maxzoom ?? 23,\n        paint: {\n          \"line-opacity\": typeof l == \"number\" ? l : z(l),\n          \"line-color\": typeof s == \"string\" ? s : be(s),\n          \"line-width\": typeof i == \"number\" ? i : z(i),\n          \"line-blur\": typeof u == \"number\" ? u : z(u),\n          \"line-offset\": v,\n          // For some reasons passing \"line-dasharray\" with the value \"undefined\"\n          // results in no showing the line while it should have the same behavior\n          // of not adding the property \"line-dasharray\" as all.\n          // As a workaround, we are inlining the addition of the prop with a conditional\n          // which is less readable.\n          ...(o && {\n            \"line-dasharray\": o\n          })\n        }\n      }, e.beforeId);\n    }\n  };\n  return f ? r.hasImage(f) ? d(f) : r.loadImage(f).then(y => {\n    r.addImage(f, y.data), d(f);\n  }).catch(y => {\n    console.error(\"Could not load the pattern image.\", y.message), d();\n  }) : d(), a;\n}\nfunction sl(r, e) {\n  if (e.layerId && r.getLayer(e.layerId)) throw new Error(`A layer already exists with the layer id: ${e.layerId}`);\n  const t = e.minPointRadius ?? 10,\n    n = e.maxPointRadius ?? 50,\n    a = e.cluster ?? !1,\n    o = 20,\n    i = Array.isArray(e.pointColor) ? e.pointColor : Sa.TURBO.scale(10, e.cluster ? 1e4 : 1e3).resample(\"ease-out-square\"),\n    s = i.getBounds(),\n    l = e.sourceId ?? et(),\n    u = e.layerId ?? tt(),\n    c = e.showLabel ?? a,\n    p = e.alignOnViewport ?? !0,\n    m = e.outline ?? !1,\n    f = e.outlineOpacity ?? 1,\n    d = e.outlineWidth ?? 1,\n    y = e.outlineColor ?? \"#FFFFFF\";\n  let v;\n  const w = e.zoomCompensation ?? !0,\n    b = e.minzoom ?? 0,\n    T = e.maxzoom ?? 23;\n  typeof e.pointOpacity == \"number\" ? v = e.pointOpacity : Array.isArray(e.pointOpacity) ? v = z(e.pointOpacity) : e.cluster ? v = lr(i, \"point_count\") : e.property ? v = lr(i, e.property) : v = z([{\n    zoom: b,\n    value: 0\n  }, {\n    zoom: b + 0.25,\n    value: 1\n  }, {\n    zoom: T - 0.25,\n    value: 1\n  }, {\n    zoom: T,\n    value: 0\n  }]);\n  const j = {\n    pointLayerId: u,\n    clusterLayerId: \"\",\n    labelLayerId: \"\",\n    pointSourceId: l\n  };\n  if (e.data && !r.getSource(l)) {\n    let R = e.data;\n    typeof R == \"string\" && vt(R) && (R = `https://api.maptiler.com/data/${R}/features.json?key=${O.apiKey}`), r.addSource(l, {\n      type: \"geojson\",\n      data: R,\n      cluster: a\n    });\n  }\n  if (a) {\n    j.clusterLayerId = `${u}_cluster`;\n    const R = Array.from({\n      length: o\n    }, (ae, Se) => {\n      const De = s.min + Se * (s.max - s.min) / (o - 1);\n      return {\n        value: De,\n        pointRadius: t + (n - t) * (Se / (o - 1)) ** 0.5,\n        color: i.getColorHex(De)\n      };\n    });\n    r.addLayer({\n      id: j.clusterLayerId,\n      type: \"circle\",\n      source: l,\n      filter: [\"has\", \"point_count\"],\n      paint: {\n        // 'circle-color': options.pointColor ?? colorDrivenByProperty(clusterStyle, \"point_count\"),\n        \"circle-color\": typeof e.pointColor == \"string\" ? e.pointColor : ir(R, \"point_count\"),\n        \"circle-radius\": typeof e.pointRadius == \"number\" ? e.pointRadius : Array.isArray(e.pointRadius) ? z(e.pointRadius) : sr(R, \"point_count\", !1),\n        \"circle-pitch-alignment\": p ? \"viewport\" : \"map\",\n        \"circle-pitch-scale\": \"map\",\n        // scale with camera distance regardless of viewport/biewport alignement\n        \"circle-opacity\": v,\n        ...(m && {\n          \"circle-stroke-opacity\": typeof f == \"number\" ? f : z(f),\n          \"circle-stroke-width\": typeof d == \"number\" ? d : z(d),\n          \"circle-stroke-color\": typeof y == \"string\" ? y : be(y)\n        })\n      },\n      minzoom: b,\n      maxzoom: T\n    }, e.beforeId), r.addLayer({\n      id: j.pointLayerId,\n      type: \"circle\",\n      source: l,\n      filter: [\"!\", [\"has\", \"point_count\"]],\n      paint: {\n        \"circle-pitch-alignment\": p ? \"viewport\" : \"map\",\n        \"circle-pitch-scale\": \"map\",\n        // scale with camera distance regardless of viewport/biewport alignement\n        // 'circle-color':  options.pointColor ?? clusterStyle[0].color,\n        \"circle-color\": typeof e.pointColor == \"string\" ? e.pointColor : i.getColorHex(i.getBounds().min),\n        \"circle-radius\": typeof e.pointRadius == \"number\" ? e.pointRadius : Array.isArray(e.pointRadius) ? z(e.pointRadius) : R[0].pointRadius * 0.75,\n        \"circle-opacity\": v,\n        ...(m && {\n          \"circle-stroke-opacity\": typeof f == \"number\" ? f : z(f),\n          \"circle-stroke-width\": typeof d == \"number\" ? d : z(d),\n          \"circle-stroke-color\": typeof y == \"string\" ? y : be(y)\n        })\n      },\n      minzoom: b,\n      maxzoom: T\n    }, e.beforeId);\n  } else {\n    let R = typeof e.pointColor == \"string\" ? e.pointColor : Array.isArray(e.pointColor) ? e.pointColor.getColorHex(e.pointColor.getBounds().min) : Pt(),\n      ae = typeof e.pointRadius == \"number\" ? w ? z([{\n        zoom: 0,\n        value: e.pointRadius * 0.025\n      }, {\n        zoom: 2,\n        value: e.pointRadius * 0.05\n      }, {\n        zoom: 4,\n        value: e.pointRadius * 0.1\n      }, {\n        zoom: 8,\n        value: e.pointRadius * 0.25\n      }, {\n        zoom: 16,\n        value: e.pointRadius * 1\n      }]) : e.pointRadius : Array.isArray(e.pointRadius) ? z(e.pointRadius) : w ? z([{\n        zoom: 0,\n        value: t * 0.05\n      }, {\n        zoom: 2,\n        value: t * 0.1\n      }, {\n        zoom: 4,\n        value: t * 0.2\n      }, {\n        zoom: 8,\n        value: t * 0.5\n      }, {\n        zoom: 16,\n        value: t * 1\n      }]) : t;\n    if (e.property && Array.isArray(e.pointColor)) {\n      const Se = Array.from({\n        length: o\n      }, (De, rt) => {\n        const nt = s.min + rt * (s.max - s.min) / (o - 1);\n        return {\n          value: nt,\n          pointRadius: typeof e.pointRadius == \"number\" ? e.pointRadius : t + (n - t) * (rt / (o - 1)) ** 0.5,\n          color: typeof e.pointColor == \"string\" ? e.pointColor : i.getColorHex(nt)\n        };\n      });\n      R = ir(Se, e.property), ae = sr(Se, e.property, w);\n    }\n    r.addLayer({\n      id: j.pointLayerId,\n      type: \"circle\",\n      source: l,\n      layout: {\n        // Contrary to labels, we want to see the small one in front. Weirdly \"circle-sort-key\" works in the opposite direction as \"symbol-sort-key\".\n        \"circle-sort-key\": e.property ? [\"/\", 1, [\"get\", e.property]] : 0\n      },\n      paint: {\n        \"circle-pitch-alignment\": p ? \"viewport\" : \"map\",\n        \"circle-pitch-scale\": \"map\",\n        // scale with camera distance regardless of viewport/biewport alignement\n        \"circle-color\": R,\n        \"circle-opacity\": v,\n        \"circle-radius\": ae,\n        ...(m && {\n          \"circle-stroke-opacity\": typeof f == \"number\" ? f : z(f),\n          \"circle-stroke-width\": typeof d == \"number\" ? d : z(d),\n          \"circle-stroke-color\": typeof y == \"string\" ? y : be(y)\n        })\n      },\n      minzoom: b,\n      maxzoom: T\n    }, e.beforeId);\n  }\n  if (c !== !1 && (e.cluster || e.property)) {\n    j.labelLayerId = `${u}_label`;\n    const R = e.labelColor ?? \"#fff\",\n      ae = e.labelSize ?? 12;\n    r.addLayer({\n      id: j.labelLayerId,\n      type: \"symbol\",\n      source: l,\n      filter: [\"has\", e.cluster ? \"point_count\" : e.property],\n      layout: {\n        \"text-field\": e.cluster ? \"{point_count_abbreviated}\" : `{${e.property}}`,\n        \"text-font\": [\"Noto Sans Regular\"],\n        \"text-size\": ae,\n        \"text-pitch-alignment\": p ? \"viewport\" : \"map\",\n        \"symbol-sort-key\": [\"/\", 1, [\"get\", e.cluster ? \"point_count\" : e.property]]\n        // so that the largest value goes on top\n      },\n      paint: {\n        \"text-color\": R,\n        \"text-opacity\": v\n      },\n      minzoom: b,\n      maxzoom: T\n    }, e.beforeId);\n  }\n  return j;\n}\nfunction ll(r, e) {\n  if (e.layerId && r.getLayer(e.layerId)) throw new Error(`A layer already exists with the layer id: ${e.layerId}`);\n  const t = e.sourceId ?? et(),\n    n = e.layerId ?? tt(),\n    a = e.minzoom ?? 0,\n    o = e.maxzoom ?? 23,\n    i = e.zoomCompensation ?? !0,\n    s = e.opacity ?? [{\n      zoom: a,\n      value: 0\n    }, {\n      zoom: a + 0.25,\n      value: 1\n    }, {\n      zoom: o - 0.25,\n      value: 1\n    }, {\n      zoom: o,\n      value: 0\n    }];\n  let l = Array.isArray(e.colorRamp) ? e.colorRamp : Sa.TURBO.transparentStart();\n  const u = l.getBounds();\n  (u.min !== 0 || u.max !== 1) && (l = l.scale(0, 1)), l.hasTransparentStart() || (l = l.transparentStart());\n  const c = e.intensity ?? [{\n      zoom: 0,\n      value: 0.01\n    }, {\n      zoom: 4,\n      value: 0.2\n    }, {\n      zoom: 16,\n      value: 1\n    }],\n    p = e.property ?? null,\n    m = e.weight ?? 1;\n  let f = 1;\n  p ? typeof m == \"number\" ? (f = m, typeof e.weight == \"number\" && console.warn(\"The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`\")) : Array.isArray(m) ? f = va(m, p) : console.warn(\"The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`\") : typeof m == \"number\" ? f = m : Array.isArray(m) && console.warn(\"The options `.propertyValueWeights` can only be used when `.property` is provided.\");\n  const d = [{\n      zoom: 0,\n      value: 50 * 0.025\n    }, {\n      zoom: 2,\n      value: 50 * 0.05\n    }, {\n      zoom: 4,\n      value: 50 * 0.1\n    }, {\n      zoom: 8,\n      value: 50 * 0.25\n    }, {\n      zoom: 16,\n      value: 50\n    }],\n    y = e.radius ?? (i ? d : 10);\n  let v = 1;\n  typeof y == \"number\" ? v = y : Array.isArray(y) && \"zoom\" in y[0] ? v = z(y) : p && Array.isArray(y) && \"propertyValue\" in y[0] ? v = ba(y, p, i) : !p && Array.isArray(y) && \"propertyValue\" in y[0] ? (v = z(d), console.warn(\"The option `.radius` can only be property-driven if the option `.property` is provided.\")) : v = z(d);\n  const w = {\n    heatmapLayerId: n,\n    heatmapSourceId: t\n  };\n  if (e.data && !r.getSource(t)) {\n    let b = e.data;\n    typeof b == \"string\" && vt(b) && (b = `https://api.maptiler.com/data/${b}/features.json?key=${O.apiKey}`), r.addSource(t, {\n      type: \"geojson\",\n      data: b\n    });\n  }\n  return r.addLayer({\n    id: n,\n    type: \"heatmap\",\n    source: t,\n    minzoom: a,\n    maxzoom: o,\n    paint: {\n      \"heatmap-weight\": f,\n      \"heatmap-intensity\": typeof c == \"number\" ? c : z(c),\n      \"heatmap-color\": wa(l),\n      \"heatmap-radius\": v,\n      \"heatmap-opacity\": typeof s == \"number\" ? s : z(s)\n    }\n  }, e.beforeId), w;\n}\nconst Nl = /* @__PURE__ */Object.freeze(/* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  addHeatmap: ll,\n  addPoint: sl,\n  addPolygon: il,\n  addPolyline: al,\n  colorDrivenByProperty: ir,\n  colorPalettes: ar,\n  computeRampedOutlineWidth: ga,\n  dashArrayMaker: $r,\n  generateRandomLayerName: tt,\n  generateRandomSourceName: et,\n  getRandomColor: Pt,\n  heatmapIntensityFromColorRamp: wa,\n  lerpZoomNumberValues: or,\n  opacityDrivenByProperty: lr,\n  paintColorOptionsToPaintSpec: be,\n  radiusDrivenByProperty: sr,\n  radiusDrivenByPropertyHeatmap: ba,\n  rampedOptionsToLayerPaintSpec: z,\n  rampedPropertyValueWeight: va,\n  takeScreenshot: tl\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nWa();\nfunction Ol() {\n  return \"3.0.3\";\n}\nconst Fl = S.Map,\n  Dl = S.Marker,\n  ql = S.Popup,\n  Bl = S.Style,\n  Ul = S.CanvasSource,\n  Vl = S.GeoJSONSource,\n  Gl = S.ImageSource,\n  Hl = S.RasterTileSource,\n  Kl = S.RasterDEMTileSource,\n  Wl = S.VectorTileSource,\n  Zl = S.VideoSource,\n  Jl = S.NavigationControl,\n  Yl = S.GeolocateControl,\n  Xl = S.AttributionControl,\n  Ql = S.LogoControl,\n  eu = S.ScaleControl,\n  tu = S.FullscreenControl,\n  ru = S.TerrainControl,\n  nu = S.BoxZoomHandler,\n  au = S.ScrollZoomHandler,\n  ou = S.CooperativeGesturesHandler,\n  iu = S.KeyboardHandler,\n  su = S.TwoFingersTouchPitchHandler,\n  lu = S.MapWheelEvent,\n  uu = S.MapTouchEvent,\n  cu = S.MapMouseEvent,\n  pu = S.config,\n  fu = S.getVersion,\n  {\n    setRTLTextPlugin: du,\n    getRTLTextPluginStatus: yu,\n    LngLat: mu,\n    LngLatBounds: hu,\n    MercatorCoordinate: gu,\n    Evented: vu,\n    AJAXError: bu,\n    prewarm: wu,\n    clearPrewarmedResources: Su,\n    Hash: xu,\n    Point: ku,\n    EdgeInsets: Lu,\n    DragRotateHandler: Cu,\n    DragPanHandler: Au,\n    TwoFingersTouchZoomRotateHandler: Tu,\n    DoubleClickZoomHandler: Iu,\n    TwoFingersTouchZoomHandler: Eu,\n    TwoFingersTouchRotateHandler: Mu,\n    getWorkerCount: _u,\n    setWorkerCount: zu,\n    getMaxParallelImageRequests: Pu,\n    setMaxParallelImageRequests: Ru,\n    getWorkerUrl: $u,\n    setWorkerUrl: ju,\n    addSourceType: Nu,\n    importScriptInWorkers: Ou,\n    addProtocol: Fu,\n    removeProtocol: Du\n  } = S;\nexport { bu as AJAXError, Tl as AttributionControl, Xl as AttributionControlMLGL, El as BoxZoomHandler, nu as BoxZoomHandlerMLGL, wl as CanvasSource, Ul as CanvasSourceMLGL, x as ColorRamp, Sa as ColorRampCollection, _l as CooperativeGesturesHandler, ou as CooperativeGesturesHandlerMLGL, fe as DOMcreate, _r as DOMremove, Iu as DoubleClickZoomHandler, Au as DragPanHandler, Cu as DragRotateHandler, Lu as EdgeInsets, vu as Evented, co as FullscreenControl, tu as FullscreenControlMLGL, Sl as GeoJSONSource, Vl as GeoJSONSourceMLGL, so as GeolocateControl, Yl as GeolocateControlMLGL, Hs as GeolocationType, xu as Hash, xl as ImageSource, Gl as ImageSourceMLGL, zl as KeyboardHandler, iu as KeyboardHandlerMLGL, M as Language, mu as LngLat, hu as LngLatBounds, lo as LogoControl, Ql as LogoControlMLGL, zr as Map, Fl as MapMLGL, jl as MapMouseEvent, cu as MapMouseEventMLGL, Uu as MapStyle, Vu as MapStyleVariant, $l as MapTouchEvent, uu as MapTouchEventMLGL, Rl as MapWheelEvent, lu as MapWheelEventMLGL, As as MaptilerGeolocateControl, Hr as MaptilerLogoControl, Ls as MaptilerNavigationControl, Ts as MaptilerProjectionControl, ks as MaptilerTerrainControl, hl as Marker, Dl as MarkerMLGL, gu as MercatorCoordinate, Jl as NavigationControMLGL, io as NavigationControl, ku as Point, vl as Popup, ql as PopupMLGL, Ll as RasterDEMTileSource, Kl as RasterDEMTileSourceMLGL, kl as RasterTileSource, Hl as RasterTileSourceMLGL, Gu as ReferenceMapStyle, uo as ScaleControl, eu as ScaleControlMLGL, Ml as ScrollZoomHandler, au as ScrollZoomHandlerMLGL, qa as SdkConfig, Hu as ServiceError, bl as Style, Bl as StyleMLGL, ru as TerrainControMLGL, Il as TerrainControl, Pl as TwoFingersTouchPitchHandler, su as TwoFingersTouchPitchHandlerMLGL, Mu as TwoFingersTouchRotateHandler, Eu as TwoFingersTouchZoomHandler, Tu as TwoFingersTouchZoomRotateHandler, Cl as VectorTileSource, Wl as VectorTileSourceMLGL, Al as VideoSource, Zl as VideoSourceMLGL, Fu as addProtocol, Nu as addSourceType, Ku as areSameLanguages, Wu as bufferToPixelDataBrowser, Zu as circumferenceAtLatitude, Su as clearPrewarmedResources, O as config, pu as configMLGL, Ju as coordinates, Yu as data, ml as displayWebGLContextLostWarning, Xu as elevation, Qu as expandMapStyle, ec as geocoding, tc as geolocation, rc as getAutoLanguage, qr as getBrowserLanguage, nc as getBufferToPixelDataParser, ac as getLanguageInfoFromCode, oc as getLanguageInfoFromFlag, ic as getLanguageInfoFromKey, fu as getMapLibreVersion, Pu as getMaxParallelImageRequests, yu as getRTLTextPluginStatus, sc as getTileCache, Ol as getVersion, Ya as getWebGLSupportError, _u as getWorkerCount, $u as getWorkerUrl, ca as gpx, el as gpxOrKml, ua as hasChildNodeWithName, Nl as helpers, Ou as importScriptInWorkers, lc as isLanguageInfo, pa as kml, uc as mapStylePresetList, cc as math, pc as misc, wu as prewarm, Du as removeProtocol, Ru as setMaxParallelImageRequests, du as setRTLTextPlugin, zu as setWorkerCount, ju as setWorkerUrl, fc as staticMaps, Pr as str2xml, dc as styleToStyle, yc as toLanguageInfo, gn as xml2str };","map":null,"metadata":{},"sourceType":"module"}