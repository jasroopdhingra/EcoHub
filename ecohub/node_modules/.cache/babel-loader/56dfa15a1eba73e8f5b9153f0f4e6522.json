{"ast":null,"code":"/* Mapbox GL JS is Copyright Â© 2020 Mapbox and subject to the Mapbox Terms of Service ((https://www.mapbox.com/legal/tos/). */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.mapboxgl = factory());\n})(this, function () {\n  'use strict';\n\n  /* eslint-disable */\n  var shared, worker, mapboxgl;\n  // define gets called three times: one for each chunk. we rely on the order\n  // they're imported to know which is which\n  function define(_, chunk) {\n    if (!shared) {\n      shared = chunk;\n    } else if (!worker) {\n      worker = chunk;\n    } else {\n      var workerBundleString = \"self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (\" + shared + \")(sharedChunk); (\" + worker + \")(sharedChunk); self.onerror = null;\";\n      var sharedChunk = {};\n      shared(sharedChunk);\n      mapboxgl = chunk(sharedChunk);\n      if (typeof window !== 'undefined' && window && window.URL && window.URL.createObjectURL) {\n        mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], {\n          type: 'text/javascript'\n        }));\n      }\n    }\n  }\n  define([\"exports\"], function (t) {\n    function e(t) {\n      return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, \"default\") ? t.default : t;\n    }\n    var r,\n      n = {},\n      i = {};\n    function s() {\n      if (r) return i;\n      r = 1, Object.defineProperty(i, \"__esModule\", {\n        value: !0\n      }), i.setMatrixArrayType = function (t) {\n        i.ARRAY_TYPE = e = t;\n      }, i.toRadian = function (t) {\n        return t * s;\n      }, i.equals = function (e, r) {\n        return Math.abs(e - r) <= t * Math.max(1, Math.abs(e), Math.abs(r));\n      }, i.RANDOM = i.ARRAY_TYPE = i.EPSILON = void 0;\n      var t = 1e-6;\n      i.EPSILON = t;\n      var e = \"undefined\" != typeof Float32Array ? Float32Array : Array;\n      i.ARRAY_TYPE = e;\n      var n = Math.random;\n      i.RANDOM = n;\n      var s = Math.PI / 180;\n      return Math.hypot || (Math.hypot = function () {\n        for (var t = 0, e = arguments.length; e--;) t += arguments[e] * arguments[e];\n        return Math.sqrt(t);\n      }), i;\n    }\n    var a,\n      o = {};\n    function l() {\n      if (a) return o;\n      function t(e) {\n        return t = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n          return typeof t;\n        } : function (t) {\n          return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n        }, t(e);\n      }\n      a = 1, Object.defineProperty(o, \"__esModule\", {\n        value: !0\n      }), o.create = function () {\n        var t = new e.ARRAY_TYPE(4);\n        return e.ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0), t[0] = 1, t[3] = 1, t;\n      }, o.clone = function (t) {\n        var r = new e.ARRAY_TYPE(4);\n        return r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r;\n      }, o.copy = function (t, e) {\n        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;\n      }, o.identity = function (t) {\n        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t;\n      }, o.fromValues = function (t, r, n, i) {\n        var s = new e.ARRAY_TYPE(4);\n        return s[0] = t, s[1] = r, s[2] = n, s[3] = i, s;\n      }, o.set = function (t, e, r, n, i) {\n        return t[0] = e, t[1] = r, t[2] = n, t[3] = i, t;\n      }, o.transpose = function (t, e) {\n        if (t === e) {\n          var r = e[1];\n          t[1] = e[2], t[2] = r;\n        } else t[0] = e[0], t[1] = e[2], t[2] = e[1], t[3] = e[3];\n        return t;\n      }, o.invert = function (t, e) {\n        var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = e[3],\n          a = r * s - i * n;\n        return a ? (t[0] = s * (a = 1 / a), t[1] = -n * a, t[2] = -i * a, t[3] = r * a, t) : null;\n      }, o.adjoint = function (t, e) {\n        var r = e[0];\n        return t[0] = e[3], t[1] = -e[1], t[2] = -e[2], t[3] = r, t;\n      }, o.determinant = function (t) {\n        return t[0] * t[3] - t[2] * t[1];\n      }, o.multiply = n, o.rotate = function (t, e, r) {\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = Math.sin(r),\n          l = Math.cos(r);\n        return t[0] = n * l + s * o, t[1] = i * l + a * o, t[2] = n * -o + s * l, t[3] = i * -o + a * l, t;\n      }, o.scale = function (t, e, r) {\n        var n = e[1],\n          i = e[2],\n          s = e[3],\n          a = r[0],\n          o = r[1];\n        return t[0] = e[0] * a, t[1] = n * a, t[2] = i * o, t[3] = s * o, t;\n      }, o.fromRotation = function (t, e) {\n        var r = Math.sin(e),\n          n = Math.cos(e);\n        return t[0] = n, t[1] = r, t[2] = -r, t[3] = n, t;\n      }, o.fromScaling = function (t, e) {\n        return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = e[1], t;\n      }, o.str = function (t) {\n        return \"mat2(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \")\";\n      }, o.frob = function (t) {\n        return Math.hypot(t[0], t[1], t[2], t[3]);\n      }, o.LDU = function (t, e, r, n) {\n        return t[2] = n[2] / n[0], r[0] = n[0], r[1] = n[1], r[3] = n[3] - t[2] * r[1], [t, e, r];\n      }, o.add = function (t, e, r) {\n        return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t[3] = e[3] + r[3], t;\n      }, o.subtract = i, o.exactEquals = function (t, e) {\n        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3];\n      }, o.equals = function (t, r) {\n        var n = t[0],\n          i = t[1],\n          s = t[2],\n          a = t[3],\n          o = r[0],\n          l = r[1],\n          u = r[2],\n          c = r[3];\n        return Math.abs(n - o) <= e.EPSILON * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(i - l) <= e.EPSILON * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(s - u) <= e.EPSILON * Math.max(1, Math.abs(s), Math.abs(u)) && Math.abs(a - c) <= e.EPSILON * Math.max(1, Math.abs(a), Math.abs(c));\n      }, o.multiplyScalar = function (t, e, r) {\n        return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t;\n      }, o.multiplyScalarAndAdd = function (t, e, r, n) {\n        return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t[2] = e[2] + r[2] * n, t[3] = e[3] + r[3] * n, t;\n      }, o.sub = o.mul = void 0;\n      var e = function (e, n) {\n        if (e && e.__esModule) return e;\n        if (null === e || \"object\" !== t(e) && \"function\" != typeof e) return {\n          default: e\n        };\n        var i = r(void 0);\n        if (i && i.has(e)) return i.get(e);\n        var s = {},\n          a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (var o in e) if (\"default\" !== o && Object.prototype.hasOwnProperty.call(e, o)) {\n          var l = a ? Object.getOwnPropertyDescriptor(e, o) : null;\n          l && (l.get || l.set) ? Object.defineProperty(s, o, l) : s[o] = e[o];\n        }\n        return s.default = e, i && i.set(e, s), s;\n      }(s());\n      function r(t) {\n        if (\"function\" != typeof WeakMap) return null;\n        var e = new WeakMap(),\n          n = new WeakMap();\n        return (r = function (t) {\n          return t ? n : e;\n        })(t);\n      }\n      function n(t, e, r) {\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = r[0],\n          l = r[1],\n          u = r[2],\n          c = r[3];\n        return t[0] = n * o + s * l, t[1] = i * o + a * l, t[2] = n * u + s * c, t[3] = i * u + a * c, t;\n      }\n      function i(t, e, r) {\n        return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t[3] = e[3] - r[3], t;\n      }\n      return o.mul = n, o.sub = i, o;\n    }\n    var u,\n      c = {};\n    function h() {\n      if (u) return c;\n      function t(e) {\n        return t = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n          return typeof t;\n        } : function (t) {\n          return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n        }, t(e);\n      }\n      u = 1, Object.defineProperty(c, \"__esModule\", {\n        value: !0\n      }), c.create = function () {\n        var t = new e.ARRAY_TYPE(6);\n        return e.ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0), t[0] = 1, t[3] = 1, t;\n      }, c.clone = function (t) {\n        var r = new e.ARRAY_TYPE(6);\n        return r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r[4] = t[4], r[5] = t[5], r;\n      }, c.copy = function (t, e) {\n        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t;\n      }, c.identity = function (t) {\n        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t;\n      }, c.fromValues = function (t, r, n, i, s, a) {\n        var o = new e.ARRAY_TYPE(6);\n        return o[0] = t, o[1] = r, o[2] = n, o[3] = i, o[4] = s, o[5] = a, o;\n      }, c.set = function (t, e, r, n, i, s, a) {\n        return t[0] = e, t[1] = r, t[2] = n, t[3] = i, t[4] = s, t[5] = a, t;\n      }, c.invert = function (t, e) {\n        var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = e[3],\n          a = e[4],\n          o = e[5],\n          l = r * s - n * i;\n        return l ? (t[0] = s * (l = 1 / l), t[1] = -n * l, t[2] = -i * l, t[3] = r * l, t[4] = (i * o - s * a) * l, t[5] = (n * a - r * o) * l, t) : null;\n      }, c.determinant = function (t) {\n        return t[0] * t[3] - t[1] * t[2];\n      }, c.multiply = n, c.rotate = function (t, e, r) {\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = e[4],\n          l = e[5],\n          u = Math.sin(r),\n          c = Math.cos(r);\n        return t[0] = n * c + s * u, t[1] = i * c + a * u, t[2] = n * -u + s * c, t[3] = i * -u + a * c, t[4] = o, t[5] = l, t;\n      }, c.scale = function (t, e, r) {\n        var n = e[1],\n          i = e[2],\n          s = e[3],\n          a = e[4],\n          o = e[5],\n          l = r[0],\n          u = r[1];\n        return t[0] = e[0] * l, t[1] = n * l, t[2] = i * u, t[3] = s * u, t[4] = a, t[5] = o, t;\n      }, c.translate = function (t, e, r) {\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = e[4],\n          l = e[5],\n          u = r[0],\n          c = r[1];\n        return t[0] = n, t[1] = i, t[2] = s, t[3] = a, t[4] = n * u + s * c + o, t[5] = i * u + a * c + l, t;\n      }, c.fromRotation = function (t, e) {\n        var r = Math.sin(e),\n          n = Math.cos(e);\n        return t[0] = n, t[1] = r, t[2] = -r, t[3] = n, t[4] = 0, t[5] = 0, t;\n      }, c.fromScaling = function (t, e) {\n        return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = e[1], t[4] = 0, t[5] = 0, t;\n      }, c.fromTranslation = function (t, e) {\n        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = e[0], t[5] = e[1], t;\n      }, c.str = function (t) {\n        return \"mat2d(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \", \" + t[4] + \", \" + t[5] + \")\";\n      }, c.frob = function (t) {\n        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], 1);\n      }, c.add = function (t, e, r) {\n        return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t[3] = e[3] + r[3], t[4] = e[4] + r[4], t[5] = e[5] + r[5], t;\n      }, c.subtract = i, c.multiplyScalar = function (t, e, r) {\n        return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t[4] = e[4] * r, t[5] = e[5] * r, t;\n      }, c.multiplyScalarAndAdd = function (t, e, r, n) {\n        return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t[2] = e[2] + r[2] * n, t[3] = e[3] + r[3] * n, t[4] = e[4] + r[4] * n, t[5] = e[5] + r[5] * n, t;\n      }, c.exactEquals = function (t, e) {\n        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5];\n      }, c.equals = function (t, r) {\n        var n = t[0],\n          i = t[1],\n          s = t[2],\n          a = t[3],\n          o = t[4],\n          l = t[5],\n          u = r[0],\n          c = r[1],\n          h = r[2],\n          p = r[3],\n          f = r[4],\n          d = r[5];\n        return Math.abs(n - u) <= e.EPSILON * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(i - c) <= e.EPSILON * Math.max(1, Math.abs(i), Math.abs(c)) && Math.abs(s - h) <= e.EPSILON * Math.max(1, Math.abs(s), Math.abs(h)) && Math.abs(a - p) <= e.EPSILON * Math.max(1, Math.abs(a), Math.abs(p)) && Math.abs(o - f) <= e.EPSILON * Math.max(1, Math.abs(o), Math.abs(f)) && Math.abs(l - d) <= e.EPSILON * Math.max(1, Math.abs(l), Math.abs(d));\n      }, c.sub = c.mul = void 0;\n      var e = function (e, n) {\n        if (e && e.__esModule) return e;\n        if (null === e || \"object\" !== t(e) && \"function\" != typeof e) return {\n          default: e\n        };\n        var i = r(void 0);\n        if (i && i.has(e)) return i.get(e);\n        var s = {},\n          a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (var o in e) if (\"default\" !== o && Object.prototype.hasOwnProperty.call(e, o)) {\n          var l = a ? Object.getOwnPropertyDescriptor(e, o) : null;\n          l && (l.get || l.set) ? Object.defineProperty(s, o, l) : s[o] = e[o];\n        }\n        return s.default = e, i && i.set(e, s), s;\n      }(s());\n      function r(t) {\n        if (\"function\" != typeof WeakMap) return null;\n        var e = new WeakMap(),\n          n = new WeakMap();\n        return (r = function (t) {\n          return t ? n : e;\n        })(t);\n      }\n      function n(t, e, r) {\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = e[4],\n          l = e[5],\n          u = r[0],\n          c = r[1],\n          h = r[2],\n          p = r[3],\n          f = r[4],\n          d = r[5];\n        return t[0] = n * u + s * c, t[1] = i * u + a * c, t[2] = n * h + s * p, t[3] = i * h + a * p, t[4] = n * f + s * d + o, t[5] = i * f + a * d + l, t;\n      }\n      function i(t, e, r) {\n        return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t[3] = e[3] - r[3], t[4] = e[4] - r[4], t[5] = e[5] - r[5], t;\n      }\n      return c.mul = n, c.sub = i, c;\n    }\n    var p,\n      f = {};\n    function d() {\n      if (p) return f;\n      function t(e) {\n        return t = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n          return typeof t;\n        } : function (t) {\n          return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n        }, t(e);\n      }\n      p = 1, Object.defineProperty(f, \"__esModule\", {\n        value: !0\n      }), f.create = function () {\n        var t = new e.ARRAY_TYPE(9);\n        return e.ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[0] = 1, t[4] = 1, t[8] = 1, t;\n      }, f.fromMat4 = function (t, e) {\n        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[4], t[4] = e[5], t[5] = e[6], t[6] = e[8], t[7] = e[9], t[8] = e[10], t;\n      }, f.clone = function (t) {\n        var r = new e.ARRAY_TYPE(9);\n        return r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r[4] = t[4], r[5] = t[5], r[6] = t[6], r[7] = t[7], r[8] = t[8], r;\n      }, f.copy = function (t, e) {\n        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;\n      }, f.fromValues = function (t, r, n, i, s, a, o, l, u) {\n        var c = new e.ARRAY_TYPE(9);\n        return c[0] = t, c[1] = r, c[2] = n, c[3] = i, c[4] = s, c[5] = a, c[6] = o, c[7] = l, c[8] = u, c;\n      }, f.set = function (t, e, r, n, i, s, a, o, l, u) {\n        return t[0] = e, t[1] = r, t[2] = n, t[3] = i, t[4] = s, t[5] = a, t[6] = o, t[7] = l, t[8] = u, t;\n      }, f.identity = function (t) {\n        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;\n      }, f.transpose = function (t, e) {\n        if (t === e) {\n          var r = e[1],\n            n = e[2],\n            i = e[5];\n          t[1] = e[3], t[2] = e[6], t[3] = r, t[5] = e[7], t[6] = n, t[7] = i;\n        } else t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8];\n        return t;\n      }, f.invert = function (t, e) {\n        var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = e[3],\n          a = e[4],\n          o = e[5],\n          l = e[6],\n          u = e[7],\n          c = e[8],\n          h = c * a - o * u,\n          p = -c * s + o * l,\n          f = u * s - a * l,\n          d = r * h + n * p + i * f;\n        return d ? (t[0] = h * (d = 1 / d), t[1] = (-c * n + i * u) * d, t[2] = (o * n - i * a) * d, t[3] = p * d, t[4] = (c * r - i * l) * d, t[5] = (-o * r + i * s) * d, t[6] = f * d, t[7] = (-u * r + n * l) * d, t[8] = (a * r - n * s) * d, t) : null;\n      }, f.adjoint = function (t, e) {\n        var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = e[3],\n          a = e[4],\n          o = e[5],\n          l = e[6],\n          u = e[7],\n          c = e[8];\n        return t[0] = a * c - o * u, t[1] = i * u - n * c, t[2] = n * o - i * a, t[3] = o * l - s * c, t[4] = r * c - i * l, t[5] = i * s - r * o, t[6] = s * u - a * l, t[7] = n * l - r * u, t[8] = r * a - n * s, t;\n      }, f.determinant = function (t) {\n        var e = t[3],\n          r = t[4],\n          n = t[5],\n          i = t[6],\n          s = t[7],\n          a = t[8];\n        return t[0] * (a * r - n * s) + t[1] * (-a * e + n * i) + t[2] * (s * e - r * i);\n      }, f.multiply = n, f.translate = function (t, e, r) {\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = e[4],\n          l = e[5],\n          u = e[6],\n          c = e[7],\n          h = e[8],\n          p = r[0],\n          f = r[1];\n        return t[0] = n, t[1] = i, t[2] = s, t[3] = a, t[4] = o, t[5] = l, t[6] = p * n + f * a + u, t[7] = p * i + f * o + c, t[8] = p * s + f * l + h, t;\n      }, f.rotate = function (t, e, r) {\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = e[4],\n          l = e[5],\n          u = e[6],\n          c = e[7],\n          h = e[8],\n          p = Math.sin(r),\n          f = Math.cos(r);\n        return t[0] = f * n + p * a, t[1] = f * i + p * o, t[2] = f * s + p * l, t[3] = f * a - p * n, t[4] = f * o - p * i, t[5] = f * l - p * s, t[6] = u, t[7] = c, t[8] = h, t;\n      }, f.scale = function (t, e, r) {\n        var n = r[0],\n          i = r[1];\n        return t[0] = n * e[0], t[1] = n * e[1], t[2] = n * e[2], t[3] = i * e[3], t[4] = i * e[4], t[5] = i * e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t;\n      }, f.fromTranslation = function (t, e) {\n        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = e[0], t[7] = e[1], t[8] = 1, t;\n      }, f.fromRotation = function (t, e) {\n        var r = Math.sin(e),\n          n = Math.cos(e);\n        return t[0] = n, t[1] = r, t[2] = 0, t[3] = -r, t[4] = n, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;\n      }, f.fromScaling = function (t, e) {\n        return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = e[1], t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, t;\n      }, f.fromMat2d = function (t, e) {\n        return t[0] = e[0], t[1] = e[1], t[2] = 0, t[3] = e[2], t[4] = e[3], t[5] = 0, t[6] = e[4], t[7] = e[5], t[8] = 1, t;\n      }, f.fromQuat = function (t, e) {\n        var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = e[3],\n          a = r + r,\n          o = n + n,\n          l = i + i,\n          u = r * a,\n          c = n * a,\n          h = n * o,\n          p = i * a,\n          f = i * o,\n          d = i * l,\n          m = s * a,\n          y = s * o,\n          g = s * l;\n        return t[0] = 1 - h - d, t[3] = c - g, t[6] = p + y, t[1] = c + g, t[4] = 1 - u - d, t[7] = f - m, t[2] = p - y, t[5] = f + m, t[8] = 1 - u - h, t;\n      }, f.normalFromMat4 = function (t, e) {\n        var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = e[3],\n          a = e[4],\n          o = e[5],\n          l = e[6],\n          u = e[7],\n          c = e[8],\n          h = e[9],\n          p = e[10],\n          f = e[11],\n          d = e[12],\n          m = e[13],\n          y = e[14],\n          g = e[15],\n          x = r * o - n * a,\n          v = r * l - i * a,\n          b = r * u - s * a,\n          _ = n * l - i * o,\n          w = n * u - s * o,\n          M = i * u - s * l,\n          A = c * m - h * d,\n          I = c * y - p * d,\n          S = c * g - f * d,\n          P = h * y - p * m,\n          E = h * g - f * m,\n          z = p * g - f * y,\n          k = x * z - v * E + b * P + _ * S - w * I + M * A;\n        return k ? (t[0] = (o * z - l * E + u * P) * (k = 1 / k), t[1] = (l * S - a * z - u * I) * k, t[2] = (a * E - o * S + u * A) * k, t[3] = (i * E - n * z - s * P) * k, t[4] = (r * z - i * S + s * I) * k, t[5] = (n * S - r * E - s * A) * k, t[6] = (m * M - y * w + g * _) * k, t[7] = (y * b - d * M - g * v) * k, t[8] = (d * w - m * b + g * x) * k, t) : null;\n      }, f.projection = function (t, e, r) {\n        return t[0] = 2 / e, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = -2 / r, t[5] = 0, t[6] = -1, t[7] = 1, t[8] = 1, t;\n      }, f.str = function (t) {\n        return \"mat3(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \", \" + t[4] + \", \" + t[5] + \", \" + t[6] + \", \" + t[7] + \", \" + t[8] + \")\";\n      }, f.frob = function (t) {\n        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8]);\n      }, f.add = function (t, e, r) {\n        return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t[3] = e[3] + r[3], t[4] = e[4] + r[4], t[5] = e[5] + r[5], t[6] = e[6] + r[6], t[7] = e[7] + r[7], t[8] = e[8] + r[8], t;\n      }, f.subtract = i, f.multiplyScalar = function (t, e, r) {\n        return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t[4] = e[4] * r, t[5] = e[5] * r, t[6] = e[6] * r, t[7] = e[7] * r, t[8] = e[8] * r, t;\n      }, f.multiplyScalarAndAdd = function (t, e, r, n) {\n        return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t[2] = e[2] + r[2] * n, t[3] = e[3] + r[3] * n, t[4] = e[4] + r[4] * n, t[5] = e[5] + r[5] * n, t[6] = e[6] + r[6] * n, t[7] = e[7] + r[7] * n, t[8] = e[8] + r[8] * n, t;\n      }, f.exactEquals = function (t, e) {\n        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8];\n      }, f.equals = function (t, r) {\n        var n = t[0],\n          i = t[1],\n          s = t[2],\n          a = t[3],\n          o = t[4],\n          l = t[5],\n          u = t[6],\n          c = t[7],\n          h = t[8],\n          p = r[0],\n          f = r[1],\n          d = r[2],\n          m = r[3],\n          y = r[4],\n          g = r[5],\n          x = r[6],\n          v = r[7],\n          b = r[8];\n        return Math.abs(n - p) <= e.EPSILON * Math.max(1, Math.abs(n), Math.abs(p)) && Math.abs(i - f) <= e.EPSILON * Math.max(1, Math.abs(i), Math.abs(f)) && Math.abs(s - d) <= e.EPSILON * Math.max(1, Math.abs(s), Math.abs(d)) && Math.abs(a - m) <= e.EPSILON * Math.max(1, Math.abs(a), Math.abs(m)) && Math.abs(o - y) <= e.EPSILON * Math.max(1, Math.abs(o), Math.abs(y)) && Math.abs(l - g) <= e.EPSILON * Math.max(1, Math.abs(l), Math.abs(g)) && Math.abs(u - x) <= e.EPSILON * Math.max(1, Math.abs(u), Math.abs(x)) && Math.abs(c - v) <= e.EPSILON * Math.max(1, Math.abs(c), Math.abs(v)) && Math.abs(h - b) <= e.EPSILON * Math.max(1, Math.abs(h), Math.abs(b));\n      }, f.sub = f.mul = void 0;\n      var e = function (e, n) {\n        if (e && e.__esModule) return e;\n        if (null === e || \"object\" !== t(e) && \"function\" != typeof e) return {\n          default: e\n        };\n        var i = r(void 0);\n        if (i && i.has(e)) return i.get(e);\n        var s = {},\n          a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (var o in e) if (\"default\" !== o && Object.prototype.hasOwnProperty.call(e, o)) {\n          var l = a ? Object.getOwnPropertyDescriptor(e, o) : null;\n          l && (l.get || l.set) ? Object.defineProperty(s, o, l) : s[o] = e[o];\n        }\n        return s.default = e, i && i.set(e, s), s;\n      }(s());\n      function r(t) {\n        if (\"function\" != typeof WeakMap) return null;\n        var e = new WeakMap(),\n          n = new WeakMap();\n        return (r = function (t) {\n          return t ? n : e;\n        })(t);\n      }\n      function n(t, e, r) {\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = e[4],\n          l = e[5],\n          u = e[6],\n          c = e[7],\n          h = e[8],\n          p = r[0],\n          f = r[1],\n          d = r[2],\n          m = r[3],\n          y = r[4],\n          g = r[5],\n          x = r[6],\n          v = r[7],\n          b = r[8];\n        return t[0] = p * n + f * a + d * u, t[1] = p * i + f * o + d * c, t[2] = p * s + f * l + d * h, t[3] = m * n + y * a + g * u, t[4] = m * i + y * o + g * c, t[5] = m * s + y * l + g * h, t[6] = x * n + v * a + b * u, t[7] = x * i + v * o + b * c, t[8] = x * s + v * l + b * h, t;\n      }\n      function i(t, e, r) {\n        return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t[3] = e[3] - r[3], t[4] = e[4] - r[4], t[5] = e[5] - r[5], t[6] = e[6] - r[6], t[7] = e[7] - r[7], t[8] = e[8] - r[8], t;\n      }\n      return f.mul = n, f.sub = i, f;\n    }\n    var m,\n      y = {};\n    function g() {\n      if (m) return y;\n      function t(e) {\n        return t = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n          return typeof t;\n        } : function (t) {\n          return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n        }, t(e);\n      }\n      m = 1, Object.defineProperty(y, \"__esModule\", {\n        value: !0\n      }), y.create = function () {\n        var t = new e.ARRAY_TYPE(16);\n        return e.ARRAY_TYPE != Float32Array && (t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0), t[0] = 1, t[5] = 1, t[10] = 1, t[15] = 1, t;\n      }, y.clone = function (t) {\n        var r = new e.ARRAY_TYPE(16);\n        return r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r[4] = t[4], r[5] = t[5], r[6] = t[6], r[7] = t[7], r[8] = t[8], r[9] = t[9], r[10] = t[10], r[11] = t[11], r[12] = t[12], r[13] = t[13], r[14] = t[14], r[15] = t[15], r;\n      }, y.copy = function (t, e) {\n        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;\n      }, y.fromValues = function (t, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y) {\n        var g = new e.ARRAY_TYPE(16);\n        return g[0] = t, g[1] = r, g[2] = n, g[3] = i, g[4] = s, g[5] = a, g[6] = o, g[7] = l, g[8] = u, g[9] = c, g[10] = h, g[11] = p, g[12] = f, g[13] = d, g[14] = m, g[15] = y, g;\n      }, y.set = function (t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y) {\n        return t[0] = e, t[1] = r, t[2] = n, t[3] = i, t[4] = s, t[5] = a, t[6] = o, t[7] = l, t[8] = u, t[9] = c, t[10] = h, t[11] = p, t[12] = f, t[13] = d, t[14] = m, t[15] = y, t;\n      }, y.identity = n, y.transpose = function (t, e) {\n        if (t === e) {\n          var r = e[1],\n            n = e[2],\n            i = e[3],\n            s = e[6],\n            a = e[7],\n            o = e[11];\n          t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = r, t[6] = e[9], t[7] = e[13], t[8] = n, t[9] = s, t[11] = e[14], t[12] = i, t[13] = a, t[14] = o;\n        } else t[0] = e[0], t[1] = e[4], t[2] = e[8], t[3] = e[12], t[4] = e[1], t[5] = e[5], t[6] = e[9], t[7] = e[13], t[8] = e[2], t[9] = e[6], t[10] = e[10], t[11] = e[14], t[12] = e[3], t[13] = e[7], t[14] = e[11], t[15] = e[15];\n        return t;\n      }, y.invert = function (t, e) {\n        var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = e[3],\n          a = e[4],\n          o = e[5],\n          l = e[6],\n          u = e[7],\n          c = e[8],\n          h = e[9],\n          p = e[10],\n          f = e[11],\n          d = e[12],\n          m = e[13],\n          y = e[14],\n          g = e[15],\n          x = r * o - n * a,\n          v = r * l - i * a,\n          b = r * u - s * a,\n          _ = n * l - i * o,\n          w = n * u - s * o,\n          M = i * u - s * l,\n          A = c * m - h * d,\n          I = c * y - p * d,\n          S = c * g - f * d,\n          P = h * y - p * m,\n          E = h * g - f * m,\n          z = p * g - f * y,\n          k = x * z - v * E + b * P + _ * S - w * I + M * A;\n        return k ? (t[0] = (o * z - l * E + u * P) * (k = 1 / k), t[1] = (i * E - n * z - s * P) * k, t[2] = (m * M - y * w + g * _) * k, t[3] = (p * w - h * M - f * _) * k, t[4] = (l * S - a * z - u * I) * k, t[5] = (r * z - i * S + s * I) * k, t[6] = (y * b - d * M - g * v) * k, t[7] = (c * M - p * b + f * v) * k, t[8] = (a * E - o * S + u * A) * k, t[9] = (n * S - r * E - s * A) * k, t[10] = (d * w - m * b + g * x) * k, t[11] = (h * b - c * w - f * x) * k, t[12] = (o * I - a * P - l * A) * k, t[13] = (r * P - n * I + i * A) * k, t[14] = (m * v - d * _ - y * x) * k, t[15] = (c * _ - h * v + p * x) * k, t) : null;\n      }, y.adjoint = function (t, e) {\n        var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = e[3],\n          a = e[4],\n          o = e[5],\n          l = e[6],\n          u = e[7],\n          c = e[8],\n          h = e[9],\n          p = e[10],\n          f = e[11],\n          d = e[12],\n          m = e[13],\n          y = e[14],\n          g = e[15];\n        return t[0] = o * (p * g - f * y) - h * (l * g - u * y) + m * (l * f - u * p), t[1] = -(n * (p * g - f * y) - h * (i * g - s * y) + m * (i * f - s * p)), t[2] = n * (l * g - u * y) - o * (i * g - s * y) + m * (i * u - s * l), t[3] = -(n * (l * f - u * p) - o * (i * f - s * p) + h * (i * u - s * l)), t[4] = -(a * (p * g - f * y) - c * (l * g - u * y) + d * (l * f - u * p)), t[5] = r * (p * g - f * y) - c * (i * g - s * y) + d * (i * f - s * p), t[6] = -(r * (l * g - u * y) - a * (i * g - s * y) + d * (i * u - s * l)), t[7] = r * (l * f - u * p) - a * (i * f - s * p) + c * (i * u - s * l), t[8] = a * (h * g - f * m) - c * (o * g - u * m) + d * (o * f - u * h), t[9] = -(r * (h * g - f * m) - c * (n * g - s * m) + d * (n * f - s * h)), t[10] = r * (o * g - u * m) - a * (n * g - s * m) + d * (n * u - s * o), t[11] = -(r * (o * f - u * h) - a * (n * f - s * h) + c * (n * u - s * o)), t[12] = -(a * (h * y - p * m) - c * (o * y - l * m) + d * (o * p - l * h)), t[13] = r * (h * y - p * m) - c * (n * y - i * m) + d * (n * p - i * h), t[14] = -(r * (o * y - l * m) - a * (n * y - i * m) + d * (n * l - i * o)), t[15] = r * (o * p - l * h) - a * (n * p - i * h) + c * (n * l - i * o), t;\n      }, y.determinant = function (t) {\n        var e = t[0],\n          r = t[1],\n          n = t[2],\n          i = t[3],\n          s = t[4],\n          a = t[5],\n          o = t[6],\n          l = t[7],\n          u = t[8],\n          c = t[9],\n          h = t[10],\n          p = t[11],\n          f = t[12],\n          d = t[13],\n          m = t[14],\n          y = t[15];\n        return (e * a - r * s) * (h * y - p * m) - (e * o - n * s) * (c * y - p * d) + (e * l - i * s) * (c * m - h * d) + (r * o - n * a) * (u * y - p * f) - (r * l - i * a) * (u * m - h * f) + (n * l - i * o) * (u * d - c * f);\n      }, y.multiply = i, y.translate = function (t, e, r) {\n        var n,\n          i,\n          s,\n          a,\n          o,\n          l,\n          u,\n          c,\n          h,\n          p,\n          f,\n          d,\n          m = r[0],\n          y = r[1],\n          g = r[2];\n        return e === t ? (t[12] = e[0] * m + e[4] * y + e[8] * g + e[12], t[13] = e[1] * m + e[5] * y + e[9] * g + e[13], t[14] = e[2] * m + e[6] * y + e[10] * g + e[14], t[15] = e[3] * m + e[7] * y + e[11] * g + e[15]) : (i = e[1], s = e[2], a = e[3], o = e[4], l = e[5], u = e[6], c = e[7], h = e[8], p = e[9], f = e[10], d = e[11], t[0] = n = e[0], t[1] = i, t[2] = s, t[3] = a, t[4] = o, t[5] = l, t[6] = u, t[7] = c, t[8] = h, t[9] = p, t[10] = f, t[11] = d, t[12] = n * m + o * y + h * g + e[12], t[13] = i * m + l * y + p * g + e[13], t[14] = s * m + u * y + f * g + e[14], t[15] = a * m + c * y + d * g + e[15]), t;\n      }, y.scale = function (t, e, r) {\n        var n = r[0],\n          i = r[1],\n          s = r[2];\n        return t[0] = e[0] * n, t[1] = e[1] * n, t[2] = e[2] * n, t[3] = e[3] * n, t[4] = e[4] * i, t[5] = e[5] * i, t[6] = e[6] * i, t[7] = e[7] * i, t[8] = e[8] * s, t[9] = e[9] * s, t[10] = e[10] * s, t[11] = e[11] * s, t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t;\n      }, y.rotate = function (t, r, n, i) {\n        var s,\n          a,\n          o,\n          l,\n          u,\n          c,\n          h,\n          p,\n          f,\n          d,\n          m,\n          y,\n          g,\n          x,\n          v,\n          b,\n          _,\n          w,\n          M,\n          A,\n          I,\n          S,\n          P,\n          E,\n          z = i[0],\n          k = i[1],\n          T = i[2],\n          B = Math.hypot(z, k, T);\n        return B < e.EPSILON ? null : (z *= B = 1 / B, k *= B, T *= B, s = Math.sin(n), a = Math.cos(n), u = r[1], c = r[2], h = r[3], f = r[5], d = r[6], m = r[7], g = r[9], x = r[10], v = r[11], b = z * z * (o = 1 - a) + a, M = z * k * o - T * s, A = k * k * o + a, I = T * k * o + z * s, S = z * T * o + k * s, P = k * T * o - z * s, E = T * T * o + a, t[0] = (l = r[0]) * b + (p = r[4]) * (_ = k * z * o + T * s) + (y = r[8]) * (w = T * z * o - k * s), t[1] = u * b + f * _ + g * w, t[2] = c * b + d * _ + x * w, t[3] = h * b + m * _ + v * w, t[4] = l * M + p * A + y * I, t[5] = u * M + f * A + g * I, t[6] = c * M + d * A + x * I, t[7] = h * M + m * A + v * I, t[8] = l * S + p * P + y * E, t[9] = u * S + f * P + g * E, t[10] = c * S + d * P + x * E, t[11] = h * S + m * P + v * E, r !== t && (t[12] = r[12], t[13] = r[13], t[14] = r[14], t[15] = r[15]), t);\n      }, y.rotateX = function (t, e, r) {\n        var n = Math.sin(r),\n          i = Math.cos(r),\n          s = e[4],\n          a = e[5],\n          o = e[6],\n          l = e[7],\n          u = e[8],\n          c = e[9],\n          h = e[10],\n          p = e[11];\n        return e !== t && (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[4] = s * i + u * n, t[5] = a * i + c * n, t[6] = o * i + h * n, t[7] = l * i + p * n, t[8] = u * i - s * n, t[9] = c * i - a * n, t[10] = h * i - o * n, t[11] = p * i - l * n, t;\n      }, y.rotateY = function (t, e, r) {\n        var n = Math.sin(r),\n          i = Math.cos(r),\n          s = e[0],\n          a = e[1],\n          o = e[2],\n          l = e[3],\n          u = e[8],\n          c = e[9],\n          h = e[10],\n          p = e[11];\n        return e !== t && (t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = s * i - u * n, t[1] = a * i - c * n, t[2] = o * i - h * n, t[3] = l * i - p * n, t[8] = s * n + u * i, t[9] = a * n + c * i, t[10] = o * n + h * i, t[11] = l * n + p * i, t;\n      }, y.rotateZ = function (t, e, r) {\n        var n = Math.sin(r),\n          i = Math.cos(r),\n          s = e[0],\n          a = e[1],\n          o = e[2],\n          l = e[3],\n          u = e[4],\n          c = e[5],\n          h = e[6],\n          p = e[7];\n        return e !== t && (t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15]), t[0] = s * i + u * n, t[1] = a * i + c * n, t[2] = o * i + h * n, t[3] = l * i + p * n, t[4] = u * i - s * n, t[5] = c * i - a * n, t[6] = h * i - o * n, t[7] = p * i - l * n, t;\n      }, y.fromTranslation = function (t, e) {\n        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = e[0], t[13] = e[1], t[14] = e[2], t[15] = 1, t;\n      }, y.fromScaling = function (t, e) {\n        return t[0] = e[0], t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = e[1], t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = e[2], t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n      }, y.fromRotation = function (t, r, n) {\n        var i,\n          s,\n          a,\n          o = n[0],\n          l = n[1],\n          u = n[2],\n          c = Math.hypot(o, l, u);\n        return c < e.EPSILON ? null : (o *= c = 1 / c, l *= c, u *= c, i = Math.sin(r), s = Math.cos(r), t[0] = o * o * (a = 1 - s) + s, t[1] = l * o * a + u * i, t[2] = u * o * a - l * i, t[3] = 0, t[4] = o * l * a - u * i, t[5] = l * l * a + s, t[6] = u * l * a + o * i, t[7] = 0, t[8] = o * u * a + l * i, t[9] = l * u * a - o * i, t[10] = u * u * a + s, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t);\n      }, y.fromXRotation = function (t, e) {\n        var r = Math.sin(e),\n          n = Math.cos(e);\n        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = n, t[6] = r, t[7] = 0, t[8] = 0, t[9] = -r, t[10] = n, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n      }, y.fromYRotation = function (t, e) {\n        var r = Math.sin(e),\n          n = Math.cos(e);\n        return t[0] = n, t[1] = 0, t[2] = -r, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = r, t[9] = 0, t[10] = n, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n      }, y.fromZRotation = function (t, e) {\n        var r = Math.sin(e),\n          n = Math.cos(e);\n        return t[0] = n, t[1] = r, t[2] = 0, t[3] = 0, t[4] = -r, t[5] = n, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n      }, y.fromRotationTranslation = a, y.fromQuat2 = function (t, r) {\n        var n = new e.ARRAY_TYPE(3),\n          i = -r[0],\n          s = -r[1],\n          o = -r[2],\n          l = r[3],\n          u = r[4],\n          c = r[5],\n          h = r[6],\n          p = r[7],\n          f = i * i + s * s + o * o + l * l;\n        return f > 0 ? (n[0] = 2 * (u * l + p * i + c * o - h * s) / f, n[1] = 2 * (c * l + p * s + h * i - u * o) / f, n[2] = 2 * (h * l + p * o + u * s - c * i) / f) : (n[0] = 2 * (u * l + p * i + c * o - h * s), n[1] = 2 * (c * l + p * s + h * i - u * o), n[2] = 2 * (h * l + p * o + u * s - c * i)), a(t, r, n), t;\n      }, y.getTranslation = function (t, e) {\n        return t[0] = e[12], t[1] = e[13], t[2] = e[14], t;\n      }, y.getScaling = o, y.getRotation = function (t, r) {\n        var n = new e.ARRAY_TYPE(3);\n        o(n, r);\n        var i = 1 / n[0],\n          s = 1 / n[1],\n          a = 1 / n[2],\n          l = r[0] * i,\n          u = r[1] * s,\n          c = r[2] * a,\n          h = r[4] * i,\n          p = r[5] * s,\n          f = r[6] * a,\n          d = r[8] * i,\n          m = r[9] * s,\n          y = r[10] * a,\n          g = l + p + y,\n          x = 0;\n        return g > 0 ? (x = 2 * Math.sqrt(g + 1), t[3] = .25 * x, t[0] = (f - m) / x, t[1] = (d - c) / x, t[2] = (u - h) / x) : l > p && l > y ? (x = 2 * Math.sqrt(1 + l - p - y), t[3] = (f - m) / x, t[0] = .25 * x, t[1] = (u + h) / x, t[2] = (d + c) / x) : p > y ? (x = 2 * Math.sqrt(1 + p - l - y), t[3] = (d - c) / x, t[0] = (u + h) / x, t[1] = .25 * x, t[2] = (f + m) / x) : (x = 2 * Math.sqrt(1 + y - l - p), t[3] = (u - h) / x, t[0] = (d + c) / x, t[1] = (f + m) / x, t[2] = .25 * x), t;\n      }, y.fromRotationTranslationScale = function (t, e, r, n) {\n        var i = e[0],\n          s = e[1],\n          a = e[2],\n          o = e[3],\n          l = i + i,\n          u = s + s,\n          c = a + a,\n          h = i * l,\n          p = i * u,\n          f = i * c,\n          d = s * u,\n          m = s * c,\n          y = a * c,\n          g = o * l,\n          x = o * u,\n          v = o * c,\n          b = n[0],\n          _ = n[1],\n          w = n[2];\n        return t[0] = (1 - (d + y)) * b, t[1] = (p + v) * b, t[2] = (f - x) * b, t[3] = 0, t[4] = (p - v) * _, t[5] = (1 - (h + y)) * _, t[6] = (m + g) * _, t[7] = 0, t[8] = (f + x) * w, t[9] = (m - g) * w, t[10] = (1 - (h + d)) * w, t[11] = 0, t[12] = r[0], t[13] = r[1], t[14] = r[2], t[15] = 1, t;\n      }, y.fromRotationTranslationScaleOrigin = function (t, e, r, n, i) {\n        var s = e[0],\n          a = e[1],\n          o = e[2],\n          l = e[3],\n          u = s + s,\n          c = a + a,\n          h = o + o,\n          p = s * u,\n          f = s * c,\n          d = s * h,\n          m = a * c,\n          y = a * h,\n          g = o * h,\n          x = l * u,\n          v = l * c,\n          b = l * h,\n          _ = n[0],\n          w = n[1],\n          M = n[2],\n          A = i[0],\n          I = i[1],\n          S = i[2],\n          P = (1 - (m + g)) * _,\n          E = (f + b) * _,\n          z = (d - v) * _,\n          k = (f - b) * w,\n          T = (1 - (p + g)) * w,\n          B = (y + x) * w,\n          V = (d + v) * M,\n          C = (y - x) * M,\n          D = (1 - (p + m)) * M;\n        return t[0] = P, t[1] = E, t[2] = z, t[3] = 0, t[4] = k, t[5] = T, t[6] = B, t[7] = 0, t[8] = V, t[9] = C, t[10] = D, t[11] = 0, t[12] = r[0] + A - (P * A + k * I + V * S), t[13] = r[1] + I - (E * A + T * I + C * S), t[14] = r[2] + S - (z * A + B * I + D * S), t[15] = 1, t;\n      }, y.fromQuat = function (t, e) {\n        var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = e[3],\n          a = r + r,\n          o = n + n,\n          l = i + i,\n          u = r * a,\n          c = n * a,\n          h = n * o,\n          p = i * a,\n          f = i * o,\n          d = i * l,\n          m = s * a,\n          y = s * o,\n          g = s * l;\n        return t[0] = 1 - h - d, t[1] = c + g, t[2] = p - y, t[3] = 0, t[4] = c - g, t[5] = 1 - u - d, t[6] = f + m, t[7] = 0, t[8] = p + y, t[9] = f - m, t[10] = 1 - u - h, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n      }, y.frustum = function (t, e, r, n, i, s, a) {\n        var o = 1 / (r - e),\n          l = 1 / (i - n),\n          u = 1 / (s - a);\n        return t[0] = 2 * s * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 2 * s * l, t[6] = 0, t[7] = 0, t[8] = (r + e) * o, t[9] = (i + n) * l, t[10] = (a + s) * u, t[11] = -1, t[12] = 0, t[13] = 0, t[14] = a * s * 2 * u, t[15] = 0, t;\n      }, y.perspectiveNO = l, y.perspectiveZO = function (t, e, r, n, i) {\n        var s,\n          a = 1 / Math.tan(e / 2);\n        return t[0] = a / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (t[10] = i * (s = 1 / (n - i)), t[14] = i * n * s) : (t[10] = -1, t[14] = -n), t;\n      }, y.perspectiveFromFieldOfView = function (t, e, r, n) {\n        var i = Math.tan(e.upDegrees * Math.PI / 180),\n          s = Math.tan(e.downDegrees * Math.PI / 180),\n          a = Math.tan(e.leftDegrees * Math.PI / 180),\n          o = Math.tan(e.rightDegrees * Math.PI / 180),\n          l = 2 / (a + o),\n          u = 2 / (i + s);\n        return t[0] = l, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = u, t[6] = 0, t[7] = 0, t[8] = -(a - o) * l * .5, t[9] = (i - s) * u * .5, t[10] = n / (r - n), t[11] = -1, t[12] = 0, t[13] = 0, t[14] = n * r / (r - n), t[15] = 0, t;\n      }, y.orthoNO = u, y.orthoZO = function (t, e, r, n, i, s, a) {\n        var o = 1 / (e - r),\n          l = 1 / (n - i),\n          u = 1 / (s - a);\n        return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = u, t[11] = 0, t[12] = (e + r) * o, t[13] = (i + n) * l, t[14] = s * u, t[15] = 1, t;\n      }, y.lookAt = function (t, r, i, s) {\n        var a,\n          o,\n          l,\n          u,\n          c,\n          h,\n          p,\n          f,\n          d,\n          m,\n          y = r[0],\n          g = r[1],\n          x = r[2],\n          v = s[0],\n          b = s[1],\n          _ = s[2],\n          w = i[0],\n          M = i[1],\n          A = i[2];\n        return Math.abs(y - w) < e.EPSILON && Math.abs(g - M) < e.EPSILON && Math.abs(x - A) < e.EPSILON ? n(t) : (p = y - w, f = g - M, d = x - A, a = b * (d *= m = 1 / Math.hypot(p, f, d)) - _ * (f *= m), o = _ * (p *= m) - v * d, l = v * f - b * p, (m = Math.hypot(a, o, l)) ? (a *= m = 1 / m, o *= m, l *= m) : (a = 0, o = 0, l = 0), u = f * l - d * o, c = d * a - p * l, h = p * o - f * a, (m = Math.hypot(u, c, h)) ? (u *= m = 1 / m, c *= m, h *= m) : (u = 0, c = 0, h = 0), t[0] = a, t[1] = u, t[2] = p, t[3] = 0, t[4] = o, t[5] = c, t[6] = f, t[7] = 0, t[8] = l, t[9] = h, t[10] = d, t[11] = 0, t[12] = -(a * y + o * g + l * x), t[13] = -(u * y + c * g + h * x), t[14] = -(p * y + f * g + d * x), t[15] = 1, t);\n      }, y.targetTo = function (t, e, r, n) {\n        var i = e[0],\n          s = e[1],\n          a = e[2],\n          o = n[0],\n          l = n[1],\n          u = n[2],\n          c = i - r[0],\n          h = s - r[1],\n          p = a - r[2],\n          f = c * c + h * h + p * p;\n        f > 0 && (c *= f = 1 / Math.sqrt(f), h *= f, p *= f);\n        var d = l * p - u * h,\n          m = u * c - o * p,\n          y = o * h - l * c;\n        return (f = d * d + m * m + y * y) > 0 && (d *= f = 1 / Math.sqrt(f), m *= f, y *= f), t[0] = d, t[1] = m, t[2] = y, t[3] = 0, t[4] = h * y - p * m, t[5] = p * d - c * y, t[6] = c * m - h * d, t[7] = 0, t[8] = c, t[9] = h, t[10] = p, t[11] = 0, t[12] = i, t[13] = s, t[14] = a, t[15] = 1, t;\n      }, y.str = function (t) {\n        return \"mat4(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \", \" + t[4] + \", \" + t[5] + \", \" + t[6] + \", \" + t[7] + \", \" + t[8] + \", \" + t[9] + \", \" + t[10] + \", \" + t[11] + \", \" + t[12] + \", \" + t[13] + \", \" + t[14] + \", \" + t[15] + \")\";\n      }, y.frob = function (t) {\n        return Math.hypot(t[0], t[1], t[2], t[3], t[4], t[5], t[6], t[7], t[8], t[9], t[10], t[11], t[12], t[13], t[14], t[15]);\n      }, y.add = function (t, e, r) {\n        return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t[3] = e[3] + r[3], t[4] = e[4] + r[4], t[5] = e[5] + r[5], t[6] = e[6] + r[6], t[7] = e[7] + r[7], t[8] = e[8] + r[8], t[9] = e[9] + r[9], t[10] = e[10] + r[10], t[11] = e[11] + r[11], t[12] = e[12] + r[12], t[13] = e[13] + r[13], t[14] = e[14] + r[14], t[15] = e[15] + r[15], t;\n      }, y.subtract = c, y.multiplyScalar = function (t, e, r) {\n        return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t[4] = e[4] * r, t[5] = e[5] * r, t[6] = e[6] * r, t[7] = e[7] * r, t[8] = e[8] * r, t[9] = e[9] * r, t[10] = e[10] * r, t[11] = e[11] * r, t[12] = e[12] * r, t[13] = e[13] * r, t[14] = e[14] * r, t[15] = e[15] * r, t;\n      }, y.multiplyScalarAndAdd = function (t, e, r, n) {\n        return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t[2] = e[2] + r[2] * n, t[3] = e[3] + r[3] * n, t[4] = e[4] + r[4] * n, t[5] = e[5] + r[5] * n, t[6] = e[6] + r[6] * n, t[7] = e[7] + r[7] * n, t[8] = e[8] + r[8] * n, t[9] = e[9] + r[9] * n, t[10] = e[10] + r[10] * n, t[11] = e[11] + r[11] * n, t[12] = e[12] + r[12] * n, t[13] = e[13] + r[13] * n, t[14] = e[14] + r[14] * n, t[15] = e[15] + r[15] * n, t;\n      }, y.exactEquals = function (t, e) {\n        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7] && t[8] === e[8] && t[9] === e[9] && t[10] === e[10] && t[11] === e[11] && t[12] === e[12] && t[13] === e[13] && t[14] === e[14] && t[15] === e[15];\n      }, y.equals = function (t, r) {\n        var n = t[0],\n          i = t[1],\n          s = t[2],\n          a = t[3],\n          o = t[4],\n          l = t[5],\n          u = t[6],\n          c = t[7],\n          h = t[8],\n          p = t[9],\n          f = t[10],\n          d = t[11],\n          m = t[12],\n          y = t[13],\n          g = t[14],\n          x = t[15],\n          v = r[0],\n          b = r[1],\n          _ = r[2],\n          w = r[3],\n          M = r[4],\n          A = r[5],\n          I = r[6],\n          S = r[7],\n          P = r[8],\n          E = r[9],\n          z = r[10],\n          k = r[11],\n          T = r[12],\n          B = r[13],\n          V = r[14],\n          C = r[15];\n        return Math.abs(n - v) <= e.EPSILON * Math.max(1, Math.abs(n), Math.abs(v)) && Math.abs(i - b) <= e.EPSILON * Math.max(1, Math.abs(i), Math.abs(b)) && Math.abs(s - _) <= e.EPSILON * Math.max(1, Math.abs(s), Math.abs(_)) && Math.abs(a - w) <= e.EPSILON * Math.max(1, Math.abs(a), Math.abs(w)) && Math.abs(o - M) <= e.EPSILON * Math.max(1, Math.abs(o), Math.abs(M)) && Math.abs(l - A) <= e.EPSILON * Math.max(1, Math.abs(l), Math.abs(A)) && Math.abs(u - I) <= e.EPSILON * Math.max(1, Math.abs(u), Math.abs(I)) && Math.abs(c - S) <= e.EPSILON * Math.max(1, Math.abs(c), Math.abs(S)) && Math.abs(h - P) <= e.EPSILON * Math.max(1, Math.abs(h), Math.abs(P)) && Math.abs(p - E) <= e.EPSILON * Math.max(1, Math.abs(p), Math.abs(E)) && Math.abs(f - z) <= e.EPSILON * Math.max(1, Math.abs(f), Math.abs(z)) && Math.abs(d - k) <= e.EPSILON * Math.max(1, Math.abs(d), Math.abs(k)) && Math.abs(m - T) <= e.EPSILON * Math.max(1, Math.abs(m), Math.abs(T)) && Math.abs(y - B) <= e.EPSILON * Math.max(1, Math.abs(y), Math.abs(B)) && Math.abs(g - V) <= e.EPSILON * Math.max(1, Math.abs(g), Math.abs(V)) && Math.abs(x - C) <= e.EPSILON * Math.max(1, Math.abs(x), Math.abs(C));\n      }, y.sub = y.mul = y.ortho = y.perspective = void 0;\n      var e = function (e, n) {\n        if (e && e.__esModule) return e;\n        if (null === e || \"object\" !== t(e) && \"function\" != typeof e) return {\n          default: e\n        };\n        var i = r(void 0);\n        if (i && i.has(e)) return i.get(e);\n        var s = {},\n          a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (var o in e) if (\"default\" !== o && Object.prototype.hasOwnProperty.call(e, o)) {\n          var l = a ? Object.getOwnPropertyDescriptor(e, o) : null;\n          l && (l.get || l.set) ? Object.defineProperty(s, o, l) : s[o] = e[o];\n        }\n        return s.default = e, i && i.set(e, s), s;\n      }(s());\n      function r(t) {\n        if (\"function\" != typeof WeakMap) return null;\n        var e = new WeakMap(),\n          n = new WeakMap();\n        return (r = function (t) {\n          return t ? n : e;\n        })(t);\n      }\n      function n(t) {\n        return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, t;\n      }\n      function i(t, e, r) {\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = e[4],\n          l = e[5],\n          u = e[6],\n          c = e[7],\n          h = e[8],\n          p = e[9],\n          f = e[10],\n          d = e[11],\n          m = e[12],\n          y = e[13],\n          g = e[14],\n          x = e[15],\n          v = r[0],\n          b = r[1],\n          _ = r[2],\n          w = r[3];\n        return t[0] = v * n + b * o + _ * h + w * m, t[1] = v * i + b * l + _ * p + w * y, t[2] = v * s + b * u + _ * f + w * g, t[3] = v * a + b * c + _ * d + w * x, t[4] = (v = r[4]) * n + (b = r[5]) * o + (_ = r[6]) * h + (w = r[7]) * m, t[5] = v * i + b * l + _ * p + w * y, t[6] = v * s + b * u + _ * f + w * g, t[7] = v * a + b * c + _ * d + w * x, t[8] = (v = r[8]) * n + (b = r[9]) * o + (_ = r[10]) * h + (w = r[11]) * m, t[9] = v * i + b * l + _ * p + w * y, t[10] = v * s + b * u + _ * f + w * g, t[11] = v * a + b * c + _ * d + w * x, t[12] = (v = r[12]) * n + (b = r[13]) * o + (_ = r[14]) * h + (w = r[15]) * m, t[13] = v * i + b * l + _ * p + w * y, t[14] = v * s + b * u + _ * f + w * g, t[15] = v * a + b * c + _ * d + w * x, t;\n      }\n      function a(t, e, r) {\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = n + n,\n          l = i + i,\n          u = s + s,\n          c = n * o,\n          h = n * l,\n          p = n * u,\n          f = i * l,\n          d = i * u,\n          m = s * u,\n          y = a * o,\n          g = a * l,\n          x = a * u;\n        return t[0] = 1 - (f + m), t[1] = h + x, t[2] = p - g, t[3] = 0, t[4] = h - x, t[5] = 1 - (c + m), t[6] = d + y, t[7] = 0, t[8] = p + g, t[9] = d - y, t[10] = 1 - (c + f), t[11] = 0, t[12] = r[0], t[13] = r[1], t[14] = r[2], t[15] = 1, t;\n      }\n      function o(t, e) {\n        var r = e[4],\n          n = e[5],\n          i = e[6],\n          s = e[8],\n          a = e[9],\n          o = e[10];\n        return t[0] = Math.hypot(e[0], e[1], e[2]), t[1] = Math.hypot(r, n, i), t[2] = Math.hypot(s, a, o), t;\n      }\n      function l(t, e, r, n, i) {\n        var s,\n          a = 1 / Math.tan(e / 2);\n        return t[0] = a / r, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = a, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[11] = -1, t[12] = 0, t[13] = 0, t[15] = 0, null != i && i !== 1 / 0 ? (t[10] = (i + n) * (s = 1 / (n - i)), t[14] = 2 * i * n * s) : (t[10] = -1, t[14] = -2 * n), t;\n      }\n      function u(t, e, r, n, i, s, a) {\n        var o = 1 / (e - r),\n          l = 1 / (n - i),\n          u = 1 / (s - a);\n        return t[0] = -2 * o, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = -2 * l, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 2 * u, t[11] = 0, t[12] = (e + r) * o, t[13] = (i + n) * l, t[14] = (a + s) * u, t[15] = 1, t;\n      }\n      function c(t, e, r) {\n        return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t[3] = e[3] - r[3], t[4] = e[4] - r[4], t[5] = e[5] - r[5], t[6] = e[6] - r[6], t[7] = e[7] - r[7], t[8] = e[8] - r[8], t[9] = e[9] - r[9], t[10] = e[10] - r[10], t[11] = e[11] - r[11], t[12] = e[12] - r[12], t[13] = e[13] - r[13], t[14] = e[14] - r[14], t[15] = e[15] - r[15], t;\n      }\n      return y.perspective = l, y.ortho = u, y.mul = i, y.sub = c, y;\n    }\n    var x,\n      v = {},\n      b = {};\n    function _() {\n      if (x) return b;\n      function t(e) {\n        return t = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n          return typeof t;\n        } : function (t) {\n          return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n        }, t(e);\n      }\n      x = 1, Object.defineProperty(b, \"__esModule\", {\n        value: !0\n      }), b.create = n, b.clone = function (t) {\n        var r = new e.ARRAY_TYPE(3);\n        return r[0] = t[0], r[1] = t[1], r[2] = t[2], r;\n      }, b.length = i, b.fromValues = function (t, r, n) {\n        var i = new e.ARRAY_TYPE(3);\n        return i[0] = t, i[1] = r, i[2] = n, i;\n      }, b.copy = function (t, e) {\n        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t;\n      }, b.set = function (t, e, r, n) {\n        return t[0] = e, t[1] = r, t[2] = n, t;\n      }, b.add = function (t, e, r) {\n        return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t;\n      }, b.subtract = a, b.multiply = o, b.divide = l, b.ceil = function (t, e) {\n        return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t[2] = Math.ceil(e[2]), t;\n      }, b.floor = function (t, e) {\n        return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t[2] = Math.floor(e[2]), t;\n      }, b.min = function (t, e, r) {\n        return t[0] = Math.min(e[0], r[0]), t[1] = Math.min(e[1], r[1]), t[2] = Math.min(e[2], r[2]), t;\n      }, b.max = function (t, e, r) {\n        return t[0] = Math.max(e[0], r[0]), t[1] = Math.max(e[1], r[1]), t[2] = Math.max(e[2], r[2]), t;\n      }, b.round = function (t, e) {\n        return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t[2] = Math.round(e[2]), t;\n      }, b.scale = function (t, e, r) {\n        return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t;\n      }, b.scaleAndAdd = function (t, e, r, n) {\n        return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t[2] = e[2] + r[2] * n, t;\n      }, b.distance = u, b.squaredDistance = c, b.squaredLength = h, b.negate = function (t, e) {\n        return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t;\n      }, b.inverse = function (t, e) {\n        return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t;\n      }, b.normalize = function (t, e) {\n        var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = r * r + n * n + i * i;\n        return s > 0 && (s = 1 / Math.sqrt(s)), t[0] = e[0] * s, t[1] = e[1] * s, t[2] = e[2] * s, t;\n      }, b.dot = p, b.cross = function (t, e, r) {\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = r[0],\n          o = r[1],\n          l = r[2];\n        return t[0] = i * l - s * o, t[1] = s * a - n * l, t[2] = n * o - i * a, t;\n      }, b.lerp = function (t, e, r, n) {\n        var i = e[0],\n          s = e[1],\n          a = e[2];\n        return t[0] = i + n * (r[0] - i), t[1] = s + n * (r[1] - s), t[2] = a + n * (r[2] - a), t;\n      }, b.hermite = function (t, e, r, n, i, s) {\n        var a = s * s,\n          o = a * (2 * s - 3) + 1,\n          l = a * (s - 2) + s,\n          u = a * (s - 1),\n          c = a * (3 - 2 * s);\n        return t[0] = e[0] * o + r[0] * l + n[0] * u + i[0] * c, t[1] = e[1] * o + r[1] * l + n[1] * u + i[1] * c, t[2] = e[2] * o + r[2] * l + n[2] * u + i[2] * c, t;\n      }, b.bezier = function (t, e, r, n, i, s) {\n        var a = 1 - s,\n          o = a * a,\n          l = s * s,\n          u = o * a,\n          c = 3 * s * o,\n          h = 3 * l * a,\n          p = l * s;\n        return t[0] = e[0] * u + r[0] * c + n[0] * h + i[0] * p, t[1] = e[1] * u + r[1] * c + n[1] * h + i[1] * p, t[2] = e[2] * u + r[2] * c + n[2] * h + i[2] * p, t;\n      }, b.random = function (t, r) {\n        r = r || 1;\n        var n = 2 * e.RANDOM() * Math.PI,\n          i = 2 * e.RANDOM() - 1,\n          s = Math.sqrt(1 - i * i) * r;\n        return t[0] = Math.cos(n) * s, t[1] = Math.sin(n) * s, t[2] = i * r, t;\n      }, b.transformMat4 = function (t, e, r) {\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = r[3] * n + r[7] * i + r[11] * s + r[15];\n        return t[0] = (r[0] * n + r[4] * i + r[8] * s + r[12]) / (a = a || 1), t[1] = (r[1] * n + r[5] * i + r[9] * s + r[13]) / a, t[2] = (r[2] * n + r[6] * i + r[10] * s + r[14]) / a, t;\n      }, b.transformMat3 = function (t, e, r) {\n        var n = e[0],\n          i = e[1],\n          s = e[2];\n        return t[0] = n * r[0] + i * r[3] + s * r[6], t[1] = n * r[1] + i * r[4] + s * r[7], t[2] = n * r[2] + i * r[5] + s * r[8], t;\n      }, b.transformQuat = function (t, e, r) {\n        var n = r[0],\n          i = r[1],\n          s = r[2],\n          a = e[0],\n          o = e[1],\n          l = e[2],\n          u = i * l - s * o,\n          c = s * a - n * l,\n          h = n * o - i * a,\n          p = i * h - s * c,\n          f = s * u - n * h,\n          d = n * c - i * u,\n          m = 2 * r[3];\n        return c *= m, h *= m, f *= 2, d *= 2, t[0] = a + (u *= m) + (p *= 2), t[1] = o + c + f, t[2] = l + h + d, t;\n      }, b.rotateX = function (t, e, r, n) {\n        var i = [],\n          s = [];\n        return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], s[0] = i[0], s[1] = i[1] * Math.cos(n) - i[2] * Math.sin(n), s[2] = i[1] * Math.sin(n) + i[2] * Math.cos(n), t[0] = s[0] + r[0], t[1] = s[1] + r[1], t[2] = s[2] + r[2], t;\n      }, b.rotateY = function (t, e, r, n) {\n        var i = [],\n          s = [];\n        return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], s[0] = i[2] * Math.sin(n) + i[0] * Math.cos(n), s[1] = i[1], s[2] = i[2] * Math.cos(n) - i[0] * Math.sin(n), t[0] = s[0] + r[0], t[1] = s[1] + r[1], t[2] = s[2] + r[2], t;\n      }, b.rotateZ = function (t, e, r, n) {\n        var i = [],\n          s = [];\n        return i[0] = e[0] - r[0], i[1] = e[1] - r[1], i[2] = e[2] - r[2], s[0] = i[0] * Math.cos(n) - i[1] * Math.sin(n), s[1] = i[0] * Math.sin(n) + i[1] * Math.cos(n), s[2] = i[2], t[0] = s[0] + r[0], t[1] = s[1] + r[1], t[2] = s[2] + r[2], t;\n      }, b.angle = function (t, e) {\n        var r = t[0],\n          n = t[1],\n          i = t[2],\n          s = e[0],\n          a = e[1],\n          o = e[2],\n          l = Math.sqrt(r * r + n * n + i * i) * Math.sqrt(s * s + a * a + o * o),\n          u = l && p(t, e) / l;\n        return Math.acos(Math.min(Math.max(u, -1), 1));\n      }, b.zero = function (t) {\n        return t[0] = 0, t[1] = 0, t[2] = 0, t;\n      }, b.str = function (t) {\n        return \"vec3(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \")\";\n      }, b.exactEquals = function (t, e) {\n        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2];\n      }, b.equals = function (t, r) {\n        var n = t[0],\n          i = t[1],\n          s = t[2],\n          a = r[0],\n          o = r[1],\n          l = r[2];\n        return Math.abs(n - a) <= e.EPSILON * Math.max(1, Math.abs(n), Math.abs(a)) && Math.abs(i - o) <= e.EPSILON * Math.max(1, Math.abs(i), Math.abs(o)) && Math.abs(s - l) <= e.EPSILON * Math.max(1, Math.abs(s), Math.abs(l));\n      }, b.forEach = b.sqrLen = b.len = b.sqrDist = b.dist = b.div = b.mul = b.sub = void 0;\n      var e = function (e, n) {\n        if (e && e.__esModule) return e;\n        if (null === e || \"object\" !== t(e) && \"function\" != typeof e) return {\n          default: e\n        };\n        var i = r(void 0);\n        if (i && i.has(e)) return i.get(e);\n        var s = {},\n          a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (var o in e) if (\"default\" !== o && Object.prototype.hasOwnProperty.call(e, o)) {\n          var l = a ? Object.getOwnPropertyDescriptor(e, o) : null;\n          l && (l.get || l.set) ? Object.defineProperty(s, o, l) : s[o] = e[o];\n        }\n        return s.default = e, i && i.set(e, s), s;\n      }(s());\n      function r(t) {\n        if (\"function\" != typeof WeakMap) return null;\n        var e = new WeakMap(),\n          n = new WeakMap();\n        return (r = function (t) {\n          return t ? n : e;\n        })(t);\n      }\n      function n() {\n        var t = new e.ARRAY_TYPE(3);\n        return e.ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t;\n      }\n      function i(t) {\n        return Math.hypot(t[0], t[1], t[2]);\n      }\n      function a(t, e, r) {\n        return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t;\n      }\n      function o(t, e, r) {\n        return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t[2] = e[2] * r[2], t;\n      }\n      function l(t, e, r) {\n        return t[0] = e[0] / r[0], t[1] = e[1] / r[1], t[2] = e[2] / r[2], t;\n      }\n      function u(t, e) {\n        return Math.hypot(e[0] - t[0], e[1] - t[1], e[2] - t[2]);\n      }\n      function c(t, e) {\n        var r = e[0] - t[0],\n          n = e[1] - t[1],\n          i = e[2] - t[2];\n        return r * r + n * n + i * i;\n      }\n      function h(t) {\n        var e = t[0],\n          r = t[1],\n          n = t[2];\n        return e * e + r * r + n * n;\n      }\n      function p(t, e) {\n        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2];\n      }\n      b.sub = a, b.mul = o, b.div = l, b.dist = u, b.sqrDist = c, b.len = i, b.sqrLen = h;\n      var f,\n        d = (f = n(), function (t, e, r, n, i, s) {\n          var a, o;\n          for (e || (e = 3), r || (r = 0), o = n ? Math.min(n * e + r, t.length) : t.length, a = r; a < o; a += e) f[0] = t[a], f[1] = t[a + 1], f[2] = t[a + 2], i(f, f, s), t[a] = f[0], t[a + 1] = f[1], t[a + 2] = f[2];\n          return t;\n        });\n      return b.forEach = d, b;\n    }\n    var w,\n      M,\n      A = {};\n    function I() {\n      if (w) return A;\n      function t(e) {\n        return t = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n          return typeof t;\n        } : function (t) {\n          return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n        }, t(e);\n      }\n      w = 1, Object.defineProperty(A, \"__esModule\", {\n        value: !0\n      }), A.create = n, A.clone = function (t) {\n        var r = new e.ARRAY_TYPE(4);\n        return r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r;\n      }, A.fromValues = function (t, r, n, i) {\n        var s = new e.ARRAY_TYPE(4);\n        return s[0] = t, s[1] = r, s[2] = n, s[3] = i, s;\n      }, A.copy = function (t, e) {\n        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t;\n      }, A.set = function (t, e, r, n, i) {\n        return t[0] = e, t[1] = r, t[2] = n, t[3] = i, t;\n      }, A.add = function (t, e, r) {\n        return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t[3] = e[3] + r[3], t;\n      }, A.subtract = i, A.multiply = a, A.divide = o, A.ceil = function (t, e) {\n        return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t[2] = Math.ceil(e[2]), t[3] = Math.ceil(e[3]), t;\n      }, A.floor = function (t, e) {\n        return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t[2] = Math.floor(e[2]), t[3] = Math.floor(e[3]), t;\n      }, A.min = function (t, e, r) {\n        return t[0] = Math.min(e[0], r[0]), t[1] = Math.min(e[1], r[1]), t[2] = Math.min(e[2], r[2]), t[3] = Math.min(e[3], r[3]), t;\n      }, A.max = function (t, e, r) {\n        return t[0] = Math.max(e[0], r[0]), t[1] = Math.max(e[1], r[1]), t[2] = Math.max(e[2], r[2]), t[3] = Math.max(e[3], r[3]), t;\n      }, A.round = function (t, e) {\n        return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t[2] = Math.round(e[2]), t[3] = Math.round(e[3]), t;\n      }, A.scale = function (t, e, r) {\n        return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t;\n      }, A.scaleAndAdd = function (t, e, r, n) {\n        return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t[2] = e[2] + r[2] * n, t[3] = e[3] + r[3] * n, t;\n      }, A.distance = l, A.squaredDistance = u, A.length = c, A.squaredLength = h, A.negate = function (t, e) {\n        return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = -e[3], t;\n      }, A.inverse = function (t, e) {\n        return t[0] = 1 / e[0], t[1] = 1 / e[1], t[2] = 1 / e[2], t[3] = 1 / e[3], t;\n      }, A.normalize = function (t, e) {\n        var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = e[3],\n          a = r * r + n * n + i * i + s * s;\n        return a > 0 && (a = 1 / Math.sqrt(a)), t[0] = r * a, t[1] = n * a, t[2] = i * a, t[3] = s * a, t;\n      }, A.dot = function (t, e) {\n        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] + t[3] * e[3];\n      }, A.cross = function (t, e, r, n) {\n        var i = r[0] * n[1] - r[1] * n[0],\n          s = r[0] * n[2] - r[2] * n[0],\n          a = r[0] * n[3] - r[3] * n[0],\n          o = r[1] * n[2] - r[2] * n[1],\n          l = r[1] * n[3] - r[3] * n[1],\n          u = r[2] * n[3] - r[3] * n[2],\n          c = e[0],\n          h = e[1],\n          p = e[2],\n          f = e[3];\n        return t[0] = h * u - p * l + f * o, t[1] = -c * u + p * a - f * s, t[2] = c * l - h * a + f * i, t[3] = -c * o + h * s - p * i, t;\n      }, A.lerp = function (t, e, r, n) {\n        var i = e[0],\n          s = e[1],\n          a = e[2],\n          o = e[3];\n        return t[0] = i + n * (r[0] - i), t[1] = s + n * (r[1] - s), t[2] = a + n * (r[2] - a), t[3] = o + n * (r[3] - o), t;\n      }, A.random = function (t, r) {\n        var n, i, s, a, o, l;\n        r = r || 1;\n        do {\n          o = (n = 2 * e.RANDOM() - 1) * n + (i = 2 * e.RANDOM() - 1) * i;\n        } while (o >= 1);\n        do {\n          l = (s = 2 * e.RANDOM() - 1) * s + (a = 2 * e.RANDOM() - 1) * a;\n        } while (l >= 1);\n        var u = Math.sqrt((1 - o) / l);\n        return t[0] = r * n, t[1] = r * i, t[2] = r * s * u, t[3] = r * a * u, t;\n      }, A.transformMat4 = function (t, e, r) {\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3];\n        return t[0] = r[0] * n + r[4] * i + r[8] * s + r[12] * a, t[1] = r[1] * n + r[5] * i + r[9] * s + r[13] * a, t[2] = r[2] * n + r[6] * i + r[10] * s + r[14] * a, t[3] = r[3] * n + r[7] * i + r[11] * s + r[15] * a, t;\n      }, A.transformQuat = function (t, e, r) {\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = r[0],\n          o = r[1],\n          l = r[2],\n          u = r[3],\n          c = u * n + o * s - l * i,\n          h = u * i + l * n - a * s,\n          p = u * s + a * i - o * n,\n          f = -a * n - o * i - l * s;\n        return t[0] = c * u + f * -a + h * -l - p * -o, t[1] = h * u + f * -o + p * -a - c * -l, t[2] = p * u + f * -l + c * -o - h * -a, t[3] = e[3], t;\n      }, A.zero = function (t) {\n        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t;\n      }, A.str = function (t) {\n        return \"vec4(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \")\";\n      }, A.exactEquals = function (t, e) {\n        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3];\n      }, A.equals = function (t, r) {\n        var n = t[0],\n          i = t[1],\n          s = t[2],\n          a = t[3],\n          o = r[0],\n          l = r[1],\n          u = r[2],\n          c = r[3];\n        return Math.abs(n - o) <= e.EPSILON * Math.max(1, Math.abs(n), Math.abs(o)) && Math.abs(i - l) <= e.EPSILON * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(s - u) <= e.EPSILON * Math.max(1, Math.abs(s), Math.abs(u)) && Math.abs(a - c) <= e.EPSILON * Math.max(1, Math.abs(a), Math.abs(c));\n      }, A.forEach = A.sqrLen = A.len = A.sqrDist = A.dist = A.div = A.mul = A.sub = void 0;\n      var e = function (e, n) {\n        if (e && e.__esModule) return e;\n        if (null === e || \"object\" !== t(e) && \"function\" != typeof e) return {\n          default: e\n        };\n        var i = r(void 0);\n        if (i && i.has(e)) return i.get(e);\n        var s = {},\n          a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (var o in e) if (\"default\" !== o && Object.prototype.hasOwnProperty.call(e, o)) {\n          var l = a ? Object.getOwnPropertyDescriptor(e, o) : null;\n          l && (l.get || l.set) ? Object.defineProperty(s, o, l) : s[o] = e[o];\n        }\n        return s.default = e, i && i.set(e, s), s;\n      }(s());\n      function r(t) {\n        if (\"function\" != typeof WeakMap) return null;\n        var e = new WeakMap(),\n          n = new WeakMap();\n        return (r = function (t) {\n          return t ? n : e;\n        })(t);\n      }\n      function n() {\n        var t = new e.ARRAY_TYPE(4);\n        return e.ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0), t;\n      }\n      function i(t, e, r) {\n        return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t[2] = e[2] - r[2], t[3] = e[3] - r[3], t;\n      }\n      function a(t, e, r) {\n        return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t[2] = e[2] * r[2], t[3] = e[3] * r[3], t;\n      }\n      function o(t, e, r) {\n        return t[0] = e[0] / r[0], t[1] = e[1] / r[1], t[2] = e[2] / r[2], t[3] = e[3] / r[3], t;\n      }\n      function l(t, e) {\n        return Math.hypot(e[0] - t[0], e[1] - t[1], e[2] - t[2], e[3] - t[3]);\n      }\n      function u(t, e) {\n        var r = e[0] - t[0],\n          n = e[1] - t[1],\n          i = e[2] - t[2],\n          s = e[3] - t[3];\n        return r * r + n * n + i * i + s * s;\n      }\n      function c(t) {\n        return Math.hypot(t[0], t[1], t[2], t[3]);\n      }\n      function h(t) {\n        var e = t[0],\n          r = t[1],\n          n = t[2],\n          i = t[3];\n        return e * e + r * r + n * n + i * i;\n      }\n      A.sub = i, A.mul = a, A.div = o, A.dist = l, A.sqrDist = u, A.len = c, A.sqrLen = h;\n      var p,\n        f = (p = n(), function (t, e, r, n, i, s) {\n          var a, o;\n          for (e || (e = 4), r || (r = 0), o = n ? Math.min(n * e + r, t.length) : t.length, a = r; a < o; a += e) p[0] = t[a], p[1] = t[a + 1], p[2] = t[a + 2], p[3] = t[a + 3], i(p, p, s), t[a] = p[0], t[a + 1] = p[1], t[a + 2] = p[2], t[a + 3] = p[3];\n          return t;\n        });\n      return A.forEach = f, A;\n    }\n    function S() {\n      if (M) return v;\n      function t(e) {\n        return t = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n          return typeof t;\n        } : function (t) {\n          return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n        }, t(e);\n      }\n      M = 1, Object.defineProperty(v, \"__esModule\", {\n        value: !0\n      }), v.create = l, v.identity = function (t) {\n        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t;\n      }, v.setAxisAngle = u, v.getAxisAngle = function (t, r) {\n        var n = 2 * Math.acos(r[3]),\n          i = Math.sin(n / 2);\n        return i > e.EPSILON ? (t[0] = r[0] / i, t[1] = r[1] / i, t[2] = r[2] / i) : (t[0] = 1, t[1] = 0, t[2] = 0), n;\n      }, v.getAngle = function (t, e) {\n        var r = g(t, e);\n        return Math.acos(2 * r * r - 1);\n      }, v.multiply = c, v.rotateX = function (t, e, r) {\n        r *= .5;\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = Math.sin(r),\n          l = Math.cos(r);\n        return t[0] = n * l + a * o, t[1] = i * l + s * o, t[2] = s * l - i * o, t[3] = a * l - n * o, t;\n      }, v.rotateY = function (t, e, r) {\n        r *= .5;\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = Math.sin(r),\n          l = Math.cos(r);\n        return t[0] = n * l - s * o, t[1] = i * l + a * o, t[2] = s * l + n * o, t[3] = a * l - i * o, t;\n      }, v.rotateZ = function (t, e, r) {\n        r *= .5;\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = Math.sin(r),\n          l = Math.cos(r);\n        return t[0] = n * l + i * o, t[1] = i * l - n * o, t[2] = s * l + a * o, t[3] = a * l - s * o, t;\n      }, v.calculateW = function (t, e) {\n        var r = e[0],\n          n = e[1],\n          i = e[2];\n        return t[0] = r, t[1] = n, t[2] = i, t[3] = Math.sqrt(Math.abs(1 - r * r - n * n - i * i)), t;\n      }, v.exp = h, v.ln = p, v.pow = function (t, e, r) {\n        return p(t, e), y(t, t, r), h(t, t), t;\n      }, v.slerp = f, v.random = function (t) {\n        var r = e.RANDOM(),\n          n = e.RANDOM(),\n          i = e.RANDOM(),\n          s = Math.sqrt(1 - r),\n          a = Math.sqrt(r);\n        return t[0] = s * Math.sin(2 * Math.PI * n), t[1] = s * Math.cos(2 * Math.PI * n), t[2] = a * Math.sin(2 * Math.PI * i), t[3] = a * Math.cos(2 * Math.PI * i), t;\n      }, v.invert = function (t, e) {\n        var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = e[3],\n          a = r * r + n * n + i * i + s * s,\n          o = a ? 1 / a : 0;\n        return t[0] = -r * o, t[1] = -n * o, t[2] = -i * o, t[3] = s * o, t;\n      }, v.conjugate = function (t, e) {\n        return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t;\n      }, v.fromMat3 = m, v.fromEuler = function (t, e, r, n) {\n        var i = .5 * Math.PI / 180;\n        e *= i, r *= i, n *= i;\n        var s = Math.sin(e),\n          a = Math.cos(e),\n          o = Math.sin(r),\n          l = Math.cos(r),\n          u = Math.sin(n),\n          c = Math.cos(n);\n        return t[0] = s * l * c - a * o * u, t[1] = a * o * c + s * l * u, t[2] = a * l * u - s * o * c, t[3] = a * l * c + s * o * u, t;\n      }, v.str = function (t) {\n        return \"quat(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \")\";\n      }, v.setAxes = v.sqlerp = v.rotationTo = v.equals = v.exactEquals = v.normalize = v.sqrLen = v.squaredLength = v.len = v.length = v.lerp = v.dot = v.scale = v.mul = v.add = v.set = v.copy = v.fromValues = v.clone = void 0;\n      var e = o(s()),\n        r = o(d()),\n        n = o(_()),\n        i = o(I());\n      function a(t) {\n        if (\"function\" != typeof WeakMap) return null;\n        var e = new WeakMap(),\n          r = new WeakMap();\n        return (a = function (t) {\n          return t ? r : e;\n        })(t);\n      }\n      function o(e, r) {\n        if (e && e.__esModule) return e;\n        if (null === e || \"object\" !== t(e) && \"function\" != typeof e) return {\n          default: e\n        };\n        var n = a(r);\n        if (n && n.has(e)) return n.get(e);\n        var i = {},\n          s = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (var o in e) if (\"default\" !== o && Object.prototype.hasOwnProperty.call(e, o)) {\n          var l = s ? Object.getOwnPropertyDescriptor(e, o) : null;\n          l && (l.get || l.set) ? Object.defineProperty(i, o, l) : i[o] = e[o];\n        }\n        return i.default = e, n && n.set(e, i), i;\n      }\n      function l() {\n        var t = new e.ARRAY_TYPE(4);\n        return e.ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0), t[3] = 1, t;\n      }\n      function u(t, e, r) {\n        r *= .5;\n        var n = Math.sin(r);\n        return t[0] = n * e[0], t[1] = n * e[1], t[2] = n * e[2], t[3] = Math.cos(r), t;\n      }\n      function c(t, e, r) {\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = r[0],\n          l = r[1],\n          u = r[2],\n          c = r[3];\n        return t[0] = n * c + a * o + i * u - s * l, t[1] = i * c + a * l + s * o - n * u, t[2] = s * c + a * u + n * l - i * o, t[3] = a * c - n * o - i * l - s * u, t;\n      }\n      function h(t, e) {\n        var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = e[3],\n          a = Math.sqrt(r * r + n * n + i * i),\n          o = Math.exp(s),\n          l = a > 0 ? o * Math.sin(a) / a : 0;\n        return t[0] = r * l, t[1] = n * l, t[2] = i * l, t[3] = o * Math.cos(a), t;\n      }\n      function p(t, e) {\n        var r = e[0],\n          n = e[1],\n          i = e[2],\n          s = e[3],\n          a = Math.sqrt(r * r + n * n + i * i),\n          o = a > 0 ? Math.atan2(a, s) / a : 0;\n        return t[0] = r * o, t[1] = n * o, t[2] = i * o, t[3] = .5 * Math.log(r * r + n * n + i * i + s * s), t;\n      }\n      function f(t, r, n, i) {\n        var s,\n          a,\n          o,\n          l,\n          u,\n          c = r[0],\n          h = r[1],\n          p = r[2],\n          f = r[3],\n          d = n[0],\n          m = n[1],\n          y = n[2],\n          g = n[3];\n        return (a = c * d + h * m + p * y + f * g) < 0 && (a = -a, d = -d, m = -m, y = -y, g = -g), 1 - a > e.EPSILON ? (s = Math.acos(a), o = Math.sin(s), l = Math.sin((1 - i) * s) / o, u = Math.sin(i * s) / o) : (l = 1 - i, u = i), t[0] = l * c + u * d, t[1] = l * h + u * m, t[2] = l * p + u * y, t[3] = l * f + u * g, t;\n      }\n      function m(t, e) {\n        var r,\n          n = e[0] + e[4] + e[8];\n        if (n > 0) r = Math.sqrt(n + 1), t[3] = .5 * r, t[0] = (e[5] - e[7]) * (r = .5 / r), t[1] = (e[6] - e[2]) * r, t[2] = (e[1] - e[3]) * r;else {\n          var i = 0;\n          e[4] > e[0] && (i = 1), e[8] > e[3 * i + i] && (i = 2);\n          var s = (i + 1) % 3,\n            a = (i + 2) % 3;\n          r = Math.sqrt(e[3 * i + i] - e[3 * s + s] - e[3 * a + a] + 1), t[i] = .5 * r, t[3] = (e[3 * s + a] - e[3 * a + s]) * (r = .5 / r), t[s] = (e[3 * s + i] + e[3 * i + s]) * r, t[a] = (e[3 * a + i] + e[3 * i + a]) * r;\n        }\n        return t;\n      }\n      v.clone = i.clone, v.fromValues = i.fromValues, v.copy = i.copy, v.set = i.set, v.add = i.add, v.mul = c;\n      var y = i.scale;\n      v.scale = y;\n      var g = i.dot;\n      v.dot = g, v.lerp = i.lerp;\n      var x = i.length;\n      v.length = x, v.len = x;\n      var b = i.squaredLength;\n      v.squaredLength = b, v.sqrLen = b;\n      var w = i.normalize;\n      v.normalize = w, v.exactEquals = i.exactEquals, v.equals = i.equals;\n      var A,\n        S,\n        P,\n        E = (A = n.create(), S = n.fromValues(1, 0, 0), P = n.fromValues(0, 1, 0), function (t, e, r) {\n          var i = n.dot(e, r);\n          return i < -.999999 ? (n.cross(A, S, e), n.len(A) < 1e-6 && n.cross(A, P, e), n.normalize(A, A), u(t, A, Math.PI), t) : i > .999999 ? (t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t) : (n.cross(A, e, r), t[0] = A[0], t[1] = A[1], t[2] = A[2], t[3] = 1 + i, w(t, t));\n        });\n      v.rotationTo = E;\n      var z,\n        k,\n        T = (z = l(), k = l(), function (t, e, r, n, i, s) {\n          return f(z, e, i, s), f(k, r, n, s), f(t, z, k, 2 * s * (1 - s)), t;\n        });\n      v.sqlerp = T;\n      var B,\n        V = (B = r.create(), function (t, e, r, n) {\n          return B[0] = r[0], B[3] = r[1], B[6] = r[2], B[1] = n[0], B[4] = n[1], B[7] = n[2], B[2] = -e[0], B[5] = -e[1], B[8] = -e[2], w(t, m(t, B));\n        });\n      return v.setAxes = V, v;\n    }\n    var P,\n      E = {};\n    function z() {\n      if (P) return E;\n      function t(e) {\n        return t = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n          return typeof t;\n        } : function (t) {\n          return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n        }, t(e);\n      }\n      P = 1, Object.defineProperty(E, \"__esModule\", {\n        value: !0\n      }), E.create = function () {\n        var t = new e.ARRAY_TYPE(8);\n        return e.ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0, t[2] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0), t[3] = 1, t;\n      }, E.clone = function (t) {\n        var r = new e.ARRAY_TYPE(8);\n        return r[0] = t[0], r[1] = t[1], r[2] = t[2], r[3] = t[3], r[4] = t[4], r[5] = t[5], r[6] = t[6], r[7] = t[7], r;\n      }, E.fromValues = function (t, r, n, i, s, a, o, l) {\n        var u = new e.ARRAY_TYPE(8);\n        return u[0] = t, u[1] = r, u[2] = n, u[3] = i, u[4] = s, u[5] = a, u[6] = o, u[7] = l, u;\n      }, E.fromRotationTranslationValues = function (t, r, n, i, s, a, o) {\n        var l = new e.ARRAY_TYPE(8);\n        l[0] = t, l[1] = r, l[2] = n, l[3] = i;\n        var u = .5 * s,\n          c = .5 * a,\n          h = .5 * o;\n        return l[4] = u * i + c * n - h * r, l[5] = c * i + h * t - u * n, l[6] = h * i + u * r - c * t, l[7] = -u * t - c * r - h * n, l;\n      }, E.fromRotationTranslation = o, E.fromTranslation = function (t, e) {\n        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = .5 * e[0], t[5] = .5 * e[1], t[6] = .5 * e[2], t[7] = 0, t;\n      }, E.fromRotation = function (t, e) {\n        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t;\n      }, E.fromMat4 = function (t, i) {\n        var s = r.create();\n        n.getRotation(s, i);\n        var a = new e.ARRAY_TYPE(3);\n        return n.getTranslation(a, i), o(t, s, a), t;\n      }, E.copy = l, E.identity = function (t) {\n        return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t;\n      }, E.set = function (t, e, r, n, i, s, a, o, l) {\n        return t[0] = e, t[1] = r, t[2] = n, t[3] = i, t[4] = s, t[5] = a, t[6] = o, t[7] = l, t;\n      }, E.getDual = function (t, e) {\n        return t[0] = e[4], t[1] = e[5], t[2] = e[6], t[3] = e[7], t;\n      }, E.setDual = function (t, e) {\n        return t[4] = e[0], t[5] = e[1], t[6] = e[2], t[7] = e[3], t;\n      }, E.getTranslation = function (t, e) {\n        var r = e[4],\n          n = e[5],\n          i = e[6],\n          s = e[7],\n          a = -e[0],\n          o = -e[1],\n          l = -e[2],\n          u = e[3];\n        return t[0] = 2 * (r * u + s * a + n * l - i * o), t[1] = 2 * (n * u + s * o + i * a - r * l), t[2] = 2 * (i * u + s * l + r * o - n * a), t;\n      }, E.translate = function (t, e, r) {\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = .5 * r[0],\n          l = .5 * r[1],\n          u = .5 * r[2],\n          c = e[4],\n          h = e[5],\n          p = e[6],\n          f = e[7];\n        return t[0] = n, t[1] = i, t[2] = s, t[3] = a, t[4] = a * o + i * u - s * l + c, t[5] = a * l + s * o - n * u + h, t[6] = a * u + n * l - i * o + p, t[7] = -n * o - i * l - s * u + f, t;\n      }, E.rotateX = function (t, e, n) {\n        var i = -e[0],\n          s = -e[1],\n          a = -e[2],\n          o = e[3],\n          l = e[4],\n          u = e[5],\n          c = e[6],\n          h = e[7],\n          p = l * o + h * i + u * a - c * s,\n          f = u * o + h * s + c * i - l * a,\n          d = c * o + h * a + l * s - u * i,\n          m = h * o - l * i - u * s - c * a;\n        return r.rotateX(t, e, n), t[4] = p * (o = t[3]) + m * (i = t[0]) + f * (a = t[2]) - d * (s = t[1]), t[5] = f * o + m * s + d * i - p * a, t[6] = d * o + m * a + p * s - f * i, t[7] = m * o - p * i - f * s - d * a, t;\n      }, E.rotateY = function (t, e, n) {\n        var i = -e[0],\n          s = -e[1],\n          a = -e[2],\n          o = e[3],\n          l = e[4],\n          u = e[5],\n          c = e[6],\n          h = e[7],\n          p = l * o + h * i + u * a - c * s,\n          f = u * o + h * s + c * i - l * a,\n          d = c * o + h * a + l * s - u * i,\n          m = h * o - l * i - u * s - c * a;\n        return r.rotateY(t, e, n), t[4] = p * (o = t[3]) + m * (i = t[0]) + f * (a = t[2]) - d * (s = t[1]), t[5] = f * o + m * s + d * i - p * a, t[6] = d * o + m * a + p * s - f * i, t[7] = m * o - p * i - f * s - d * a, t;\n      }, E.rotateZ = function (t, e, n) {\n        var i = -e[0],\n          s = -e[1],\n          a = -e[2],\n          o = e[3],\n          l = e[4],\n          u = e[5],\n          c = e[6],\n          h = e[7],\n          p = l * o + h * i + u * a - c * s,\n          f = u * o + h * s + c * i - l * a,\n          d = c * o + h * a + l * s - u * i,\n          m = h * o - l * i - u * s - c * a;\n        return r.rotateZ(t, e, n), t[4] = p * (o = t[3]) + m * (i = t[0]) + f * (a = t[2]) - d * (s = t[1]), t[5] = f * o + m * s + d * i - p * a, t[6] = d * o + m * a + p * s - f * i, t[7] = m * o - p * i - f * s - d * a, t;\n      }, E.rotateByQuatAppend = function (t, e, r) {\n        var n = r[0],\n          i = r[1],\n          s = r[2],\n          a = r[3],\n          o = e[0],\n          l = e[1],\n          u = e[2],\n          c = e[3];\n        return t[0] = o * a + c * n + l * s - u * i, t[1] = l * a + c * i + u * n - o * s, t[2] = u * a + c * s + o * i - l * n, t[3] = c * a - o * n - l * i - u * s, t[4] = (o = e[4]) * a + (c = e[7]) * n + (l = e[5]) * s - (u = e[6]) * i, t[5] = l * a + c * i + u * n - o * s, t[6] = u * a + c * s + o * i - l * n, t[7] = c * a - o * n - l * i - u * s, t;\n      }, E.rotateByQuatPrepend = function (t, e, r) {\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = r[0],\n          l = r[1],\n          u = r[2],\n          c = r[3];\n        return t[0] = n * c + a * o + i * u - s * l, t[1] = i * c + a * l + s * o - n * u, t[2] = s * c + a * u + n * l - i * o, t[3] = a * c - n * o - i * l - s * u, t[4] = n * (c = r[7]) + a * (o = r[4]) + i * (u = r[6]) - s * (l = r[5]), t[5] = i * c + a * l + s * o - n * u, t[6] = s * c + a * u + n * l - i * o, t[7] = a * c - n * o - i * l - s * u, t;\n      }, E.rotateAroundAxis = function (t, r, n, i) {\n        if (Math.abs(i) < e.EPSILON) return l(t, r);\n        var s = Math.hypot(n[0], n[1], n[2]);\n        i *= .5;\n        var a = Math.sin(i),\n          o = a * n[0] / s,\n          u = a * n[1] / s,\n          c = a * n[2] / s,\n          h = Math.cos(i),\n          p = r[0],\n          f = r[1],\n          d = r[2],\n          m = r[3];\n        t[0] = p * h + m * o + f * c - d * u, t[1] = f * h + m * u + d * o - p * c, t[2] = d * h + m * c + p * u - f * o, t[3] = m * h - p * o - f * u - d * c;\n        var y = r[4],\n          g = r[5],\n          x = r[6],\n          v = r[7];\n        return t[4] = y * h + v * o + g * c - x * u, t[5] = g * h + v * u + x * o - y * c, t[6] = x * h + v * c + y * u - g * o, t[7] = v * h - y * o - g * u - x * c, t;\n      }, E.add = function (t, e, r) {\n        return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t[2] = e[2] + r[2], t[3] = e[3] + r[3], t[4] = e[4] + r[4], t[5] = e[5] + r[5], t[6] = e[6] + r[6], t[7] = e[7] + r[7], t;\n      }, E.multiply = u, E.scale = function (t, e, r) {\n        return t[0] = e[0] * r, t[1] = e[1] * r, t[2] = e[2] * r, t[3] = e[3] * r, t[4] = e[4] * r, t[5] = e[5] * r, t[6] = e[6] * r, t[7] = e[7] * r, t;\n      }, E.lerp = function (t, e, r, n) {\n        var i = 1 - n;\n        return c(e, r) < 0 && (n = -n), t[0] = e[0] * i + r[0] * n, t[1] = e[1] * i + r[1] * n, t[2] = e[2] * i + r[2] * n, t[3] = e[3] * i + r[3] * n, t[4] = e[4] * i + r[4] * n, t[5] = e[5] * i + r[5] * n, t[6] = e[6] * i + r[6] * n, t[7] = e[7] * i + r[7] * n, t;\n      }, E.invert = function (t, e) {\n        var r = p(e);\n        return t[0] = -e[0] / r, t[1] = -e[1] / r, t[2] = -e[2] / r, t[3] = e[3] / r, t[4] = -e[4] / r, t[5] = -e[5] / r, t[6] = -e[6] / r, t[7] = e[7] / r, t;\n      }, E.conjugate = function (t, e) {\n        return t[0] = -e[0], t[1] = -e[1], t[2] = -e[2], t[3] = e[3], t[4] = -e[4], t[5] = -e[5], t[6] = -e[6], t[7] = e[7], t;\n      }, E.normalize = function (t, e) {\n        var r = p(e);\n        if (r > 0) {\n          r = Math.sqrt(r);\n          var n = e[0] / r,\n            i = e[1] / r,\n            s = e[2] / r,\n            a = e[3] / r,\n            o = e[4],\n            l = e[5],\n            u = e[6],\n            c = e[7],\n            h = n * o + i * l + s * u + a * c;\n          t[0] = n, t[1] = i, t[2] = s, t[3] = a, t[4] = (o - n * h) / r, t[5] = (l - i * h) / r, t[6] = (u - s * h) / r, t[7] = (c - a * h) / r;\n        }\n        return t;\n      }, E.str = function (t) {\n        return \"quat2(\" + t[0] + \", \" + t[1] + \", \" + t[2] + \", \" + t[3] + \", \" + t[4] + \", \" + t[5] + \", \" + t[6] + \", \" + t[7] + \")\";\n      }, E.exactEquals = function (t, e) {\n        return t[0] === e[0] && t[1] === e[1] && t[2] === e[2] && t[3] === e[3] && t[4] === e[4] && t[5] === e[5] && t[6] === e[6] && t[7] === e[7];\n      }, E.equals = function (t, r) {\n        var n = t[0],\n          i = t[1],\n          s = t[2],\n          a = t[3],\n          o = t[4],\n          l = t[5],\n          u = t[6],\n          c = t[7],\n          h = r[0],\n          p = r[1],\n          f = r[2],\n          d = r[3],\n          m = r[4],\n          y = r[5],\n          g = r[6],\n          x = r[7];\n        return Math.abs(n - h) <= e.EPSILON * Math.max(1, Math.abs(n), Math.abs(h)) && Math.abs(i - p) <= e.EPSILON * Math.max(1, Math.abs(i), Math.abs(p)) && Math.abs(s - f) <= e.EPSILON * Math.max(1, Math.abs(s), Math.abs(f)) && Math.abs(a - d) <= e.EPSILON * Math.max(1, Math.abs(a), Math.abs(d)) && Math.abs(o - m) <= e.EPSILON * Math.max(1, Math.abs(o), Math.abs(m)) && Math.abs(l - y) <= e.EPSILON * Math.max(1, Math.abs(l), Math.abs(y)) && Math.abs(u - g) <= e.EPSILON * Math.max(1, Math.abs(u), Math.abs(g)) && Math.abs(c - x) <= e.EPSILON * Math.max(1, Math.abs(c), Math.abs(x));\n      }, E.sqrLen = E.squaredLength = E.len = E.length = E.dot = E.mul = E.setReal = E.getReal = void 0;\n      var e = a(s()),\n        r = a(S()),\n        n = a(g());\n      function i(t) {\n        if (\"function\" != typeof WeakMap) return null;\n        var e = new WeakMap(),\n          r = new WeakMap();\n        return (i = function (t) {\n          return t ? r : e;\n        })(t);\n      }\n      function a(e, r) {\n        if (e && e.__esModule) return e;\n        if (null === e || \"object\" !== t(e) && \"function\" != typeof e) return {\n          default: e\n        };\n        var n = i(r);\n        if (n && n.has(e)) return n.get(e);\n        var s = {},\n          a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (var o in e) if (\"default\" !== o && Object.prototype.hasOwnProperty.call(e, o)) {\n          var l = a ? Object.getOwnPropertyDescriptor(e, o) : null;\n          l && (l.get || l.set) ? Object.defineProperty(s, o, l) : s[o] = e[o];\n        }\n        return s.default = e, n && n.set(e, s), s;\n      }\n      function o(t, e, r) {\n        var n = .5 * r[0],\n          i = .5 * r[1],\n          s = .5 * r[2],\n          a = e[0],\n          o = e[1],\n          l = e[2],\n          u = e[3];\n        return t[0] = a, t[1] = o, t[2] = l, t[3] = u, t[4] = n * u + i * l - s * o, t[5] = i * u + s * a - n * l, t[6] = s * u + n * o - i * a, t[7] = -n * a - i * o - s * l, t;\n      }\n      function l(t, e) {\n        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t;\n      }\n      function u(t, e, r) {\n        var n = e[0],\n          i = e[1],\n          s = e[2],\n          a = e[3],\n          o = r[4],\n          l = r[5],\n          u = r[6],\n          c = r[7],\n          h = e[4],\n          p = e[5],\n          f = e[6],\n          d = e[7],\n          m = r[0],\n          y = r[1],\n          g = r[2],\n          x = r[3];\n        return t[0] = n * x + a * m + i * g - s * y, t[1] = i * x + a * y + s * m - n * g, t[2] = s * x + a * g + n * y - i * m, t[3] = a * x - n * m - i * y - s * g, t[4] = n * c + a * o + i * u - s * l + h * x + d * m + p * g - f * y, t[5] = i * c + a * l + s * o - n * u + p * x + d * y + f * m - h * g, t[6] = s * c + a * u + n * l - i * o + f * x + d * g + h * y - p * m, t[7] = a * c - n * o - i * l - s * u + d * x - h * m - p * y - f * g, t;\n      }\n      E.getReal = r.copy, E.setReal = r.copy, E.mul = u;\n      var c = r.dot;\n      E.dot = c;\n      var h = r.length;\n      E.length = h, E.len = h;\n      var p = r.squaredLength;\n      return E.squaredLength = p, E.sqrLen = p, E;\n    }\n    var k,\n      T,\n      B = {};\n    function V() {\n      if (k) return B;\n      function t(e) {\n        return t = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n          return typeof t;\n        } : function (t) {\n          return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n        }, t(e);\n      }\n      k = 1, Object.defineProperty(B, \"__esModule\", {\n        value: !0\n      }), B.create = n, B.clone = function (t) {\n        var r = new e.ARRAY_TYPE(2);\n        return r[0] = t[0], r[1] = t[1], r;\n      }, B.fromValues = function (t, r) {\n        var n = new e.ARRAY_TYPE(2);\n        return n[0] = t, n[1] = r, n;\n      }, B.copy = function (t, e) {\n        return t[0] = e[0], t[1] = e[1], t;\n      }, B.set = function (t, e, r) {\n        return t[0] = e, t[1] = r, t;\n      }, B.add = function (t, e, r) {\n        return t[0] = e[0] + r[0], t[1] = e[1] + r[1], t;\n      }, B.subtract = i, B.multiply = a, B.divide = o, B.ceil = function (t, e) {\n        return t[0] = Math.ceil(e[0]), t[1] = Math.ceil(e[1]), t;\n      }, B.floor = function (t, e) {\n        return t[0] = Math.floor(e[0]), t[1] = Math.floor(e[1]), t;\n      }, B.min = function (t, e, r) {\n        return t[0] = Math.min(e[0], r[0]), t[1] = Math.min(e[1], r[1]), t;\n      }, B.max = function (t, e, r) {\n        return t[0] = Math.max(e[0], r[0]), t[1] = Math.max(e[1], r[1]), t;\n      }, B.round = function (t, e) {\n        return t[0] = Math.round(e[0]), t[1] = Math.round(e[1]), t;\n      }, B.scale = function (t, e, r) {\n        return t[0] = e[0] * r, t[1] = e[1] * r, t;\n      }, B.scaleAndAdd = function (t, e, r, n) {\n        return t[0] = e[0] + r[0] * n, t[1] = e[1] + r[1] * n, t;\n      }, B.distance = l, B.squaredDistance = u, B.length = c, B.squaredLength = h, B.negate = function (t, e) {\n        return t[0] = -e[0], t[1] = -e[1], t;\n      }, B.inverse = function (t, e) {\n        return t[0] = 1 / e[0], t[1] = 1 / e[1], t;\n      }, B.normalize = function (t, e) {\n        var r = e[0],\n          n = e[1],\n          i = r * r + n * n;\n        return i > 0 && (i = 1 / Math.sqrt(i)), t[0] = e[0] * i, t[1] = e[1] * i, t;\n      }, B.dot = function (t, e) {\n        return t[0] * e[0] + t[1] * e[1];\n      }, B.cross = function (t, e, r) {\n        var n = e[0] * r[1] - e[1] * r[0];\n        return t[0] = t[1] = 0, t[2] = n, t;\n      }, B.lerp = function (t, e, r, n) {\n        var i = e[0],\n          s = e[1];\n        return t[0] = i + n * (r[0] - i), t[1] = s + n * (r[1] - s), t;\n      }, B.random = function (t, r) {\n        r = r || 1;\n        var n = 2 * e.RANDOM() * Math.PI;\n        return t[0] = Math.cos(n) * r, t[1] = Math.sin(n) * r, t;\n      }, B.transformMat2 = function (t, e, r) {\n        var n = e[0],\n          i = e[1];\n        return t[0] = r[0] * n + r[2] * i, t[1] = r[1] * n + r[3] * i, t;\n      }, B.transformMat2d = function (t, e, r) {\n        var n = e[0],\n          i = e[1];\n        return t[0] = r[0] * n + r[2] * i + r[4], t[1] = r[1] * n + r[3] * i + r[5], t;\n      }, B.transformMat3 = function (t, e, r) {\n        var n = e[0],\n          i = e[1];\n        return t[0] = r[0] * n + r[3] * i + r[6], t[1] = r[1] * n + r[4] * i + r[7], t;\n      }, B.transformMat4 = function (t, e, r) {\n        var n = e[0],\n          i = e[1];\n        return t[0] = r[0] * n + r[4] * i + r[12], t[1] = r[1] * n + r[5] * i + r[13], t;\n      }, B.rotate = function (t, e, r, n) {\n        var i = e[0] - r[0],\n          s = e[1] - r[1],\n          a = Math.sin(n),\n          o = Math.cos(n);\n        return t[0] = i * o - s * a + r[0], t[1] = i * a + s * o + r[1], t;\n      }, B.angle = function (t, e) {\n        var r = t[0],\n          n = t[1],\n          i = e[0],\n          s = e[1],\n          a = Math.sqrt(r * r + n * n) * Math.sqrt(i * i + s * s);\n        return Math.acos(Math.min(Math.max(a && (r * i + n * s) / a, -1), 1));\n      }, B.zero = function (t) {\n        return t[0] = 0, t[1] = 0, t;\n      }, B.str = function (t) {\n        return \"vec2(\" + t[0] + \", \" + t[1] + \")\";\n      }, B.exactEquals = function (t, e) {\n        return t[0] === e[0] && t[1] === e[1];\n      }, B.equals = function (t, r) {\n        var n = t[0],\n          i = t[1],\n          s = r[0],\n          a = r[1];\n        return Math.abs(n - s) <= e.EPSILON * Math.max(1, Math.abs(n), Math.abs(s)) && Math.abs(i - a) <= e.EPSILON * Math.max(1, Math.abs(i), Math.abs(a));\n      }, B.forEach = B.sqrLen = B.sqrDist = B.dist = B.div = B.mul = B.sub = B.len = void 0;\n      var e = function (e, n) {\n        if (e && e.__esModule) return e;\n        if (null === e || \"object\" !== t(e) && \"function\" != typeof e) return {\n          default: e\n        };\n        var i = r(void 0);\n        if (i && i.has(e)) return i.get(e);\n        var s = {},\n          a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (var o in e) if (\"default\" !== o && Object.prototype.hasOwnProperty.call(e, o)) {\n          var l = a ? Object.getOwnPropertyDescriptor(e, o) : null;\n          l && (l.get || l.set) ? Object.defineProperty(s, o, l) : s[o] = e[o];\n        }\n        return s.default = e, i && i.set(e, s), s;\n      }(s());\n      function r(t) {\n        if (\"function\" != typeof WeakMap) return null;\n        var e = new WeakMap(),\n          n = new WeakMap();\n        return (r = function (t) {\n          return t ? n : e;\n        })(t);\n      }\n      function n() {\n        var t = new e.ARRAY_TYPE(2);\n        return e.ARRAY_TYPE != Float32Array && (t[0] = 0, t[1] = 0), t;\n      }\n      function i(t, e, r) {\n        return t[0] = e[0] - r[0], t[1] = e[1] - r[1], t;\n      }\n      function a(t, e, r) {\n        return t[0] = e[0] * r[0], t[1] = e[1] * r[1], t;\n      }\n      function o(t, e, r) {\n        return t[0] = e[0] / r[0], t[1] = e[1] / r[1], t;\n      }\n      function l(t, e) {\n        return Math.hypot(e[0] - t[0], e[1] - t[1]);\n      }\n      function u(t, e) {\n        var r = e[0] - t[0],\n          n = e[1] - t[1];\n        return r * r + n * n;\n      }\n      function c(t) {\n        return Math.hypot(t[0], t[1]);\n      }\n      function h(t) {\n        var e = t[0],\n          r = t[1];\n        return e * e + r * r;\n      }\n      B.len = c, B.sub = i, B.mul = a, B.div = o, B.dist = l, B.sqrDist = u, B.sqrLen = h;\n      var p,\n        f = (p = n(), function (t, e, r, n, i, s) {\n          var a, o;\n          for (e || (e = 2), r || (r = 0), o = n ? Math.min(n * e + r, t.length) : t.length, a = r; a < o; a += e) p[0] = t[a], p[1] = t[a + 1], i(p, p, s), t[a] = p[0], t[a + 1] = p[1];\n          return t;\n        });\n      return B.forEach = f, B;\n    }\n    function C() {\n      if (T) return n;\n      function t(e) {\n        return t = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (t) {\n          return typeof t;\n        } : function (t) {\n          return t && \"function\" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? \"symbol\" : typeof t;\n        }, t(e);\n      }\n      T = 1, Object.defineProperty(n, \"__esModule\", {\n        value: !0\n      }), n.vec4 = n.vec3 = n.vec2 = n.quat2 = n.quat = n.mat4 = n.mat3 = n.mat2d = n.mat2 = n.glMatrix = void 0;\n      var e = x(s());\n      n.glMatrix = e;\n      var r = x(l());\n      n.mat2 = r;\n      var i = x(h());\n      n.mat2d = i;\n      var a = x(d());\n      n.mat3 = a;\n      var o = x(g());\n      n.mat4 = o;\n      var u = x(S());\n      n.quat = u;\n      var c = x(z());\n      n.quat2 = c;\n      var p = x(V());\n      n.vec2 = p;\n      var f = x(_());\n      n.vec3 = f;\n      var m = x(I());\n      function y(t) {\n        if (\"function\" != typeof WeakMap) return null;\n        var e = new WeakMap(),\n          r = new WeakMap();\n        return (y = function (t) {\n          return t ? r : e;\n        })(t);\n      }\n      function x(e, r) {\n        if (e && e.__esModule) return e;\n        if (null === e || \"object\" !== t(e) && \"function\" != typeof e) return {\n          default: e\n        };\n        var n = y(r);\n        if (n && n.has(e)) return n.get(e);\n        var i = {},\n          s = Object.defineProperty && Object.getOwnPropertyDescriptor;\n        for (var a in e) if (\"default\" !== a && Object.prototype.hasOwnProperty.call(e, a)) {\n          var o = s ? Object.getOwnPropertyDescriptor(e, a) : null;\n          o && (o.get || o.set) ? Object.defineProperty(i, a, o) : i[a] = e[a];\n        }\n        return i.default = e, n && n.set(e, i), i;\n      }\n      return n.vec4 = m, n;\n    }\n    var D,\n      R,\n      L,\n      F,\n      O = C(),\n      N = function () {\n        if (R) return D;\n        function t(t, e, r, n) {\n          this.cx = 3 * t, this.bx = 3 * (r - t) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e, this.by = 3 * (n - e) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t, this.p1y = e, this.p2x = r, this.p2y = n;\n        }\n        return R = 1, D = t, t.prototype = {\n          sampleCurveX: function (t) {\n            return ((this.ax * t + this.bx) * t + this.cx) * t;\n          },\n          sampleCurveY: function (t) {\n            return ((this.ay * t + this.by) * t + this.cy) * t;\n          },\n          sampleCurveDerivativeX: function (t) {\n            return (3 * this.ax * t + 2 * this.bx) * t + this.cx;\n          },\n          solveCurveX: function (t, e) {\n            if (void 0 === e && (e = 1e-6), t < 0) return 0;\n            if (t > 1) return 1;\n            for (var r = t, n = 0; n < 8; n++) {\n              var i = this.sampleCurveX(r) - t;\n              if (Math.abs(i) < e) return r;\n              var s = this.sampleCurveDerivativeX(r);\n              if (Math.abs(s) < 1e-6) break;\n              r -= i / s;\n            }\n            var a = 0,\n              o = 1;\n            for (r = t, n = 0; n < 20 && (i = this.sampleCurveX(r), !(Math.abs(i - t) < e)); n++) t > i ? a = r : o = r, r = .5 * (o - a) + a;\n            return r;\n          },\n          solve: function (t, e) {\n            return this.sampleCurveY(this.solveCurveX(t, e));\n          }\n        }, D;\n      }(),\n      U = e(N);\n    function j() {\n      if (F) return L;\n      function t(t, e) {\n        this.x = t, this.y = e;\n      }\n      return F = 1, L = t, t.prototype = {\n        clone: function () {\n          return new t(this.x, this.y);\n        },\n        add: function (t) {\n          return this.clone()._add(t);\n        },\n        sub: function (t) {\n          return this.clone()._sub(t);\n        },\n        multByPoint: function (t) {\n          return this.clone()._multByPoint(t);\n        },\n        divByPoint: function (t) {\n          return this.clone()._divByPoint(t);\n        },\n        mult: function (t) {\n          return this.clone()._mult(t);\n        },\n        div: function (t) {\n          return this.clone()._div(t);\n        },\n        rotate: function (t) {\n          return this.clone()._rotate(t);\n        },\n        rotateAround: function (t, e) {\n          return this.clone()._rotateAround(t, e);\n        },\n        matMult: function (t) {\n          return this.clone()._matMult(t);\n        },\n        unit: function () {\n          return this.clone()._unit();\n        },\n        perp: function () {\n          return this.clone()._perp();\n        },\n        round: function () {\n          return this.clone()._round();\n        },\n        mag: function () {\n          return Math.sqrt(this.x * this.x + this.y * this.y);\n        },\n        equals: function (t) {\n          return this.x === t.x && this.y === t.y;\n        },\n        dist: function (t) {\n          return Math.sqrt(this.distSqr(t));\n        },\n        distSqr: function (t) {\n          var e = t.x - this.x,\n            r = t.y - this.y;\n          return e * e + r * r;\n        },\n        angle: function () {\n          return Math.atan2(this.y, this.x);\n        },\n        angleTo: function (t) {\n          return Math.atan2(this.y - t.y, this.x - t.x);\n        },\n        angleWith: function (t) {\n          return this.angleWithSep(t.x, t.y);\n        },\n        angleWithSep: function (t, e) {\n          return Math.atan2(this.x * e - this.y * t, this.x * t + this.y * e);\n        },\n        _matMult: function (t) {\n          var e = t[2] * this.x + t[3] * this.y;\n          return this.x = t[0] * this.x + t[1] * this.y, this.y = e, this;\n        },\n        _add: function (t) {\n          return this.x += t.x, this.y += t.y, this;\n        },\n        _sub: function (t) {\n          return this.x -= t.x, this.y -= t.y, this;\n        },\n        _mult: function (t) {\n          return this.x *= t, this.y *= t, this;\n        },\n        _div: function (t) {\n          return this.x /= t, this.y /= t, this;\n        },\n        _multByPoint: function (t) {\n          return this.x *= t.x, this.y *= t.y, this;\n        },\n        _divByPoint: function (t) {\n          return this.x /= t.x, this.y /= t.y, this;\n        },\n        _unit: function () {\n          return this._div(this.mag()), this;\n        },\n        _perp: function () {\n          var t = this.y;\n          return this.y = this.x, this.x = -t, this;\n        },\n        _rotate: function (t) {\n          var e = Math.cos(t),\n            r = Math.sin(t),\n            n = r * this.x + e * this.y;\n          return this.x = e * this.x - r * this.y, this.y = n, this;\n        },\n        _rotateAround: function (t, e) {\n          var r = Math.cos(t),\n            n = Math.sin(t),\n            i = e.y + n * (this.x - e.x) + r * (this.y - e.y);\n          return this.x = e.x + r * (this.x - e.x) - n * (this.y - e.y), this.y = i, this;\n        },\n        _round: function () {\n          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;\n        }\n      }, t.convert = function (e) {\n        return e instanceof t ? e : Array.isArray(e) ? new t(e[0], e[1]) : e;\n      }, L;\n    }\n    var q = e(j());\n    function $(t, e) {\n      if (Array.isArray(t)) {\n        if (!Array.isArray(e) || t.length !== e.length) return !1;\n        for (let r = 0; r < t.length; r++) if (!$(t[r], e[r])) return !1;\n        return !0;\n      }\n      if (\"object\" == typeof t && null !== t && null !== e) {\n        if (\"object\" != typeof e) return !1;\n        if (Object.keys(t).length !== Object.keys(e).length) return !1;\n        for (const r in t) if (!$(t[r], e[r])) return !1;\n        return !0;\n      }\n      return t === e;\n    }\n    const G = Math.PI / 180,\n      Y = 180 / Math.PI;\n    function H(t) {\n      return t * G;\n    }\n    function X(t) {\n      return t * Y;\n    }\n    const Z = [[0, 0], [1, 0], [1, 1], [0, 1]];\n    function W(t) {\n      if (t <= 0) return 0;\n      if (t >= 1) return 1;\n      const e = t * t,\n        r = e * t;\n      return 4 * (t < .5 ? r : 3 * (t - e) + r - .75);\n    }\n    function K(t, e, r, n) {\n      const i = new U(t, e, r, n);\n      return function (t) {\n        return i.solve(t);\n      };\n    }\n    const J = K(.25, .1, .25, 1);\n    function Q(t, e, r) {\n      return Math.min(r, Math.max(e, t));\n    }\n    function tt(t, e, r) {\n      return (r = Q((r - t) / (e - t), 0, 1)) * r * (3 - 2 * r);\n    }\n    function et(t, e, r) {\n      const n = r - e,\n        i = ((t - e) % n + n) % n + e;\n      return i === e ? r : i;\n    }\n    function rt(t, e, r) {\n      if (!t.length) return r(null, []);\n      let n = t.length;\n      const i = new Array(t.length);\n      let s = null;\n      t.forEach((t, a) => {\n        e(t, (t, e) => {\n          t && (s = t), i[a] = e, 0 == --n && r(s, i);\n        });\n      });\n    }\n    function nt(t, ...e) {\n      for (const r of e) for (const e in r) t[e] = r[e];\n      return t;\n    }\n    let it = 1;\n    function st() {\n      return it++;\n    }\n    function at(t) {\n      return t <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));\n    }\n    function ot(t, e) {\n      t.forEach(t => {\n        e[t] && (e[t] = e[t].bind(e));\n      });\n    }\n    function lt(t, e, r) {\n      const n = {};\n      for (const r in t) n[r] = e.call(this, t[r], r, t);\n      return n;\n    }\n    function ut(t, e, r) {\n      const n = {};\n      for (const r in t) e.call(this, t[r], r, t) && (n[r] = t[r]);\n      return n;\n    }\n    function ct(t) {\n      return Array.isArray(t) ? t.map(ct) : \"object\" == typeof t && t ? lt(t, ct) : t;\n    }\n    const ht = {};\n    function pt(t) {\n      ht[t] || (\"undefined\" != typeof console && console.warn(t), ht[t] = !0);\n    }\n    function ft(t, e, r) {\n      return (r.y - t.y) * (e.x - t.x) > (e.y - t.y) * (r.x - t.x);\n    }\n    function dt(t) {\n      let e = 0;\n      for (let r, n, i = 0, s = t.length, a = s - 1; i < s; a = i++) r = t[i], n = t[a], e += (n.x - r.x) * (r.y + n.y);\n      return e;\n    }\n    function mt([t, e, r]) {\n      const n = H(e + 90),\n        i = H(r);\n      return {\n        x: t * Math.cos(n) * Math.sin(i),\n        y: t * Math.sin(n) * Math.sin(i),\n        z: t * Math.cos(i),\n        azimuthal: e,\n        polar: r\n      };\n    }\n    function yt() {\n      return \"undefined\" != typeof WorkerGlobalScope && \"undefined\" != typeof self && self instanceof WorkerGlobalScope;\n    }\n    function gt(t) {\n      const e = {};\n      if (t.replace(/(?:^|(?:\\s*\\,\\s*))([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)(?:\\=(?:([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)|(?:\\\"((?:[^\"\\\\]|\\\\.)*)\\\")))?/g, (t, r, n, i) => {\n        const s = n || i;\n        return e[r] = !s || s.toLowerCase(), \"\";\n      }), e[\"max-age\"]) {\n        const t = parseInt(e[\"max-age\"], 10);\n        isNaN(t) ? delete e[\"max-age\"] : e[\"max-age\"] = t;\n      }\n      return e;\n    }\n    let xt = null;\n    function vt(t, e) {\n      return [t[4 * e], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]];\n    }\n    function bt(t, e, r, n) {\n      for (; e < r;) {\n        const i = e + r >> 1;\n        t[i] < n ? e = i + 1 : r = i;\n      }\n      return e;\n    }\n    function _t(t, e, r, n) {\n      for (; e < r;) {\n        const i = e + r >> 1;\n        t[i] <= n ? e = i + 1 : r = i;\n      }\n      return e;\n    }\n    function wt(t) {\n      return t > 0 ? 1 / (1.001 - t) : 1 + t;\n    }\n    function Mt(t) {\n      return t > 0 ? 1 - 1 / (1.001 - t) : -t;\n    }\n    const At = {\n      API_URL: \"https://api.mapbox.com\",\n      get API_URL_REGEX() {\n        return /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/|\\?|$)/i;\n      },\n      get API_TILEJSON_REGEX() {\n        return /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/v[0-9]*\\/.*\\.json.*$)/i;\n      },\n      get API_SPRITE_REGEX() {\n        return /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/styles\\/v[0-9]*\\/)(.*\\/sprite.*\\..*$)/i;\n      },\n      get API_FONTS_REGEX() {\n        return /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/fonts\\/v[0-9]*\\/)(.*\\.pbf.*$)/i;\n      },\n      get API_STYLE_REGEX() {\n        return /^((https?:)?\\/\\/)?([^\\/]+\\.)?mapbox\\.c(n|om)(\\/styles\\/v[0-9]*\\/)(.*$)/i;\n      },\n      get API_CDN_URL_REGEX() {\n        return /^((https?:)?\\/\\/)?api\\.mapbox\\.c(n|om)(\\/mapbox-gl-js\\/)(.*$)/i;\n      },\n      get EVENTS_URL() {\n        if (!At.API_URL) return null;\n        try {\n          const t = new URL(At.API_URL);\n          return \"api.mapbox.cn\" === t.hostname ? \"https://events.mapbox.cn/events/v2\" : \"api.mapbox.com\" === t.hostname ? \"https://events.mapbox.com/events/v2\" : null;\n        } catch (t) {\n          return null;\n        }\n      },\n      SESSION_PATH: \"/map-sessions/v1\",\n      FEEDBACK_URL: \"https://apps.mapbox.com/feedback\",\n      TILE_URL_VERSION: \"v4\",\n      RASTER_URL_PREFIX: \"raster/v1\",\n      RASTERARRAYS_URL_PREFIX: \"rasterarrays/v1\",\n      REQUIRE_ACCESS_TOKEN: !0,\n      ACCESS_TOKEN: null,\n      DEFAULT_STYLE: \"mapbox://styles/mapbox/standard\",\n      MAX_PARALLEL_IMAGE_REQUESTS: 16,\n      DRACO_URL: \"https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm\",\n      MESHOPT_URL: \"https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm\",\n      MESHOPT_SIMD_URL: \"https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm\",\n      GLYPHS_URL: \"mapbox://fonts/mapbox/{fontstack}/{range}.pbf\",\n      TILES3D_URL_PREFIX: \"3dtiles/v1\"\n    };\n    function It(t) {\n      return At.API_URL_REGEX.test(t);\n    }\n    function St(t) {\n      return At.API_SPRITE_REGEX.test(t);\n    }\n    let Pt, Et, zt, kt, Tt, Bt;\n    function Vt() {\n      return null == Pt && (Pt = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext(\"2d\") && \"function\" == typeof self.createImageBitmap), Pt;\n    }\n    const Ct = {\n      now: () => void 0 !== kt ? kt : performance.now(),\n      setNow(t) {\n        kt = t;\n      },\n      restoreNow() {\n        kt = void 0;\n      },\n      frame(t) {\n        const e = requestAnimationFrame(t);\n        return {\n          cancel: () => cancelAnimationFrame(e)\n        };\n      },\n      getImageData(t, e = 0) {\n        const {\n          width: r,\n          height: n\n        } = t;\n        Tt || (Tt = document.createElement(\"canvas\"));\n        const i = Tt.getContext(\"2d\", {\n          willReadFrequently: !0\n        });\n        if (!i) throw new Error(\"failed to create canvas 2d context\");\n        return (r > Tt.width || n > Tt.height) && (Tt.width = r, Tt.height = n), i.clearRect(-e, -e, r + 2 * e, n + 2 * e), i.drawImage(t, 0, 0, r, n), i.getImageData(-e, -e, r + 2 * e, n + 2 * e);\n      },\n      resolveURL: t => (Et || (Et = document.createElement(\"a\")), Et.href = t, Et.href),\n      get devicePixelRatio() {\n        return window.devicePixelRatio;\n      },\n      get prefersReducedMotion() {\n        return !!window.matchMedia && (null == zt && (zt = window.matchMedia(\"(prefers-reduced-motion: reduce)\")), zt.matches);\n      },\n      hasCanvasFingerprintNoise() {\n        if (void 0 !== Bt) return Bt;\n        if (!Vt()) return Bt = !1, !1;\n        const t = new OffscreenCanvas(85, 1),\n          e = t.getContext(\"2d\", {\n            willReadFrequently: !0\n          });\n        let r = 0;\n        for (let n = 0; n < t.width; ++n) e.fillStyle = `rgba(${r++},${r++},${r++}, 255)`, e.fillRect(n, 0, 1, 1);\n        const n = e.getImageData(0, 0, t.width, t.height);\n        r = 0;\n        for (let t = 0; t < n.data.length; ++t) if (t % 4 != 3 && r++ !== n.data[t]) return Bt = !0, !0;\n        return Bt = !1, !1;\n      }\n    };\n    function Dt(t, e) {\n      const r = t.indexOf(\"?\");\n      if (r < 0) return `${t}?${new URLSearchParams(e).toString()}`;\n      const n = new URLSearchParams(t.slice(r));\n      for (const t in e) n.set(t, e[t]);\n      return `${t.slice(0, r)}?${n.toString()}`;\n    }\n    function Rt(t, e = {\n      persistentParams: []\n    }) {\n      const r = t.indexOf(\"?\");\n      if (r < 0) return t;\n      const n = new URLSearchParams(),\n        i = new URLSearchParams(t.slice(r));\n      for (const t of e.persistentParams) {\n        const e = i.get(t);\n        e && n.set(t, e);\n      }\n      const s = n.toString();\n      return `${t.slice(0, r)}${s.length > 0 ? `?${s}` : \"\"}`;\n    }\n    const Lt = \"mapbox-tiles\";\n    let Ft = 500,\n      Ot = 50;\n    const Nt = [\"language\", \"worldview\", \"jobid\"];\n    let Ut, jt;\n    function qt() {\n      try {\n        return caches;\n      } catch (t) {}\n    }\n    function $t() {\n      const t = qt();\n      t && null == Ut && (Ut = t.open(Lt));\n    }\n    let Gt = 1 / 0;\n    const Yt = {\n      supported: !1,\n      testSupport: function (t) {\n        !Zt && Xt && (Wt ? Jt(t) : Ht = t);\n      }\n    };\n    let Ht,\n      Xt,\n      Zt = !1,\n      Wt = !1;\n    const Kt = \"undefined\" != typeof self ? self : {};\n    function Jt(t) {\n      const e = t.createTexture();\n      t.bindTexture(t.TEXTURE_2D, e);\n      try {\n        if (t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, Xt), t.isContextLost()) return;\n        Yt.supported = !0;\n      } catch (t) {}\n      t.deleteTexture(e), Zt = !0;\n    }\n    Kt.document && (Xt = Kt.document.createElement(\"img\"), Xt.onload = function () {\n      Ht && Jt(Ht), Ht = null, Wt = !0;\n    }, Xt.onerror = function () {\n      Zt = !0, Ht = null;\n    }, Xt.src = \"data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=\");\n    const Qt = {\n      Unknown: \"Unknown\",\n      Style: \"Style\",\n      Source: \"Source\",\n      Tile: \"Tile\",\n      Glyphs: \"Glyphs\",\n      SpriteImage: \"SpriteImage\",\n      SpriteJSON: \"SpriteJSON\",\n      Iconset: \"Iconset\",\n      Image: \"Image\",\n      Model: \"Model\"\n    };\n    \"function\" == typeof Object.freeze && Object.freeze(Qt);\n    class te extends Error {\n      constructor(t, e, r) {\n        401 === e && It(r) && (t += \": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes\"), super(t), this.status = e, this.url = r;\n      }\n      toString() {\n        return `${this.name}: ${this.message} (${this.status}): ${this.url}`;\n      }\n    }\n    const ee = yt() ? () => self.worker && self.worker.referrer : () => (\"blob:\" === location.protocol ? parent : self).location.href;\n    const re = function (t, e) {\n        if (!(/^file:/.test(r = t.url) || /^file:/.test(ee()) && !/^\\w+:/.test(r))) {\n          if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty(\"signal\")) return function (t, e) {\n            const r = new AbortController(),\n              n = new Request(t.url, {\n                method: t.method || \"GET\",\n                body: t.body,\n                credentials: t.credentials,\n                headers: t.headers,\n                referrer: ee(),\n                referrerPolicy: t.referrerPolicy,\n                signal: r.signal\n              });\n            let i = !1,\n              s = !1;\n            const a = (o = n.url).indexOf(\"sku=\") > 0 && It(o);\n            var o;\n            \"json\" === t.type && n.headers.set(\"Accept\", \"application/json\");\n            const l = (r, i, o) => {\n                if (s) return;\n                if (r && \"SecurityError\" !== r.message && pt(r.toString()), i && o) return u(i);\n                const l = Date.now();\n                fetch(n).then(r => {\n                  if (r.ok) {\n                    const t = a ? r.clone() : null;\n                    return u(r, t, l);\n                  }\n                  return e(new te(r.statusText, r.status, t.url));\n                }).catch(r => {\n                  \"AbortError\" !== r.name && e(new Error(`${r.message} ${t.url}`));\n                });\n              },\n              u = (r, a, o) => {\n                (\"arrayBuffer\" === t.type ? r.arrayBuffer() : \"json\" === t.type ? r.json() : r.text()).then(t => {\n                  s || (a && o && function (t, e, r) {\n                    if ($t(), null == Ut) return;\n                    const n = gt(e.headers.get(\"Cache-Control\") || \"\");\n                    if (n[\"no-store\"]) return;\n                    const i = {\n                      status: e.status,\n                      statusText: e.statusText,\n                      headers: new Headers()\n                    };\n                    e.headers.forEach((t, e) => i.headers.set(e, t)), n[\"max-age\"] && i.headers.set(\"Expires\", new Date(r + 1e3 * n[\"max-age\"]).toUTCString());\n                    const s = i.headers.get(\"Expires\");\n                    if (!s) return;\n                    if (new Date(s).getTime() - r < 42e4) return;\n                    let a = Rt(t.url, {\n                      persistentParams: Nt\n                    });\n                    if (206 === e.status) {\n                      const e = t.headers.get(\"Range\");\n                      if (!e) return;\n                      i.status = 200, a = Dt(a, {\n                        range: e\n                      });\n                    }\n                    !function (t, e) {\n                      if (void 0 === jt) try {\n                        new Response(new ReadableStream()), jt = !0;\n                      } catch (t) {\n                        jt = !1;\n                      }\n                      jt ? e(t.body) : t.blob().then(e);\n                    }(e, t => {\n                      const r = new Response(200 !== (n = e.status) && 404 !== n && [101, 103, 204, 205, 304].includes(n) ? null : t, i);\n                      var n;\n                      $t(), null != Ut && Ut.then(t => t.put(a, r)).catch(t => pt(t.message));\n                    });\n                  }(n, a, o), i = !0, e(null, t, r.headers.get(\"Cache-Control\"), r.headers.get(\"Expires\")));\n                }).catch(t => {\n                  s || e(new Error(t.message));\n                });\n              };\n            return a ? function (t, e) {\n              if ($t(), null == Ut) return e(null);\n              Ut.then(r => {\n                let n = Rt(t.url, {\n                  persistentParams: Nt\n                });\n                const i = t.headers.get(\"Range\");\n                i && (n = Dt(n, {\n                  range: i\n                })), r.match(n).then(t => {\n                  const i = function (t) {\n                    if (!t) return !1;\n                    const e = new Date(t.headers.get(\"Expires\") || 0),\n                      r = gt(t.headers.get(\"Cache-Control\") || \"\");\n                    return e > Date.now() && !r[\"no-cache\"];\n                  }(t);\n                  r.delete(n), i && r.put(n, t.clone()), e(null, t, i);\n                }).catch(e);\n              }).catch(e);\n            }(n, l) : l(null, null), {\n              cancel: () => {\n                s = !0, i || r.abort();\n              }\n            };\n          }(t, e);\n          if (yt() && self.worker && self.worker.actor) return self.worker.actor.send(\"getResource\", t, e, void 0, !0);\n        }\n        var r;\n        return function (t, e) {\n          const r = new XMLHttpRequest();\n          r.open(t.method || \"GET\", t.url, !0), \"arrayBuffer\" === t.type && (r.responseType = \"arraybuffer\");\n          for (const e in t.headers) r.setRequestHeader(e, t.headers[e]);\n          return \"json\" === t.type && (r.responseType = \"text\", r.setRequestHeader(\"Accept\", \"application/json\")), r.withCredentials = \"include\" === t.credentials, r.onerror = () => {\n            e(new Error(r.statusText));\n          }, r.onload = () => {\n            if ((r.status >= 200 && r.status < 300 || 0 === r.status) && null !== r.response) {\n              let n = r.response;\n              if (\"json\" === t.type) try {\n                n = JSON.parse(r.response);\n              } catch (t) {\n                return e(t);\n              }\n              e(null, n, r.getResponseHeader(\"Cache-Control\"), r.getResponseHeader(\"Expires\"));\n            } else e(new te(r.statusText, r.status, t.url));\n          }, r.send(t.body), {\n            cancel: () => r.abort()\n          };\n        }(t, e);\n      },\n      ne = function (t, e) {\n        return re(nt(t, {\n          type: \"arrayBuffer\"\n        }), e);\n      };\n    function ie(t) {\n      const e = document.createElement(\"a\");\n      return e.href = t, e.protocol === location.protocol && e.host === location.host;\n    }\n    const se = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=\";\n    let ae, oe;\n    ae = [], oe = 0;\n    const le = function (t, e) {\n      if (Yt.supported && (t.headers || (t.headers = {}), t.headers.accept = \"image/webp,*/*\"), oe >= At.MAX_PARALLEL_IMAGE_REQUESTS) {\n        const r = {\n          requestParameters: t,\n          callback: e,\n          cancelled: !1,\n          cancel() {\n            this.cancelled = !0;\n          }\n        };\n        return ae.push(r), r;\n      }\n      oe++;\n      let r = !1;\n      const n = () => {\n          if (!r) for (r = !0, oe--; ae.length && oe < At.MAX_PARALLEL_IMAGE_REQUESTS;) {\n            const t = ae.shift(),\n              {\n                requestParameters: e,\n                callback: r,\n                cancelled: n\n              } = t;\n            n || (t.cancel = le(e, r).cancel);\n          }\n        },\n        i = ne(t, (t, r, i, s) => {\n          n(), t ? e(t) : r && (self.createImageBitmap ? function (t, e) {\n            const r = new Blob([new Uint8Array(t)], {\n              type: \"image/png\"\n            });\n            createImageBitmap(r).then(t => {\n              e(null, t);\n            }).catch(t => {\n              e(new Error(`Could not load image because of ${t.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));\n            });\n          }(r, (t, r) => e(t, r, i, s)) : function (t, e) {\n            const r = new Image();\n            r.onload = () => {\n              e(null, r), URL.revokeObjectURL(r.src), r.onload = null, requestAnimationFrame(() => {\n                r.src = se;\n              });\n            }, r.onerror = () => e(new Error(\"Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.\"));\n            const n = new Blob([new Uint8Array(t)], {\n              type: \"image/png\"\n            });\n            r.src = t.byteLength ? URL.createObjectURL(n) : se;\n          }(r, (t, r) => e(t, r, i, s)));\n        });\n      return {\n        cancel: () => {\n          i.cancel(), n();\n        }\n      };\n    };\n    var ue,\n      ce,\n      he,\n      pe = {\n        exports: {}\n      },\n      fe = {\n        exports: {}\n      },\n      de = {\n        exports: {}\n      },\n      me = function () {\n        if (he) return pe.exports;\n        he = 1;\n        var t = (ue || (ue = 1, fe.exports = function (t, e) {\n            var r, n, i, s, a, o, l, u;\n            for (n = t.length - (r = 3 & t.length), i = e, a = 3432918353, o = 461845907, u = 0; u < n;) l = 255 & t.charCodeAt(u) | (255 & t.charCodeAt(++u)) << 8 | (255 & t.charCodeAt(++u)) << 16 | (255 & t.charCodeAt(++u)) << 24, ++u, i = 27492 + (65535 & (s = 5 * (65535 & (i = (i ^= l = (65535 & (l = (l = (65535 & l) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295) << 13 | i >>> 19)) + ((5 * (i >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s >>> 16) & 65535) << 16);\n            switch (l = 0, r) {\n              case 3:\n                l ^= (255 & t.charCodeAt(u + 2)) << 16;\n              case 2:\n                l ^= (255 & t.charCodeAt(u + 1)) << 8;\n              case 1:\n                i ^= l = (65535 & (l = (l = (65535 & (l ^= 255 & t.charCodeAt(u))) * a + (((l >>> 16) * a & 65535) << 16) & 4294967295) << 15 | l >>> 17)) * o + (((l >>> 16) * o & 65535) << 16) & 4294967295;\n            }\n            return i ^= t.length, i = 2246822507 * (65535 & (i ^= i >>> 16)) + ((2246822507 * (i >>> 16) & 65535) << 16) & 4294967295, i = 3266489909 * (65535 & (i ^= i >>> 13)) + ((3266489909 * (i >>> 16) & 65535) << 16) & 4294967295, (i ^= i >>> 16) >>> 0;\n          }), fe.exports),\n          e = (ce || (ce = 1, de.exports = function (t, e) {\n            for (var r, n = t.length, i = e ^ n, s = 0; n >= 4;) r = 1540483477 * (65535 & (r = 255 & t.charCodeAt(s) | (255 & t.charCodeAt(++s)) << 8 | (255 & t.charCodeAt(++s)) << 16 | (255 & t.charCodeAt(++s)) << 24)) + ((1540483477 * (r >>> 16) & 65535) << 16), i = 1540483477 * (65535 & i) + ((1540483477 * (i >>> 16) & 65535) << 16) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + ((1540483477 * (r >>> 16) & 65535) << 16)), n -= 4, ++s;\n            switch (n) {\n              case 3:\n                i ^= (255 & t.charCodeAt(s + 2)) << 16;\n              case 2:\n                i ^= (255 & t.charCodeAt(s + 1)) << 8;\n              case 1:\n                i = 1540483477 * (65535 & (i ^= 255 & t.charCodeAt(s))) + ((1540483477 * (i >>> 16) & 65535) << 16);\n            }\n            return i = 1540483477 * (65535 & (i ^= i >>> 13)) + ((1540483477 * (i >>> 16) & 65535) << 16), (i ^= i >>> 15) >>> 0;\n          }), de.exports);\n        return pe.exports = t, pe.exports.murmur3 = t, pe.exports.murmur2 = e, pe.exports;\n      }(),\n      ye = e(me);\n    class ge {\n      constructor(t, ...e) {\n        nt(this, e[0] || {}), this.type = t;\n      }\n    }\n    class xe extends ge {\n      constructor(t, e = {}) {\n        super(\"error\", nt({\n          error: t\n        }, e));\n      }\n    }\n    function ve(t, e, r) {\n      r[t] && -1 !== r[t].indexOf(e) || (r[t] = r[t] || [], r[t].push(e));\n    }\n    function be(t, e, r) {\n      if (r && r[t]) {\n        const n = r[t].indexOf(e);\n        -1 !== n && r[t].splice(n, 1);\n      }\n    }\n    class _e {\n      on(t, e) {\n        return this._listeners = this._listeners || {}, ve(t, e, this._listeners), this;\n      }\n      off(t, e) {\n        return be(t, e, this._listeners), be(t, e, this._oneTimeListeners), this;\n      }\n      once(t, e) {\n        return e ? (this._oneTimeListeners = this._oneTimeListeners || {}, ve(t, e, this._oneTimeListeners), this) : new Promise(e => {\n          this.once(t, e);\n        });\n      }\n      fire(t, e) {\n        const r = \"string\" == typeof t ? new ge(t, e) : t,\n          n = r.type;\n        if (this.listens(n)) {\n          r.target = this;\n          const t = this._listeners && this._listeners[n] ? this._listeners[n].slice() : [];\n          for (const e of t) e.call(this, r);\n          const e = this._oneTimeListeners && this._oneTimeListeners[n] ? this._oneTimeListeners[n].slice() : [];\n          for (const t of e) be(n, t, this._oneTimeListeners), t.call(this, r);\n          const i = this._eventedParent;\n          i && (nt(r, \"function\" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i.fire(r));\n        } else r instanceof xe && console.error(r.error);\n        return this;\n      }\n      listens(t) {\n        return !!(this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t));\n      }\n      setEventedParent(t, e) {\n        return this._eventedParent = t, this._eventedParentData = e, this;\n      }\n    }\n    class we {\n      constructor(t) {\n        \"string\" == typeof t ? this.name = t : (this.name = t.name, this.iconsetId = t.iconsetId);\n      }\n      static from(t) {\n        return new we(t);\n      }\n      static toString(t) {\n        return t.iconsetId ? `${t.name}\u001f${t.iconsetId}` : t.name;\n      }\n      static parse(t) {\n        const [e, r] = t.split(\"\u001f\");\n        return new we({\n          name: e,\n          iconsetId: r\n        });\n      }\n      static isEqual(t, e) {\n        return t.name === e.name && t.iconsetId === e.iconsetId;\n      }\n      toString() {\n        return we.toString(this);\n      }\n      serialize() {\n        return {\n          name: this.name,\n          iconsetId: this.iconsetId\n        };\n      }\n    }\n    var Me,\n      Ae = {},\n      Ie = function () {\n        if (Me) return Ae;\n        Me = 1;\n        var t = {\n          transparent: [0, 0, 0, 0],\n          aliceblue: [240, 248, 255, 1],\n          antiquewhite: [250, 235, 215, 1],\n          aqua: [0, 255, 255, 1],\n          aquamarine: [127, 255, 212, 1],\n          azure: [240, 255, 255, 1],\n          beige: [245, 245, 220, 1],\n          bisque: [255, 228, 196, 1],\n          black: [0, 0, 0, 1],\n          blanchedalmond: [255, 235, 205, 1],\n          blue: [0, 0, 255, 1],\n          blueviolet: [138, 43, 226, 1],\n          brown: [165, 42, 42, 1],\n          burlywood: [222, 184, 135, 1],\n          cadetblue: [95, 158, 160, 1],\n          chartreuse: [127, 255, 0, 1],\n          chocolate: [210, 105, 30, 1],\n          coral: [255, 127, 80, 1],\n          cornflowerblue: [100, 149, 237, 1],\n          cornsilk: [255, 248, 220, 1],\n          crimson: [220, 20, 60, 1],\n          cyan: [0, 255, 255, 1],\n          darkblue: [0, 0, 139, 1],\n          darkcyan: [0, 139, 139, 1],\n          darkgoldenrod: [184, 134, 11, 1],\n          darkgray: [169, 169, 169, 1],\n          darkgreen: [0, 100, 0, 1],\n          darkgrey: [169, 169, 169, 1],\n          darkkhaki: [189, 183, 107, 1],\n          darkmagenta: [139, 0, 139, 1],\n          darkolivegreen: [85, 107, 47, 1],\n          darkorange: [255, 140, 0, 1],\n          darkorchid: [153, 50, 204, 1],\n          darkred: [139, 0, 0, 1],\n          darksalmon: [233, 150, 122, 1],\n          darkseagreen: [143, 188, 143, 1],\n          darkslateblue: [72, 61, 139, 1],\n          darkslategray: [47, 79, 79, 1],\n          darkslategrey: [47, 79, 79, 1],\n          darkturquoise: [0, 206, 209, 1],\n          darkviolet: [148, 0, 211, 1],\n          deeppink: [255, 20, 147, 1],\n          deepskyblue: [0, 191, 255, 1],\n          dimgray: [105, 105, 105, 1],\n          dimgrey: [105, 105, 105, 1],\n          dodgerblue: [30, 144, 255, 1],\n          firebrick: [178, 34, 34, 1],\n          floralwhite: [255, 250, 240, 1],\n          forestgreen: [34, 139, 34, 1],\n          fuchsia: [255, 0, 255, 1],\n          gainsboro: [220, 220, 220, 1],\n          ghostwhite: [248, 248, 255, 1],\n          gold: [255, 215, 0, 1],\n          goldenrod: [218, 165, 32, 1],\n          gray: [128, 128, 128, 1],\n          green: [0, 128, 0, 1],\n          greenyellow: [173, 255, 47, 1],\n          grey: [128, 128, 128, 1],\n          honeydew: [240, 255, 240, 1],\n          hotpink: [255, 105, 180, 1],\n          indianred: [205, 92, 92, 1],\n          indigo: [75, 0, 130, 1],\n          ivory: [255, 255, 240, 1],\n          khaki: [240, 230, 140, 1],\n          lavender: [230, 230, 250, 1],\n          lavenderblush: [255, 240, 245, 1],\n          lawngreen: [124, 252, 0, 1],\n          lemonchiffon: [255, 250, 205, 1],\n          lightblue: [173, 216, 230, 1],\n          lightcoral: [240, 128, 128, 1],\n          lightcyan: [224, 255, 255, 1],\n          lightgoldenrodyellow: [250, 250, 210, 1],\n          lightgray: [211, 211, 211, 1],\n          lightgreen: [144, 238, 144, 1],\n          lightgrey: [211, 211, 211, 1],\n          lightpink: [255, 182, 193, 1],\n          lightsalmon: [255, 160, 122, 1],\n          lightseagreen: [32, 178, 170, 1],\n          lightskyblue: [135, 206, 250, 1],\n          lightslategray: [119, 136, 153, 1],\n          lightslategrey: [119, 136, 153, 1],\n          lightsteelblue: [176, 196, 222, 1],\n          lightyellow: [255, 255, 224, 1],\n          lime: [0, 255, 0, 1],\n          limegreen: [50, 205, 50, 1],\n          linen: [250, 240, 230, 1],\n          magenta: [255, 0, 255, 1],\n          maroon: [128, 0, 0, 1],\n          mediumaquamarine: [102, 205, 170, 1],\n          mediumblue: [0, 0, 205, 1],\n          mediumorchid: [186, 85, 211, 1],\n          mediumpurple: [147, 112, 219, 1],\n          mediumseagreen: [60, 179, 113, 1],\n          mediumslateblue: [123, 104, 238, 1],\n          mediumspringgreen: [0, 250, 154, 1],\n          mediumturquoise: [72, 209, 204, 1],\n          mediumvioletred: [199, 21, 133, 1],\n          midnightblue: [25, 25, 112, 1],\n          mintcream: [245, 255, 250, 1],\n          mistyrose: [255, 228, 225, 1],\n          moccasin: [255, 228, 181, 1],\n          navajowhite: [255, 222, 173, 1],\n          navy: [0, 0, 128, 1],\n          oldlace: [253, 245, 230, 1],\n          olive: [128, 128, 0, 1],\n          olivedrab: [107, 142, 35, 1],\n          orange: [255, 165, 0, 1],\n          orangered: [255, 69, 0, 1],\n          orchid: [218, 112, 214, 1],\n          palegoldenrod: [238, 232, 170, 1],\n          palegreen: [152, 251, 152, 1],\n          paleturquoise: [175, 238, 238, 1],\n          palevioletred: [219, 112, 147, 1],\n          papayawhip: [255, 239, 213, 1],\n          peachpuff: [255, 218, 185, 1],\n          peru: [205, 133, 63, 1],\n          pink: [255, 192, 203, 1],\n          plum: [221, 160, 221, 1],\n          powderblue: [176, 224, 230, 1],\n          purple: [128, 0, 128, 1],\n          rebeccapurple: [102, 51, 153, 1],\n          red: [255, 0, 0, 1],\n          rosybrown: [188, 143, 143, 1],\n          royalblue: [65, 105, 225, 1],\n          saddlebrown: [139, 69, 19, 1],\n          salmon: [250, 128, 114, 1],\n          sandybrown: [244, 164, 96, 1],\n          seagreen: [46, 139, 87, 1],\n          seashell: [255, 245, 238, 1],\n          sienna: [160, 82, 45, 1],\n          silver: [192, 192, 192, 1],\n          skyblue: [135, 206, 235, 1],\n          slateblue: [106, 90, 205, 1],\n          slategray: [112, 128, 144, 1],\n          slategrey: [112, 128, 144, 1],\n          snow: [255, 250, 250, 1],\n          springgreen: [0, 255, 127, 1],\n          steelblue: [70, 130, 180, 1],\n          tan: [210, 180, 140, 1],\n          teal: [0, 128, 128, 1],\n          thistle: [216, 191, 216, 1],\n          tomato: [255, 99, 71, 1],\n          turquoise: [64, 224, 208, 1],\n          violet: [238, 130, 238, 1],\n          wheat: [245, 222, 179, 1],\n          white: [255, 255, 255, 1],\n          whitesmoke: [245, 245, 245, 1],\n          yellow: [255, 255, 0, 1],\n          yellowgreen: [154, 205, 50, 1]\n        };\n        function e(t) {\n          return (t = Math.round(t)) < 0 ? 0 : t > 255 ? 255 : t;\n        }\n        function r(t) {\n          return e(\"%\" === t[t.length - 1] ? parseFloat(t) / 100 * 255 : parseInt(t));\n        }\n        function n(t) {\n          return (e = \"%\" === t[t.length - 1] ? parseFloat(t) / 100 : parseFloat(t)) < 0 ? 0 : e > 1 ? 1 : e;\n          var e;\n        }\n        function i(t, e, r) {\n          return r < 0 ? r += 1 : r > 1 && (r -= 1), 6 * r < 1 ? t + (e - t) * r * 6 : 2 * r < 1 ? e : 3 * r < 2 ? t + (e - t) * (2 / 3 - r) * 6 : t;\n        }\n        try {\n          Ae.parseCSSColor = function (s) {\n            var a,\n              o = s.replace(/ /g, \"\").toLowerCase();\n            if (o in t) return t[o].slice();\n            if (\"#\" === o[0]) return 4 === o.length ? (a = parseInt(o.substr(1), 16)) >= 0 && a <= 4095 ? [(3840 & a) >> 4 | (3840 & a) >> 8, 240 & a | (240 & a) >> 4, 15 & a | (15 & a) << 4, 1] : null : 7 === o.length && (a = parseInt(o.substr(1), 16)) >= 0 && a <= 16777215 ? [(16711680 & a) >> 16, (65280 & a) >> 8, 255 & a, 1] : null;\n            var l = o.indexOf(\"(\"),\n              u = o.indexOf(\")\");\n            if (-1 !== l && u + 1 === o.length) {\n              var c = o.substr(0, l),\n                h = o.substr(l + 1, u - (l + 1)).split(\",\"),\n                p = 1;\n              switch (c) {\n                case \"rgba\":\n                  if (4 !== h.length) return null;\n                  p = n(h.pop());\n                case \"rgb\":\n                  return 3 !== h.length ? null : [r(h[0]), r(h[1]), r(h[2]), p];\n                case \"hsla\":\n                  if (4 !== h.length) return null;\n                  p = n(h.pop());\n                case \"hsl\":\n                  if (3 !== h.length) return null;\n                  var f = (parseFloat(h[0]) % 360 + 360) % 360 / 360,\n                    d = n(h[1]),\n                    m = n(h[2]),\n                    y = m <= .5 ? m * (d + 1) : m + d - m * d,\n                    g = 2 * m - y;\n                  return [e(255 * i(g, y, f + 1 / 3)), e(255 * i(g, y, f)), e(255 * i(g, y, f - 1 / 3)), p];\n                default:\n                  return null;\n              }\n            }\n            return null;\n          };\n        } catch (t) {}\n        return Ae;\n      }();\n    class Se {\n      constructor(t, e, r, n = 1) {\n        this.r = t, this.g = e, this.b = r, this.a = n;\n      }\n      static parse(t) {\n        if (!t) return;\n        if (t instanceof Se) return t;\n        if (\"string\" != typeof t) return;\n        const e = Ie.parseCSSColor(t);\n        return e ? new Se(e[0] / 255 * e[3], e[1] / 255 * e[3], e[2] / 255 * e[3], e[3]) : void 0;\n      }\n      toStringPremultipliedAlpha() {\n        const [t, e, r, n] = 0 === this.a ? [0, 0, 0, 0] : [255 * this.r / this.a, 255 * this.g / this.a, 255 * this.b / this.a, this.a];\n        return `rgba(${Math.round(t)},${Math.round(e)},${Math.round(r)},${n})`;\n      }\n      toString() {\n        const [t, e, r, n] = [this.r, this.g, this.b, this.a];\n        return `rgba(${Math.round(255 * t)},${Math.round(255 * e)},${Math.round(255 * r)},${n})`;\n      }\n      toRenderColor(t) {\n        const {\n          r: e,\n          g: r,\n          b: n,\n          a: i\n        } = this;\n        return new Pe(t, e, r, n, i);\n      }\n      clone() {\n        return new Se(this.r, this.g, this.b, this.a);\n      }\n    }\n    class Pe {\n      constructor(t, e, r, n, i) {\n        if (t) {\n          const s = t.image.height,\n            a = s * s;\n          e = 0 === i ? 0 : e / i * (s - 1), r = 0 === i ? 0 : r / i * (s - 1), n = 0 === i ? 0 : n / i * (s - 1);\n          const o = Math.floor(e),\n            l = Math.floor(r),\n            u = Math.floor(n),\n            c = Math.ceil(e),\n            h = Math.ceil(r),\n            p = Math.ceil(n),\n            f = e - o,\n            d = r - l,\n            m = n - u,\n            y = t.image.data,\n            g = 4 * (o + l * a + u * s),\n            x = 4 * (o + l * a + p * s),\n            v = 4 * (o + h * a + u * s),\n            b = 4 * (o + h * a + p * s),\n            _ = 4 * (c + l * a + u * s),\n            w = 4 * (c + l * a + p * s),\n            M = 4 * (c + h * a + u * s),\n            A = 4 * (c + h * a + p * s);\n          if (g < 0 || A >= y.length) throw new Error(\"out of range\");\n          this.r = Ee(Ee(Ee(y[g], y[x], m), Ee(y[v], y[b], m), d), Ee(Ee(y[_], y[w], m), Ee(y[M], y[A], m), d), f) / 255 * i, this.g = Ee(Ee(Ee(y[g + 1], y[x + 1], m), Ee(y[v + 1], y[b + 1], m), d), Ee(Ee(y[_ + 1], y[w + 1], m), Ee(y[M + 1], y[A + 1], m), d), f) / 255 * i, this.b = Ee(Ee(Ee(y[g + 2], y[x + 2], m), Ee(y[v + 2], y[b + 2], m), d), Ee(Ee(y[_ + 2], y[w + 2], m), Ee(y[M + 2], y[A + 2], m), d), f) / 255 * i, this.a = i;\n        } else this.r = e, this.g = r, this.b = n, this.a = i;\n      }\n      toArray() {\n        const {\n          r: t,\n          g: e,\n          b: r,\n          a: n\n        } = this;\n        return 0 === n ? [0, 0, 0, 0] : [255 * t / n, 255 * e / n, 255 * r / n, n];\n      }\n      toHslaArray() {\n        if (0 === this.a) return [0, 0, 0, 0];\n        const {\n            r: t,\n            g: e,\n            b: r,\n            a: n\n          } = this,\n          i = Math.min(Math.max(t / n, 0), 1),\n          s = Math.min(Math.max(e / n, 0), 1),\n          a = Math.min(Math.max(r / n, 0), 1),\n          o = Math.min(i, s, a),\n          l = Math.max(i, s, a),\n          u = (o + l) / 2;\n        if (o === l) return [0, 0, 100 * u, n];\n        const c = l - o,\n          h = u > .5 ? c / (2 - l - o) : c / (l + o);\n        let p = 0;\n        return l === i ? p = (s - a) / c + (s < a ? 6 : 0) : l === s ? p = (a - i) / c + 2 : l === a && (p = (i - s) / c + 4), p *= 60, [Math.min(Math.max(p, 0), 360), Math.min(Math.max(100 * h, 0), 100), Math.min(Math.max(100 * u, 0), 100), n];\n      }\n      toArray01() {\n        const {\n          r: t,\n          g: e,\n          b: r,\n          a: n\n        } = this;\n        return 0 === n ? [0, 0, 0, 0] : [t / n, e / n, r / n, n];\n      }\n      toArray01Scaled(t) {\n        const {\n          r: e,\n          g: r,\n          b: n,\n          a: i\n        } = this;\n        return 0 === i ? [0, 0, 0] : [e / i * t, r / i * t, n / i * t];\n      }\n      toArray01PremultipliedAlpha() {\n        const {\n          r: t,\n          g: e,\n          b: r,\n          a: n\n        } = this;\n        return [t, e, r, n];\n      }\n      toArray01Linear() {\n        const {\n          r: t,\n          g: e,\n          b: r,\n          a: n\n        } = this;\n        return 0 === n ? [0, 0, 0, 0] : [Math.pow(t / n, 2.2), Math.pow(e / n, 2.2), Math.pow(r / n, 2.2), n];\n      }\n    }\n    function Ee(t, e, r) {\n      return t * (1 - r) + e * r;\n    }\n    function ze(t, e, r) {\n      return t.map((t, n) => Ee(t, e[n], r));\n    }\n    function ke(t) {\n      return t * t * t * t * t;\n    }\n    Se.black = new Se(0, 0, 0, 1), Se.white = new Se(1, 1, 1, 1), Se.transparent = new Se(0, 0, 0, 0), Se.red = new Se(1, 0, 0, 1), Se.blue = new Se(0, 0, 1, 1);\n    var Te = Object.freeze({\n      __proto__: null,\n      array: ze,\n      color: function (t, e, r) {\n        return new Se(Ee(t.r, e.r, r), Ee(t.g, e.g, r), Ee(t.b, e.b, r), Ee(t.a, e.a, r));\n      },\n      easeIn: ke,\n      number: Ee\n    });\n    function Be(t, ...e) {\n      for (const r of e) for (const e in r) t[e] = r[e];\n      return t;\n    }\n    class Ve extends Error {\n      constructor(t, e) {\n        super(e), this.message = e, this.key = t;\n      }\n    }\n    class Ce {\n      constructor(t, e = []) {\n        this.parent = t, this.bindings = {};\n        for (const [t, r] of e) this.bindings[t] = r;\n      }\n      concat(t) {\n        return new Ce(this, t);\n      }\n      get(t) {\n        if (this.bindings[t]) return this.bindings[t];\n        if (this.parent) return this.parent.get(t);\n        throw new Error(`${t} not found in scope.`);\n      }\n      has(t) {\n        return !!this.bindings[t] || !!this.parent && this.parent.has(t);\n      }\n    }\n    const De = {\n        kind: \"null\"\n      },\n      Re = {\n        kind: \"number\"\n      },\n      Le = {\n        kind: \"string\"\n      },\n      Fe = {\n        kind: \"boolean\"\n      },\n      Oe = {\n        kind: \"color\"\n      },\n      Ne = {\n        kind: \"object\"\n      },\n      Ue = {\n        kind: \"value\"\n      },\n      je = {\n        kind: \"collator\"\n      },\n      qe = {\n        kind: \"formatted\"\n      },\n      $e = {\n        kind: \"resolvedImage\"\n      };\n    function Ge(t, e) {\n      return {\n        kind: \"array\",\n        itemType: t,\n        N: e\n      };\n    }\n    function Ye(t) {\n      if (\"array\" === t.kind) {\n        const e = Ye(t.itemType);\n        return \"number\" == typeof t.N ? `array<${e}, ${t.N}>` : \"value\" === t.itemType.kind ? \"array\" : `array<${e}>`;\n      }\n      return t.kind;\n    }\n    const He = [De, Re, Le, Fe, Oe, qe, Ne, Ge(Ue), $e];\n    function Xe(t, e) {\n      if (\"error\" === e.kind) return null;\n      if (\"array\" === t.kind) {\n        if (\"array\" === e.kind && (0 === e.N && \"value\" === e.itemType.kind || !Xe(t.itemType, e.itemType)) && (\"number\" != typeof t.N || t.N === e.N)) return null;\n      } else {\n        if (t.kind === e.kind) return null;\n        if (\"value\" === t.kind) for (const t of He) if (!Xe(t, e)) return null;\n      }\n      return `Expected ${Ye(t)} but found ${Ye(e)} instead.`;\n    }\n    function Ze(t, e) {\n      return e.some(e => e.kind === t.kind);\n    }\n    function We(t, e) {\n      return e.some(e => \"null\" === e ? null === t : \"array\" === e ? Array.isArray(t) : \"object\" === e ? t && !Array.isArray(t) && \"object\" == typeof t : e === typeof t);\n    }\n    class Ke {\n      constructor(t, e, r) {\n        this.sensitivity = t ? e ? \"variant\" : \"case\" : e ? \"accent\" : \"base\", this.locale = r, this.collator = new Intl.Collator(this.locale ? this.locale : [], {\n          sensitivity: this.sensitivity,\n          usage: \"search\"\n        });\n      }\n      compare(t, e) {\n        return this.collator.compare(t, e);\n      }\n      resolvedLocale() {\n        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;\n      }\n    }\n    class Je {\n      constructor(t, e, r, n, i) {\n        this.text = t.normalize ? t.normalize() : t, this.image = e, this.scale = r, this.fontStack = n, this.textColor = i;\n      }\n    }\n    class Qe {\n      constructor(t) {\n        this.sections = t;\n      }\n      static fromString(t) {\n        return new Qe([new Je(t, null, null, null, null)]);\n      }\n      isEmpty() {\n        return 0 === this.sections.length || !this.sections.some(t => 0 !== t.text.length || !!t.image && t.image.hasPrimary());\n      }\n      static factory(t) {\n        return t instanceof Qe ? t : Qe.fromString(t);\n      }\n      toString() {\n        return 0 === this.sections.length ? \"\" : this.sections.map(t => t.text).join(\"\");\n      }\n      serialize() {\n        const t = [\"format\"];\n        for (const e of this.sections) {\n          if (e.image) {\n            const r = e.image.getPrimary().id.toString();\n            t.push([\"image\", r]);\n            continue;\n          }\n          t.push(e.text);\n          const r = {};\n          e.fontStack && (r[\"text-font\"] = [\"literal\", e.fontStack.split(\",\")]), e.scale && (r[\"font-scale\"] = e.scale), e.textColor && (r[\"text-color\"] = [\"rgba\"].concat(e.textColor.toRenderColor(null).toArray())), t.push(r);\n        }\n        return t;\n      }\n    }\n    class tr {\n      constructor(t, e = {}) {\n        if (this.id = we.from(t), this.options = Object.assign({}, e), e.transform) {\n          const {\n            a: t,\n            b: r,\n            c: n,\n            d: i,\n            e: s,\n            f: a\n          } = e.transform;\n          this.options.transform = new DOMMatrix([t, r, n, i, s, a]);\n        } else this.options.transform = new DOMMatrix([1, 0, 0, 1, 0, 0]);\n      }\n      toString() {\n        const {\n          a: t,\n          b: e,\n          c: r,\n          d: n,\n          e: i,\n          f: s\n        } = this.options.transform;\n        return JSON.stringify({\n          name: this.id.name,\n          iconsetId: this.id.iconsetId,\n          params: this.options.params,\n          transform: {\n            a: t,\n            b: e,\n            c: r,\n            d: n,\n            e: i,\n            f: s\n          }\n        });\n      }\n      static parse(t) {\n        let e, r, n, i;\n        try {\n          ({\n            name: e,\n            iconsetId: r,\n            params: n,\n            transform: i\n          } = JSON.parse(t) || {});\n        } catch (t) {\n          return null;\n        }\n        if (!e) return null;\n        const {\n          a: s,\n          b: a,\n          c: o,\n          d: l,\n          e: u,\n          f: c\n        } = i || {};\n        return new tr({\n          name: e,\n          iconsetId: r\n        }, {\n          params: n,\n          transform: new DOMMatrix([s, a, o, l, u, c])\n        });\n      }\n      scaleSelf(t) {\n        return this.options.transform.scaleSelf(t), this;\n      }\n    }\n    class er {\n      constructor(t, e, r, n, i = !1) {\n        this.primaryId = we.from(t), this.primaryOptions = e, r && (this.secondaryId = we.from(r)), this.secondaryOptions = n, this.available = i;\n      }\n      toString() {\n        return this.primaryId && this.secondaryId ? `[${this.primaryId.name},${this.secondaryId.name}]` : this.primaryId.name;\n      }\n      hasPrimary() {\n        return !!this.primaryId;\n      }\n      getPrimary() {\n        return new tr(this.primaryId, this.primaryOptions);\n      }\n      hasSecondary() {\n        return !!this.secondaryId;\n      }\n      getSecondary() {\n        return this.secondaryId ? new tr(this.secondaryId, this.secondaryOptions) : null;\n      }\n      static from(t) {\n        return \"string\" == typeof t ? er.build({\n          name: t\n        }) : t;\n      }\n      static build(t, e, r, n) {\n        return !t || \"object\" == typeof t && !(\"name\" in t) ? null : new er(t, r, e, n);\n      }\n    }\n    function rr(t, e, r, n) {\n      return \"number\" == typeof t && t >= 0 && t <= 255 && \"number\" == typeof e && e >= 0 && e <= 255 && \"number\" == typeof r && r >= 0 && r <= 255 ? void 0 === n || \"number\" == typeof n && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[t, e, r, n].join(\", \")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(\"number\" == typeof n ? [t, e, r, n] : [t, e, r]).join(\", \")}]: 'r', 'g', and 'b' must be between 0 and 255.`;\n    }\n    function nr(t) {\n      if (null === t) return !0;\n      if (\"string\" == typeof t) return !0;\n      if (\"boolean\" == typeof t) return !0;\n      if (\"number\" == typeof t) return !0;\n      if (t instanceof Se) return !0;\n      if (t instanceof Ke) return !0;\n      if (t instanceof Qe) return !0;\n      if (t instanceof er) return !0;\n      if (Array.isArray(t)) {\n        for (const e of t) if (!nr(e)) return !1;\n        return !0;\n      }\n      if (\"object\" == typeof t) {\n        for (const e in t) if (!nr(t[e])) return !1;\n        return !0;\n      }\n      return !1;\n    }\n    function ir(t) {\n      if (null === t) return De;\n      if (\"string\" == typeof t) return Le;\n      if (\"boolean\" == typeof t) return Fe;\n      if (\"number\" == typeof t) return Re;\n      if (t instanceof Se) return Oe;\n      if (t instanceof Ke) return je;\n      if (t instanceof Qe) return qe;\n      if (t instanceof er) return $e;\n      if (Array.isArray(t)) {\n        const e = t.length;\n        let r;\n        for (const e of t) {\n          const t = ir(e);\n          if (r) {\n            if (r === t) continue;\n            r = Ue;\n            break;\n          }\n          r = t;\n        }\n        return Ge(r || Ue, e);\n      }\n      return Ne;\n    }\n    function sr(t) {\n      const e = typeof t;\n      return null === t ? \"\" : \"string\" === e || \"number\" === e || \"boolean\" === e ? String(t) : t instanceof Se ? t.toStringPremultipliedAlpha() : t instanceof Qe || t instanceof er ? t.toString() : JSON.stringify(t);\n    }\n    class ar {\n      constructor(t, e) {\n        this.type = t, this.value = e;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);\n        if (!nr(t[1])) return e.error(\"invalid value\");\n        const r = t[1];\n        let n = ir(r);\n        const i = e.expectedType;\n        return \"array\" !== n.kind || 0 !== n.N || !i || \"array\" !== i.kind || \"number\" == typeof i.N && 0 !== i.N || (n = i), new ar(n, r);\n      }\n      evaluate() {\n        return this.value;\n      }\n      eachChild() {}\n      outputDefined() {\n        return !0;\n      }\n      serialize() {\n        return \"array\" === this.type.kind || \"object\" === this.type.kind ? [\"literal\", this.value] : this.value instanceof Se ? [\"rgba\"].concat(this.value.toRenderColor(null).toArray()) : this.value instanceof Qe ? this.value.serialize() : this.value;\n      }\n    }\n    class or {\n      constructor(t) {\n        this.name = \"ExpressionEvaluationError\", this.message = t;\n      }\n      toJSON() {\n        return this.message;\n      }\n    }\n    const lr = {\n      string: Le,\n      number: Re,\n      boolean: Fe,\n      object: Ne\n    };\n    class ur {\n      constructor(t, e) {\n        this.type = t, this.args = e;\n      }\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected at least one argument.\");\n        let r,\n          n = 1;\n        const i = t[0];\n        if (\"array\" === i) {\n          let i, s;\n          if (t.length > 2) {\n            const r = t[1];\n            if (\"string\" != typeof r || !(r in lr) || \"object\" === r) return e.error('The item type argument of \"array\" must be one of string, number, boolean', 1);\n            i = lr[r], n++;\n          } else i = Ue;\n          if (t.length > 3) {\n            if (null !== t[2] && (\"number\" != typeof t[2] || t[2] < 0 || t[2] !== Math.floor(t[2]))) return e.error('The length argument to \"array\" must be a positive integer literal', 2);\n            s = t[2], n++;\n          }\n          r = Ge(i, s);\n        } else r = lr[i];\n        const s = [];\n        for (; n < t.length; n++) {\n          const r = e.parse(t[n], n, Ue);\n          if (!r) return null;\n          s.push(r);\n        }\n        return new ur(r, s);\n      }\n      evaluate(t) {\n        for (let e = 0; e < this.args.length; e++) {\n          const r = this.args[e].evaluate(t);\n          if (!Xe(this.type, ir(r))) return r;\n          if (e === this.args.length - 1) throw new or(`The expression ${JSON.stringify(this.args[e].serialize())} evaluated to ${Ye(ir(r))} but was expected to be of type ${Ye(this.type)}.`);\n        }\n        return null;\n      }\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n      outputDefined() {\n        return this.args.every(t => t.outputDefined());\n      }\n      serialize() {\n        const t = this.type,\n          e = [t.kind];\n        if (\"array\" === t.kind) {\n          const r = t.itemType;\n          if (\"string\" === r.kind || \"number\" === r.kind || \"boolean\" === r.kind) {\n            e.push(r.kind);\n            const n = t.N;\n            (\"number\" == typeof n || this.args.length > 1) && e.push(n);\n          }\n        }\n        return e.concat(this.args.map(t => t.serialize()));\n      }\n    }\n    class cr {\n      constructor(t) {\n        this.type = qe, this.sections = t;\n      }\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected at least one argument.\");\n        const r = t[1];\n        if (!Array.isArray(r) && \"object\" == typeof r) return e.error(\"First argument must be an image or text section.\");\n        const n = [];\n        let i = !1;\n        for (let r = 1; r <= t.length - 1; ++r) {\n          const s = t[r];\n          if (i && \"object\" == typeof s && !Array.isArray(s)) {\n            i = !1;\n            let t = null;\n            if (s[\"font-scale\"] && (t = e.parseObjectValue(s[\"font-scale\"], r, \"font-scale\", Re), !t)) return null;\n            let a = null;\n            if (s[\"text-font\"] && (a = e.parseObjectValue(s[\"text-font\"], r, \"text-font\", Ge(Le)), !a)) return null;\n            let o = null;\n            if (s[\"text-color\"] && (o = e.parseObjectValue(s[\"text-color\"], r, \"text-color\", Oe), !o)) return null;\n            const l = n[n.length - 1];\n            l.scale = t, l.font = a, l.textColor = o;\n          } else {\n            const s = e.parse(t[r], r, Ue);\n            if (!s) return null;\n            const a = s.type.kind;\n            if (\"string\" !== a && \"value\" !== a && \"null\" !== a && \"resolvedImage\" !== a) return e.error(\"Formatted text type must be 'string', 'value', 'image' or 'null'.\");\n            i = !0, n.push({\n              content: s,\n              scale: null,\n              font: null,\n              textColor: null\n            });\n          }\n        }\n        return new cr(n);\n      }\n      evaluate(t) {\n        return new Qe(this.sections.map(e => {\n          const r = e.content.evaluate(t);\n          return ir(r) === $e ? new Je(\"\", r, null, null, null) : new Je(sr(r), null, e.scale ? e.scale.evaluate(t) : null, e.font ? e.font.evaluate(t).join(\",\") : null, e.textColor ? e.textColor.evaluate(t) : null);\n        }));\n      }\n      eachChild(t) {\n        for (const e of this.sections) t(e.content), e.scale && t(e.scale), e.font && t(e.font), e.textColor && t(e.textColor);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        const t = [\"format\"];\n        for (const e of this.sections) {\n          t.push(e.content.serialize());\n          const r = {};\n          e.scale && (r[\"font-scale\"] = e.scale.serialize()), e.font && (r[\"text-font\"] = e.font.serialize()), e.textColor && (r[\"text-color\"] = e.textColor.serialize()), t.push(r);\n        }\n        return t;\n      }\n    }\n    class hr {\n      constructor(t, e, r, n) {\n        this._imageWarnHistory = {}, this.type = $e, this.namePrimary = t, this.nameSecondary = e, r && (this.paramsPrimary = r.params, this.iconsetIdPrimary = r.iconset ? r.iconset.id : void 0), n && (this.paramsSecondary = n.params, this.iconsetIdSecondary = n.iconset ? n.iconset.id : void 0);\n      }\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected two or more arguments.\");\n        let r = 1;\n        const n = [];\n        function i() {\n          if (r < t.length) {\n            const i = e.parse(t[r], r++, Le);\n            return i ? (n.push({\n              image: i,\n              options: {}\n            }), !0) : (e.error(n.length ? \"Secondary image variant is not a string.\" : \"No image name provided.\"), !1);\n          }\n          return !0;\n        }\n        function s() {\n          if (r < t.length) {\n            const s = t[r];\n            if (null === (i = s) || \"object\" != typeof i || Array.isArray(i)) return !0;\n            const a = s.params,\n              o = s.iconset,\n              l = e.concat(r);\n            if (!a && !o) return r++, !0;\n            if (a) {\n              if (\"object\" != typeof a || a.constructor !== Object) return l.error('Image options \"params\" should be an object'), !1;\n              const t = {},\n                e = l.concat(void 0, \"params\");\n              for (const r in a) {\n                if (!r) return e.error(\"Image parameter name should be non-empty\"), !1;\n                const n = e.concat(void 0, r).parse(a[r], void 0, Oe, void 0, {\n                  typeAnnotation: \"coerce\"\n                });\n                if (!n) return !1;\n                t[r] = n;\n              }\n              n[n.length - 1].options.params = t;\n            }\n            if (o) {\n              if (\"object\" != typeof o || o.constructor !== Object) return l.error('Image options \"iconset\" should be an object'), !1;\n              if (!o.id) return l.error('Image options \"iconset\" should have an \"id\" property'), !1;\n              n[n.length - 1].options.iconset = o;\n            }\n            return r++, !0;\n          }\n          var i;\n          return !0;\n        }\n        for (let t = 0; t < 2; t++) if (!i() || !s()) return;\n        return new hr(n[0].image, n[1] ? n[1].image : void 0, n[0].options, n[1] ? n[1].options : void 0);\n      }\n      evaluateParams(t, e) {\n        const r = {};\n        if (e) {\n          for (const n in e) if (e[n]) try {\n            r[n] = e[n].evaluate(t);\n          } catch (t) {\n            continue;\n          }\n          if (0 !== Object.keys(r).length) return {\n            params: r\n          };\n        }\n      }\n      evaluate(t) {\n        const e = {\n            name: this.namePrimary.evaluate(t),\n            iconsetId: this.iconsetIdPrimary\n          },\n          r = this.nameSecondary ? {\n            name: this.nameSecondary.evaluate(t),\n            iconsetId: this.iconsetIdSecondary\n          } : void 0,\n          n = er.build(e, r, this.paramsPrimary ? this.evaluateParams(t, this.paramsPrimary) : void 0, this.paramsSecondary ? this.evaluateParams(t, this.paramsSecondary) : void 0);\n        if (n && t.availableImages) {\n          const e = n.getPrimary().id;\n          if (n.available = t.availableImages.some(t => we.isEqual(t, e)), n.available) {\n            const e = n.getSecondary() ? n.getSecondary().id : null;\n            e && (n.available = t.availableImages.some(t => we.isEqual(t, e)));\n          }\n        }\n        return n;\n      }\n      eachChild(t) {\n        if (t(this.namePrimary), this.paramsPrimary) for (const e in this.paramsPrimary) this.paramsPrimary[e] && t(this.paramsPrimary[e]);\n        if (this.nameSecondary && (t(this.nameSecondary), this.paramsSecondary)) for (const e in this.paramsSecondary) this.paramsSecondary[e] && t(this.paramsSecondary[e]);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serializeOptions(t, e) {\n        const r = {};\n        if (e && (r.iconset = {\n          id: e\n        }), t) {\n          r.params = {};\n          for (const e in t) t[e] && (r.params[e] = t[e].serialize());\n        }\n        return Object.keys(r).length > 0 ? r : void 0;\n      }\n      serialize() {\n        const t = [\"image\", this.namePrimary.serialize()];\n        if (this.paramsPrimary || this.iconsetIdPrimary) {\n          const e = this.serializeOptions(this.paramsPrimary, this.iconsetIdPrimary);\n          e && t.push(e);\n        }\n        if (this.nameSecondary && (t.push(this.nameSecondary.serialize()), this.paramsSecondary || this.iconsetIdSecondary)) {\n          const e = this.serializeOptions(this.paramsSecondary, this.iconsetIdSecondary);\n          e && t.push(e);\n        }\n        return t;\n      }\n    }\n    function pr(t) {\n      return t instanceof Number ? \"number\" : t instanceof String ? \"string\" : t instanceof Boolean ? \"boolean\" : Array.isArray(t) ? \"array\" : null === t ? \"null\" : typeof t;\n    }\n    const fr = {\n      \"to-boolean\": Fe,\n      \"to-color\": Oe,\n      \"to-number\": Re,\n      \"to-string\": Le\n    };\n    class dr {\n      constructor(t, e) {\n        this.type = t, this.args = e;\n      }\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expected at least one argument.\");\n        const r = t[0],\n          n = [];\n        let i = De;\n        if (\"to-array\" === r) {\n          if (!Array.isArray(t[1])) return null;\n          const r = t[1].length;\n          if (e.expectedType) {\n            if (\"array\" !== e.expectedType.kind) return e.error(`Expected ${e.expectedType.kind} but found array.`);\n            i = Ge(e.expectedType.itemType, r);\n          } else {\n            if (!(r > 0 && nr(t[1][0]))) return null;\n            i = Ge(ir(t[1][0]), r);\n          }\n          for (let s = 0; s < r; s++) {\n            const r = t[1][s];\n            let a;\n            if (\"array\" === pr(r)) a = e.parse(r, void 0, i.itemType);else {\n              const t = pr(r);\n              if (t !== i.itemType.kind) return e.error(`Expected ${i.itemType.kind} but found ${t}.`);\n              a = e.registry.literal.parse([\"literal\", void 0 === r ? null : r], e);\n            }\n            if (!a) return null;\n            n.push(a);\n          }\n        } else {\n          if ((\"to-boolean\" === r || \"to-string\" === r) && 2 !== t.length) return e.error(\"Expected one argument.\");\n          i = fr[r];\n          for (let r = 1; r < t.length; r++) {\n            const i = e.parse(t[r], r, Ue);\n            if (!i) return null;\n            n.push(i);\n          }\n        }\n        return new dr(i, n);\n      }\n      evaluate(t) {\n        if (\"boolean\" === this.type.kind) return Boolean(this.args[0].evaluate(t));\n        if (\"color\" === this.type.kind) {\n          let e, r;\n          for (const n of this.args) {\n            if (e = n.evaluate(t), r = null, e instanceof Se) return e;\n            if (\"string\" == typeof e) {\n              const r = t.parseColor(e);\n              if (r) return r;\n            } else if (Array.isArray(e) && (r = e.length < 3 || e.length > 4 ? `Invalid rbga value ${JSON.stringify(e)}: expected an array containing either three or four numeric values.` : rr(e[0], e[1], e[2], e[3]), !r)) return new Se(e[0] / 255, e[1] / 255, e[2] / 255, e[3]);\n          }\n          throw new or(r || `Could not parse color from value '${\"string\" == typeof e ? e : String(JSON.stringify(e))}'`);\n        }\n        if (\"number\" === this.type.kind) {\n          let e = null;\n          for (const r of this.args) {\n            if (e = r.evaluate(t), null === e) return 0;\n            const n = Number(e);\n            if (!isNaN(n)) return n;\n          }\n          throw new or(`Could not convert ${JSON.stringify(e)} to number.`);\n        }\n        return \"formatted\" === this.type.kind ? Qe.fromString(sr(this.args[0].evaluate(t))) : \"resolvedImage\" === this.type.kind ? er.build(sr(this.args[0].evaluate(t))) : \"array\" === this.type.kind ? this.args.map(e => e.evaluate(t)) : sr(this.args[0].evaluate(t));\n      }\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n      outputDefined() {\n        return this.args.every(t => t.outputDefined());\n      }\n      serialize() {\n        if (\"formatted\" === this.type.kind) return new cr([{\n          content: this.args[0],\n          scale: null,\n          font: null,\n          textColor: null\n        }]).serialize();\n        if (\"resolvedImage\" === this.type.kind) return new hr(this.args[0]).serialize();\n        const t = \"array\" === this.type.kind ? [] : [`to-${this.type.kind}`];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n    }\n    const mr = [\"Unknown\", \"Point\", \"LineString\", \"Polygon\"];\n    class yr {\n      constructor(t, e) {\n        this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = t, this.options = e;\n      }\n      id() {\n        return this.feature && void 0 !== this.feature.id ? this.feature.id : null;\n      }\n      geometryType() {\n        return this.feature ? \"number\" == typeof this.feature.type ? mr[this.feature.type] : this.feature.type : null;\n      }\n      geometry() {\n        return this.feature && \"geometry\" in this.feature ? this.feature.geometry : null;\n      }\n      canonicalID() {\n        return this.canonical;\n      }\n      properties() {\n        return this.feature && this.feature.properties || {};\n      }\n      measureLight(t) {\n        return this.globals.brightness || 0;\n      }\n      distanceFromCenter() {\n        if (this.featureTileCoord && this.featureDistanceData) {\n          const t = this.featureDistanceData.center,\n            e = this.featureDistanceData.scale,\n            {\n              x: r,\n              y: n\n            } = this.featureTileCoord;\n          return this.featureDistanceData.bearing[0] * (r * e - t[0]) + this.featureDistanceData.bearing[1] * (n * e - t[1]);\n        }\n        return 0;\n      }\n      parseColor(t) {\n        let e = this._parseColorCache[t];\n        return e || (e = this._parseColorCache[t] = Se.parse(t)), e;\n      }\n      getConfig(t) {\n        return this.options ? this.options.get(t) : null;\n      }\n    }\n    class gr {\n      constructor(t, e, r, n, i) {\n        this.name = t, this.type = e, this._evaluate = r, this.args = n, this._overloadIndex = i;\n      }\n      evaluate(t) {\n        if (!this._evaluate) {\n          const t = gr.definitions[this.name];\n          this._evaluate = Array.isArray(t) ? t[2] : t.overloads[this._overloadIndex][1];\n        }\n        return this._evaluate(t, this.args);\n      }\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return [this.name].concat(this.args.map(t => t.serialize()));\n      }\n      static parse(t, e) {\n        const r = t[0],\n          n = gr.definitions[r];\n        if (!n) return e.error(`Unknown expression \"${r}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n        const i = Array.isArray(n) ? n[0] : n.type,\n          s = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads,\n          a = [];\n        let o = null,\n          l = -1;\n        for (const [n, u] of s) {\n          if (Array.isArray(n) && n.length !== t.length - 1) continue;\n          a.push(n), l++, o = new Fn(e.registry, e.path, null, e.scope, void 0, e._scope, e.options);\n          const s = [];\n          let c = !1;\n          for (let e = 1; e < t.length; e++) {\n            const r = t[e],\n              i = Array.isArray(n) ? n[e - 1] : n.type,\n              a = o.parse(r, 1 + s.length, i);\n            if (!a) {\n              c = !0;\n              break;\n            }\n            s.push(a);\n          }\n          if (!c) if (Array.isArray(n) && n.length !== s.length) o.error(`Expected ${n.length} arguments, but found ${s.length} instead.`);else {\n            for (let t = 0; t < s.length; t++) {\n              const e = Array.isArray(n) ? n[t] : n.type,\n                r = s[t];\n              o.concat(t + 1).checkSubtype(e, r.type);\n            }\n            if (0 === o.errors.length) return new gr(r, i, u, s, l);\n          }\n        }\n        if (1 === a.length) e.errors.push(...o.errors);else {\n          const r = (a.length ? a : s.map(([t]) => t)).map(xr).join(\" | \"),\n            n = [];\n          for (let r = 1; r < t.length; r++) {\n            const i = e.parse(t[r], 1 + n.length);\n            if (!i) return null;\n            n.push(Ye(i.type));\n          }\n          e.error(`Expected arguments of type ${r}, but found (${n.join(\", \")}) instead.`);\n        }\n        return null;\n      }\n      static register(t, e) {\n        gr.definitions = e;\n        for (const r in e) t[r] = gr;\n      }\n    }\n    function xr(t) {\n      return Array.isArray(t) ? `(${t.map(Ye).join(\", \")})` : `(${Ye(t.type)}...)`;\n    }\n    class vr {\n      constructor(t, e, r) {\n        this.type = je, this.locale = r, this.caseSensitive = t, this.diacriticSensitive = e;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(\"Expected one argument.\");\n        const r = t[1];\n        if (\"object\" != typeof r || Array.isArray(r)) return e.error(\"Collator options argument must be an object.\");\n        const n = void 0 === r[\"case-sensitive\"] ? e.parse(!1, 1, Fe) : e.parseObjectValue(r[\"case-sensitive\"], 1, \"case-sensitive\", Fe);\n        if (!n) return null;\n        const i = void 0 === r[\"diacritic-sensitive\"] ? e.parse(!1, 1, Fe) : e.parseObjectValue(r[\"diacritic-sensitive\"], 1, \"diacritic-sensitive\", Fe);\n        if (!i) return null;\n        let s = null;\n        return r.locale && (s = e.parseObjectValue(r.locale, 1, \"locale\", Le), !s) ? null : new vr(n, i, s);\n      }\n      evaluate(t) {\n        return new Ke(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);\n      }\n      eachChild(t) {\n        t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        const t = {};\n        return t[\"case-sensitive\"] = this.caseSensitive.serialize(), t[\"diacritic-sensitive\"] = this.diacriticSensitive.serialize(), this.locale && (t.locale = this.locale.serialize()), [\"collator\", t];\n      }\n    }\n    function br(t, e, r = 0, n = t.length - 1, i = wr) {\n      for (; n > r;) {\n        if (n - r > 600) {\n          const s = n - r + 1,\n            a = e - r + 1,\n            o = Math.log(s),\n            l = .5 * Math.exp(2 * o / 3),\n            u = .5 * Math.sqrt(o * l * (s - l) / s) * (a - s / 2 < 0 ? -1 : 1);\n          br(t, e, Math.max(r, Math.floor(e - a * l / s + u)), Math.min(n, Math.floor(e + (s - a) * l / s + u)), i);\n        }\n        const s = t[e];\n        let a = r,\n          o = n;\n        for (_r(t, r, e), i(t[n], s) > 0 && _r(t, r, n); a < o;) {\n          for (_r(t, a, o), a++, o--; i(t[a], s) < 0;) a++;\n          for (; i(t[o], s) > 0;) o--;\n        }\n        0 === i(t[r], s) ? _r(t, r, o) : (o++, _r(t, o, n)), o <= e && (r = o + 1), e <= o && (n = o - 1);\n      }\n    }\n    function _r(t, e, r) {\n      const n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n    function wr(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n    function Mr(t) {\n      let e = 0;\n      for (let r, n, i = 0, s = t.length, a = s - 1; i < s; a = i++) r = t[i], n = t[a], e += (n.x - r.x) * (r.y + n.y);\n      return e;\n    }\n    function Ar(t, e) {\n      t[0] = Math.min(t[0], e[0]), t[1] = Math.min(t[1], e[1]), t[2] = Math.max(t[2], e[0]), t[3] = Math.max(t[3], e[1]);\n    }\n    function Ir(t, e) {\n      return !(t[0] <= e[0] || t[2] >= e[2] || t[1] <= e[1] || t[3] >= e[3]);\n    }\n    function Sr(t, e, r) {\n      const n = t[0] - e[0],\n        i = t[1] - e[1],\n        s = t[0] - r[0],\n        a = t[1] - r[1];\n      return n * a - s * i == 0 && n * s <= 0 && i * a <= 0;\n    }\n    function Pr(t, e, r = !1) {\n      let n = !1;\n      for (let o = 0, l = e.length; o < l; o++) {\n        const l = e[o];\n        for (let e = 0, o = l.length, u = o - 1; e < o; u = e++) {\n          const o = l[u],\n            c = l[e];\n          if (Sr(t, o, c)) return r;\n          (s = o)[1] > (i = t)[1] != (a = c)[1] > i[1] && i[0] < (a[0] - s[0]) * (i[1] - s[1]) / (a[1] - s[1]) + s[0] && (n = !n);\n        }\n      }\n      var i, s, a;\n      return n;\n    }\n    function Er(t, e, r, n) {\n      const i = n[0] - r[0],\n        s = n[1] - r[1],\n        a = (t[0] - r[0]) * s - i * (t[1] - r[1]),\n        o = (e[0] - r[0]) * s - i * (e[1] - r[1]);\n      return a > 0 && o < 0 || a < 0 && o > 0;\n    }\n    function zr(t, e, r, n) {\n      return 0 != (i = [n[0] - r[0], n[1] - r[1]])[0] * (s = [e[0] - t[0], e[1] - t[1]])[1] - i[1] * s[0] && !(!Er(t, e, r, n) || !Er(r, n, t, e));\n      var i, s;\n    }\n    const kr = 8192;\n    function Tr(t, e) {\n      const r = (180 + t[0]) / 360,\n        n = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t[1] * Math.PI / 360))) / 360,\n        i = Math.pow(2, e.z);\n      return [Math.round(r * i * kr), Math.round(n * i * kr)];\n    }\n    function Br(t, e) {\n      for (let r = 0; r < e.length; r++) if (Pr(t, e[r])) return !0;\n      return !1;\n    }\n    function Vr(t, e, r) {\n      for (const n of r) for (let r = 0, i = n.length, s = i - 1; r < i; s = r++) if (zr(t, e, n[s], n[r])) return !0;\n      return !1;\n    }\n    function Cr(t, e) {\n      for (let r = 0; r < t.length; ++r) if (!Pr(t[r], e)) return !1;\n      for (let r = 0; r < t.length - 1; ++r) if (Vr(t[r], t[r + 1], e)) return !1;\n      return !0;\n    }\n    function Dr(t, e) {\n      for (let r = 0; r < e.length; r++) if (Cr(t, e[r])) return !0;\n      return !1;\n    }\n    function Rr(t, e, r) {\n      const n = [];\n      for (let i = 0; i < t.length; i++) {\n        const s = [];\n        for (let n = 0; n < t[i].length; n++) {\n          const a = Tr(t[i][n], r);\n          Ar(e, a), s.push(a);\n        }\n        n.push(s);\n      }\n      return n;\n    }\n    function Lr(t, e, r) {\n      const n = [];\n      for (let i = 0; i < t.length; i++) {\n        const s = Rr(t[i], e, r);\n        n.push(s);\n      }\n      return n;\n    }\n    function Fr(t, e, r, n) {\n      if (t[0] < r[0] || t[0] > r[2]) {\n        const e = .5 * n;\n        let i = t[0] - r[0] > e ? -n : r[0] - t[0] > e ? n : 0;\n        0 === i && (i = t[0] - r[2] > e ? -n : r[2] - t[0] > e ? n : 0), t[0] += i;\n      }\n      Ar(e, t);\n    }\n    function Or(t, e, r, n) {\n      const i = Math.pow(2, n.z) * kr,\n        s = [n.x * kr, n.y * kr],\n        a = [];\n      if (!t) return a;\n      for (const n of t) for (const t of n) {\n        const n = [t.x + s[0], t.y + s[1]];\n        Fr(n, e, r, i), a.push(n);\n      }\n      return a;\n    }\n    function Nr(t, e, r, n) {\n      const i = Math.pow(2, n.z) * kr,\n        s = [n.x * kr, n.y * kr],\n        a = [];\n      if (!t) return a;\n      for (const r of t) {\n        const t = [];\n        for (const n of r) {\n          const r = [n.x + s[0], n.y + s[1]];\n          Ar(e, r), t.push(r);\n        }\n        a.push(t);\n      }\n      if (e[2] - e[0] <= i / 2) {\n        (o = e)[0] = o[1] = 1 / 0, o[2] = o[3] = -1 / 0;\n        for (const t of a) for (const n of t) Fr(n, e, r, i);\n      }\n      var o;\n      return a;\n    }\n    class Ur {\n      constructor(t, e) {\n        this.type = Fe, this.geojson = t, this.geometries = e;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);\n        if (nr(t[1])) {\n          const e = t[1];\n          if (\"FeatureCollection\" === e.type) for (let t = 0; t < e.features.length; ++t) {\n            const r = e.features[t].geometry.type;\n            if (\"Polygon\" === r || \"MultiPolygon\" === r) return new Ur(e, e.features[t].geometry);\n          } else if (\"Feature\" === e.type) {\n            const t = e.geometry.type;\n            if (\"Polygon\" === t || \"MultiPolygon\" === t) return new Ur(e, e.geometry);\n          } else if (\"Polygon\" === e.type || \"MultiPolygon\" === e.type) return new Ur(e, e);\n        }\n        return e.error(\"'within' expression requires valid geojson object that contains polygon geometry type.\");\n      }\n      evaluate(t) {\n        if (null != t.geometry() && null != t.canonicalID()) {\n          if (\"Point\" === t.geometryType()) return function (t, e) {\n            const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              i = t.canonicalID();\n            if (!i) return !1;\n            if (\"Polygon\" === e.type) {\n              const s = Rr(e.coordinates, n, i),\n                a = Or(t.geometry(), r, n, i);\n              if (!Ir(r, n)) return !1;\n              for (const t of a) if (!Pr(t, s)) return !1;\n            }\n            if (\"MultiPolygon\" === e.type) {\n              const s = Lr(e.coordinates, n, i),\n                a = Or(t.geometry(), r, n, i);\n              if (!Ir(r, n)) return !1;\n              for (const t of a) if (!Br(t, s)) return !1;\n            }\n            return !0;\n          }(t, this.geometries);\n          if (\"LineString\" === t.geometryType()) return function (t, e) {\n            const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],\n              i = t.canonicalID();\n            if (!i) return !1;\n            if (\"Polygon\" === e.type) {\n              const s = Rr(e.coordinates, n, i),\n                a = Nr(t.geometry(), r, n, i);\n              if (!Ir(r, n)) return !1;\n              for (const t of a) if (!Cr(t, s)) return !1;\n            }\n            if (\"MultiPolygon\" === e.type) {\n              const s = Lr(e.coordinates, n, i),\n                a = Nr(t.geometry(), r, n, i);\n              if (!Ir(r, n)) return !1;\n              for (const t of a) if (!Dr(t, s)) return !1;\n            }\n            return !0;\n          }(t, this.geometries);\n        }\n        return !1;\n      }\n      eachChild() {}\n      outputDefined() {\n        return !0;\n      }\n      serialize() {\n        return [\"within\", this.geojson];\n      }\n    }\n    const jr = {\n        kilometers: 1,\n        miles: 1e3 / 1609.344,\n        nauticalmiles: 1e3 / 1852,\n        meters: 1e3,\n        metres: 1e3,\n        yards: 1e3 / .9144,\n        feet: 1e3 / .3048,\n        inches: 1e3 / .0254\n      },\n      qr = 1 / 298.257223563,\n      $r = qr * (2 - qr),\n      Gr = Math.PI / 180;\n    class Yr {\n      static fromTile(t, e, r) {\n        const n = Math.PI * (1 - 2 * (t + .5) / Math.pow(2, e)),\n          i = Math.atan(.5 * (Math.exp(n) - Math.exp(-n))) / Gr;\n        return new Yr(i, r);\n      }\n      static get units() {\n        return jr;\n      }\n      constructor(t, e) {\n        if (void 0 === t) throw new Error(\"No latitude given.\");\n        if (e && !jr[e]) throw new Error(`Unknown unit ${e}. Use one of: ${Object.keys(jr).join(\", \")}`);\n        const r = 6378.137 * Gr * (e ? jr[e] : 1),\n          n = Math.cos(t * Gr),\n          i = 1 / (1 - $r * (1 - n * n)),\n          s = Math.sqrt(i);\n        this.kx = r * s * n, this.ky = r * s * i * (1 - $r);\n      }\n      distance(t, e) {\n        const r = Zr(t[0] - e[0]) * this.kx,\n          n = (t[1] - e[1]) * this.ky;\n        return Math.sqrt(r * r + n * n);\n      }\n      bearing(t, e) {\n        const r = Zr(e[0] - t[0]) * this.kx;\n        return Math.atan2(r, (e[1] - t[1]) * this.ky) / Gr;\n      }\n      destination(t, e, r) {\n        const n = r * Gr;\n        return this.offset(t, Math.sin(n) * e, Math.cos(n) * e);\n      }\n      offset(t, e, r) {\n        return [t[0] + e / this.kx, t[1] + r / this.ky];\n      }\n      lineDistance(t) {\n        let e = 0;\n        for (let r = 0; r < t.length - 1; r++) e += this.distance(t[r], t[r + 1]);\n        return e;\n      }\n      area(t) {\n        let e = 0;\n        for (let r = 0; r < t.length; r++) {\n          const n = t[r];\n          for (let t = 0, i = n.length, s = i - 1; t < i; s = t++) e += Zr(n[t][0] - n[s][0]) * (n[t][1] + n[s][1]) * (r ? -1 : 1);\n        }\n        return Math.abs(e) / 2 * this.kx * this.ky;\n      }\n      along(t, e) {\n        let r = 0;\n        if (e <= 0) return t[0];\n        for (let n = 0; n < t.length - 1; n++) {\n          const i = t[n],\n            s = t[n + 1],\n            a = this.distance(i, s);\n          if (r += a, r > e) return Xr(i, s, (e - (r - a)) / a);\n        }\n        return t[t.length - 1];\n      }\n      pointToSegmentDistance(t, e, r) {\n        let [n, i] = e,\n          s = Zr(r[0] - n) * this.kx,\n          a = (r[1] - i) * this.ky;\n        if (0 !== s || 0 !== a) {\n          const e = (Zr(t[0] - n) * this.kx * s + (t[1] - i) * this.ky * a) / (s * s + a * a);\n          e > 1 ? (n = r[0], i = r[1]) : e > 0 && (n += s / this.kx * e, i += a / this.ky * e);\n        }\n        return s = Zr(t[0] - n) * this.kx, a = (t[1] - i) * this.ky, Math.sqrt(s * s + a * a);\n      }\n      pointOnLine(t, e) {\n        let r = 1 / 0,\n          n = t[0][0],\n          i = t[0][1],\n          s = 0,\n          a = 0;\n        for (let o = 0; o < t.length - 1; o++) {\n          let l = t[o][0],\n            u = t[o][1],\n            c = Zr(t[o + 1][0] - l) * this.kx,\n            h = (t[o + 1][1] - u) * this.ky,\n            p = 0;\n          0 === c && 0 === h || (p = (Zr(e[0] - l) * this.kx * c + (e[1] - u) * this.ky * h) / (c * c + h * h), p > 1 ? (l = t[o + 1][0], u = t[o + 1][1]) : p > 0 && (l += c / this.kx * p, u += h / this.ky * p)), c = Zr(e[0] - l) * this.kx, h = (e[1] - u) * this.ky;\n          const f = c * c + h * h;\n          f < r && (r = f, n = l, i = u, s = o, a = p);\n        }\n        return {\n          point: [n, i],\n          index: s,\n          t: Math.max(0, Math.min(1, a))\n        };\n      }\n      lineSlice(t, e, r) {\n        let n = this.pointOnLine(r, t),\n          i = this.pointOnLine(r, e);\n        if (n.index > i.index || n.index === i.index && n.t > i.t) {\n          const t = n;\n          n = i, i = t;\n        }\n        const s = [n.point],\n          a = n.index + 1,\n          o = i.index;\n        !Hr(r[a], s[0]) && a <= o && s.push(r[a]);\n        for (let t = a + 1; t <= o; t++) s.push(r[t]);\n        return Hr(r[o], i.point) || s.push(i.point), s;\n      }\n      lineSliceAlong(t, e, r) {\n        let n = 0;\n        const i = [];\n        for (let s = 0; s < r.length - 1; s++) {\n          const a = r[s],\n            o = r[s + 1],\n            l = this.distance(a, o);\n          if (n += l, n > t && 0 === i.length && i.push(Xr(a, o, (t - (n - l)) / l)), n >= e) return i.push(Xr(a, o, (e - (n - l)) / l)), i;\n          n > t && i.push(o);\n        }\n        return i;\n      }\n      bufferPoint(t, e) {\n        const r = e / this.ky,\n          n = e / this.kx;\n        return [t[0] - n, t[1] - r, t[0] + n, t[1] + r];\n      }\n      bufferBBox(t, e) {\n        const r = e / this.ky,\n          n = e / this.kx;\n        return [t[0] - n, t[1] - r, t[2] + n, t[3] + r];\n      }\n      insideBBox(t, e) {\n        return Zr(t[0] - e[0]) >= 0 && Zr(t[0] - e[2]) <= 0 && t[1] >= e[1] && t[1] <= e[3];\n      }\n    }\n    function Hr(t, e) {\n      return t[0] === e[0] && t[1] === e[1];\n    }\n    function Xr(t, e, r) {\n      const n = Zr(e[0] - t[0]);\n      return [t[0] + n * r, t[1] + (e[1] - t[1]) * r];\n    }\n    function Zr(t) {\n      for (; t < -180;) t += 360;\n      for (; t > 180;) t -= 360;\n      return t;\n    }\n    class Wr {\n      constructor(t = [], e = (t, e) => t < e ? -1 : t > e ? 1 : 0) {\n        if (this.data = t, this.length = this.data.length, this.compare = e, this.length > 0) for (let t = (this.length >> 1) - 1; t >= 0; t--) this._down(t);\n      }\n      push(t) {\n        this.data.push(t), this._up(this.length++);\n      }\n      pop() {\n        if (0 === this.length) return;\n        const t = this.data[0],\n          e = this.data.pop();\n        return --this.length > 0 && (this.data[0] = e, this._down(0)), t;\n      }\n      peek() {\n        return this.data[0];\n      }\n      _up(t) {\n        const {\n            data: e,\n            compare: r\n          } = this,\n          n = e[t];\n        for (; t > 0;) {\n          const i = t - 1 >> 1,\n            s = e[i];\n          if (r(n, s) >= 0) break;\n          e[t] = s, t = i;\n        }\n        e[t] = n;\n      }\n      _down(t) {\n        const {\n            data: e,\n            compare: r\n          } = this,\n          n = this.length >> 1,\n          i = e[t];\n        for (; t < n;) {\n          let n = 1 + (t << 1);\n          const s = n + 1;\n          if (s < this.length && r(e[s], e[n]) < 0 && (n = s), r(e[n], i) >= 0) break;\n          e[t] = e[n], t = n;\n        }\n        e[t] = i;\n      }\n    }\n    var Kr = 8192;\n    function Jr(t, e) {\n      return e.dist - t.dist;\n    }\n    const Qr = 100,\n      tn = 50;\n    function en(t) {\n      const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n      if (e.length !== t.length) return !1;\n      for (let r = 0; r < e.length; r++) if (e[r] !== t[r]) return !1;\n      return !0;\n    }\n    function rn(t) {\n      return t[1] - t[0] + 1;\n    }\n    function nn(t, e) {\n      const r = t[1] >= t[0] && t[1] < e;\n      return r || console.warn(\"Distance Expression: Index is out of range\"), r;\n    }\n    function sn(t, e) {\n      if (t[0] > t[1]) return [null, null];\n      const r = rn(t);\n      if (e) {\n        if (2 === r) return [t, null];\n        const e = Math.floor(r / 2);\n        return [[t[0], t[0] + e], [t[0] + e, t[1]]];\n      }\n      {\n        if (1 === r) return [t, null];\n        const e = Math.floor(r / 2) - 1;\n        return [[t[0], t[0] + e], [t[0] + e + 1, t[1]]];\n      }\n    }\n    function an(t, e) {\n      const r = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n      if (!nn(e, t.length)) return r;\n      for (let n = e[0]; n <= e[1]; ++n) Ar(r, t[n]);\n      return r;\n    }\n    function on(t) {\n      const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n      for (let r = 0; r < t.length; ++r) for (let n = 0; n < t[r].length; ++n) Ar(e, t[r][n]);\n      return e;\n    }\n    function ln(t, e, r) {\n      if (en(t) || en(e)) return NaN;\n      let n = 0,\n        i = 0;\n      return t[2] < e[0] && (n = e[0] - t[2]), t[0] > e[2] && (n = t[0] - e[2]), t[1] > e[3] && (i = t[1] - e[3]), t[3] < e[1] && (i = e[1] - t[3]), r.distance([0, 0], [n, i]);\n    }\n    function un(t) {\n      return 360 * t - 180;\n    }\n    function cn(t) {\n      return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90;\n    }\n    function hn(t, e) {\n      const r = Math.pow(2, e.z),\n        n = (t.y / Kr + e.y) / r;\n      return [un((t.x / Kr + e.x) / r), cn(n)];\n    }\n    function pn(t, e) {\n      const r = [];\n      for (let n = 0; n < t.length; ++n) r.push(hn(t[n], e));\n      return r;\n    }\n    function fn(t, e, r) {\n      const n = r.pointOnLine(e, t).point;\n      return r.distance(t, n);\n    }\n    function dn(t, e, r, n, i) {\n      const s = r.slice(n[0], n[1] + 1);\n      let a = 1 / 0;\n      for (let r = e[0]; r <= e[1]; ++r) if (0 === (a = Math.min(a, fn(t[r], s, i)))) return 0;\n      return a;\n    }\n    function mn(t, e, r, n, i) {\n      const s = Math.min(i.pointToSegmentDistance(t, r, n), i.pointToSegmentDistance(e, r, n)),\n        a = Math.min(i.pointToSegmentDistance(r, t, e), i.pointToSegmentDistance(n, t, e));\n      return Math.min(s, a);\n    }\n    function yn(t, e, r, n, i) {\n      if (!nn(e, t.length) || !nn(n, r.length)) return NaN;\n      let s = 1 / 0;\n      for (let a = e[0]; a < e[1]; ++a) for (let e = n[0]; e < n[1]; ++e) {\n        if (zr(t[a], t[a + 1], r[e], r[e + 1])) return 0;\n        s = Math.min(s, mn(t[a], t[a + 1], r[e], r[e + 1], i));\n      }\n      return s;\n    }\n    function gn(t, e, r, n, i) {\n      if (!nn(e, t.length) || !nn(n, r.length)) return NaN;\n      let s = 1 / 0;\n      for (let a = e[0]; a <= e[1]; ++a) for (let e = n[0]; e <= n[1]; ++e) if (0 === (s = Math.min(s, i.distance(t[a], r[e])))) return s;\n      return s;\n    }\n    function xn(t, e, r) {\n      if (Pr(t, e, !0)) return 0;\n      let n = 1 / 0;\n      for (const i of e) {\n        const e = i.length;\n        if (e < 2) return console.warn(\"Distance Expression: Invalid polygon!\"), NaN;\n        if (i[0] !== i[e - 1] && 0 === (n = Math.min(n, r.pointToSegmentDistance(t, i[e - 1], i[0])))) return n;\n        if (0 === (n = Math.min(n, fn(t, i, r)))) return n;\n      }\n      return n;\n    }\n    function vn(t, e, r, n) {\n      if (!nn(e, t.length)) return NaN;\n      for (let n = e[0]; n <= e[1]; ++n) if (Pr(t[n], r, !0)) return 0;\n      let i = 1 / 0;\n      for (let s = e[0]; s < e[1]; ++s) for (const e of r) for (let r = 0, a = e.length, o = a - 1; r < a; o = r++) {\n        if (zr(t[s], t[s + 1], e[o], e[r])) return 0;\n        i = Math.min(i, mn(t[s], t[s + 1], e[o], e[r], n));\n      }\n      return i;\n    }\n    function bn(t, e) {\n      for (const r of t) for (let t = 0; t <= r.length - 1; ++t) if (Pr(r[t], e, !0)) return !0;\n      return !1;\n    }\n    function _n(t, e, r, n = 1 / 0) {\n      const i = on(t),\n        s = on(e);\n      if (n !== 1 / 0 && ln(i, s, r) >= n) return n;\n      if (Ir(i, s)) {\n        if (bn(t, e)) return 0;\n      } else if (bn(e, t)) return 0;\n      let a = n;\n      for (const n of t) for (let t = 0, i = n.length, s = i - 1; t < i; s = t++) for (const i of e) for (let e = 0, o = i.length, l = o - 1; e < o; l = e++) {\n        if (zr(n[s], n[t], i[l], i[e])) return 0;\n        a = Math.min(a, mn(n[s], n[t], i[l], i[e], r));\n      }\n      return a;\n    }\n    function wn(t, e, r, n, i, s, a) {\n      if (null === s || null === a) return;\n      const o = ln(an(n, s), an(i, a), r);\n      o < e && t.push({\n        dist: o,\n        range1: s,\n        range2: a\n      });\n    }\n    function Mn(t, e, r, n, i = 1 / 0) {\n      let s = Math.min(n.distance(t[0], r[0][0]), i);\n      if (0 === s) return s;\n      const a = new Wr([{\n          dist: 0,\n          range1: [0, t.length - 1],\n          range2: [0, 0]\n        }], Jr),\n        o = e ? tn : Qr,\n        l = on(r);\n      for (; a.length;) {\n        const i = a.pop();\n        if (i.dist >= s) continue;\n        const u = i.range1;\n        if (rn(u) <= o) {\n          if (!nn(u, t.length)) return NaN;\n          if (e) {\n            const e = vn(t, u, r, n);\n            if (0 === (s = Math.min(s, e))) return s;\n          } else for (let e = u[0]; e <= u[1]; ++e) {\n            const i = xn(t[e], r, n);\n            if (0 === (s = Math.min(s, i))) return s;\n          }\n        } else {\n          const r = sn(u, e);\n          if (null !== r[0]) {\n            const e = ln(an(t, r[0]), l, n);\n            e < s && a.push({\n              dist: e,\n              range1: r[0],\n              range2: [0, 0]\n            });\n          }\n          if (null !== r[1]) {\n            const e = ln(an(t, r[1]), l, n);\n            e < s && a.push({\n              dist: e,\n              range1: r[1],\n              range2: [0, 0]\n            });\n          }\n        }\n      }\n      return s;\n    }\n    function An(t, e, r, n, i, s = 1 / 0) {\n      let a = Math.min(s, i.distance(t[0], r[0]));\n      if (0 === a) return a;\n      const o = new Wr([{\n          dist: 0,\n          range1: [0, t.length - 1],\n          range2: [0, r.length - 1]\n        }], Jr),\n        l = e ? tn : Qr,\n        u = n ? tn : Qr;\n      for (; o.length;) {\n        const s = o.pop();\n        if (s.dist >= a) continue;\n        const c = s.range1,\n          h = s.range2;\n        if (rn(c) <= l && rn(h) <= u) {\n          if (!nn(c, t.length) || !nn(h, r.length)) return NaN;\n          if (e && n ? a = Math.min(a, yn(t, c, r, h, i)) : e || n ? e && !n ? a = Math.min(a, dn(r, h, t, c, i)) : !e && n && (a = Math.min(a, dn(t, c, r, h, i))) : a = Math.min(a, gn(t, c, r, h, i)), 0 === a) return a;\n        } else {\n          const s = sn(c, e),\n            l = sn(h, n);\n          wn(o, a, i, t, r, s[0], l[0]), wn(o, a, i, t, r, s[0], l[1]), wn(o, a, i, t, r, s[1], l[0]), wn(o, a, i, t, r, s[1], l[1]);\n        }\n      }\n      return a;\n    }\n    function In(t, e, r, n, i = 1 / 0) {\n      let s = i;\n      const a = an(t, [0, t.length - 1]);\n      for (const i of r) if (!(s !== 1 / 0 && ln(a, an(i, [0, i.length - 1]), n) >= s) && (s = Math.min(s, An(t, e, i, !0, n, s)), 0 === s)) return s;\n      return s;\n    }\n    function Sn(t, e, r, n, i = 1 / 0) {\n      let s = i;\n      const a = an(t, [0, t.length - 1]);\n      for (const i of r) {\n        if (s !== 1 / 0 && ln(a, on(i), n) >= s) continue;\n        const r = Mn(t, e, i, n, s);\n        if (isNaN(r)) return r;\n        if (0 === (s = Math.min(s, r))) return s;\n      }\n      return s;\n    }\n    function Pn(t) {\n      return \"Point\" === t || \"MultiPoint\" === t || \"LineString\" === t || \"MultiLineString\" === t || \"Polygon\" === t || \"MultiPolygon\" === t;\n    }\n    class En {\n      constructor(t, e) {\n        this.type = Re, this.geojson = t, this.geometries = e;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(`'distance' expression requires either one argument, but found ' ${t.length - 1} instead.`);\n        if (nr(t[1])) {\n          const e = t[1];\n          if (\"FeatureCollection\" === e.type) {\n            for (let t = 0; t < e.features.length; ++t) if (Pn(e.features[t].geometry.type)) return new En(e, e.features[t].geometry);\n          } else if (\"Feature\" === e.type) {\n            if (Pn(e.geometry.type)) return new En(e, e.geometry);\n          } else if (Pn(e.type)) return new En(e, e);\n        }\n        return e.error(\"'distance' expression needs to be an array with format ['Distance', GeoJSONObj].\");\n      }\n      evaluate(t) {\n        const e = t.geometry(),\n          r = t.canonicalID();\n        if (null != e && null != r) {\n          if (\"Point\" === t.geometryType()) return function (t, e, r) {\n            const n = [];\n            for (const r of t) for (const t of r) n.push(hn(t, e));\n            const i = new Yr(n[0][1], \"meters\");\n            return \"Point\" === r.type || \"MultiPoint\" === r.type || \"LineString\" === r.type ? An(n, !1, \"Point\" === r.type ? [r.coordinates] : r.coordinates, \"LineString\" === r.type, i) : \"MultiLineString\" === r.type ? In(n, !1, r.coordinates, i) : \"Polygon\" === r.type || \"MultiPolygon\" === r.type ? Sn(n, !1, \"Polygon\" === r.type ? [r.coordinates] : r.coordinates, i) : null;\n          }(e, r, this.geometries);\n          if (\"LineString\" === t.geometryType()) return function (t, e, r) {\n            const n = [];\n            for (const r of t) {\n              const t = [];\n              for (const n of r) t.push(hn(n, e));\n              n.push(t);\n            }\n            const i = new Yr(n[0][0][1], \"meters\");\n            if (\"Point\" === r.type || \"MultiPoint\" === r.type || \"LineString\" === r.type) return In(\"Point\" === r.type ? [r.coordinates] : r.coordinates, \"LineString\" === r.type, n, i);\n            if (\"MultiLineString\" === r.type) {\n              let t = 1 / 0;\n              for (let e = 0; e < r.coordinates.length; e++) {\n                const s = In(r.coordinates[e], !0, n, i, t);\n                if (isNaN(s)) return s;\n                if (0 === (t = Math.min(t, s))) return t;\n              }\n              return t;\n            }\n            if (\"Polygon\" === r.type || \"MultiPolygon\" === r.type) {\n              let t = 1 / 0;\n              for (let e = 0; e < n.length; e++) {\n                const s = Sn(n[e], !0, \"Polygon\" === r.type ? [r.coordinates] : r.coordinates, i, t);\n                if (isNaN(s)) return s;\n                if (0 === (t = Math.min(t, s))) return t;\n              }\n              return t;\n            }\n            return null;\n          }(e, r, this.geometries);\n          if (\"Polygon\" === t.geometryType()) return function (t, e, r) {\n            const n = [];\n            for (const r of function (t, e) {\n              const r = t.length;\n              if (r <= 1) return [t];\n              const n = [];\n              let i, s;\n              for (let e = 0; e < r; e++) {\n                const r = Mr(t[e]);\n                0 !== r && (t[e].area = Math.abs(r), void 0 === s && (s = r < 0), s === r < 0 ? (i && n.push(i), i = [t[e]]) : i.push(t[e]));\n              }\n              return i && n.push(i), n;\n            }(t)) {\n              const t = [];\n              for (let n = 0; n < r.length; ++n) t.push(pn(r[n], e));\n              n.push(t);\n            }\n            const i = new Yr(n[0][0][0][1], \"meters\");\n            if (\"Point\" === r.type || \"MultiPoint\" === r.type || \"LineString\" === r.type) return Sn(\"Point\" === r.type ? [r.coordinates] : r.coordinates, \"LineString\" === r.type, n, i);\n            if (\"MultiLineString\" === r.type) {\n              let t = 1 / 0;\n              for (let e = 0; e < r.coordinates.length; e++) {\n                const s = Sn(r.coordinates[e], !0, n, i, t);\n                if (isNaN(s)) return s;\n                if (0 === (t = Math.min(t, s))) return t;\n              }\n              return t;\n            }\n            return \"Polygon\" === r.type || \"MultiPolygon\" === r.type ? function (t, e, r) {\n              let n = 1 / 0;\n              for (const i of t) for (const t of e) {\n                const e = _n(i, t, r, n);\n                if (isNaN(e)) return e;\n                if (0 === (n = Math.min(n, e))) return n;\n              }\n              return n;\n            }(\"Polygon\" === r.type ? [r.coordinates] : r.coordinates, n, i) : null;\n          }(e, r, this.geometries);\n          console.warn(\"Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.\");\n        } else console.warn(\"Distance Expression: requirs valid feature and canonical information.\");\n        return null;\n      }\n      eachChild() {}\n      outputDefined() {\n        return !0;\n      }\n      serialize() {\n        return [\"distance\", this.geojson];\n      }\n    }\n    function zn(t, e) {\n      switch (t) {\n        case \"string\":\n          return sr(e);\n        case \"number\":\n          return +e;\n        case \"boolean\":\n          return !!e;\n        case \"color\":\n          return Se.parse(e);\n        case \"formatted\":\n          return Qe.fromString(sr(e));\n        case \"resolvedImage\":\n          return er.build(sr(e));\n      }\n      return e;\n    }\n    function kn(t, e, r, n) {\n      return void 0 !== n && (t = n * Math.round(t / n)), void 0 !== e && t < e && (t = e), void 0 !== r && t > r && (t = r), t;\n    }\n    class Tn {\n      constructor(t, e, r) {\n        this.type = t, this.key = e, this.scope = r;\n      }\n      static parse(t, e) {\n        let r = e.expectedType;\n        if (null == r && (r = Ue), t.length < 2 || t.length > 3) return e.error(\"Invalid number of arguments for 'config' expression.\");\n        const n = e.parse(t[1], 1);\n        if (!(n instanceof ar)) return e.error(\"Key name of 'config' expression must be a string literal.\");\n        if (t.length >= 3) {\n          const i = e.parse(t[2], 2);\n          return i instanceof ar ? new Tn(r, sr(n.value), sr(i.value)) : e.error(\"Scope of 'config' expression must be a string literal.\");\n        }\n        return new Tn(r, sr(n.value));\n      }\n      evaluate(t) {\n        const e = [this.key, this.scope, t.scope].filter(Boolean).join(\"\u001f\"),\n          r = t.getConfig(e);\n        if (!r) return null;\n        const {\n            type: n,\n            value: i,\n            values: s,\n            minValue: a,\n            maxValue: o,\n            stepValue: l\n          } = r,\n          u = r.default.evaluate(t);\n        let c = u;\n        if (i) {\n          const e = t.scope;\n          t.scope = (e || \"\").split(\"\u001f\").slice(1).join(\"\u001f\"), c = i.evaluate(t), t.scope = e;\n        }\n        return n && (c = zn(n, c)), void 0 === c || void 0 === a && void 0 === o && void 0 === l || (\"number\" == typeof c ? c = kn(c, a, o, l) : Array.isArray(c) && (c = c.map(t => \"number\" == typeof t ? kn(t, a, o, l) : t))), void 0 !== i && void 0 !== c && s && !s.includes(c) && (c = u, n && (c = zn(n, c))), (n && n !== this.type || void 0 !== c && ir(c) !== this.type) && (c = zn(this.type.kind, c)), c;\n      }\n      eachChild() {}\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        const t = [\"config\", this.key];\n        return this.scope && t.concat(this.key), t;\n      }\n    }\n    function Bn(t) {\n      if (t instanceof gr) {\n        if (\"get\" === t.name && 1 === t.args.length) return !1;\n        if (\"feature-state\" === t.name) return !1;\n        if (\"has\" === t.name && 1 === t.args.length) return !1;\n        if (\"properties\" === t.name || \"geometry-type\" === t.name || \"id\" === t.name) return !1;\n        if (/^filter-/.test(t.name)) return !1;\n      }\n      if (t instanceof Ur) return !1;\n      if (t instanceof En) return !1;\n      let e = !0;\n      return t.eachChild(t => {\n        e && !Bn(t) && (e = !1);\n      }), e;\n    }\n    function Vn(t) {\n      if (t instanceof gr && \"feature-state\" === t.name) return !1;\n      let e = !0;\n      return t.eachChild(t => {\n        e && !Vn(t) && (e = !1);\n      }), e;\n    }\n    function Cn(t) {\n      if (t instanceof Tn) return new Set([t.key]);\n      let e = new Set();\n      return t.eachChild(t => {\n        e = new Set([...e, ...Cn(t)]);\n      }), e;\n    }\n    function Dn(t, e) {\n      if (t instanceof gr && e.indexOf(t.name) >= 0) return !1;\n      let r = !0;\n      return t.eachChild(t => {\n        r && !Dn(t, e) && (r = !1);\n      }), r;\n    }\n    class Rn {\n      constructor(t, e) {\n        this.type = e.type, this.name = t, this.boundExpression = e;\n      }\n      static parse(t, e) {\n        if (2 !== t.length || \"string\" != typeof t[1]) return e.error(\"'var' expression requires exactly one string literal argument.\");\n        const r = t[1];\n        return e.scope.has(r) ? new Rn(r, e.scope.get(r)) : e.error(`Unknown variable \"${r}\". Make sure \"${r}\" has been bound in an enclosing \"let\" expression before using it.`, 1);\n      }\n      evaluate(t) {\n        return this.boundExpression.evaluate(t);\n      }\n      eachChild() {}\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return [\"var\", this.name];\n      }\n    }\n    class Ln {\n      constructor(t, e = [], r, n = new Ce(), i = [], s, a) {\n        this.registry = t, this.path = e, this.key = e.map(t => \"string\" == typeof t ? `['${t}']` : `[${t}]`).join(\"\"), this.scope = n, this.errors = i, this.expectedType = r, this._scope = s, this.options = a;\n      }\n      parse(t, e, r, n, i = {}) {\n        return e || r ? this.concat(e, null, r, n)._parse(t, i) : this._parse(t, i);\n      }\n      parseObjectValue(t, e, r, n, i, s = {}) {\n        return this.concat(e, r, n, i)._parse(t, s);\n      }\n      _parse(t, e) {\n        function r(t, e, r) {\n          return \"assert\" === r ? new ur(e, [t]) : \"coerce\" === r ? new dr(e, [t]) : t;\n        }\n        if (null !== t && \"string\" != typeof t && \"boolean\" != typeof t && \"number\" != typeof t || (t = [\"literal\", t]), Array.isArray(t)) {\n          if (0 === t.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].');\n          const n = \"string\" == typeof t[0] ? this.registry[t[0]] : void 0;\n          if (n) {\n            let i = n.parse(t, this);\n            if (!i) return null;\n            if (this.expectedType) {\n              const t = this.expectedType,\n                n = i.type;\n              if (\"string\" !== t.kind && \"number\" !== t.kind && \"boolean\" !== t.kind && \"object\" !== t.kind && \"array\" !== t.kind || \"value\" !== n.kind) {\n                if (\"color\" !== t.kind && \"formatted\" !== t.kind && \"resolvedImage\" !== t.kind || \"value\" !== n.kind && \"string\" !== n.kind) {\n                  if (this.checkSubtype(t, n)) return null;\n                } else i = r(i, t, e.typeAnnotation || \"coerce\");\n              } else i = r(i, t, e.typeAnnotation || \"assert\");\n            }\n            if (!(i instanceof ar) && \"resolvedImage\" !== i.type.kind && On(i)) {\n              const t = new yr(this._scope, this.options);\n              try {\n                i = new ar(i.type, i.evaluate(t));\n              } catch (t) {\n                return this.error(t.message), null;\n              }\n            }\n            return i;\n          }\n          return dr.parse([\"to-array\", t], this);\n        }\n        return this.error(void 0 === t ? \"'undefined' value invalid. Use null instead.\" : \"object\" == typeof t ? 'Bare objects invalid. Use [\"literal\", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);\n      }\n      concat(t, e, r, n) {\n        let i = \"number\" == typeof t ? this.path.concat(t) : this.path;\n        i = \"string\" == typeof e ? i.concat(e) : i;\n        const s = n ? this.scope.concat(n) : this.scope;\n        return new Ln(this.registry, i, r || null, s, this.errors, this._scope, this.options);\n      }\n      error(t, ...e) {\n        const r = `${this.key}${e.map(t => `[${t}]`).join(\"\")}`;\n        this.errors.push(new Ve(r, t));\n      }\n      checkSubtype(t, e) {\n        const r = Xe(t, e);\n        return r && this.error(r), r;\n      }\n    }\n    var Fn = Ln;\n    function On(t) {\n      if (t instanceof Rn) return On(t.boundExpression);\n      if (t instanceof gr && \"error\" === t.name) return !1;\n      if (t instanceof vr) return !1;\n      if (t instanceof Ur) return !1;\n      if (t instanceof En) return !1;\n      if (t instanceof Tn) return !1;\n      const e = t instanceof dr || t instanceof ur;\n      let r = !0;\n      return t.eachChild(t => {\n        r = e ? r && On(t) : r && t instanceof ar;\n      }), !!r && Bn(t) && Dn(t, [\"zoom\", \"heatmap-density\", \"line-progress\", \"raster-value\", \"sky-radial-progress\", \"accumulated\", \"is-supported-script\", \"pitch\", \"distance-from-center\", \"measure-light\", \"raster-particle-speed\"]);\n    }\n    function Nn(t, e) {\n      const r = t.length - 1;\n      let n,\n        i,\n        s = 0,\n        a = r,\n        o = 0;\n      for (; s <= a;) if (o = Math.floor((s + a) / 2), n = t[o], i = t[o + 1], n <= e) {\n        if (o === r || e < i) return o;\n        s = o + 1;\n      } else {\n        if (!(n > e)) throw new or(\"Input is not a number.\");\n        a = o - 1;\n      }\n      return 0;\n    }\n    class Un {\n      constructor(t, e, r) {\n        this.type = t, this.input = e, this.labels = [], this.outputs = [];\n        for (const [t, e] of r) this.labels.push(t), this.outputs.push(e);\n      }\n      static parse(t, e) {\n        if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);\n        if ((t.length - 1) % 2 != 0) return e.error(\"Expected an even number of arguments.\");\n        const r = e.parse(t[1], 1, Re);\n        if (!r) return null;\n        const n = [];\n        let i = null;\n        e.expectedType && \"value\" !== e.expectedType.kind && (i = e.expectedType);\n        for (let r = 1; r < t.length; r += 2) {\n          const s = 1 === r ? -1 / 0 : t[r],\n            a = t[r + 1],\n            o = r,\n            l = r + 1;\n          if (\"number\" != typeof s) return e.error('Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o);\n          if (n.length && n[n.length - 1][0] >= s) return e.error('Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.', o);\n          const u = e.parse(a, l, i);\n          if (!u) return null;\n          i = i || u.type, n.push([s, u]);\n        }\n        return new Un(i, r, n);\n      }\n      evaluate(t) {\n        const e = this.labels,\n          r = this.outputs;\n        if (1 === e.length) return r[0].evaluate(t);\n        const n = this.input.evaluate(t);\n        if (n <= e[0]) return r[0].evaluate(t);\n        const i = e.length;\n        return n >= e[i - 1] ? r[i - 1].evaluate(t) : r[Nn(e, n)].evaluate(t);\n      }\n      eachChild(t) {\n        t(this.input);\n        for (const e of this.outputs) t(e);\n      }\n      outputDefined() {\n        return this.outputs.every(t => t.outputDefined());\n      }\n      serialize() {\n        const t = [\"step\", this.input.serialize()];\n        for (let e = 0; e < this.labels.length; e++) e > 0 && t.push(this.labels[e]), t.push(this.outputs[e].serialize());\n        return t;\n      }\n    }\n    const jn = .95047,\n      qn = 1.08883,\n      $n = 4 / 29,\n      Gn = 6 / 29,\n      Yn = 3 * Gn * Gn,\n      Hn = Gn * Gn * Gn,\n      Xn = Math.PI / 180,\n      Zn = 180 / Math.PI;\n    function Wn(t) {\n      return t > Hn ? Math.pow(t, 1 / 3) : t / Yn + $n;\n    }\n    function Kn(t) {\n      return t > Gn ? t * t * t : Yn * (t - $n);\n    }\n    function Jn(t) {\n      return 255 * (t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055);\n    }\n    function Qn(t) {\n      return (t /= 255) <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);\n    }\n    function ti(t) {\n      const e = Qn(t.r),\n        r = Qn(t.g),\n        n = Qn(t.b),\n        i = Wn((.4124564 * e + .3575761 * r + .1804375 * n) / jn),\n        s = Wn((.2126729 * e + .7151522 * r + .072175 * n) / 1);\n      return {\n        l: 116 * s - 16,\n        a: 500 * (i - s),\n        b: 200 * (s - Wn((.0193339 * e + .119192 * r + .9503041 * n) / qn)),\n        alpha: t.a\n      };\n    }\n    function ei(t) {\n      let e = (t.l + 16) / 116,\n        r = isNaN(t.a) ? e : e + t.a / 500,\n        n = isNaN(t.b) ? e : e - t.b / 200;\n      return e = 1 * Kn(e), r = jn * Kn(r), n = qn * Kn(n), new Se(Jn(3.2404542 * r - 1.5371385 * e - .4985314 * n), Jn(-.969266 * r + 1.8760108 * e + .041556 * n), Jn(.0556434 * r - .2040259 * e + 1.0572252 * n), t.alpha);\n    }\n    function ri(t, e, r) {\n      const n = e - t;\n      return t + r * (n > 180 || n < -180 ? n - 360 * Math.round(n / 360) : n);\n    }\n    const ni = {\n        forward: ti,\n        reverse: ei,\n        interpolate: function (t, e, r) {\n          return {\n            l: Ee(t.l, e.l, r),\n            a: Ee(t.a, e.a, r),\n            b: Ee(t.b, e.b, r),\n            alpha: Ee(t.alpha, e.alpha, r)\n          };\n        }\n      },\n      ii = {\n        forward: function (t) {\n          const {\n              l: e,\n              a: r,\n              b: n\n            } = ti(t),\n            i = Math.atan2(n, r) * Zn;\n          return {\n            h: i < 0 ? i + 360 : i,\n            c: Math.sqrt(r * r + n * n),\n            l: e,\n            alpha: t.a\n          };\n        },\n        reverse: function (t) {\n          const e = t.h * Xn,\n            r = t.c;\n          return ei({\n            l: t.l,\n            a: Math.cos(e) * r,\n            b: Math.sin(e) * r,\n            alpha: t.alpha\n          });\n        },\n        interpolate: function (t, e, r) {\n          return {\n            h: ri(t.h, e.h, r),\n            c: Ee(t.c, e.c, r),\n            l: Ee(t.l, e.l, r),\n            alpha: Ee(t.alpha, e.alpha, r)\n          };\n        }\n      };\n    var si = Object.freeze({\n      __proto__: null,\n      hcl: ii,\n      lab: ni\n    });\n    class ai {\n      constructor(t, e, r, n, i) {\n        this.type = t, this.operator = e, this.interpolation = r, this.input = n, this.labels = [], this.outputs = [];\n        for (const [t, e] of i) this.labels.push(t), this.outputs.push(e);\n      }\n      static interpolationFactor(t, e, r, n) {\n        let i = 0;\n        if (\"exponential\" === t.name) i = oi(e, t.base, r, n);else if (\"linear\" === t.name) i = oi(e, 1, r, n);else if (\"cubic-bezier\" === t.name) {\n          const s = t.controlPoints;\n          i = new U(s[0], s[1], s[2], s[3]).solve(oi(e, 1, r, n));\n        }\n        return i;\n      }\n      static parse(t, e) {\n        let [r, n, i, ...s] = t;\n        if (!Array.isArray(n) || 0 === n.length) return e.error(\"Expected an interpolation type expression.\", 1);\n        if (\"linear\" === n[0]) n = {\n          name: \"linear\"\n        };else if (\"exponential\" === n[0]) {\n          const t = n[1];\n          if (\"number\" != typeof t) return e.error(\"Exponential interpolation requires a numeric base.\", 1, 1);\n          n = {\n            name: \"exponential\",\n            base: t\n          };\n        } else {\n          if (\"cubic-bezier\" !== n[0]) return e.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);\n          {\n            const t = n.slice(1);\n            if (4 !== t.length || t.some(t => \"number\" != typeof t || t < 0 || t > 1)) return e.error(\"Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.\", 1);\n            n = {\n              name: \"cubic-bezier\",\n              controlPoints: t\n            };\n          }\n        }\n        if (t.length - 1 < 4) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);\n        if (t.length - 1 > 3 && (t.length - 1) % 2 != 0) return e.error(\"Expected an even number of arguments.\");\n        if (i = e.parse(i, 2, Re), !i) return null;\n        const a = [];\n        let o = null;\n        \"interpolate-hcl\" === r || \"interpolate-lab\" === r ? o = Oe : e.expectedType && \"value\" !== e.expectedType.kind && (o = e.expectedType);\n        for (let t = 0; t < s.length; t += 2) {\n          const r = s[t],\n            n = s[t + 1],\n            i = t + 3,\n            l = t + 4;\n          if (\"number\" != typeof r) return e.error('Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i);\n          if (a.length && a[a.length - 1][0] >= r) return e.error('Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.', i);\n          const u = e.parse(n, l, o);\n          if (!u) return null;\n          o = o || u.type, a.push([r, u]);\n        }\n        return \"number\" === o.kind || \"color\" === o.kind || \"array\" === o.kind && \"number\" === o.itemType.kind && \"number\" == typeof o.N ? new ai(o, r, n, i, a) : e.error(`Type ${Ye(o)} is not interpolatable.`);\n      }\n      evaluate(t) {\n        const e = this.labels,\n          r = this.outputs;\n        if (1 === e.length) return r[0].evaluate(t);\n        const n = this.input.evaluate(t);\n        if (n <= e[0]) return r[0].evaluate(t);\n        const i = e.length;\n        if (n >= e[i - 1]) return r[i - 1].evaluate(t);\n        const s = Nn(e, n),\n          a = ai.interpolationFactor(this.interpolation, n, e[s], e[s + 1]),\n          o = r[s].evaluate(t),\n          l = r[s + 1].evaluate(t);\n        return \"interpolate\" === this.operator ? Te[this.type.kind.toLowerCase()](o, l, a) : \"interpolate-hcl\" === this.operator ? ii.reverse(ii.interpolate(ii.forward(o), ii.forward(l), a)) : ni.reverse(ni.interpolate(ni.forward(o), ni.forward(l), a));\n      }\n      eachChild(t) {\n        t(this.input);\n        for (const e of this.outputs) t(e);\n      }\n      outputDefined() {\n        return this.outputs.every(t => t.outputDefined());\n      }\n      serialize() {\n        let t;\n        t = \"linear\" === this.interpolation.name ? [\"linear\"] : \"exponential\" === this.interpolation.name ? 1 === this.interpolation.base ? [\"linear\"] : [\"exponential\", this.interpolation.base] : [\"cubic-bezier\", ...this.interpolation.controlPoints];\n        const e = [this.operator, t, this.input.serialize()];\n        for (let t = 0; t < this.labels.length; t++) e.push(this.labels[t], this.outputs[t].serialize());\n        return e;\n      }\n    }\n    function oi(t, e, r, n) {\n      const i = n - r,\n        s = t - r;\n      return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);\n    }\n    class li {\n      constructor(t, e) {\n        this.type = t, this.args = e;\n      }\n      static parse(t, e) {\n        if (t.length < 2) return e.error(\"Expectected at least one argument.\");\n        let r = null;\n        const n = e.expectedType;\n        n && \"value\" !== n.kind && (r = n);\n        const i = [];\n        for (const n of t.slice(1)) {\n          const t = e.parse(n, 1 + i.length, r, void 0, {\n            typeAnnotation: \"omit\"\n          });\n          if (!t) return null;\n          r = r || t.type, i.push(t);\n        }\n        const s = n && i.some(t => Xe(n, t.type));\n        return new li(s ? Ue : r, i);\n      }\n      evaluate(t) {\n        let e,\n          r = null,\n          n = 0;\n        for (const i of this.args) {\n          if (n++, r = i.evaluate(t), r && r instanceof er && !r.available && (e || (e = r), r = null, n === this.args.length)) return e;\n          if (null !== r) break;\n        }\n        return r;\n      }\n      eachChild(t) {\n        this.args.forEach(t);\n      }\n      outputDefined() {\n        return this.args.every(t => t.outputDefined());\n      }\n      serialize() {\n        const t = [\"coalesce\"];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n    }\n    class ui {\n      constructor(t, e) {\n        this.type = e.type, this.bindings = [].concat(t), this.result = e;\n      }\n      evaluate(t) {\n        return this.result.evaluate(t);\n      }\n      eachChild(t) {\n        for (const e of this.bindings) t(e[1]);\n        t(this.result);\n      }\n      static parse(t, e) {\n        if (t.length < 4) return e.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);\n        const r = [];\n        for (let n = 1; n < t.length - 1; n += 2) {\n          const i = t[n];\n          if (\"string\" != typeof i) return e.error(`Expected string, but found ${typeof i} instead.`, n);\n          if (/[^a-zA-Z0-9_]/.test(i)) return e.error(\"Variable names must contain only alphanumeric characters or '_'.\", n);\n          const s = e.parse(t[n + 1], n + 1);\n          if (!s) return null;\n          r.push([i, s]);\n        }\n        const n = e.parse(t[t.length - 1], t.length - 1, e.expectedType, r);\n        return n ? new ui(r, n) : null;\n      }\n      outputDefined() {\n        return this.result.outputDefined();\n      }\n      serialize() {\n        const t = [\"let\"];\n        for (const [e, r] of this.bindings) t.push(e, r.serialize());\n        return t.push(this.result.serialize()), t;\n      }\n    }\n    class ci {\n      constructor(t, e, r) {\n        this.type = t, this.index = e, this.input = r;\n      }\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, Re),\n          n = e.parse(t[2], 2, Ge(e.expectedType || Ue));\n        return r && n ? new ci(n.type.itemType, r, n) : null;\n      }\n      evaluate(t) {\n        const e = this.index.evaluate(t),\n          r = this.input.evaluate(t);\n        if (e < 0) throw new or(`Array index out of bounds: ${e} < 0.`);\n        if (e >= r.length) throw new or(`Array index out of bounds: ${e} > ${r.length - 1}.`);\n        if (e !== Math.floor(e)) throw new or(`Array index must be an integer, but found ${e} instead. Use at-interpolated to retrieve interpolated result with a fractional index.`);\n        return r[e];\n      }\n      eachChild(t) {\n        t(this.index), t(this.input);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return [\"at\", this.index.serialize(), this.input.serialize()];\n      }\n    }\n    class hi {\n      constructor(t, e, r) {\n        this.type = t, this.index = e, this.input = r;\n      }\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, Re),\n          n = e.parse(t[2], 2, Ge(e.expectedType || Ue));\n        return r && n ? new hi(n.type.itemType, r, n) : null;\n      }\n      evaluate(t) {\n        const e = this.index.evaluate(t),\n          r = this.input.evaluate(t);\n        if (e < 0) throw new or(`Array index out of bounds: ${e} < 0.`);\n        if (e > r.length - 1) throw new or(`Array index out of bounds: ${e} > ${r.length - 1}.`);\n        if (e === Math.floor(e)) return r[e];\n        const n = Math.floor(e),\n          i = Math.ceil(e),\n          s = r[n],\n          a = r[i];\n        if (\"number\" != typeof s || \"number\" != typeof a) throw new or(`Cannot interpolate between non-number values at index ${e}.`);\n        const o = e - n;\n        return s * (1 - o) + a * o;\n      }\n      eachChild(t) {\n        t(this.index), t(this.input);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return [\"at-interpolated\", this.index.serialize(), this.input.serialize()];\n      }\n    }\n    class pi {\n      constructor(t, e) {\n        this.type = Fe, this.needle = t, this.haystack = e;\n      }\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, Ue),\n          n = e.parse(t[2], 2, Ue);\n        return r && n ? Ze(r.type, [Fe, Le, Re, De, Ue]) ? new pi(r, n) : e.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ye(r.type)} instead`) : null;\n      }\n      evaluate(t) {\n        const e = this.needle.evaluate(t),\n          r = this.haystack.evaluate(t);\n        if (null == r) return !1;\n        if (!We(e, [\"boolean\", \"string\", \"number\", \"null\"])) throw new or(`Expected first argument to be of type boolean, string, number or null, but found ${Ye(ir(e))} instead.`);\n        if (!We(r, [\"string\", \"array\"])) throw new or(`Expected second argument to be of type array or string, but found ${Ye(ir(r))} instead.`);\n        return r.indexOf(e) >= 0;\n      }\n      eachChild(t) {\n        t(this.needle), t(this.haystack);\n      }\n      outputDefined() {\n        return !0;\n      }\n      serialize() {\n        return [\"in\", this.needle.serialize(), this.haystack.serialize()];\n      }\n    }\n    class fi {\n      constructor(t, e, r) {\n        this.type = Re, this.needle = t, this.haystack = e, this.fromIndex = r;\n      }\n      static parse(t, e) {\n        if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, Ue),\n          n = e.parse(t[2], 2, Ue);\n        if (!r || !n) return null;\n        if (!Ze(r.type, [Fe, Le, Re, De, Ue])) return e.error(`Expected first argument to be of type boolean, string, number or null, but found ${Ye(r.type)} instead`);\n        if (4 === t.length) {\n          const i = e.parse(t[3], 3, Re);\n          return i ? new fi(r, n, i) : null;\n        }\n        return new fi(r, n);\n      }\n      evaluate(t) {\n        const e = this.needle.evaluate(t),\n          r = this.haystack.evaluate(t);\n        if (!We(e, [\"boolean\", \"string\", \"number\", \"null\"])) throw new or(`Expected first argument to be of type boolean, string, number or null, but found ${Ye(ir(e))} instead.`);\n        if (!We(r, [\"string\", \"array\"])) throw new or(`Expected second argument to be of type array or string, but found ${Ye(ir(r))} instead.`);\n        if (this.fromIndex) {\n          const n = this.fromIndex.evaluate(t);\n          return r.indexOf(e, n);\n        }\n        return r.indexOf(e);\n      }\n      eachChild(t) {\n        t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        if (null != this.fromIndex && void 0 !== this.fromIndex) {\n          const t = this.fromIndex.serialize();\n          return [\"index-of\", this.needle.serialize(), this.haystack.serialize(), t];\n        }\n        return [\"index-of\", this.needle.serialize(), this.haystack.serialize()];\n      }\n    }\n    class di {\n      constructor(t, e, r, n, i, s) {\n        this.inputType = t, this.type = e, this.input = r, this.cases = n, this.outputs = i, this.otherwise = s;\n      }\n      static parse(t, e) {\n        if (t.length < 5) return e.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);\n        if (t.length % 2 != 1) return e.error(\"Expected an even number of arguments.\");\n        let r, n;\n        e.expectedType && \"value\" !== e.expectedType.kind && (n = e.expectedType);\n        const i = {},\n          s = [];\n        for (let a = 2; a < t.length - 1; a += 2) {\n          let o = t[a];\n          const l = t[a + 1];\n          Array.isArray(o) || (o = [o]);\n          const u = e.concat(a);\n          if (0 === o.length) return u.error(\"Expected at least one branch label.\");\n          for (const t of o) {\n            if (\"number\" != typeof t && \"string\" != typeof t) return u.error(\"Branch labels must be numbers or strings.\");\n            if (\"number\" == typeof t && Math.abs(t) > Number.MAX_SAFE_INTEGER) return u.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);\n            if (\"number\" == typeof t && Math.floor(t) !== t) return u.error(\"Numeric branch labels must be integer values.\");\n            if (r) {\n              if (u.checkSubtype(r, ir(t))) return null;\n            } else r = ir(t);\n            if (void 0 !== i[String(t)]) return u.error(\"Branch labels must be unique.\");\n            i[String(t)] = s.length;\n          }\n          const c = e.parse(l, a, n);\n          if (!c) return null;\n          n = n || c.type, s.push(c);\n        }\n        const a = e.parse(t[1], 1, Ue);\n        if (!a) return null;\n        const o = e.parse(t[t.length - 1], t.length - 1, n);\n        return o ? \"value\" !== a.type.kind && e.concat(1).checkSubtype(r, a.type) ? null : new di(r, n, a, i, s, o) : null;\n      }\n      evaluate(t) {\n        const e = this.input.evaluate(t);\n        return (ir(e) === this.inputType && this.outputs[this.cases[e]] || this.otherwise).evaluate(t);\n      }\n      eachChild(t) {\n        t(this.input), this.outputs.forEach(t), t(this.otherwise);\n      }\n      outputDefined() {\n        return this.outputs.every(t => t.outputDefined()) && this.otherwise.outputDefined();\n      }\n      serialize() {\n        const t = [\"match\", this.input.serialize()],\n          e = Object.keys(this.cases).sort(),\n          r = [],\n          n = {};\n        for (const t of e) {\n          const e = n[this.cases[t]];\n          void 0 === e ? (n[this.cases[t]] = r.length, r.push([this.cases[t], [t]])) : r[e][1].push(t);\n        }\n        const i = t => \"number\" === this.inputType.kind ? Number(t) : t;\n        for (const [e, n] of r) t.push(1 === n.length ? i(n[0]) : n.map(i)), t.push(this.outputs[e].serialize());\n        return t.push(this.otherwise.serialize()), t;\n      }\n    }\n    class mi {\n      constructor(t, e, r) {\n        this.type = t, this.branches = e, this.otherwise = r;\n      }\n      static parse(t, e) {\n        if (t.length < 4) return e.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);\n        if (t.length % 2 != 0) return e.error(\"Expected an odd number of arguments.\");\n        let r;\n        e.expectedType && \"value\" !== e.expectedType.kind && (r = e.expectedType);\n        const n = [];\n        for (let i = 1; i < t.length - 1; i += 2) {\n          const s = e.parse(t[i], i, Fe);\n          if (!s) return null;\n          const a = e.parse(t[i + 1], i + 1, r);\n          if (!a) return null;\n          n.push([s, a]), r = r || a.type;\n        }\n        const i = e.parse(t[t.length - 1], t.length - 1, r);\n        return i ? new mi(r, n, i) : null;\n      }\n      evaluate(t) {\n        for (const [e, r] of this.branches) if (e.evaluate(t)) return r.evaluate(t);\n        return this.otherwise.evaluate(t);\n      }\n      eachChild(t) {\n        for (const [e, r] of this.branches) t(e), t(r);\n        t(this.otherwise);\n      }\n      outputDefined() {\n        return this.branches.every(([t, e]) => e.outputDefined()) && this.otherwise.outputDefined();\n      }\n      serialize() {\n        const t = [\"case\"];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n    }\n    class yi {\n      constructor(t, e, r, n) {\n        this.type = t, this.input = e, this.beginIndex = r, this.endIndex = n;\n      }\n      static parse(t, e) {\n        if (t.length <= 2 || t.length >= 5) return e.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1, Ue),\n          n = e.parse(t[2], 2, Re);\n        if (!r || !n) return null;\n        if (!Ze(r.type, [Ge(Ue), Le, Ue])) return e.error(`Expected first argument to be of type array or string, but found ${Ye(r.type)} instead`);\n        if (4 === t.length) {\n          const i = e.parse(t[3], 3, Re);\n          return i ? new yi(r.type, r, n, i) : null;\n        }\n        return new yi(r.type, r, n);\n      }\n      evaluate(t) {\n        const e = this.input.evaluate(t),\n          r = this.beginIndex.evaluate(t);\n        if (!We(e, [\"string\", \"array\"])) throw new or(`Expected first argument to be of type array or string, but found ${Ye(ir(e))} instead.`);\n        if (this.endIndex) {\n          const n = this.endIndex.evaluate(t);\n          return e.slice(r, n);\n        }\n        return e.slice(r);\n      }\n      eachChild(t) {\n        t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        if (null != this.endIndex && void 0 !== this.endIndex) {\n          const t = this.endIndex.serialize();\n          return [\"slice\", this.input.serialize(), this.beginIndex.serialize(), t];\n        }\n        return [\"slice\", this.input.serialize(), this.beginIndex.serialize()];\n      }\n    }\n    function gi(t, e) {\n      return \"==\" === t || \"!=\" === t ? \"boolean\" === e.kind || \"string\" === e.kind || \"number\" === e.kind || \"null\" === e.kind || \"value\" === e.kind : \"string\" === e.kind || \"number\" === e.kind || \"value\" === e.kind;\n    }\n    function xi(t, e, r, n) {\n      return 0 === n.compare(e, r);\n    }\n    function vi(t, e, r) {\n      const n = \"==\" !== t && \"!=\" !== t;\n      return class i {\n        constructor(t, e, r) {\n          this.type = Fe, this.lhs = t, this.rhs = e, this.collator = r, this.hasUntypedArgument = \"value\" === t.type.kind || \"value\" === e.type.kind;\n        }\n        static parse(t, e) {\n          if (3 !== t.length && 4 !== t.length) return e.error(\"Expected two or three arguments.\");\n          const r = t[0];\n          let s = e.parse(t[1], 1, Ue);\n          if (!s) return null;\n          if (!gi(r, s.type)) return e.concat(1).error(`\"${r}\" comparisons are not supported for type '${Ye(s.type)}'.`);\n          let a = e.parse(t[2], 2, Ue);\n          if (!a) return null;\n          if (!gi(r, a.type)) return e.concat(2).error(`\"${r}\" comparisons are not supported for type '${Ye(a.type)}'.`);\n          if (s.type.kind !== a.type.kind && \"value\" !== s.type.kind && \"value\" !== a.type.kind) return e.error(`Cannot compare types '${Ye(s.type)}' and '${Ye(a.type)}'.`);\n          n && (\"value\" === s.type.kind && \"value\" !== a.type.kind ? s = new ur(a.type, [s]) : \"value\" !== s.type.kind && \"value\" === a.type.kind && (a = new ur(s.type, [a])));\n          let o = null;\n          if (4 === t.length) {\n            if (\"string\" !== s.type.kind && \"string\" !== a.type.kind && \"value\" !== s.type.kind && \"value\" !== a.type.kind) return e.error(\"Cannot use collator to compare non-string types.\");\n            if (o = e.parse(t[3], 3, je), !o) return null;\n          }\n          return new i(s, a, o);\n        }\n        evaluate(i) {\n          const s = this.lhs.evaluate(i),\n            a = this.rhs.evaluate(i);\n          if (n && this.hasUntypedArgument) {\n            const e = ir(s),\n              r = ir(a);\n            if (e.kind !== r.kind || \"string\" !== e.kind && \"number\" !== e.kind) throw new or(`Expected arguments for \"${t}\" to be (string, string) or (number, number), but found (${e.kind}, ${r.kind}) instead.`);\n          }\n          if (this.collator && !n && this.hasUntypedArgument) {\n            const t = ir(s),\n              r = ir(a);\n            if (\"string\" !== t.kind || \"string\" !== r.kind) return e(i, s, a);\n          }\n          return this.collator ? r(i, s, a, this.collator.evaluate(i)) : e(i, s, a);\n        }\n        eachChild(t) {\n          t(this.lhs), t(this.rhs), this.collator && t(this.collator);\n        }\n        outputDefined() {\n          return !0;\n        }\n        serialize() {\n          const e = [t];\n          return this.eachChild(t => {\n            e.push(t.serialize());\n          }), e;\n        }\n      };\n    }\n    const bi = vi(\"==\", function (t, e, r) {\n        return e === r;\n      }, xi),\n      _i = vi(\"!=\", function (t, e, r) {\n        return e !== r;\n      }, function (t, e, r, n) {\n        return !xi(0, e, r, n);\n      }),\n      wi = vi(\"<\", function (t, e, r) {\n        return e < r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) < 0;\n      }),\n      Mi = vi(\">\", function (t, e, r) {\n        return e > r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) > 0;\n      }),\n      Ai = vi(\"<=\", function (t, e, r) {\n        return e <= r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) <= 0;\n      }),\n      Ii = vi(\">=\", function (t, e, r) {\n        return e >= r;\n      }, function (t, e, r, n) {\n        return n.compare(e, r) >= 0;\n      });\n    class Si {\n      constructor(t, e, r, n, i, s) {\n        this.type = Le, this.number = t, this.locale = e, this.currency = r, this.unit = n, this.minFractionDigits = i, this.maxFractionDigits = s;\n      }\n      static parse(t, e) {\n        if (3 !== t.length) return e.error(\"Expected two arguments.\");\n        const r = e.parse(t[1], 1, Re);\n        if (!r) return null;\n        const n = t[2];\n        if (\"object\" != typeof n || Array.isArray(n)) return e.error(\"NumberFormat options argument must be an object.\");\n        let i = null;\n        if (n.locale && (i = e.parseObjectValue(n.locale, 2, \"locale\", Le), !i)) return null;\n        let s = null;\n        if (n.currency && (s = e.parseObjectValue(n.currency, 2, \"currency\", Le), !s)) return null;\n        let a = null;\n        if (n.unit && (a = e.parseObjectValue(n.unit, 2, \"unit\", Le), !a)) return null;\n        let o = null;\n        if (n[\"min-fraction-digits\"] && (o = e.parseObjectValue(n[\"min-fraction-digits\"], 2, \"min-fraction-digits\", Re), !o)) return null;\n        let l = null;\n        return n[\"max-fraction-digits\"] && (l = e.parseObjectValue(n[\"max-fraction-digits\"], 2, \"max-fraction-digits\", Re), !l) ? null : new Si(r, i, s, a, o, l);\n      }\n      evaluate(t) {\n        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], {\n          style: (this.currency ? \"currency\" : this.unit && \"unit\") || \"decimal\",\n          currency: this.currency ? this.currency.evaluate(t) : void 0,\n          unit: this.unit ? this.unit.evaluate(t) : void 0,\n          minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,\n          maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0\n        }).format(this.number.evaluate(t));\n      }\n      eachChild(t) {\n        t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.unit && t(this.unit), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        const t = {};\n        return this.locale && (t.locale = this.locale.serialize()), this.currency && (t.currency = this.currency.serialize()), this.unit && (t.unit = this.unit.serialize()), this.minFractionDigits && (t[\"min-fraction-digits\"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t[\"max-fraction-digits\"] = this.maxFractionDigits.serialize()), [\"number-format\", this.number.serialize(), t];\n      }\n    }\n    class Pi {\n      constructor(t) {\n        this.type = Re, this.input = t;\n      }\n      static parse(t, e) {\n        if (2 !== t.length) return e.error(`Expected 1 argument, but found ${t.length - 1} instead.`);\n        const r = e.parse(t[1], 1);\n        return r ? \"array\" !== r.type.kind && \"string\" !== r.type.kind && \"value\" !== r.type.kind ? e.error(`Expected argument of type string or array, but found ${Ye(r.type)} instead.`) : new Pi(r) : null;\n      }\n      evaluate(t) {\n        const e = this.input.evaluate(t);\n        if (\"string\" == typeof e) return e.length;\n        if (Array.isArray(e)) return e.length;\n        throw new or(`Expected value to be of type string or array, but found ${Ye(ir(e))} instead.`);\n      }\n      eachChild(t) {\n        t(this.input);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        const t = [\"length\"];\n        return this.eachChild(e => {\n          t.push(e.serialize());\n        }), t;\n      }\n    }\n    function Ei(t) {\n      return function () {\n        t = 1831565813 + (t |= 0) | 0;\n        let e = Math.imul(t ^ t >>> 15, 1 | t);\n        return e = e + Math.imul(e ^ e >>> 7, 61 | e) ^ e, ((e ^ e >>> 14) >>> 0) / 4294967296;\n      };\n    }\n    const zi = {\n      \"==\": bi,\n      \"!=\": _i,\n      \">\": Mi,\n      \"<\": wi,\n      \">=\": Ii,\n      \"<=\": Ai,\n      array: ur,\n      at: ci,\n      \"at-interpolated\": hi,\n      boolean: ur,\n      case: mi,\n      coalesce: li,\n      collator: vr,\n      format: cr,\n      image: hr,\n      in: pi,\n      \"index-of\": fi,\n      interpolate: ai,\n      \"interpolate-hcl\": ai,\n      \"interpolate-lab\": ai,\n      length: Pi,\n      let: ui,\n      literal: ar,\n      match: di,\n      number: ur,\n      \"number-format\": Si,\n      object: ur,\n      slice: yi,\n      step: Un,\n      string: ur,\n      \"to-boolean\": dr,\n      \"to-color\": dr,\n      \"to-number\": dr,\n      \"to-string\": dr,\n      var: Rn,\n      within: Ur,\n      distance: En,\n      config: Tn\n    };\n    function ki(t, [e, r, n, i]) {\n      e = e.evaluate(t), r = r.evaluate(t), n = n.evaluate(t);\n      const s = i ? i.evaluate(t) : 1,\n        a = rr(e, r, n, s);\n      if (a) throw new or(a);\n      return new Se(e / 255 * s, r / 255 * s, n / 255 * s, s);\n    }\n    function Ti(t, [e, r, n, i]) {\n      e = e.evaluate(t), r = r.evaluate(t), n = n.evaluate(t);\n      const s = i ? i.evaluate(t) : 1,\n        a = function (t, e, r, n) {\n          return \"number\" == typeof t && t >= 0 && t <= 360 ? \"number\" == typeof e && e >= 0 && e <= 100 && \"number\" == typeof r && r >= 0 && r <= 100 ? void 0 === n || \"number\" == typeof n && n >= 0 && n <= 1 ? null : `Invalid hsla value [${[t, e, r, n].join(\", \")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${(\"number\" == typeof n ? [t, e, r, n] : [t, e, r]).join(\", \")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${(\"number\" == typeof n ? [t, e, r, n] : [t, e, r]).join(\", \")}]: 'h' must be between 0 and 360.`;\n        }(e, r, n, s);\n      if (a) throw new or(a);\n      const o = `hsla(${e}, ${r}%, ${n}%, ${s})`,\n        l = Se.parse(o);\n      if (!l) throw new or(`Failed to parse HSLA color: ${o}`);\n      return l;\n    }\n    function Bi(t, e) {\n      return t in e;\n    }\n    function Vi(t, e) {\n      const r = e[t];\n      return void 0 === r ? null : r;\n    }\n    function Ci(t) {\n      return {\n        type: t\n      };\n    }\n    function Di(t) {\n      return {\n        result: \"success\",\n        value: t\n      };\n    }\n    function Ri(t) {\n      return {\n        result: \"error\",\n        value: t\n      };\n    }\n    function Li(t, e) {\n      return !!t && !!t.parameters && t.parameters.indexOf(e) > -1;\n    }\n    function Fi(t) {\n      return \"data-driven\" === t[\"property-type\"];\n    }\n    function Oi(t) {\n      return Li(t.expression, \"measure-light\");\n    }\n    function Ni(t) {\n      return Li(t.expression, \"zoom\");\n    }\n    function Ui(t) {\n      return !!t.expression && t.expression.interpolated;\n    }\n    function ji(t) {\n      return \"object\" == typeof t && null !== t && !Array.isArray(t);\n    }\n    function qi(t) {\n      return t;\n    }\n    function $i(t, e) {\n      const r = \"color\" === e.type,\n        n = t.stops && \"object\" == typeof t.stops[0][0],\n        i = n || !(n || void 0 !== t.property),\n        s = t.type || (Ui(e) ? \"exponential\" : \"interval\");\n      if (r && ((t = Be({}, t)).stops && (t.stops = t.stops.map(t => [t[0], Se.parse(t[1])])), t.default = Se.parse(t.default ? t.default : e.default)), t.colorSpace && \"rgb\" !== t.colorSpace && !si[t.colorSpace]) throw new Error(`Unknown color space: ${t.colorSpace}`);\n      let a, o, l;\n      if (\"exponential\" === s) a = Xi;else if (\"interval\" === s) a = Hi;else if (\"categorical\" === s) {\n        a = Yi, o = Object.create(null);\n        for (const e of t.stops) o[e[0]] = e[1];\n        l = typeof t.stops[0][0];\n      } else {\n        if (\"identity\" !== s) throw new Error(`Unknown function type \"${s}\"`);\n        a = Zi;\n      }\n      if (n) {\n        const r = {},\n          n = [];\n        for (let e = 0; e < t.stops.length; e++) {\n          const i = t.stops[e],\n            s = i[0].zoom;\n          void 0 === r[s] && (r[s] = {\n            zoom: s,\n            type: t.type,\n            property: t.property,\n            default: t.default,\n            stops: []\n          }, n.push(s)), r[s].stops.push([i[0].value, i[1]]);\n        }\n        const i = [];\n        for (const t of n) i.push([r[t].zoom, $i(r[t], e)]);\n        const s = {\n          name: \"linear\"\n        };\n        return {\n          kind: \"composite\",\n          interpolationType: s,\n          interpolationFactor: ai.interpolationFactor.bind(void 0, s),\n          zoomStops: i.map(t => t[0]),\n          evaluate: ({\n            zoom: r\n          }, n) => Xi({\n            stops: i,\n            base: t.base\n          }, e, r).evaluate(r, n)\n        };\n      }\n      if (i) {\n        const r = \"exponential\" === s ? {\n          name: \"exponential\",\n          base: void 0 !== t.base ? t.base : 1\n        } : null;\n        return {\n          kind: \"camera\",\n          interpolationType: r,\n          interpolationFactor: ai.interpolationFactor.bind(void 0, r),\n          zoomStops: t.stops.map(t => t[0]),\n          evaluate: ({\n            zoom: r\n          }) => a(t, e, r, o, l)\n        };\n      }\n      return {\n        kind: \"source\",\n        evaluate(r, n) {\n          const i = n && n.properties ? n.properties[t.property] : void 0;\n          return void 0 === i ? Gi(t.default, e.default) : a(t, e, i, o, l);\n        }\n      };\n    }\n    function Gi(t, e, r) {\n      return void 0 !== t ? t : void 0 !== e ? e : void 0 !== r ? r : void 0;\n    }\n    function Yi(t, e, r, n, i) {\n      return Gi(typeof r === i ? n[r] : void 0, t.default, e.default);\n    }\n    function Hi(t, e, r) {\n      if (\"number\" !== pr(r)) return Gi(t.default, e.default);\n      const n = t.stops.length;\n      if (1 === n) return t.stops[0][1];\n      if (r <= t.stops[0][0]) return t.stops[0][1];\n      if (r >= t.stops[n - 1][0]) return t.stops[n - 1][1];\n      const i = Nn(t.stops.map(t => t[0]), r);\n      return t.stops[i][1];\n    }\n    function Xi(t, e, r) {\n      const n = void 0 !== t.base ? t.base : 1;\n      if (\"number\" !== pr(r)) return Gi(t.default, e.default);\n      const i = t.stops.length;\n      if (1 === i) return t.stops[0][1];\n      if (r <= t.stops[0][0]) return t.stops[0][1];\n      if (r >= t.stops[i - 1][0]) return t.stops[i - 1][1];\n      const s = Nn(t.stops.map(t => t[0]), r),\n        a = function (t, e, r, n) {\n          const i = n - r,\n            s = t - r;\n          return 0 === i ? 0 : 1 === e ? s / i : (Math.pow(e, s) - 1) / (Math.pow(e, i) - 1);\n        }(r, n, t.stops[s][0], t.stops[s + 1][0]),\n        o = t.stops[s][1],\n        l = t.stops[s + 1][1];\n      let u = Te[e.type] || qi;\n      if (t.colorSpace && \"rgb\" !== t.colorSpace) {\n        const e = si[t.colorSpace];\n        u = (t, r) => e.reverse(e.interpolate(e.forward(t), e.forward(r), a));\n      }\n      return \"function\" == typeof o.evaluate ? {\n        evaluate(...t) {\n          const e = o.evaluate.apply(void 0, t),\n            r = l.evaluate.apply(void 0, t);\n          if (void 0 !== e && void 0 !== r) return u(e, r, a);\n        }\n      } : u(o, l, a);\n    }\n    function Zi(t, e, r) {\n      return \"color\" === e.type ? r = Se.parse(r) : \"formatted\" === e.type ? r = Qe.fromString(r.toString()) : \"resolvedImage\" === e.type ? r = er.build(r.toString()) : pr(r) === e.type || \"enum\" === e.type && e.values[r] || (r = void 0), Gi(r, t.default, e.default);\n    }\n    gr.register(zi, {\n      error: [{\n        kind: \"error\"\n      }, [Le], (t, [e]) => {\n        throw new or(e.evaluate(t));\n      }],\n      typeof: [Le, [Ue], (t, [e]) => Ye(ir(e.evaluate(t)))],\n      \"to-rgba\": [Ge(Re, 4), [Oe], (t, [e]) => e.evaluate(t).toRenderColor(null).toArray()],\n      \"to-hsla\": [Ge(Re, 4), [Oe], (t, [e]) => e.evaluate(t).toRenderColor(null).toHslaArray()],\n      rgb: [Oe, [Re, Re, Re], ki],\n      rgba: [Oe, [Re, Re, Re, Re], ki],\n      hsl: [Oe, [Re, Re, Re], Ti],\n      hsla: [Oe, [Re, Re, Re, Re], Ti],\n      has: {\n        type: Fe,\n        overloads: [[[Le], (t, [e]) => Bi(e.evaluate(t), t.properties())], [[Le, Ne], (t, [e, r]) => Bi(e.evaluate(t), r.evaluate(t))]]\n      },\n      get: {\n        type: Ue,\n        overloads: [[[Le], (t, [e]) => Vi(e.evaluate(t), t.properties())], [[Le, Ne], (t, [e, r]) => Vi(e.evaluate(t), r.evaluate(t))]]\n      },\n      \"feature-state\": [Ue, [Le], (t, [e]) => Vi(e.evaluate(t), t.featureState || {})],\n      properties: [Ne, [], t => t.properties()],\n      \"geometry-type\": [Le, [], t => t.geometryType()],\n      id: [Ue, [], t => t.id()],\n      zoom: [Re, [], t => t.globals.zoom],\n      pitch: [Re, [], t => t.globals.pitch || 0],\n      \"distance-from-center\": [Re, [], t => t.distanceFromCenter()],\n      \"measure-light\": [Re, [Le], (t, [e]) => t.measureLight(e.evaluate(t))],\n      \"heatmap-density\": [Re, [], t => t.globals.heatmapDensity || 0],\n      \"line-progress\": [Re, [], t => t.globals.lineProgress || 0],\n      \"raster-value\": [Re, [], t => t.globals.rasterValue || 0],\n      \"raster-particle-speed\": [Re, [], t => t.globals.rasterParticleSpeed || 0],\n      \"sky-radial-progress\": [Re, [], t => t.globals.skyRadialProgress || 0],\n      accumulated: [Ue, [], t => void 0 === t.globals.accumulated ? null : t.globals.accumulated],\n      \"+\": [Re, Ci(Re), (t, e) => {\n        let r = 0;\n        for (const n of e) r += n.evaluate(t);\n        return r;\n      }],\n      \"*\": [Re, Ci(Re), (t, e) => {\n        let r = 1;\n        for (const n of e) r *= n.evaluate(t);\n        return r;\n      }],\n      \"-\": {\n        type: Re,\n        overloads: [[[Re, Re], (t, [e, r]) => e.evaluate(t) - r.evaluate(t)], [[Re], (t, [e]) => -e.evaluate(t)]]\n      },\n      \"/\": [Re, [Re, Re], (t, [e, r]) => e.evaluate(t) / r.evaluate(t)],\n      \"%\": [Re, [Re, Re], (t, [e, r]) => e.evaluate(t) % r.evaluate(t)],\n      ln2: [Re, [], () => Math.LN2],\n      pi: [Re, [], () => Math.PI],\n      e: [Re, [], () => Math.E],\n      \"^\": [Re, [Re, Re], (t, [e, r]) => Math.pow(e.evaluate(t), r.evaluate(t))],\n      sqrt: [Re, [Re], (t, [e]) => Math.sqrt(e.evaluate(t))],\n      log10: [Re, [Re], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN10],\n      ln: [Re, [Re], (t, [e]) => Math.log(e.evaluate(t))],\n      log2: [Re, [Re], (t, [e]) => Math.log(e.evaluate(t)) / Math.LN2],\n      sin: [Re, [Re], (t, [e]) => Math.sin(e.evaluate(t))],\n      cos: [Re, [Re], (t, [e]) => Math.cos(e.evaluate(t))],\n      tan: [Re, [Re], (t, [e]) => Math.tan(e.evaluate(t))],\n      asin: [Re, [Re], (t, [e]) => Math.asin(e.evaluate(t))],\n      acos: [Re, [Re], (t, [e]) => Math.acos(e.evaluate(t))],\n      atan: [Re, [Re], (t, [e]) => Math.atan(e.evaluate(t))],\n      min: [Re, Ci(Re), (t, e) => Math.min(...e.map(e => e.evaluate(t)))],\n      max: [Re, Ci(Re), (t, e) => Math.max(...e.map(e => e.evaluate(t)))],\n      abs: [Re, [Re], (t, [e]) => Math.abs(e.evaluate(t))],\n      round: [Re, [Re], (t, [e]) => {\n        const r = e.evaluate(t);\n        return r < 0 ? -Math.round(-r) : Math.round(r);\n      }],\n      floor: [Re, [Re], (t, [e]) => Math.floor(e.evaluate(t))],\n      ceil: [Re, [Re], (t, [e]) => Math.ceil(e.evaluate(t))],\n      \"filter-==\": [Fe, [Le, Ue], (t, [e, r]) => t.properties()[e.value] === r.value],\n      \"filter-id-==\": [Fe, [Ue], (t, [e]) => t.id() === e.value],\n      \"filter-type-==\": [Fe, [Le], (t, [e]) => t.geometryType() === e.value],\n      \"filter-<\": [Fe, [Le, Ue], (t, [e, r]) => {\n        const n = t.properties()[e.value],\n          i = r.value;\n        return typeof n == typeof i && n < i;\n      }],\n      \"filter-id-<\": [Fe, [Ue], (t, [e]) => {\n        const r = t.id(),\n          n = e.value;\n        return typeof r == typeof n && r < n;\n      }],\n      \"filter->\": [Fe, [Le, Ue], (t, [e, r]) => {\n        const n = t.properties()[e.value],\n          i = r.value;\n        return typeof n == typeof i && n > i;\n      }],\n      \"filter-id->\": [Fe, [Ue], (t, [e]) => {\n        const r = t.id(),\n          n = e.value;\n        return typeof r == typeof n && r > n;\n      }],\n      \"filter-<=\": [Fe, [Le, Ue], (t, [e, r]) => {\n        const n = t.properties()[e.value],\n          i = r.value;\n        return typeof n == typeof i && n <= i;\n      }],\n      \"filter-id-<=\": [Fe, [Ue], (t, [e]) => {\n        const r = t.id(),\n          n = e.value;\n        return typeof r == typeof n && r <= n;\n      }],\n      \"filter->=\": [Fe, [Le, Ue], (t, [e, r]) => {\n        const n = t.properties()[e.value],\n          i = r.value;\n        return typeof n == typeof i && n >= i;\n      }],\n      \"filter-id->=\": [Fe, [Ue], (t, [e]) => {\n        const r = t.id(),\n          n = e.value;\n        return typeof r == typeof n && r >= n;\n      }],\n      \"filter-has\": [Fe, [Ue], (t, [e]) => e.value in t.properties()],\n      \"filter-has-id\": [Fe, [], t => null !== t.id() && void 0 !== t.id()],\n      \"filter-type-in\": [Fe, [Ge(Le)], (t, [e]) => e.value.indexOf(t.geometryType()) >= 0],\n      \"filter-id-in\": [Fe, [Ge(Ue)], (t, [e]) => e.value.indexOf(t.id()) >= 0],\n      \"filter-in-small\": [Fe, [Le, Ge(Ue)], (t, [e, r]) => r.value.indexOf(t.properties()[e.value]) >= 0],\n      \"filter-in-large\": [Fe, [Le, Ge(Ue)], (t, [e, r]) => function (t, e, r, n) {\n        for (; r <= n;) {\n          const i = r + n >> 1;\n          if (e[i] === t) return !0;\n          e[i] > t ? n = i - 1 : r = i + 1;\n        }\n        return !1;\n      }(t.properties()[e.value], r.value, 0, r.value.length - 1)],\n      all: {\n        type: Fe,\n        overloads: [[[Fe, Fe], (t, [e, r]) => e.evaluate(t) && r.evaluate(t)], [Ci(Fe), (t, e) => {\n          for (const r of e) if (!r.evaluate(t)) return !1;\n          return !0;\n        }]]\n      },\n      any: {\n        type: Fe,\n        overloads: [[[Fe, Fe], (t, [e, r]) => e.evaluate(t) || r.evaluate(t)], [Ci(Fe), (t, e) => {\n          for (const r of e) if (r.evaluate(t)) return !0;\n          return !1;\n        }]]\n      },\n      \"!\": [Fe, [Fe], (t, [e]) => !e.evaluate(t)],\n      \"is-supported-script\": [Fe, [Le], (t, [e]) => {\n        const r = t.globals && t.globals.isSupportedScript;\n        return !r || r(e.evaluate(t));\n      }],\n      upcase: [Le, [Le], (t, [e]) => e.evaluate(t).toUpperCase()],\n      downcase: [Le, [Le], (t, [e]) => e.evaluate(t).toLowerCase()],\n      concat: [Le, Ci(Ue), (t, e) => e.map(e => sr(e.evaluate(t))).join(\"\")],\n      \"resolved-locale\": [Le, [je], (t, [e]) => e.evaluate(t).resolvedLocale()],\n      random: [Re, [Re, Re, Ue], (t, e) => {\n        const [r, n, i] = e.map(e => e.evaluate(t));\n        if (r > n) return r;\n        if (r === n) return r;\n        let s;\n        if (\"string\" == typeof i) s = function (t) {\n          let e = 0;\n          if (0 === t.length) return e;\n          for (let r = 0; r < t.length; r++) e = (e << 5) - e + t.charCodeAt(r), e |= 0;\n          return e;\n        }(i);else {\n          if (\"number\" != typeof i) throw new or(`Invalid seed input: ${i}`);\n          s = i;\n        }\n        return r + Ei(s)() * (n - r);\n      }]\n    });\n    class Wi {\n      constructor(t, e, r, n) {\n        this.expression = t, this._warningHistory = {}, this._evaluator = new yr(r, n), this._defaultValue = e ? function (t) {\n          return \"color\" === t.type && (ji(t.default) || Array.isArray(t.default)) ? new Se(0, 0, 0, 0) : \"color\" === t.type ? Se.parse(t.default) || null : void 0 === t.default ? null : t.default;\n        }(e) : null, this._enumValues = e && \"enum\" === e.type ? e.values : null, this.configDependencies = Cn(t);\n      }\n      evaluateWithoutErrorHandling(t, e, r, n, i, s, a, o) {\n        return this._evaluator.globals = t, this._evaluator.feature = e, this._evaluator.featureState = r, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null, this.expression.evaluate(this._evaluator);\n      }\n      evaluate(t, e, r, n, i, s, a, o) {\n        this._evaluator.globals = t, this._evaluator.feature = e || null, this._evaluator.featureState = r || null, this._evaluator.canonical = n || null, this._evaluator.availableImages = i || null, this._evaluator.formattedSection = s || null, this._evaluator.featureTileCoord = a || null, this._evaluator.featureDistanceData = o || null;\n        try {\n          const t = this.expression.evaluate(this._evaluator);\n          if (null == t || \"number\" == typeof t && t != t) return this._defaultValue;\n          if (this._enumValues && !(t in this._enumValues)) throw new or(`Expected value to be one of ${Object.keys(this._enumValues).map(t => JSON.stringify(t)).join(\", \")}, but found ${JSON.stringify(t)} instead.`);\n          return t;\n        } catch (t) {\n          return this._warningHistory[t.message] || (this._warningHistory[t.message] = !0, \"undefined\" != typeof console && console.warn(`Failed to evaluate expression \"${JSON.stringify(this.expression.serialize())}\". ${t.message}`)), this._defaultValue;\n        }\n      }\n    }\n    function Ki(t) {\n      return Array.isArray(t) && t.length > 0 && \"string\" == typeof t[0] && t[0] in zi;\n    }\n    function Ji(t, e, r, n) {\n      const i = new Fn(zi, [], e ? function (t) {\n          const e = {\n            color: Oe,\n            string: Le,\n            number: Re,\n            enum: Le,\n            boolean: Fe,\n            formatted: qe,\n            resolvedImage: $e\n          };\n          return \"array\" === t.type ? Ge(e[t.value] || Ue, t.length) : e[t.type];\n        }(e) : void 0, void 0, void 0, r, n),\n        s = i.parse(t, void 0, void 0, void 0, e && \"string\" === e.type ? {\n          typeAnnotation: \"coerce\"\n        } : void 0);\n      return s ? Di(new Wi(s, e, r, n)) : Ri(i.errors);\n    }\n    class Qi {\n      constructor(t, e, r, n) {\n        this.kind = t, this._styleExpression = e, this.isLightConstant = r, this.isLineProgressConstant = n, this.isStateDependent = \"constant\" !== t && !Vn(e.expression), this.configDependencies = Cn(e.expression);\n      }\n      evaluateWithoutErrorHandling(t, e, r, n, i, s) {\n        return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);\n      }\n      evaluate(t, e, r, n, i, s) {\n        return this._styleExpression.evaluate(t, e, r, n, i, s);\n      }\n    }\n    class ts {\n      constructor(t, e, r, n, i, s) {\n        this.kind = t, this.zoomStops = r, this._styleExpression = e, this.isStateDependent = \"camera\" !== t && !Vn(e.expression), this.isLightConstant = i, this.isLineProgressConstant = s, this.configDependencies = Cn(e.expression), this.interpolationType = n;\n      }\n      evaluateWithoutErrorHandling(t, e, r, n, i, s) {\n        return this._styleExpression.evaluateWithoutErrorHandling(t, e, r, n, i, s);\n      }\n      evaluate(t, e, r, n, i, s) {\n        return this._styleExpression.evaluate(t, e, r, n, i, s);\n      }\n      interpolationFactor(t, e, r) {\n        return this.interpolationType ? ai.interpolationFactor(this.interpolationType, t, e, r) : 0;\n      }\n    }\n    function es(t, e, r, n) {\n      if (\"error\" === (t = Ji(t, e, r, n)).result) return t;\n      const i = t.value.expression,\n        s = Bn(i);\n      if (!s && !Fi(e)) return Ri([new Ve(\"\", \"data expressions not supported\")]);\n      const a = Dn(i, [\"zoom\", \"pitch\", \"distance-from-center\"]);\n      if (!a && !Ni(e)) return Ri([new Ve(\"\", \"zoom expressions not supported\")]);\n      const o = Dn(i, [\"measure-light\"]);\n      if (!o && !Oi(e)) return Ri([new Ve(\"\", \"measure-light expression not supported\")]);\n      const l = Dn(i, [\"line-progress\"]);\n      if (!l && !function (t) {\n        return Li(t.expression, \"line-progress\");\n      }(e)) return Ri([new Ve(\"\", \"line-progress expression not supported\")]);\n      const u = e.expression && e.expression.relaxZoomRestriction,\n        c = ns(i);\n      return c || a || u ? c instanceof Ve ? Ri([c]) : c instanceof ai && !Ui(e) ? Ri([new Ve(\"\", '\"interpolate\" expressions cannot be used with this property')]) : Di(c ? new ts(s && l ? \"camera\" : \"composite\", t.value, c.labels, c instanceof ai ? c.interpolation : void 0, o, l) : new Qi(s && l ? \"constant\" : \"source\", t.value, o, l)) : Ri([new Ve(\"\", '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression, or in the properties of atmosphere.')]);\n    }\n    class rs {\n      constructor(t, e) {\n        this._parameters = t, this._specification = e, Be(this, $i(this._parameters, this._specification));\n      }\n      static deserialize(t) {\n        return new rs(t._parameters, t._specification);\n      }\n      static serialize(t) {\n        return {\n          _parameters: t._parameters,\n          _specification: t._specification\n        };\n      }\n    }\n    function ns(t) {\n      let e = null;\n      if (t instanceof ui) e = ns(t.result);else if (t instanceof li) {\n        for (const r of t.args) if (e = ns(r), e) break;\n      } else (t instanceof Un || t instanceof ai) && t.input instanceof gr && \"zoom\" === t.input.name && (e = t);\n      return e instanceof Ve || t.eachChild(t => {\n        const r = ns(t);\n        r instanceof Ve ? e = r : e && r && e !== r && (e = new Ve(\"\", 'Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression.'));\n      }), e;\n    }\n    var is,\n      ss,\n      as = function () {\n        if (ss) return is;\n        ss = 1, is = e;\n        var t = 3;\n        function e(e, r, n) {\n          var i = this.cells = [];\n          if (e instanceof ArrayBuffer) {\n            this.arrayBuffer = e;\n            var s = new Int32Array(this.arrayBuffer);\n            e = s[0], this.d = (r = s[1]) + 2 * (n = s[2]);\n            for (var a = 0; a < this.d * this.d; a++) {\n              var o = s[t + a],\n                l = s[t + a + 1];\n              i.push(o === l ? null : s.subarray(o, l));\n            }\n            var u = s[t + i.length + 1];\n            this.keys = s.subarray(s[t + i.length], u), this.bboxes = s.subarray(u), this.insert = this._insertReadonly;\n          } else {\n            this.d = r + 2 * n;\n            for (var c = 0; c < this.d * this.d; c++) i.push([]);\n            this.keys = [], this.bboxes = [];\n          }\n          this.n = r, this.extent = e, this.padding = n, this.scale = r / e, this.uid = 0;\n          var h = n / r * e;\n          this.min = -h, this.max = e + h;\n        }\n        return e.prototype.insert = function (t, e, r, n, i) {\n          this._forEachCell(e, r, n, i, this._insertCell, this.uid++), this.keys.push(t), this.bboxes.push(e), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(i);\n        }, e.prototype._insertReadonly = function () {\n          throw \"Cannot insert into a GridIndex created from an ArrayBuffer.\";\n        }, e.prototype._insertCell = function (t, e, r, n, i, s) {\n          this.cells[i].push(s);\n        }, e.prototype.query = function (t, e, r, n, i) {\n          var s = this.min,\n            a = this.max;\n          if (t <= s && e <= s && a <= r && a <= n && !i) return Array.prototype.slice.call(this.keys);\n          var o = [];\n          return this._forEachCell(t, e, r, n, this._queryCell, o, {}, i), o;\n        }, e.prototype._queryCell = function (t, e, r, n, i, s, a, o) {\n          var l = this.cells[i];\n          if (null !== l) for (var u = this.keys, c = this.bboxes, h = 0; h < l.length; h++) {\n            var p = l[h];\n            if (void 0 === a[p]) {\n              var f = 4 * p;\n              (o ? o(c[f + 0], c[f + 1], c[f + 2], c[f + 3]) : t <= c[f + 2] && e <= c[f + 3] && r >= c[f + 0] && n >= c[f + 1]) ? (a[p] = !0, s.push(u[p])) : a[p] = !1;\n            }\n          }\n        }, e.prototype._forEachCell = function (t, e, r, n, i, s, a, o) {\n          for (var l = this._convertToCellCoord(t), u = this._convertToCellCoord(e), c = this._convertToCellCoord(r), h = this._convertToCellCoord(n), p = l; p <= c; p++) for (var f = u; f <= h; f++) {\n            var d = this.d * f + p;\n            if ((!o || o(this._convertFromCellCoord(p), this._convertFromCellCoord(f), this._convertFromCellCoord(p + 1), this._convertFromCellCoord(f + 1))) && i.call(this, t, e, r, n, d, s, a, o)) return;\n          }\n        }, e.prototype._convertFromCellCoord = function (t) {\n          return (t - this.padding) / this.scale;\n        }, e.prototype._convertToCellCoord = function (t) {\n          return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding));\n        }, e.prototype.toArrayBuffer = function () {\n          if (this.arrayBuffer) return this.arrayBuffer;\n          for (var e = this.cells, r = t + this.cells.length + 1 + 1, n = 0, i = 0; i < this.cells.length; i++) n += this.cells[i].length;\n          var s = new Int32Array(r + n + this.keys.length + this.bboxes.length);\n          s[0] = this.extent, s[1] = this.n, s[2] = this.padding;\n          for (var a = r, o = 0; o < e.length; o++) {\n            var l = e[o];\n            s[t + o] = a, s.set(l, a), a += l.length;\n          }\n          return s[t + e.length] = a, s.set(this.keys, a), s[t + e.length + 1] = a += this.keys.length, s.set(this.bboxes, a), a += this.bboxes.length, s.buffer;\n        }, is;\n      }(),\n      os = e(as);\n    const ls = {};\n    function us(t, e, r = {}) {\n      Object.defineProperty(t, \"_classRegistryKey\", {\n        value: e,\n        writable: !1\n      }), ls[e] = {\n        klass: t,\n        omit: r.omit || []\n      };\n    }\n    us(Object, \"Object\"), os.serialize = function (t, e) {\n      const r = t.toArrayBuffer();\n      return e && e.add(r), {\n        buffer: r\n      };\n    }, os.deserialize = function (t) {\n      return new os(t.buffer);\n    }, Object.defineProperty(os, \"name\", {\n      value: \"Grid\"\n    }), us(os, \"Grid\"), \"undefined\" != typeof DOMMatrix && us(DOMMatrix, \"DOMMatrix\"), us(Se, \"Color\"), us(Error, \"Error\"), us(Qe, \"Formatted\"), us(Je, \"FormattedSection\"), us(te, \"AJAXError\"), us(er, \"ResolvedImage\"), us(rs, \"StylePropertyFunction\"), us(Wi, \"StyleExpression\", {\n      omit: [\"_evaluator\"]\n    }), us(we, \"ImageId\"), us(tr, \"ImageVariant\"), us(ts, \"ZoomDependentExpression\"), us(Qi, \"ZoomConstantExpression\"), us(gr, \"CompoundExpression\", {\n      omit: [\"_evaluate\"]\n    });\n    for (const t in zi) ls[zi[t]._classRegistryKey] || us(zi[t], `Expression${t}`);\n    function cs(t) {\n      return t && \"undefined\" != typeof ArrayBuffer && (t instanceof ArrayBuffer || t.constructor && \"ArrayBuffer\" === t.constructor.name);\n    }\n    function hs(t) {\n      return self.ImageBitmap && t instanceof ImageBitmap;\n    }\n    function ps(t, e) {\n      if (null == t || \"boolean\" == typeof t || \"number\" == typeof t || \"string\" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp) return t;\n      if (cs(t) || hs(t)) return e && e.add(t), t;\n      if (ArrayBuffer.isView(t)) return e && e.add(t.buffer), t;\n      if (t instanceof ImageData) return e && e.add(t.data.buffer), t;\n      if (Array.isArray(t)) {\n        const r = [];\n        for (const n of t) r.push(ps(n, e));\n        return r;\n      }\n      if (t instanceof Map) {\n        const e = {\n          $name: \"Map\",\n          entries: []\n        };\n        for (const [r, n] of t.entries()) e.entries.push(ps(r), ps(n));\n        return e;\n      }\n      if (t instanceof Set) {\n        const e = {\n          $name: \"Set\"\n        };\n        let r = 0;\n        for (const n of t.values()) e[++r] = ps(n);\n        return e;\n      }\n      if (t instanceof DOMMatrix) {\n        const e = {\n            $name: \"DOMMatrix\"\n          },\n          r = [\"is2D\", \"m11\", \"m12\", \"m13\", \"m14\", \"m21\", \"m22\", \"m23\", \"m24\", \"m31\", \"m32\", \"m33\", \"m34\", \"m41\", \"m42\", \"m43\", \"m44\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\n        for (const n of r) e[n] = t[n];\n        return e;\n      }\n      if (\"bigint\" == typeof t) return {\n        $name: \"BigInt\",\n        value: t.toString()\n      };\n      if (\"object\" == typeof t) {\n        const r = t.constructor,\n          n = r._classRegistryKey;\n        if (!n) throw new Error(`Can't serialize object of unregistered class \"${r.name}\".`);\n        const i = r.serialize ? r.serialize(t, e) : {};\n        if (!r.serialize) {\n          for (const r in t) t.hasOwnProperty(r) && (ls[n].omit.indexOf(r) >= 0 || (i[r] = ps(t[r], e)));\n          t instanceof Error && (i.message = t.message);\n        }\n        if (i.$name) throw new Error(\"$name property is reserved for worker serialization logic.\");\n        return \"Object\" !== n && (i.$name = n), i;\n      }\n      throw new Error(\"can't serialize object of type \" + typeof t);\n    }\n    function fs(t) {\n      if (null == t || \"boolean\" == typeof t || \"number\" == typeof t || \"string\" == typeof t || t instanceof Boolean || t instanceof Number || t instanceof String || t instanceof Date || t instanceof RegExp || cs(t) || hs(t) || ArrayBuffer.isView(t) || t instanceof ImageData) return t;\n      if (Array.isArray(t)) return t.map(fs);\n      if (\"object\" == typeof t) {\n        const e = t.$name || \"Object\";\n        if (\"Map\" === e) {\n          const e = t.entries || [],\n            r = new Map();\n          for (let t = 0; t < e.length; t += 2) r.set(fs(e[t]), fs(e[t + 1]));\n          return r;\n        }\n        if (\"Set\" === e) {\n          const e = new Set();\n          for (const r of Object.keys(t)) \"$name\" !== r && e.add(fs(t[r]));\n          return e;\n        }\n        if (\"DOMMatrix\" === e) {\n          let e;\n          return e = t.is2D ? [t.a, t.b, t.c, t.d, t.e, t.f] : [t.m11, t.m12, t.m13, t.m14, t.m21, t.m22, t.m23, t.m24, t.m31, t.m32, t.m33, t.m34, t.m41, t.m42, t.m43, t.m44], new DOMMatrix(e);\n        }\n        if (\"BigInt\" === e) return BigInt(t.value);\n        const {\n          klass: r\n        } = ls[e];\n        if (!r) throw new Error(`Can't deserialize unregistered class \"${e}\".`);\n        if (r.deserialize) return r.deserialize(t);\n        const n = Object.create(r.prototype);\n        for (const e of Object.keys(t)) \"$name\" !== e && (n[e] = fs(t[e]));\n        return n;\n      }\n      throw new Error(\"can't deserialize object of type \" + typeof t);\n    }\n    const ds = {\n      \"Latin-1 Supplement\": t => t >= 128 && t <= 255,\n      Arabic: t => t >= 1536 && t <= 1791,\n      \"Arabic Supplement\": t => t >= 1872 && t <= 1919,\n      \"Arabic Extended-A\": t => t >= 2208 && t <= 2303,\n      \"Hangul Jamo\": t => t >= 4352 && t <= 4607,\n      \"Unified Canadian Aboriginal Syllabics\": t => t >= 5120 && t <= 5759,\n      Khmer: t => t >= 6016 && t <= 6143,\n      \"Unified Canadian Aboriginal Syllabics Extended\": t => t >= 6320 && t <= 6399,\n      \"General Punctuation\": t => t >= 8192 && t <= 8303,\n      \"Letterlike Symbols\": t => t >= 8448 && t <= 8527,\n      \"Number Forms\": t => t >= 8528 && t <= 8591,\n      \"Miscellaneous Technical\": t => t >= 8960 && t <= 9215,\n      \"Control Pictures\": t => t >= 9216 && t <= 9279,\n      \"Optical Character Recognition\": t => t >= 9280 && t <= 9311,\n      \"Enclosed Alphanumerics\": t => t >= 9312 && t <= 9471,\n      \"Geometric Shapes\": t => t >= 9632 && t <= 9727,\n      \"Miscellaneous Symbols\": t => t >= 9728 && t <= 9983,\n      \"Miscellaneous Symbols and Arrows\": t => t >= 11008 && t <= 11263,\n      \"CJK Radicals Supplement\": t => t >= 11904 && t <= 12031,\n      \"Kangxi Radicals\": t => t >= 12032 && t <= 12255,\n      \"Ideographic Description Characters\": t => t >= 12272 && t <= 12287,\n      \"CJK Symbols and Punctuation\": t => t >= 12288 && t <= 12351,\n      Hiragana: t => t >= 12352 && t <= 12447,\n      Katakana: t => t >= 12448 && t <= 12543,\n      Bopomofo: t => t >= 12544 && t <= 12591,\n      \"Hangul Compatibility Jamo\": t => t >= 12592 && t <= 12687,\n      Kanbun: t => t >= 12688 && t <= 12703,\n      \"Bopomofo Extended\": t => t >= 12704 && t <= 12735,\n      \"CJK Strokes\": t => t >= 12736 && t <= 12783,\n      \"Katakana Phonetic Extensions\": t => t >= 12784 && t <= 12799,\n      \"Enclosed CJK Letters and Months\": t => t >= 12800 && t <= 13055,\n      \"CJK Compatibility\": t => t >= 13056 && t <= 13311,\n      \"CJK Unified Ideographs Extension A\": t => t >= 13312 && t <= 19903,\n      \"Yijing Hexagram Symbols\": t => t >= 19904 && t <= 19967,\n      \"CJK Unified Ideographs\": t => t >= 19968 && t <= 40959,\n      \"Yi Syllables\": t => t >= 40960 && t <= 42127,\n      \"Yi Radicals\": t => t >= 42128 && t <= 42191,\n      \"Hangul Jamo Extended-A\": t => t >= 43360 && t <= 43391,\n      \"Hangul Syllables\": t => t >= 44032 && t <= 55215,\n      \"Hangul Jamo Extended-B\": t => t >= 55216 && t <= 55295,\n      \"Private Use Area\": t => t >= 57344 && t <= 63743,\n      \"CJK Compatibility Ideographs\": t => t >= 63744 && t <= 64255,\n      \"Arabic Presentation Forms-A\": t => t >= 64336 && t <= 65023,\n      \"Vertical Forms\": t => t >= 65040 && t <= 65055,\n      \"CJK Compatibility Forms\": t => t >= 65072 && t <= 65103,\n      \"Small Form Variants\": t => t >= 65104 && t <= 65135,\n      \"Arabic Presentation Forms-B\": t => t >= 65136 && t <= 65279,\n      \"Halfwidth and Fullwidth Forms\": t => t >= 65280 && t <= 65519,\n      Osage: t => t >= 66736 && t <= 66815,\n      \"CJK Unified Ideographs Extension B\": t => t >= 131072 && t <= 173791\n    };\n    function ms(t) {\n      for (const e of t) if (xs(e.charCodeAt(0))) return !0;\n      return !1;\n    }\n    function ys(t) {\n      for (const e of t) if (!gs(e.charCodeAt(0))) return !1;\n      return !0;\n    }\n    function gs(t) {\n      return !(ds.Arabic(t) || ds[\"Arabic Supplement\"](t) || ds[\"Arabic Extended-A\"](t) || ds[\"Arabic Presentation Forms-A\"](t) || ds[\"Arabic Presentation Forms-B\"](t));\n    }\n    function xs(t) {\n      return !(746 !== t && 747 !== t && (t < 4352 || !(ds[\"Bopomofo Extended\"](t) || ds.Bopomofo(t) || ds[\"CJK Compatibility Forms\"](t) && !(t >= 65097 && t <= 65103) || ds[\"CJK Compatibility Ideographs\"](t) || ds[\"CJK Compatibility\"](t) || ds[\"CJK Radicals Supplement\"](t) || ds[\"CJK Strokes\"](t) || !(!ds[\"CJK Symbols and Punctuation\"](t) || t >= 12296 && t <= 12305 || t >= 12308 && t <= 12319 || 12336 === t) || ds[\"CJK Unified Ideographs Extension A\"](t) || ds[\"CJK Unified Ideographs\"](t) || ds[\"Enclosed CJK Letters and Months\"](t) || ds[\"Hangul Compatibility Jamo\"](t) || ds[\"Hangul Jamo Extended-A\"](t) || ds[\"Hangul Jamo Extended-B\"](t) || ds[\"Hangul Jamo\"](t) || ds[\"Hangul Syllables\"](t) || ds.Hiragana(t) || ds[\"Ideographic Description Characters\"](t) || ds.Kanbun(t) || ds[\"Kangxi Radicals\"](t) || ds[\"Katakana Phonetic Extensions\"](t) || ds.Katakana(t) && 12540 !== t || !(!ds[\"Halfwidth and Fullwidth Forms\"](t) || 65288 === t || 65289 === t || 65293 === t || t >= 65306 && t <= 65310 || 65339 === t || 65341 === t || 65343 === t || t >= 65371 && t <= 65503 || 65507 === t || t >= 65512 && t <= 65519) || !(!ds[\"Small Form Variants\"](t) || t >= 65112 && t <= 65118 || t >= 65123 && t <= 65126) || ds[\"Unified Canadian Aboriginal Syllabics\"](t) || ds[\"Unified Canadian Aboriginal Syllabics Extended\"](t) || ds[\"Vertical Forms\"](t) || ds[\"Yijing Hexagram Symbols\"](t) || ds[\"Yi Syllables\"](t) || ds[\"Yi Radicals\"](t))));\n    }\n    function vs(t) {\n      return !(xs(t) || function (t) {\n        return !!(ds[\"Latin-1 Supplement\"](t) && (167 === t || 169 === t || 174 === t || 177 === t || 188 === t || 189 === t || 190 === t || 215 === t || 247 === t) || ds[\"General Punctuation\"](t) && (8214 === t || 8224 === t || 8225 === t || 8240 === t || 8241 === t || 8251 === t || 8252 === t || 8258 === t || 8263 === t || 8264 === t || 8265 === t || 8273 === t) || ds[\"Letterlike Symbols\"](t) || ds[\"Number Forms\"](t) || ds[\"Miscellaneous Technical\"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || 9003 === t || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || 9167 === t || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || ds[\"Control Pictures\"](t) && 9251 !== t || ds[\"Optical Character Recognition\"](t) || ds[\"Enclosed Alphanumerics\"](t) || ds[\"Geometric Shapes\"](t) || ds[\"Miscellaneous Symbols\"](t) && !(t >= 9754 && t <= 9759) || ds[\"Miscellaneous Symbols and Arrows\"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || ds[\"CJK Symbols and Punctuation\"](t) || ds.Katakana(t) || ds[\"Private Use Area\"](t) || ds[\"CJK Compatibility Forms\"](t) || ds[\"Small Form Variants\"](t) || ds[\"Halfwidth and Fullwidth Forms\"](t) || 8734 === t || 8756 === t || 8757 === t || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || 65532 === t || 65533 === t);\n      }(t));\n    }\n    function bs(t) {\n      return ds.Arabic(t) || ds[\"Arabic Supplement\"](t) || ds[\"Arabic Extended-A\"](t) || ds[\"Arabic Presentation Forms-A\"](t) || ds[\"Arabic Presentation Forms-B\"](t);\n    }\n    function _s(t) {\n      return t >= 1424 && t <= 2303 || ds[\"Arabic Presentation Forms-A\"](t) || ds[\"Arabic Presentation Forms-B\"](t);\n    }\n    function ws(t, e) {\n      return !(!e && _s(t) || t >= 2304 && t <= 3583 || t >= 3840 && t <= 4255 || ds.Khmer(t));\n    }\n    function Ms(t) {\n      for (const e of t) if (_s(e.charCodeAt(0))) return !0;\n      return !1;\n    }\n    const As = \"deferred\",\n      Is = \"loading\",\n      Ss = \"loaded\";\n    let Ps = null,\n      Es = \"unavailable\",\n      zs = null;\n    const ks = function (t) {\n      t && \"string\" == typeof t && t.indexOf(\"NetworkError\") > -1 && (Es = \"error\"), Ps && Ps(t);\n    };\n    function Ts() {\n      Bs.fire(new ge(\"pluginStateChange\", {\n        pluginStatus: Es,\n        pluginURL: zs\n      }));\n    }\n    const Bs = new _e(),\n      Vs = function () {\n        return Es;\n      },\n      Cs = function () {\n        if (Es !== As || !zs) throw new Error(\"rtl-text-plugin cannot be downloaded unless a pluginURL is specified\");\n        Es = Is, Ts(), zs && ne({\n          url: zs\n        }, t => {\n          t ? ks(t) : (Es = Ss, Ts());\n        });\n      },\n      Ds = {\n        applyArabicShaping: null,\n        processBidirectionalText: null,\n        processStyledBidirectionalText: null,\n        isLoaded: () => Es === Ss || null != Ds.applyArabicShaping,\n        isLoading: () => Es === Is,\n        setState(t) {\n          Es = t.pluginStatus, zs = t.pluginURL;\n        },\n        isParsed: () => null != Ds.applyArabicShaping && null != Ds.processBidirectionalText && null != Ds.processStyledBidirectionalText,\n        getPluginURL: () => zs\n      };\n    class Rs {\n      constructor(t, e) {\n        this.zoom = t, e ? (this.now = e.now, this.fadeDuration = e.fadeDuration, this.transition = e.transition, this.pitch = e.pitch, this.brightness = e.brightness) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);\n      }\n      isSupportedScript(t) {\n        return function (t, e) {\n          for (const r of t) if (!ws(r.charCodeAt(0), e)) return !1;\n          return !0;\n        }(t, Ds.isLoaded());\n      }\n    }\n    class Ls {\n      constructor(t, e, r, n) {\n        this.property = t, this.value = e, this.expression = function (t, e, r, n) {\n          if (ji(t)) return new rs(t, e);\n          if (Ki(t) || Array.isArray(t) && t.length > 0) {\n            const i = es(t, e, r, n);\n            if (\"error\" === i.result) throw new Error(i.value.map(t => `${t.key}: ${t.message}`).join(\", \"));\n            return i.value;\n          }\n          {\n            let r = t;\n            return \"string\" == typeof t && \"color\" === e.type && (r = Se.parse(t)), {\n              kind: \"constant\",\n              configDependencies: new Set(),\n              evaluate: () => r\n            };\n          }\n        }(void 0 === e ? t.specification.default : e, t.specification, r, n);\n      }\n      isDataDriven() {\n        return \"source\" === this.expression.kind || \"composite\" === this.expression.kind;\n      }\n      possiblyEvaluate(t, e, r) {\n        return this.property.possiblyEvaluate(this, t, e, r);\n      }\n    }\n    class Fs {\n      constructor(t, e, r) {\n        this.property = t, this.value = new Ls(t, void 0, e, r);\n      }\n      transitioned(t, e) {\n        return new Ns(this.property, this.value, e, nt({}, t.transition, this.transition), t.now);\n      }\n      untransitioned() {\n        return new Ns(this.property, this.value, null, {}, 0);\n      }\n    }\n    class Os {\n      constructor(t, e, r) {\n        this._properties = t, this._values = Object.create(t.defaultTransitionablePropertyValues), this._scope = e, this._options = r, this.configDependencies = new Set();\n      }\n      getValue(t) {\n        return ct(this._values[t].value.value);\n      }\n      setValue(t, e) {\n        this._values.hasOwnProperty(t) || (this._values[t] = new Fs(this._values[t].property, this._scope, this._options)), this._values[t].value = new Ls(this._values[t].property, null === e ? void 0 : ct(e), this._scope, this._options), this._values[t].value.expression.configDependencies && (this.configDependencies = new Set([...this.configDependencies, ...this._values[t].value.expression.configDependencies]));\n      }\n      setTransitionOrValue(t, e) {\n        e && (this._options = e);\n        const r = this._properties.properties;\n        if (t) for (const e in t) {\n          const n = t[e];\n          if (e.endsWith(\"-transition\")) {\n            const t = e.slice(0, -11);\n            r[t] && this.setTransition(t, n);\n          } else r.hasOwnProperty(e) && this.setValue(e, n);\n        }\n      }\n      getTransition(t) {\n        return ct(this._values[t].transition);\n      }\n      setTransition(t, e) {\n        this._values.hasOwnProperty(t) || (this._values[t] = new Fs(this._values[t].property)), this._values[t].transition = ct(e) || void 0;\n      }\n      serialize() {\n        const t = {};\n        for (const e of Object.keys(this._values)) {\n          const r = this.getValue(e);\n          void 0 !== r && (t[e] = r);\n          const n = this.getTransition(e);\n          void 0 !== n && (t[`${e}-transition`] = n);\n        }\n        return t;\n      }\n      transitioned(t, e) {\n        const r = new Us(this._properties);\n        for (const n of Object.keys(this._values)) r._values[n] = this._values[n].transitioned(t, e._values[n]);\n        return r;\n      }\n      untransitioned() {\n        const t = new Us(this._properties);\n        for (const e of Object.keys(this._values)) t._values[e] = this._values[e].untransitioned();\n        return t;\n      }\n    }\n    class Ns {\n      constructor(t, e, r, n, i) {\n        const s = n.delay || 0,\n          a = n.duration || 0;\n        i = i || 0, this.property = t, this.value = e, this.begin = i + s, this.end = this.begin + a, t.specification.transition && (n.delay || n.duration) && (this.prior = r);\n      }\n      possiblyEvaluate(t, e, r) {\n        const n = t.now || 0,\n          i = this.value.possiblyEvaluate(t, e, r),\n          s = this.prior;\n        if (s) {\n          if (n > this.end) return this.prior = null, i;\n          if (this.value.isDataDriven()) return this.prior = null, i;\n          if (n < this.begin) return s.possiblyEvaluate(t, e, r);\n          {\n            const a = (n - this.begin) / (this.end - this.begin);\n            return this.property.interpolate(s.possiblyEvaluate(t, e, r), i, W(a));\n          }\n        }\n        return i;\n      }\n    }\n    class Us {\n      constructor(t) {\n        this._properties = t, this._values = Object.create(t.defaultTransitioningPropertyValues);\n      }\n      possiblyEvaluate(t, e, r) {\n        const n = new $s(this._properties);\n        for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r);\n        return n;\n      }\n      hasTransition() {\n        for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0;\n        return !1;\n      }\n    }\n    class js {\n      constructor(t, e, r) {\n        this._properties = t, this._values = Object.create(t.defaultPropertyValues), this._scope = e, this._options = r, this.configDependencies = new Set();\n      }\n      getValue(t) {\n        return ct(this._values[t].value);\n      }\n      setValue(t, e) {\n        this._values[t] = new Ls(this._values[t].property, null === e ? void 0 : ct(e), this._scope, this._options), this._values[t].expression.configDependencies && (this.configDependencies = new Set([...this.configDependencies, ...this._values[t].expression.configDependencies]));\n      }\n      serialize() {\n        const t = {};\n        for (const e of Object.keys(this._values)) {\n          const r = this.getValue(e);\n          void 0 !== r && (t[e] = r);\n        }\n        return t;\n      }\n      possiblyEvaluate(t, e, r) {\n        const n = new $s(this._properties);\n        for (const i of Object.keys(this._values)) n._values[i] = this._values[i].possiblyEvaluate(t, e, r);\n        return n;\n      }\n    }\n    class qs {\n      constructor(t, e, r) {\n        this.property = t, this.value = e, this.parameters = r;\n      }\n      isConstant() {\n        return \"constant\" === this.value.kind;\n      }\n      constantOr(t) {\n        return \"constant\" === this.value.kind ? this.value.value : t;\n      }\n      evaluate(t, e, r, n) {\n        return this.property.evaluate(this.value, this.parameters, t, e, r, n);\n      }\n    }\n    class $s {\n      constructor(t) {\n        this._properties = t, this._values = Object.create(t.defaultPossiblyEvaluatedValues);\n      }\n      get(t) {\n        return this._values[t];\n      }\n    }\n    class Gs {\n      constructor(t) {\n        this.specification = t;\n      }\n      possiblyEvaluate(t, e) {\n        return t.expression.evaluate(e);\n      }\n      interpolate(t, e, r) {\n        const n = Te[this.specification.type];\n        return n ? n(t, e, r) : t;\n      }\n    }\n    class Ys {\n      constructor(t, e) {\n        this.specification = t, this.overrides = e;\n      }\n      possiblyEvaluate(t, e, r, n) {\n        return new qs(this, \"constant\" === t.expression.kind || \"camera\" === t.expression.kind ? {\n          kind: \"constant\",\n          value: t.expression.evaluate(e, null, {}, r, n)\n        } : t.expression, e);\n      }\n      interpolate(t, e, r) {\n        if (\"constant\" !== t.value.kind || \"constant\" !== e.value.kind) return t;\n        if (void 0 === t.value.value || void 0 === e.value.value) return new qs(this, {\n          kind: \"constant\",\n          value: void 0\n        }, t.parameters);\n        const n = Te[this.specification.type];\n        return n ? new qs(this, {\n          kind: \"constant\",\n          value: n(t.value.value, e.value.value, r)\n        }, t.parameters) : t;\n      }\n      evaluate(t, e, r, n, i, s) {\n        return \"constant\" === t.kind ? t.value : t.evaluate(e, r, n, i, s);\n      }\n    }\n    class Hs {\n      constructor(t) {\n        this.specification = t;\n      }\n      possiblyEvaluate(t, e, r, n) {\n        return !!t.expression.evaluate(e, null, {}, r, n);\n      }\n      interpolate() {\n        return !1;\n      }\n    }\n    class Xs {\n      constructor(t) {\n        this.properties = t, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];\n        const e = new Rs(0, {});\n        for (const r in t) {\n          const n = t[r];\n          n.specification.overridable && this.overridableProperties.push(r);\n          const i = this.defaultPropertyValues[r] = new Ls(n, void 0),\n            s = this.defaultTransitionablePropertyValues[r] = new Fs(n);\n          this.defaultTransitioningPropertyValues[r] = s.untransitioned(), this.defaultPossiblyEvaluatedValues[r] = i.possiblyEvaluate(e);\n        }\n      }\n    }\n    us(Ys, \"DataDrivenProperty\"), us(Gs, \"DataConstantProperty\"), us(Hs, \"ColorRampProperty\");\n    var Zs = JSON.parse('{\"$version\":8,\"$root\":{\"version\":{\"required\":true,\"type\":\"enum\",\"values\":[8]},\"fragment\":{\"type\":\"boolean\"},\"name\":{\"type\":\"string\"},\"metadata\":{\"type\":\"*\"},\"center\":{\"type\":\"array\",\"value\":\"number\"},\"zoom\":{\"type\":\"number\"},\"bearing\":{\"type\":\"number\",\"default\":0,\"period\":360},\"pitch\":{\"type\":\"number\",\"default\":0},\"light\":{\"type\":\"light\"},\"lights\":{\"required\":false,\"type\":\"array\",\"value\":\"light-3d\"},\"terrain\":{\"type\":\"terrain\",\"optional\":true},\"fog\":{\"type\":\"fog\"},\"snow\":{\"type\":\"snow\",\"experimental\":true},\"rain\":{\"type\":\"rain\",\"experimental\":true},\"camera\":{\"type\":\"camera\"},\"color-theme\":{\"type\":\"colorTheme\"},\"indoor\":{\"type\":\"indoor\",\"experimental\":true},\"imports\":{\"type\":\"array\",\"value\":\"import\"},\"iconsets\":{\"experimental\":true,\"type\":\"iconsets\"},\"schema\":{\"type\":\"schema\"},\"sources\":{\"required\":true,\"type\":\"sources\"},\"sprite\":{\"type\":\"string\"},\"glyphs\":{\"type\":\"string\",\"default\":\"mapbox://fonts/mapbox/{fontstack}/{range}.pbf\"},\"transition\":{\"type\":\"transition\"},\"projection\":{\"type\":\"projection\"},\"layers\":{\"required\":true,\"type\":\"array\",\"value\":\"layer\"},\"models\":{\"type\":\"models\"},\"featuresets\":{\"experimental\":true,\"type\":\"featuresets\"}},\"featuresets\":{\"experimental\":true,\"*\":{\"type\":\"featureset\"}},\"featureset\":{\"experimental\":true,\"metadata\":{\"experimental\":true,\"type\":\"*\"},\"selectors\":{\"experimental\":true,\"type\":\"array\",\"value\":\"selector\"}},\"selector\":{\"experimental\":true,\"layer\":{\"experimental\":true,\"type\":\"string\",\"required\":true},\"properties\":{\"experimental\":true,\"type\":\"selectorProperty\",\"required\":false},\"featureNamespace\":{\"experimental\":true,\"type\":\"string\",\"required\":false},\"_uniqueFeatureID\":{\"experimental\":true,\"type\":\"boolean\",\"private\":true,\"required\":false}},\"selectorProperty\":{\"experimental\":true,\"*\":{\"experimental\":true,\"type\":\"*\"}},\"model\":{\"type\":\"string\",\"required\":true},\"import\":{\"id\":{\"type\":\"string\",\"required\":true},\"url\":{\"type\":\"string\",\"required\":true},\"config\":{\"type\":\"config\"},\"data\":{\"type\":\"$root\"},\"color-theme\":{\"type\":\"colorTheme\",\"optional\":true}},\"config\":{\"*\":{\"type\":\"*\"}},\"schema\":{\"*\":{\"type\":\"option\"}},\"option\":{\"default\":{\"type\":\"*\",\"property-type\":\"data-constant\",\"expression\":{},\"required\":true},\"type\":{\"type\":\"enum\",\"values\":{\"string\":1,\"number\":1,\"boolean\":1,\"color\":1}},\"array\":{\"type\":\"boolean\"},\"minValue\":{\"type\":\"number\"},\"maxValue\":{\"type\":\"number\"},\"stepValue\":{\"type\":\"number\"},\"values\":{\"type\":\"array\",\"value\":\"*\"},\"metadata\":{\"type\":\"*\"}},\"models\":{\"*\":{\"type\":\"model\"}},\"light-3d\":{\"id\":{\"type\":\"string\",\"required\":true},\"properties\":{\"type\":\"properties\"},\"type\":{\"type\":\"enum\",\"values\":{\"ambient\":{},\"directional\":{},\"flat\":{}}}},\"properties\":[\"properties_light_directional\",\"properties_light_ambient\",\"properties_light_flat\"],\"properties_light_directional\":{\"direction\":{\"type\":\"array\",\"default\":[210,30],\"minimum\":[0,0],\"maximum\":[360,90],\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"intensity\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"cast-shadows\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-constant\"},\"shadow-quality\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"parameters\":[\"zoom\"]},\"experimental\":true},\"shadow-intensity\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"properties_light_ambient\":{\"color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"intensity\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"properties_light_flat\":{\"anchor\":{\"type\":\"enum\",\"default\":\"viewport\",\"values\":{\"map\":1,\"viewport\":1},\"property-type\":\"data-constant\",\"expression\":{\"parameters\":[\"zoom\"]}},\"position\":{\"type\":\"array\",\"default\":[1.15,210,30],\"length\":3,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"intensity\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"iconsets\":{\"*\":{\"type\":\"iconset\"}},\"iconset\":[\"iconset_sprite\",\"iconset_source\"],\"iconset_sprite\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"sprite\":1}},\"url\":{\"required\":true,\"type\":\"string\"}},\"iconset_source\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"source\":1}},\"source\":{\"required\":true,\"type\":\"string\"}},\"sources\":{\"*\":{\"type\":\"source\"}},\"source\":[\"source_vector\",\"source_raster\",\"source_raster_dem\",\"source_raster_array\",\"source_geojson\",\"source_video\",\"source_image\",\"source_model\"],\"source_vector\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"vector\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"scheme\":{\"type\":\"enum\",\"values\":{\"xyz\":1,\"tms\":1},\"default\":\"xyz\"},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"attribution\":{\"type\":\"string\"},\"promoteId\":{\"type\":\"promoteId\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_raster\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"raster\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"tileSize\":{\"type\":\"number\",\"default\":512},\"scheme\":{\"type\":\"enum\",\"values\":{\"xyz\":1,\"tms\":1},\"default\":\"xyz\"},\"attribution\":{\"type\":\"string\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_raster_dem\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"raster-dem\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"tileSize\":{\"type\":\"number\",\"default\":512},\"attribution\":{\"type\":\"string\"},\"encoding\":{\"type\":\"enum\",\"values\":{\"terrarium\":1,\"mapbox\":1},\"default\":\"mapbox\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_raster_array\":{\"experimental\":true,\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"raster-array\":1}},\"url\":{\"type\":\"string\"},\"tiles\":{\"type\":\"array\",\"value\":\"string\"},\"bounds\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[-180,-85.051129,180,85.051129]},\"minzoom\":{\"type\":\"number\",\"default\":0},\"maxzoom\":{\"type\":\"number\",\"default\":22},\"tileSize\":{\"type\":\"number\",\"default\":512},\"attribution\":{\"type\":\"string\"},\"rasterLayers\":{\"type\":\"*\"},\"volatile\":{\"type\":\"boolean\",\"default\":false},\"*\":{\"type\":\"*\"}},\"source_geojson\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"geojson\":1}},\"data\":{\"type\":\"*\"},\"maxzoom\":{\"type\":\"number\",\"default\":18},\"minzoom\":{\"type\":\"number\",\"default\":0},\"attribution\":{\"type\":\"string\"},\"buffer\":{\"type\":\"number\",\"default\":128,\"maximum\":512,\"minimum\":0},\"filter\":{\"type\":\"*\"},\"tolerance\":{\"type\":\"number\",\"default\":0.375},\"cluster\":{\"type\":\"boolean\",\"default\":false},\"clusterRadius\":{\"type\":\"number\",\"default\":50,\"minimum\":0},\"clusterMaxZoom\":{\"type\":\"number\"},\"clusterMinPoints\":{\"type\":\"number\"},\"clusterProperties\":{\"type\":\"*\"},\"lineMetrics\":{\"type\":\"boolean\",\"default\":false},\"generateId\":{\"type\":\"boolean\",\"default\":false},\"promoteId\":{\"type\":\"promoteId\"},\"dynamic\":{\"type\":\"boolean\",\"default\":false}},\"source_video\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"video\":1}},\"urls\":{\"required\":true,\"type\":\"array\",\"value\":\"string\"},\"coordinates\":{\"required\":true,\"type\":\"array\",\"length\":4,\"value\":{\"type\":\"array\",\"length\":2,\"value\":\"number\"}}},\"source_image\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"image\":1}},\"url\":{\"required\":false,\"type\":\"string\"},\"coordinates\":{\"required\":true,\"type\":\"array\",\"length\":4,\"value\":{\"type\":\"array\",\"length\":2,\"value\":\"number\"}}},\"source_model\":{\"type\":{\"required\":true,\"type\":\"enum\",\"values\":{\"model\":1,\"batched-model\":1}},\"maxzoom\":{\"type\":\"number\",\"default\":18},\"minzoom\":{\"type\":\"number\",\"default\":0},\"tiles\":{\"type\":\"array\",\"value\":\"string\"}},\"layer\":{\"id\":{\"type\":\"string\",\"required\":true},\"type\":{\"type\":\"enum\",\"values\":{\"fill\":{},\"line\":{},\"symbol\":{},\"circle\":{},\"heatmap\":{},\"fill-extrusion\":{},\"raster\":{},\"raster-particle\":{\"experimental\":true},\"hillshade\":{},\"model\":{\"experimental\":true},\"background\":{},\"sky\":{},\"slot\":{},\"clip\":{}},\"required\":true},\"metadata\":{\"type\":\"*\"},\"source\":{\"type\":\"string\"},\"source-layer\":{\"type\":\"string\"},\"slot\":{\"type\":\"string\"},\"minzoom\":{\"type\":\"number\",\"minimum\":0,\"maximum\":24},\"maxzoom\":{\"type\":\"number\",\"minimum\":0,\"maximum\":24},\"filter\":{\"type\":\"filter\"},\"layout\":{\"type\":\"layout\"},\"paint\":{\"type\":\"paint\"}},\"layout\":[\"layout_clip\",\"layout_fill\",\"layout_line\",\"layout_circle\",\"layout_heatmap\",\"layout_fill-extrusion\",\"layout_symbol\",\"layout_raster\",\"layout_raster-particle\",\"layout_hillshade\",\"layout_background\",\"layout_sky\",\"layout_model\"],\"layout_background\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"}},\"layout_sky\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"}},\"layout_model\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"},\"model-id\":{\"type\":\"string\",\"default\":\"\",\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}}},\"layout_clip\":{\"clip-layer-types\":{\"type\":\"array\",\"value\":\"enum\",\"values\":{\"model\":1,\"symbol\":1},\"default\":[],\"expression\":{},\"property-type\":\"data-constant\"},\"clip-layer-scope\":{\"type\":\"array\",\"value\":\"string\",\"default\":[],\"expression\":{},\"property-type\":\"data-constant\"}},\"layout_fill\":{\"fill-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"},\"fill-elevation-reference\":{\"type\":\"enum\",\"values\":{\"none\":1,\"hd-road-base\":1,\"hd-road-markup\":1},\"default\":\"none\",\"experimental\":true,\"private\":true,\"expression\":{},\"property-type\":\"data-constant\"},\"fill-construct-bridge-guard-rail\":{\"type\":\"boolean\",\"default\":\"true\",\"experimental\":true,\"private\":true,\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"}},\"layout_circle\":{\"circle-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"circle-elevation-reference\":{\"type\":\"enum\",\"values\":{\"none\":1,\"hd-road-markup\":1},\"default\":\"none\",\"experimental\":true,\"expression\":{},\"property-type\":\"data-constant\"},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"}},\"layout_heatmap\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"}},\"layout_fill-extrusion\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"},\"fill-extrusion-edge-radius\":{\"type\":\"number\",\"experimental\":true,\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{},\"property-type\":\"constant\"}},\"layout_line\":{\"line-cap\":{\"type\":\"enum\",\"values\":{\"butt\":1,\"round\":1,\"square\":1},\"default\":\"butt\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-join\":{\"type\":\"enum\",\"values\":{\"bevel\":1,\"round\":1,\"miter\":1,\"none\":1},\"default\":\"miter\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-miter-limit\":{\"type\":\"number\",\"default\":2,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"line-round-limit\":{\"type\":\"number\",\"default\":1.05,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"line-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-z-offset\":{\"type\":\"number\",\"experimental\":true,\"default\":0,\"expression\":{\"parameters\":[\"zoom\",\"feature\",\"line-progress\"]},\"property-type\":\"data-driven\"},\"line-elevation-reference\":{\"type\":\"enum\",\"values\":{\"none\":1,\"sea\":1,\"ground\":1,\"hd-road-markup\":1},\"default\":\"none\",\"experimental\":true,\"expression\":{},\"property-type\":\"data-constant\"},\"line-cross-slope\":{\"type\":\"number\",\"experimental\":true,\"expression\":{},\"property-type\":\"constant\"},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"},\"line-width-unit\":{\"type\":\"enum\",\"values\":{\"pixels\":1,\"meters\":1},\"default\":\"pixels\",\"experimental\":true,\"private\":true,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"layout_symbol\":{\"symbol-placement\":{\"type\":\"enum\",\"values\":{\"point\":1,\"line\":1,\"line-center\":1},\"default\":\"point\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"symbol-spacing\":{\"type\":\"number\",\"default\":250,\"minimum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"symbol-avoid-edges\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"symbol-sort-key\":{\"type\":\"number\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"symbol-z-order\":{\"type\":\"enum\",\"values\":{\"auto\":1,\"viewport-y\":1,\"source\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"symbol-z-elevate\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"symbol-elevation-reference\":{\"type\":\"enum\",\"values\":{\"sea\":1,\"ground\":1,\"hd-road-markup\":1},\"default\":\"ground\",\"experimental\":true,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-allow-overlap\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-ignore-placement\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-optional\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-rotation-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-size\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-size-scale-range\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0.8,2],\"minimum\":0.1,\"maximum\":10,\"experimental\":true,\"private\":true,\"expression\":{},\"property-type\":\"data-constant\"},\"icon-text-fit\":{\"type\":\"enum\",\"values\":{\"none\":1,\"width\":1,\"height\":1,\"both\":1},\"default\":\"none\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-text-fit-padding\":{\"type\":\"array\",\"value\":\"number\",\"length\":4,\"default\":[0,0,0,0],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-image\":{\"type\":\"resolvedImage\",\"tokens\":true,\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-padding\":{\"type\":\"number\",\"default\":2,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-keep-upright\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-offset\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-anchor\":{\"type\":\"enum\",\"values\":{\"center\":1,\"left\":1,\"right\":1,\"top\":1,\"bottom\":1,\"top-left\":1,\"top-right\":1,\"bottom-left\":1,\"bottom-right\":1},\"default\":\"center\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"icon-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-rotation-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1,\"auto\":1},\"default\":\"auto\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-field\":{\"type\":\"formatted\",\"default\":\"\",\"tokens\":true,\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-font\":{\"type\":\"array\",\"value\":\"string\",\"default\":[\"Open Sans Regular\",\"Arial Unicode MS Regular\"],\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-size\":{\"type\":\"number\",\"default\":16,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-size-scale-range\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0.8,2],\"minimum\":0.1,\"maximum\":10,\"experimental\":true,\"private\":true,\"expression\":{},\"property-type\":\"data-constant\"},\"text-max-width\":{\"type\":\"number\",\"default\":10,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-line-height\":{\"type\":\"number\",\"default\":1.2,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-letter-spacing\":{\"type\":\"number\",\"default\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-justify\":{\"type\":\"enum\",\"values\":{\"auto\":1,\"left\":1,\"center\":1,\"right\":1},\"default\":\"center\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-radial-offset\":{\"type\":\"number\",\"default\":0,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]}},\"text-variable-anchor\":{\"type\":\"array\",\"value\":\"enum\",\"values\":{\"center\":1,\"left\":1,\"right\":1,\"top\":1,\"bottom\":1,\"top-left\":1,\"top-right\":1,\"bottom-left\":1,\"bottom-right\":1},\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-anchor\":{\"type\":\"enum\",\"values\":{\"center\":1,\"left\":1,\"right\":1,\"top\":1,\"bottom\":1,\"top-left\":1,\"top-right\":1,\"bottom-left\":1,\"bottom-right\":1},\"default\":\"center\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-max-angle\":{\"type\":\"number\",\"default\":45,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-writing-mode\":{\"type\":\"array\",\"value\":\"enum\",\"values\":{\"horizontal\":1,\"vertical\":1},\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-padding\":{\"type\":\"number\",\"default\":2,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-keep-upright\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-transform\":{\"type\":\"enum\",\"values\":{\"none\":1,\"uppercase\":1,\"lowercase\":1},\"default\":\"none\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-offset\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"text-allow-overlap\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-ignore-placement\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-optional\":{\"type\":\"boolean\",\"default\":false,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"}},\"layout_raster\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"}},\"layout_raster-particle\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"}},\"layout_hillshade\":{\"visibility\":{\"type\":\"enum\",\"values\":{\"visible\":1,\"none\":1},\"default\":\"visible\",\"expression\":{},\"property-type\":\"constant\"}},\"filter\":{\"type\":\"array\",\"value\":\"*\"},\"filter_symbol\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\",\"pitch\",\"distance-from-center\"]}},\"filter_fill\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_hillshade\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_raster\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_raster-particle\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_clip\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_model\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_line\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_circle\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_fill-extrusion\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_heatmap\":{\"type\":\"boolean\",\"default\":false,\"property-type\":\"data-driven\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]}},\"filter_operator\":{\"type\":\"enum\",\"values\":{\"==\":1,\"!=\":1,\">\":1,\">=\":1,\"<\":1,\"<=\":1,\"in\":1,\"!in\":1,\"all\":1,\"any\":1,\"none\":1,\"has\":1,\"!has\":1}},\"geometry_type\":{\"type\":\"enum\",\"values\":{\"Point\":1,\"LineString\":1,\"Polygon\":1}},\"function\":{\"expression\":{\"type\":\"expression\"},\"stops\":{\"type\":\"array\",\"value\":\"function_stop\"},\"base\":{\"type\":\"number\",\"default\":1,\"minimum\":0},\"property\":{\"type\":\"string\",\"default\":\"$zoom\"},\"type\":{\"type\":\"enum\",\"values\":{\"identity\":1,\"exponential\":1,\"interval\":1,\"categorical\":1},\"default\":\"exponential\"},\"colorSpace\":{\"type\":\"enum\",\"values\":{\"rgb\":1,\"lab\":1,\"hcl\":1},\"default\":\"rgb\"},\"default\":{\"type\":\"*\",\"required\":false}},\"function_stop\":{\"type\":\"array\",\"minimum\":0,\"maximum\":24,\"value\":[\"number\",\"color\"],\"length\":2},\"expression\":{\"type\":\"array\",\"value\":\"*\",\"minimum\":1},\"fog\":{\"range\":{\"type\":\"array\",\"default\":[0.5,10],\"minimum\":-20,\"maximum\":20,\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}},\"color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"high-color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":\"#245cdf\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"space-color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],4,\"#010b19\",7,\"#367ab9\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"horizon-blend\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],4,0.2,7,0.1],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"star-intensity\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],5,0.35,6,0],\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vertical-range\":{\"type\":\"array\",\"default\":[0,0],\"minimum\":0,\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}}},\"snow\":{\"density\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],11,0,13,0.85],\"minimum\":0,\"maximum\":1,\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"intensity\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":1,\"minimum\":0,\"maximum\":1,\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":\"#ffffff\",\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"opacity\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":1,\"minimum\":0,\"maximum\":1,\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vignette\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],11,0,13,0.3],\"minimum\":0,\"maximum\":1,\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vignette-color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":\"#ffffff\",\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"center-thinning\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":0.4,\"minimum\":0,\"maximum\":1,\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"direction\":{\"type\":\"array\",\"default\":[0,50],\"minimum\":0,\"maximum\":360,\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}},\"flake-size\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":0.71,\"minimum\":0,\"maximum\":5,\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true}},\"rain\":{\"density\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],11,0,13,0.5],\"minimum\":0,\"maximum\":1,\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"intensity\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":1,\"minimum\":0,\"maximum\":1,\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":[\"interpolate\",[\"linear\"],[\"measure-light\",\"brightness\"],0,\"#03113d\",0.3,\"#a8adbc\"],\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"opacity\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":[\"interpolate\",[\"linear\"],[\"measure-light\",\"brightness\"],0,0.88,1,0.7],\"minimum\":0,\"maximum\":1,\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vignette\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":[\"interpolate\",[\"linear\"],[\"zoom\"],11,0,13,1],\"minimum\":0,\"maximum\":1,\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"vignette-color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":[\"interpolate\",[\"linear\"],[\"measure-light\",\"brightness\"],0,\"#001736\",0.3,\"#464646\"],\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"center-thinning\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":0.57,\"minimum\":0,\"maximum\":1,\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true},\"direction\":{\"type\":\"array\",\"default\":[0,80],\"minimum\":0,\"maximum\":360,\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}},\"droplet-size\":{\"type\":\"array\",\"default\":[2.6,18.2],\"minimum\":0,\"maximum\":50,\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true}},\"distortion-strength\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":0.7,\"minimum\":0,\"maximum\":1,\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"],\"relaxZoomRestriction\":true},\"transition\":true}},\"camera\":{\"camera-projection\":{\"type\":\"enum\",\"values\":{\"perspective\":1,\"orthographic\":1},\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"default\":\"perspective\",\"property-type\":\"data-constant\"}},\"colorTheme\":{\"data\":{\"type\":\"string\",\"property-type\":\"data-constant\",\"expression\":{}}},\"indoor\":{\"floorplanFeaturesetId\":{\"type\":\"string\",\"experimental\":true,\"property-type\":\"data-constant\",\"expression\":{}},\"buildingFeaturesetId\":{\"type\":\"string\",\"experimental\":true,\"property-type\":\"data-constant\",\"expression\":{}}},\"light\":{\"anchor\":{\"type\":\"enum\",\"default\":\"viewport\",\"values\":{\"map\":1,\"viewport\":1},\"property-type\":\"data-constant\",\"expression\":{\"parameters\":[\"zoom\"]}},\"position\":{\"type\":\"array\",\"default\":[1.15,210,30],\"length\":3,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"color\":{\"type\":\"color\",\"property-type\":\"data-constant\",\"default\":\"#ffffff\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"intensity\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"projection\":{\"name\":{\"type\":\"enum\",\"values\":{\"albers\":1,\"equalEarth\":1,\"equirectangular\":1,\"lambertConformalConic\":1,\"mercator\":1,\"naturalEarth\":1,\"winkelTripel\":1,\"globe\":1},\"default\":\"mercator\",\"required\":true},\"center\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"minimum\":[-180,-90],\"maximum\":[180,90]},\"parallels\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"minimum\":[-90,-90],\"maximum\":[90,90]}},\"terrain\":{\"source\":{\"type\":\"string\",\"required\":true},\"exaggeration\":{\"type\":\"number\",\"property-type\":\"data-constant\",\"default\":1,\"minimum\":0,\"maximum\":1000,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true}},\"paint\":[\"paint_fill\",\"paint_line\",\"paint_circle\",\"paint_heatmap\",\"paint_fill-extrusion\",\"paint_symbol\",\"paint_raster\",\"paint_raster-particle\",\"paint_hillshade\",\"paint_background\",\"paint_sky\",\"paint_model\"],\"paint_fill\":{\"fill-antialias\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-outline-color\":{\"type\":\"color\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"fill-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"},\"fill-z-offset\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"fill-bridge-guard-rail-color\":{\"type\":\"color\",\"default\":\"rgba(241, 236, 225, 255)\",\"experimental\":true,\"private\":true,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature\"]},\"property-type\":\"data-driven\"},\"fill-tunnel-structure-color\":{\"type\":\"color\",\"default\":\"rgba(241, 236, 225, 255)\",\"transition\":true,\"experimental\":true,\"private\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature\"]},\"property-type\":\"data-driven\"}},\"paint_fill-extrusion\":{\"fill-extrusion-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-extrusion-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-extrusion-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-extrusion-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-height\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-base\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-height-alignment\":{\"type\":\"enum\",\"experimental\":true,\"values\":{\"terrain\":1,\"flat\":1},\"default\":\"flat\",\"property-type\":\"data-constant\"},\"fill-extrusion-base-alignment\":{\"type\":\"enum\",\"experimental\":true,\"values\":{\"terrain\":1,\"flat\":1},\"default\":\"terrain\",\"property-type\":\"data-constant\"},\"fill-extrusion-vertical-gradient\":{\"type\":\"boolean\",\"default\":true,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"fill-extrusion-ambient-occlusion-intensity\":{\"property-type\":\"data-constant\",\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-radius\":{\"property-type\":\"data-constant\",\"type\":\"number\",\"default\":3,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-wall-radius\":{\"property-type\":\"data-constant\",\"type\":\"number\",\"experimental\":true,\"default\":3,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-ground-radius\":{\"property-type\":\"data-constant\",\"type\":\"number\",\"experimental\":true,\"default\":3,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true},\"fill-extrusion-ambient-occlusion-ground-attenuation\":{\"property-type\":\"data-constant\",\"type\":\"number\",\"experimental\":true,\"default\":0.69,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-flood-light-color\":{\"property-type\":\"data-constant\",\"type\":\"color\",\"experimental\":true,\"default\":\"#ffffff\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"fill-extrusion-flood-light-intensity\":{\"property-type\":\"data-constant\",\"type\":\"number\",\"experimental\":true,\"default\":0,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]}},\"fill-extrusion-flood-light-wall-radius\":{\"property-type\":\"data-driven\",\"type\":\"number\",\"experimental\":true,\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]}},\"fill-extrusion-flood-light-ground-radius\":{\"property-type\":\"data-driven\",\"type\":\"number\",\"experimental\":true,\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]}},\"fill-extrusion-flood-light-ground-attenuation\":{\"property-type\":\"data-constant\",\"type\":\"number\",\"experimental\":true,\"default\":0.69,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-vertical-scale\":{\"property-type\":\"data-constant\",\"type\":\"number\",\"experimental\":true,\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"fill-extrusion-rounded-roof\":{\"property-type\":\"data-constant\",\"type\":\"boolean\",\"default\":true,\"experimental\":true,\"expression\":{\"parameters\":[\"zoom\"]}},\"fill-extrusion-cutoff-fade-range\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{},\"property-type\":\"data-constant\"},\"fill-extrusion-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-line-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"fill-extrusion-cast-shadows\":{\"type\":\"boolean\",\"default\":true,\"property-type\":\"data-constant\"}},\"paint_line\":{\"line-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"line-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"line-width\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\",\"line-progress\"]},\"property-type\":\"data-driven\"},\"line-gap-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-offset\":{\"type\":\"number\",\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"line-dasharray\":{\"type\":\"array\",\"value\":\"number\",\"minimum\":0,\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"},\"line-gradient\":{\"type\":\"color\",\"expression\":{\"interpolated\":true,\"parameters\":[\"line-progress\"]},\"property-type\":\"color-ramp\"},\"line-trim-offset\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"minimum\":[0,0],\"maximum\":[1,1],\"property-type\":\"constant\"},\"line-trim-fade-range\":{\"type\":\"array\",\"value\":\"number\",\"experimental\":true,\"length\":2,\"default\":[0,0],\"minimum\":[0,0],\"maximum\":[1,1],\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"},\"line-trim-color\":{\"type\":\"color\",\"experimental\":true,\"default\":\"transparent\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"},\"line-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"},\"line-border-width\":{\"type\":\"number\",\"private\":true,\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-border-color\":{\"type\":\"color\",\"private\":true,\"default\":\"rgba(0, 0, 0, 0)\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"line-occlusion-opacity\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"transition\":true,\"property-type\":\"data-constant\"}},\"paint_circle\":{\"circle-radius\":{\"type\":\"number\",\"default\":5,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-blur\":{\"type\":\"number\",\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"circle-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"circle-pitch-scale\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"circle-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"viewport\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"circle-stroke-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-stroke-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-stroke-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"circle-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"}},\"paint_heatmap\":{\"heatmap-radius\":{\"type\":\"number\",\"default\":30,\"minimum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"heatmap-weight\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"heatmap-intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"heatmap-color\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"heatmap-density\"],0,\"rgba(0, 0, 255, 0)\",0.1,\"royalblue\",0.3,\"cyan\",0.5,\"lime\",0.7,\"yellow\",1,\"red\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"heatmap-density\"]},\"property-type\":\"color-ramp\"},\"heatmap-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"paint_symbol\":{\"icon-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-occlusion-opacity\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1,\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-emissive-strength\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"text-emissive-strength\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\",\"feature-state\"]},\"property-type\":\"data-driven\"},\"icon-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-halo-color\":{\"type\":\"color\",\"default\":\"rgba(0, 0, 0, 0)\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-halo-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-halo-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"icon-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-image-cross-fade\":{\"type\":\"number\",\"property-type\":\"data-driven\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"transition\":true},\"text-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-occlusion-opacity\":{\"type\":\"number\",\"minimum\":0,\"maximum\":1,\"default\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"overridable\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-halo-color\":{\"type\":\"color\",\"default\":\"rgba(0, 0, 0, 0)\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-halo-width\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-halo-blur\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\",\"feature-state\",\"measure-light\"]},\"property-type\":\"data-driven\"},\"text-translate\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"default\":[0,0],\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"text-translate-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"icon-color-saturation\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"expression\":{},\"property-type\":\"data-constant\"},\"icon-color-contrast\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"expression\":{},\"property-type\":\"data-constant\"},\"icon-color-brightness-min\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{},\"property-type\":\"data-constant\"},\"icon-color-brightness-max\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{},\"property-type\":\"data-constant\"},\"symbol-z-offset\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"feature\"]},\"property-type\":\"data-driven\"}},\"paint_raster\":{\"raster-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-color\":{\"type\":\"color\",\"expression\":{\"interpolated\":true,\"parameters\":[\"raster-value\"]},\"property-type\":\"color-ramp\"},\"raster-color-mix\":{\"type\":\"array\",\"default\":[0.2126,0.7152,0.0722,0],\"length\":4,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-color-range\":{\"type\":\"array\",\"length\":2,\"value\":\"number\",\"property-type\":\"data-constant\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]}},\"raster-hue-rotate\":{\"type\":\"number\",\"default\":0,\"period\":360,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-brightness-min\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-brightness-max\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-saturation\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-contrast\":{\"type\":\"number\",\"default\":0,\"minimum\":-1,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-resampling\":{\"type\":\"enum\",\"values\":{\"linear\":1,\"nearest\":1},\"default\":\"linear\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-fade-duration\":{\"type\":\"number\",\"default\":300,\"minimum\":0,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"},\"raster-array-band\":{\"type\":\"string\",\"required\":false,\"experimental\":true,\"property-type\":\"data-constant\"},\"raster-elevation\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"experimental\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"paint_raster-particle\":{\"raster-particle-array-band\":{\"type\":\"string\",\"required\":false,\"property-type\":\"data-constant\"},\"raster-particle-count\":{\"type\":\"number\",\"default\":512,\"minimum\":1,\"property-type\":\"data-constant\"},\"raster-particle-color\":{\"type\":\"color\",\"expression\":{\"interpolated\":true,\"parameters\":[\"raster-particle-speed\"]},\"property-type\":\"color-ramp\"},\"raster-particle-max-speed\":{\"type\":\"number\",\"default\":1,\"minimum\":1,\"property-type\":\"data-constant\"},\"raster-particle-speed-factor\":{\"type\":\"number\",\"default\":0.2,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-particle-fade-opacity-factor\":{\"type\":\"number\",\"default\":0.98,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"raster-particle-reset-rate-factor\":{\"type\":\"number\",\"default\":0.8,\"minimum\":0,\"maximum\":1,\"property-type\":\"data-constant\"},\"raster-particle-elevation\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"paint_hillshade\":{\"hillshade-illumination-direction\":{\"type\":\"number\",\"default\":335,\"minimum\":0,\"maximum\":359,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"hillshade-illumination-anchor\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"viewport\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"hillshade-exaggeration\":{\"type\":\"number\",\"default\":0.5,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"hillshade-shadow-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"},\"hillshade-highlight-color\":{\"type\":\"color\",\"default\":\"#FFFFFF\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"},\"hillshade-accent-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"},\"hillshade-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"}},\"paint_background\":{\"background-pitch-alignment\":{\"type\":\"enum\",\"values\":{\"map\":1,\"viewport\":1},\"default\":\"map\",\"expression\":{\"parameters\":[]},\"experimental\":true,\"property-type\":\"data-constant\"},\"background-color\":{\"type\":\"color\",\"default\":\"#000000\",\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"background-pattern\":{\"type\":\"resolvedImage\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"background-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"background-emissive-strength\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\",\"measure-light\"]},\"property-type\":\"data-constant\"}},\"paint_sky\":{\"sky-type\":{\"type\":\"enum\",\"values\":{\"gradient\":1,\"atmosphere\":1},\"default\":\"atmosphere\",\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"sky-atmosphere-sun\":{\"type\":\"array\",\"value\":\"number\",\"length\":2,\"minimum\":[0,0],\"maximum\":[360,180],\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"sky-atmosphere-sun-intensity\":{\"type\":\"number\",\"default\":10,\"minimum\":0,\"maximum\":100,\"property-type\":\"data-constant\"},\"sky-gradient-center\":{\"type\":\"array\",\"value\":\"number\",\"default\":[0,0],\"length\":2,\"minimum\":[0,0],\"maximum\":[360,180],\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"sky-gradient-radius\":{\"type\":\"number\",\"default\":90,\"minimum\":0,\"maximum\":180,\"expression\":{\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"},\"sky-gradient\":{\"type\":\"color\",\"default\":[\"interpolate\",[\"linear\"],[\"sky-radial-progress\"],0.8,\"#87ceeb\",1,\"white\"],\"expression\":{\"interpolated\":true,\"parameters\":[\"sky-radial-progress\"]},\"property-type\":\"color-ramp\"},\"sky-atmosphere-halo-color\":{\"type\":\"color\",\"default\":\"white\",\"property-type\":\"data-constant\"},\"sky-atmosphere-color\":{\"type\":\"color\",\"default\":\"white\",\"property-type\":\"data-constant\"},\"sky-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\"}},\"paint_model\":{\"model-opacity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"transition\":true,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"zoom\"]},\"property-type\":\"data-driven\"},\"model-rotation\":{\"type\":\"array\",\"value\":\"number\",\"length\":3,\"default\":[0,0,0],\"period\":360,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"zoom\"]},\"transition\":true},\"model-scale\":{\"type\":\"array\",\"value\":\"number\",\"length\":3,\"default\":[1,1,1],\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"zoom\"]},\"transition\":true},\"model-translation\":{\"type\":\"array\",\"value\":\"number\",\"length\":3,\"default\":[0,0,0],\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"zoom\"]},\"transition\":true},\"model-color\":{\"type\":\"color\",\"default\":\"#ffffff\",\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\",\"zoom\"]},\"transition\":true},\"model-color-mix-intensity\":{\"type\":\"number\",\"property-type\":\"data-driven\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"transition\":true},\"model-type\":{\"type\":\"enum\",\"values\":{\"common-3d\":1,\"location-indicator\":1},\"default\":\"common-3d\",\"property-type\":\"data-constant\"},\"model-cast-shadows\":{\"type\":\"boolean\",\"default\":true,\"property-type\":\"data-constant\"},\"model-receive-shadows\":{\"type\":\"boolean\",\"default\":true,\"property-type\":\"data-constant\"},\"model-ambient-occlusion-intensity\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"property-type\":\"data-constant\",\"transition\":true},\"model-emissive-strength\":{\"type\":\"number\",\"property-type\":\"data-driven\",\"default\":0,\"minimum\":0,\"maximum\":5,\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"transition\":true},\"model-roughness\":{\"type\":\"number\",\"default\":1,\"minimum\":0,\"maximum\":1,\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\"]},\"transition\":true},\"model-height-based-emissive-strength-multiplier\":{\"type\":\"array\",\"default\":[1,1,1,1,0],\"length\":5,\"value\":\"number\",\"property-type\":\"data-driven\",\"expression\":{\"interpolated\":true,\"parameters\":[\"feature\",\"feature-state\",\"measure-light\"]},\"transition\":true},\"model-cutoff-fade-range\":{\"type\":\"number\",\"default\":0,\"minimum\":0,\"maximum\":1,\"expression\":{},\"property-type\":\"data-constant\"},\"model-front-cutoff\":{\"type\":\"array\",\"private\":true,\"value\":\"number\",\"property-type\":\"data-constant\",\"expression\":{\"interpolated\":true,\"parameters\":[\"zoom\"]},\"length\":3,\"default\":[0,0,1],\"minimum\":[0,0,0],\"maximum\":[1,1,1]}},\"transition\":{\"duration\":{\"type\":\"number\",\"default\":300,\"minimum\":0},\"delay\":{\"type\":\"number\",\"default\":0,\"minimum\":0}},\"property-type\":{\"data-driven\":{\"type\":\"property-type\"},\"color-ramp\":{\"type\":\"property-type\"},\"data-constant\":{\"type\":\"property-type\"},\"constant\":{\"type\":\"property-type\"}},\"promoteId\":{\"*\":{\"type\":\"*\"}}}');\n    function Ws(t) {\n      return t instanceof Number || t instanceof String || t instanceof Boolean ? t.valueOf() : t;\n    }\n    function Ks(t) {\n      if (Array.isArray(t)) return t.map(Ks);\n      if (t instanceof Object && !(t instanceof Number || t instanceof String || t instanceof Boolean)) {\n        const e = {};\n        for (const r in t) e[r] = Ks(t[r]);\n        return e;\n      }\n      return Ws(t);\n    }\n    function Js(t) {\n      if (!0 === t || !1 === t) return !0;\n      if (!Array.isArray(t) || 0 === t.length) return !1;\n      switch (t[0]) {\n        case \"has\":\n          return t.length >= 2 && \"$id\" !== t[1] && \"$type\" !== t[1];\n        case \"in\":\n          return t.length >= 3 && (\"string\" != typeof t[1] || Array.isArray(t[2]));\n        case \"!in\":\n        case \"!has\":\n        case \"none\":\n          return !1;\n        case \"==\":\n        case \"!=\":\n        case \">\":\n        case \">=\":\n        case \"<\":\n        case \"<=\":\n          return 3 !== t.length || Array.isArray(t[1]) || Array.isArray(t[2]);\n        case \"any\":\n        case \"all\":\n          for (const e of t.slice(1)) if (!Js(e) && \"boolean\" != typeof e) return !1;\n          return !0;\n        default:\n          return !0;\n      }\n    }\n    function Qs(t, e = \"\", r = null, n = \"fill\") {\n      if (null == t) return {\n        filter: () => !0,\n        needGeometry: !1,\n        needFeature: !1\n      };\n      Js(t) || (t = aa(t));\n      const i = t;\n      let s = !0;\n      try {\n        s = function (t) {\n          if (!ra(t)) return t;\n          let e = Ks(t);\n          return ea(e), e = ta(e), e;\n        }(i);\n      } catch (t) {\n        console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\\nand paste the contents of this message in the report.\\nThank you!\\nFilter Expression:\\n${JSON.stringify(i, null, 2)}\\n        `);\n      }\n      let a = null,\n        o = null;\n      if (\"background\" !== n && \"sky\" !== n && \"slot\" !== n) {\n        o = Zs[`filter_${n}`];\n        const t = Ji(s, o, e, r);\n        if (\"error\" === t.result) throw new Error(t.value.map(t => `${t.key}: ${t.message}`).join(\", \"));\n        a = (e, r, n) => t.value.evaluate(e, r, {}, n);\n      }\n      let l = null,\n        u = null;\n      if (s !== i) {\n        const t = Ji(i, o, e, r);\n        if (\"error\" === t.result) throw new Error(t.value.map(t => `${t.key}: ${t.message}`).join(\", \"));\n        l = (e, r, n, i, s) => t.value.evaluate(e, r, {}, n, void 0, void 0, i, s), u = !Bn(t.value.expression);\n      }\n      return {\n        filter: a,\n        dynamicFilter: l || void 0,\n        needGeometry: sa(s),\n        needFeature: !!u\n      };\n    }\n    function ta(t) {\n      if (!Array.isArray(t)) return t;\n      const e = function (t) {\n        if (na.has(t[0])) for (let e = 1; e < t.length; e++) if (ra(t[e])) return !0;\n        return t;\n      }(t);\n      return !0 === e ? e : e.map(t => ta(t));\n    }\n    function ea(t) {\n      let e = !1;\n      const r = [];\n      if (\"case\" === t[0]) {\n        for (let n = 1; n < t.length - 1; n += 2) e = e || ra(t[n]), r.push(t[n + 1]);\n        r.push(t[t.length - 1]);\n      } else if (\"match\" === t[0]) {\n        e = e || ra(t[1]);\n        for (let e = 2; e < t.length - 1; e += 2) r.push(t[e + 1]);\n        r.push(t[t.length - 1]);\n      } else if (\"step\" === t[0]) {\n        e = e || ra(t[1]);\n        for (let e = 1; e < t.length - 1; e += 2) r.push(t[e + 1]);\n      }\n      e && (t.length = 0, t.push(\"any\", ...r));\n      for (let e = 1; e < t.length; e++) ea(t[e]);\n    }\n    function ra(t) {\n      if (!Array.isArray(t)) return !1;\n      if (\"pitch\" === (e = t[0]) || \"distance-from-center\" === e) return !0;\n      var e;\n      for (let e = 1; e < t.length; e++) if (ra(t[e])) return !0;\n      return !1;\n    }\n    const na = new Set([\"in\", \"==\", \"!=\", \">\", \">=\", \"<\", \"<=\", \"to-boolean\"]);\n    function ia(t, e) {\n      return t < e ? -1 : t > e ? 1 : 0;\n    }\n    function sa(t) {\n      if (!Array.isArray(t)) return !1;\n      if (\"within\" === t[0] || \"distance\" === t[0]) return !0;\n      for (let e = 1; e < t.length; e++) if (sa(t[e])) return !0;\n      return !1;\n    }\n    function aa(t) {\n      if (!t) return !0;\n      const e = t[0];\n      return t.length <= 1 ? \"any\" !== e : \"==\" === e ? oa(t[1], t[2], \"==\") : \"!=\" === e ? ca(oa(t[1], t[2], \"==\")) : \"<\" === e || \">\" === e || \"<=\" === e || \">=\" === e ? oa(t[1], t[2], e) : \"any\" === e ? (r = t.slice(1), [\"any\"].concat(r.map(aa))) : \"all\" === e ? [\"all\"].concat(t.slice(1).map(aa)) : \"none\" === e ? [\"all\"].concat(t.slice(1).map(aa).map(ca)) : \"in\" === e ? la(t[1], t.slice(2)) : \"!in\" === e ? ca(la(t[1], t.slice(2))) : \"has\" === e ? ua(t[1]) : \"!has\" !== e || ca(ua(t[1]));\n      var r;\n    }\n    function oa(t, e, r) {\n      switch (t) {\n        case \"$type\":\n          return [`filter-type-${r}`, e];\n        case \"$id\":\n          return [`filter-id-${r}`, e];\n        default:\n          return [`filter-${r}`, t, e];\n      }\n    }\n    function la(t, e) {\n      if (0 === e.length) return !1;\n      switch (t) {\n        case \"$type\":\n          return [\"filter-type-in\", [\"literal\", e]];\n        case \"$id\":\n          return [\"filter-id-in\", [\"literal\", e]];\n        default:\n          return e.length > 200 && !e.some(t => typeof t != typeof e[0]) ? [\"filter-in-large\", t, [\"literal\", e.sort(ia)]] : [\"filter-in-small\", t, [\"literal\", e]];\n      }\n    }\n    function ua(t) {\n      switch (t) {\n        case \"$type\":\n          return !0;\n        case \"$id\":\n          return [\"filter-has-id\"];\n        default:\n          return [\"filter-has\", t];\n      }\n    }\n    function ca(t) {\n      return [\"!\", t];\n    }\n    const ha = \"\u001f\";\n    function pa(t, e) {\n      return e ? `${t}${ha}${e}` : t;\n    }\n    const fa = \"-transition\",\n      da = new Set([\"fill\", \"line\", \"background\", \"hillshade\", \"raster\"]);\n    class ma extends _e {\n      constructor(t, e, r, n, i) {\n        if (super(), this.id = t.id, this.fqid = pa(this.id, r), this.type = t.type, this.scope = r, this.lut = n, this.options = i, this._featureFilter = {\n          filter: () => !0,\n          needGeometry: !1,\n          needFeature: !1\n        }, this._filterCompiled = !1, this.configDependencies = new Set(), \"custom\" !== t.type) {\n          if (this.metadata = t.metadata, this.minzoom = t.minzoom, this.maxzoom = t.maxzoom, t.type && \"background\" !== t.type && \"sky\" !== t.type && \"slot\" !== t.type) {\n            this.source = t.source, this.sourceLayer = t[\"source-layer\"], this.filter = t.filter;\n            const e = Ji(this.filter, Zs[`filter_${t.type}`]);\n            \"error\" !== e.result && (this.configDependencies = new Set([...this.configDependencies, ...e.value.configDependencies]));\n          }\n          if (t.slot && (this.slot = t.slot), e.layout && (this._unevaluatedLayout = new js(e.layout, this.scope, i), this.configDependencies = new Set([...this.configDependencies, ...this._unevaluatedLayout.configDependencies])), e.paint) {\n            this._transitionablePaint = new Os(e.paint, this.scope, i);\n            for (const e in t.paint) this.setPaintProperty(e, t.paint[e]);\n            for (const e in t.layout) this.setLayoutProperty(e, t.layout[e]);\n            this.configDependencies = new Set([...this.configDependencies, ...this._transitionablePaint.configDependencies]), this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new $s(e.paint);\n          }\n        }\n      }\n      onAdd(t) {}\n      onRemove(t) {}\n      isDraped(t) {\n        return !this.is3D(!0) && da.has(this.type);\n      }\n      getLayoutProperty(t) {\n        return \"visibility\" === t ? this.visibility : this._unevaluatedLayout.getValue(t);\n      }\n      setLayoutProperty(t, e) {\n        if (\"custom\" === this.type && \"visibility\" === t) return void (this.visibility = e);\n        const r = this._unevaluatedLayout;\n        r._properties.properties[t] && (r.setValue(t, e), this.configDependencies = new Set([...this.configDependencies, ...r.configDependencies]), \"visibility\" === t && this.possiblyEvaluateVisibility());\n      }\n      possiblyEvaluateVisibility() {\n        this._unevaluatedLayout._values.visibility && (this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({\n          zoom: 0\n        }));\n      }\n      getPaintProperty(t) {\n        return t.endsWith(fa) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t);\n      }\n      setPaintProperty(t, e) {\n        const r = this._transitionablePaint,\n          n = r._properties.properties;\n        if (t.endsWith(fa)) {\n          const i = t.slice(0, -11);\n          return n[i] && r.setTransition(i, e || void 0), !1;\n        }\n        if (!n[t]) return !1;\n        const i = r._values[t],\n          s = i.value.isDataDriven(),\n          a = i.value;\n        r.setValue(t, e), this.configDependencies = new Set([...this.configDependencies, ...r.configDependencies]), this._handleSpecialPaintPropertyUpdate(t);\n        const o = r._values[t].value,\n          l = o.isDataDriven(),\n          u = t.endsWith(\"pattern\") || \"line-dasharray\" === t;\n        return l || s || u || this._handleOverridablePaintPropertyUpdate(t, a, o);\n      }\n      _handleSpecialPaintPropertyUpdate(t) {}\n      getProgramIds() {\n        return null;\n      }\n      getDefaultProgramParams(t, e, r) {\n        return null;\n      }\n      _handleOverridablePaintPropertyUpdate(t, e, r) {\n        return !1;\n      }\n      isHidden(t) {\n        return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || \"none\" === this.visibility;\n      }\n      updateTransitions(t) {\n        this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);\n      }\n      hasTransition() {\n        return this._transitioningPaint.hasTransition();\n      }\n      recalculate(t, e) {\n        this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, e)), this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, e);\n      }\n      serialize() {\n        return ut({\n          id: this.id,\n          type: this.type,\n          slot: this.slot,\n          source: this.source,\n          \"source-layer\": this.sourceLayer,\n          metadata: this.metadata,\n          minzoom: this.minzoom,\n          maxzoom: this.maxzoom,\n          filter: this.filter,\n          layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),\n          paint: this._transitionablePaint && this._transitionablePaint.serialize()\n        }, (t, e) => !(void 0 === t || \"layout\" === e && !Object.keys(t).length || \"paint\" === e && !Object.keys(t).length));\n      }\n      is3D(t) {\n        return !1;\n      }\n      isSky() {\n        return !1;\n      }\n      isTileClipped() {\n        return !1;\n      }\n      hasOffscreenPass() {\n        return !1;\n      }\n      hasShadowPass() {\n        return !1;\n      }\n      canCastShadows() {\n        return !1;\n      }\n      hasLightBeamPass() {\n        return !1;\n      }\n      cutoffRange() {\n        return 0;\n      }\n      tileCoverLift() {\n        return 0;\n      }\n      resize() {}\n      isStateDependent() {\n        for (const t in this.paint._values) {\n          const e = this.paint.get(t);\n          if (e instanceof qs && Fi(e.property.specification) && (\"source\" === e.value.kind || \"composite\" === e.value.kind) && e.value.isStateDependent) return !0;\n        }\n        return !1;\n      }\n      compileFilter(t) {\n        this._filterCompiled || (this._featureFilter = Qs(this.filter, this.scope, t), this._filterCompiled = !0);\n      }\n      invalidateCompiledFilter() {\n        this._filterCompiled = !1;\n      }\n      dynamicFilter() {\n        return this._featureFilter.dynamicFilter;\n      }\n      dynamicFilterNeedsFeature() {\n        return this._featureFilter.needFeature;\n      }\n      getLayerRenderingStats() {\n        return this._stats;\n      }\n      resetLayerRenderingStats(t) {\n        this._stats && (\"shadow\" === t.renderPass ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0);\n      }\n      queryRadius(t) {}\n      queryIntersectsFeature(t, e, r, n, i, s, a, o, l) {}\n    }\n    const ya = {\n      Int8: Int8Array,\n      Uint8: Uint8Array,\n      Int16: Int16Array,\n      Uint16: Uint16Array,\n      Int32: Int32Array,\n      Uint32: Uint32Array,\n      Float32: Float32Array\n    };\n    class ga {\n      constructor(t, e) {\n        this._structArray = t, this._pos1 = e * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;\n      }\n    }\n    class xa {\n      constructor() {\n        this.isTransferred = !1, this.capacity = -1, this.resize(0);\n      }\n      static serialize(t, e) {\n        return t._trim(), e && (t.isTransferred = !0, e.add(t.arrayBuffer)), {\n          length: t.length,\n          arrayBuffer: t.arrayBuffer\n        };\n      }\n      static deserialize(t) {\n        const e = Object.create(this.prototype);\n        return e.arrayBuffer = t.arrayBuffer, e.length = t.length, e.capacity = t.arrayBuffer.byteLength / e.bytesPerElement, e._refreshViews(), e;\n      }\n      _trim() {\n        this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());\n      }\n      clear() {\n        this.length = 0;\n      }\n      resize(t) {\n        this.reserve(t), this.length = t;\n      }\n      reserve(t) {\n        if (t > this.capacity) {\n          this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);\n          const e = this.uint8;\n          this._refreshViews(), e && this.uint8.set(e);\n        }\n      }\n      _refreshViews() {\n        throw new Error(\"StructArray#_refreshViews() must be implemented by each concrete StructArray layout\");\n      }\n      emplace(...t) {\n        throw new Error(\"StructArray#emplace() must be implemented by each concrete StructArray layout\");\n      }\n      emplaceBack(...t) {\n        throw new Error(\"StructArray#emplaceBack() must be implemented by each concrete StructArray layout\");\n      }\n      destroy() {\n        this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;\n      }\n    }\n    function va(t, e = 1) {\n      let r = 0,\n        n = 0;\n      return {\n        members: t.map(t => {\n          const i = ya[t.type].BYTES_PER_ELEMENT,\n            s = r = ba(r, Math.max(e, i)),\n            a = t.components || 1;\n          return n = Math.max(n, i), r += i * a, {\n            name: t.name,\n            type: t.type,\n            components: a,\n            offset: s\n          };\n        }),\n        size: ba(r, Math.max(n, e)),\n        alignment: e\n      };\n    }\n    function ba(t, e) {\n      return Math.ceil(t / e) * e;\n    }\n    class _a extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e) {\n        const r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }\n      emplace(t, e, r) {\n        const n = 2 * t;\n        return this.int16[n + 0] = e, this.int16[n + 1] = r, t;\n      }\n    }\n    _a.prototype.bytesPerElement = 4, us(_a, \"StructArrayLayout2i4\");\n    class wa extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n      emplace(t, e, r, n) {\n        const i = 3 * t;\n        return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t;\n      }\n    }\n    wa.prototype.bytesPerElement = 6, us(wa, \"StructArrayLayout3i6\");\n    class Ma extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n      emplace(t, e, r, n, i) {\n        const s = 4 * t;\n        return this.int16[s + 0] = e, this.int16[s + 1] = r, this.int16[s + 2] = n, this.int16[s + 3] = i, t;\n      }\n    }\n    Ma.prototype.bytesPerElement = 8, us(Ma, \"StructArrayLayout4i8\");\n    class Aa extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n      emplace(t, e) {\n        return this.float32[1 * t + 0] = e, t;\n      }\n    }\n    Aa.prototype.bytesPerElement = 4, us(Aa, \"StructArrayLayout1f4\");\n    class Ia extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n      emplace(t, e, r, n) {\n        const i = 4 * t,\n          s = 2 * t;\n        return this.int16[i + 0] = e, this.int16[i + 1] = r, this.float32[s + 1] = n, t;\n      }\n    }\n    Ia.prototype.bytesPerElement = 8, us(Ia, \"StructArrayLayout2i1f8\");\n    class Sa extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n      emplace(t, e, r, n) {\n        const i = 4 * t;\n        return this.int16[i + 0] = e, this.int16[i + 1] = r, this.int16[i + 2] = n, t;\n      }\n    }\n    Sa.prototype.bytesPerElement = 8, us(Sa, \"StructArrayLayout3i8\");\n    class Pa extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i) {\n        const s = this.length;\n        return this.resize(s + 1), this.emplace(s, t, e, r, n, i);\n      }\n      emplace(t, e, r, n, i, s) {\n        const a = 5 * t;\n        return this.int16[a + 0] = e, this.int16[a + 1] = r, this.int16[a + 2] = n, this.int16[a + 3] = i, this.int16[a + 4] = s, t;\n      }\n    }\n    Pa.prototype.bytesPerElement = 10, us(Pa, \"StructArrayLayout5i10\");\n    class Ea extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, a) {\n        const o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s, a);\n      }\n      emplace(t, e, r, n, i, s, a, o) {\n        const l = 6 * t,\n          u = 12 * t,\n          c = 3 * t;\n        return this.int16[l + 0] = e, this.int16[l + 1] = r, this.uint8[u + 4] = n, this.uint8[u + 5] = i, this.uint8[u + 6] = s, this.uint8[u + 7] = a, this.float32[c + 2] = o, t;\n      }\n    }\n    Ea.prototype.bytesPerElement = 12, us(Ea, \"StructArrayLayout2i4ub1f12\");\n    class za extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n      emplace(t, e, r, n) {\n        const i = 3 * t;\n        return this.float32[i + 0] = e, this.float32[i + 1] = r, this.float32[i + 2] = n, t;\n      }\n    }\n    za.prototype.bytesPerElement = 12, us(za, \"StructArrayLayout3f12\");\n    class ka extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i) {\n        const s = this.length;\n        return this.resize(s + 1), this.emplace(s, t, e, r, n, i);\n      }\n      emplace(t, e, r, n, i, s) {\n        const a = 6 * t,\n          o = 3 * t;\n        return this.uint16[a + 0] = e, this.uint16[a + 1] = r, this.uint16[a + 2] = n, this.uint16[a + 3] = i, this.float32[o + 2] = s, t;\n      }\n    }\n    ka.prototype.bytesPerElement = 12, us(ka, \"StructArrayLayout4ui1f12\");\n    class Ta extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n      emplace(t, e, r, n, i) {\n        const s = 4 * t;\n        return this.uint16[s + 0] = e, this.uint16[s + 1] = r, this.uint16[s + 2] = n, this.uint16[s + 3] = i, t;\n      }\n    }\n    Ta.prototype.bytesPerElement = 8, us(Ta, \"StructArrayLayout4ui8\");\n    class Ba extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s) {\n        const a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s);\n      }\n      emplace(t, e, r, n, i, s, a) {\n        const o = 6 * t;\n        return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.int16[o + 3] = i, this.int16[o + 4] = s, this.int16[o + 5] = a, t;\n      }\n    }\n    Ba.prototype.bytesPerElement = 12, us(Ba, \"StructArrayLayout6i12\");\n    class Va extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h) {\n        const p = this.length;\n        return this.resize(p + 1), this.emplace(p, t, e, r, n, i, s, a, o, l, u, c, h);\n      }\n      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p) {\n        const f = 12 * t;\n        return this.int16[f + 0] = e, this.int16[f + 1] = r, this.int16[f + 2] = n, this.int16[f + 3] = i, this.uint16[f + 4] = s, this.uint16[f + 5] = a, this.uint16[f + 6] = o, this.uint16[f + 7] = l, this.int16[f + 8] = u, this.int16[f + 9] = c, this.int16[f + 10] = h, this.int16[f + 11] = p, t;\n      }\n    }\n    Va.prototype.bytesPerElement = 24, us(Va, \"StructArrayLayout4i4ui4i24\");\n    class Ca extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s) {\n        const a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s);\n      }\n      emplace(t, e, r, n, i, s, a) {\n        const o = 10 * t,\n          l = 5 * t;\n        return this.int16[o + 0] = e, this.int16[o + 1] = r, this.int16[o + 2] = n, this.float32[l + 2] = i, this.float32[l + 3] = s, this.float32[l + 4] = a, t;\n      }\n    }\n    Ca.prototype.bytesPerElement = 20, us(Ca, \"StructArrayLayout3i3f20\");\n    class Da extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n      emplace(t, e, r, n, i) {\n        const s = 4 * t;\n        return this.float32[s + 0] = e, this.float32[s + 1] = r, this.float32[s + 2] = n, this.float32[s + 3] = i, t;\n      }\n    }\n    Da.prototype.bytesPerElement = 16, us(Da, \"StructArrayLayout4f16\");\n    class Ra extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n      }\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n      emplace(t, e) {\n        return this.uint32[1 * t + 0] = e, t;\n      }\n    }\n    Ra.prototype.bytesPerElement = 4, us(Ra, \"StructArrayLayout1ul4\");\n    class La extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e) {\n        const r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }\n      emplace(t, e, r) {\n        const n = 2 * t;\n        return this.uint16[n + 0] = e, this.uint16[n + 1] = r, t;\n      }\n    }\n    La.prototype.bytesPerElement = 4, us(La, \"StructArrayLayout2ui4\");\n    class Fa extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p) {\n        const f = this.length;\n        return this.resize(f + 1), this.emplace(f, t, e, r, n, i, s, a, o, l, u, c, h, p);\n      }\n      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f) {\n        const d = 20 * t,\n          m = 10 * t;\n        return this.int16[d + 0] = e, this.int16[d + 1] = r, this.int16[d + 2] = n, this.int16[d + 3] = i, this.int16[d + 4] = s, this.float32[m + 3] = a, this.float32[m + 4] = o, this.float32[m + 5] = l, this.float32[m + 6] = u, this.int16[d + 14] = c, this.uint32[m + 8] = h, this.uint16[d + 18] = p, this.uint16[d + 19] = f, t;\n      }\n    }\n    Fa.prototype.bytesPerElement = 40, us(Fa, \"StructArrayLayout5i4f1i1ul2ui40\");\n    class Oa extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, a) {\n        const o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s, a);\n      }\n      emplace(t, e, r, n, i, s, a, o) {\n        const l = 8 * t;\n        return this.int16[l + 0] = e, this.int16[l + 1] = r, this.int16[l + 2] = n, this.int16[l + 4] = i, this.int16[l + 5] = s, this.int16[l + 6] = a, this.int16[l + 7] = o, t;\n      }\n    }\n    Oa.prototype.bytesPerElement = 16, us(Oa, \"StructArrayLayout3i2i2i16\");\n    class Na extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i) {\n        const s = this.length;\n        return this.resize(s + 1), this.emplace(s, t, e, r, n, i);\n      }\n      emplace(t, e, r, n, i, s) {\n        const a = 4 * t,\n          o = 8 * t;\n        return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.int16[o + 6] = i, this.int16[o + 7] = s, t;\n      }\n    }\n    Na.prototype.bytesPerElement = 16, us(Na, \"StructArrayLayout2f1f2i16\");\n    class Ua extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s) {\n        const a = this.length;\n        return this.resize(a + 1), this.emplace(a, t, e, r, n, i, s);\n      }\n      emplace(t, e, r, n, i, s, a) {\n        const o = 20 * t,\n          l = 5 * t;\n        return this.uint8[o + 0] = e, this.uint8[o + 1] = r, this.float32[l + 1] = n, this.float32[l + 2] = i, this.float32[l + 3] = s, this.float32[l + 4] = a, t;\n      }\n    }\n    Ua.prototype.bytesPerElement = 20, us(Ua, \"StructArrayLayout2ub4f20\");\n    class ja extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r) {\n        const n = this.length;\n        return this.resize(n + 1), this.emplace(n, t, e, r);\n      }\n      emplace(t, e, r, n) {\n        const i = 3 * t;\n        return this.uint16[i + 0] = e, this.uint16[i + 1] = r, this.uint16[i + 2] = n, t;\n      }\n    }\n    ja.prototype.bytesPerElement = 6, us(ja, \"StructArrayLayout3ui6\");\n    class qa extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y, g, x, v, b) {\n        const _ = this.length;\n        return this.resize(_ + 1), this.emplace(_, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y, g, x, v, b);\n      }\n      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y, g, x, v, b, _) {\n        const w = 30 * t,\n          M = 15 * t,\n          A = 60 * t;\n        return this.int16[w + 0] = e, this.int16[w + 1] = r, this.int16[w + 2] = n, this.float32[M + 2] = i, this.float32[M + 3] = s, this.uint16[w + 8] = a, this.uint16[w + 9] = o, this.uint32[M + 5] = l, this.uint32[M + 6] = u, this.uint32[M + 7] = c, this.uint16[w + 16] = h, this.uint16[w + 17] = p, this.uint16[w + 18] = f, this.float32[M + 10] = d, this.float32[M + 11] = m, this.uint8[A + 48] = y, this.uint8[A + 49] = g, this.uint8[A + 50] = x, this.uint32[M + 13] = v, this.int16[w + 28] = b, this.uint8[A + 58] = _, t;\n      }\n    }\n    qa.prototype.bytesPerElement = 60, us(qa, \"StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60\");\n    class $a extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y, g, x, v, b, _, w, M, A, I, S, P, E, z, k, T, B) {\n        const V = this.length;\n        return this.resize(V + 1), this.emplace(V, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y, g, x, v, b, _, w, M, A, I, S, P, E, z, k, T, B);\n      }\n      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y, g, x, v, b, _, w, M, A, I, S, P, E, z, k, T, B, V) {\n        const C = 20 * t,\n          D = 40 * t,\n          R = 80 * t;\n        return this.float32[C + 0] = e, this.float32[C + 1] = r, this.int16[D + 4] = n, this.int16[D + 5] = i, this.int16[D + 6] = s, this.int16[D + 7] = a, this.int16[D + 8] = o, this.int16[D + 9] = l, this.int16[D + 10] = u, this.int16[D + 11] = c, this.int16[D + 12] = h, this.uint16[D + 13] = p, this.uint16[D + 14] = f, this.uint16[D + 15] = d, this.uint16[D + 16] = m, this.uint16[D + 17] = y, this.uint16[D + 18] = g, this.uint16[D + 19] = x, this.uint16[D + 20] = v, this.uint16[D + 21] = b, this.uint16[D + 22] = _, this.uint16[D + 23] = w, this.uint16[D + 24] = M, this.uint16[D + 25] = A, this.uint16[D + 26] = I, this.uint16[D + 27] = S, this.uint32[C + 14] = P, this.float32[C + 15] = E, this.float32[C + 16] = z, this.float32[C + 17] = k, this.float32[C + 18] = T, this.uint8[R + 76] = B, this.uint16[D + 39] = V, t;\n      }\n    }\n    $a.prototype.bytesPerElement = 80, us($a, \"StructArrayLayout2f9i15ui1ul4f1ub1ui80\");\n    class Ga extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i) {\n        const s = this.length;\n        return this.resize(s + 1), this.emplace(s, t, e, r, n, i);\n      }\n      emplace(t, e, r, n, i, s) {\n        const a = 5 * t;\n        return this.float32[a + 0] = e, this.float32[a + 1] = r, this.float32[a + 2] = n, this.float32[a + 3] = i, this.float32[a + 4] = s, t;\n      }\n    }\n    Ga.prototype.bytesPerElement = 20, us(Ga, \"StructArrayLayout5f20\");\n    class Ya extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, a) {\n        const o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s, a);\n      }\n      emplace(t, e, r, n, i, s, a, o) {\n        const l = 7 * t;\n        return this.float32[l + 0] = e, this.float32[l + 1] = r, this.float32[l + 2] = n, this.float32[l + 3] = i, this.float32[l + 4] = s, this.float32[l + 5] = a, this.float32[l + 6] = o, t;\n      }\n    }\n    Ya.prototype.bytesPerElement = 28, us(Ya, \"StructArrayLayout7f28\");\n    class Ha extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, a, o, l, u, c) {\n        const h = this.length;\n        return this.resize(h + 1), this.emplace(h, t, e, r, n, i, s, a, o, l, u, c);\n      }\n      emplace(t, e, r, n, i, s, a, o, l, u, c, h) {\n        const p = 11 * t;\n        return this.float32[p + 0] = e, this.float32[p + 1] = r, this.float32[p + 2] = n, this.float32[p + 3] = i, this.float32[p + 4] = s, this.float32[p + 5] = a, this.float32[p + 6] = o, this.float32[p + 7] = l, this.float32[p + 8] = u, this.float32[p + 9] = c, this.float32[p + 10] = h, t;\n      }\n    }\n    Ha.prototype.bytesPerElement = 44, us(Ha, \"StructArrayLayout11f44\");\n    class Xa extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, a, o, l) {\n        const u = this.length;\n        return this.resize(u + 1), this.emplace(u, t, e, r, n, i, s, a, o, l);\n      }\n      emplace(t, e, r, n, i, s, a, o, l, u) {\n        const c = 9 * t;\n        return this.float32[c + 0] = e, this.float32[c + 1] = r, this.float32[c + 2] = n, this.float32[c + 3] = i, this.float32[c + 4] = s, this.float32[c + 5] = a, this.float32[c + 6] = o, this.float32[c + 7] = l, this.float32[c + 8] = u, t;\n      }\n    }\n    Xa.prototype.bytesPerElement = 36, us(Xa, \"StructArrayLayout9f36\");\n    class Za extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e) {\n        const r = this.length;\n        return this.resize(r + 1), this.emplace(r, t, e);\n      }\n      emplace(t, e, r) {\n        const n = 2 * t;\n        return this.float32[n + 0] = e, this.float32[n + 1] = r, t;\n      }\n    }\n    Za.prototype.bytesPerElement = 8, us(Za, \"StructArrayLayout2f8\");\n    class Wa extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n) {\n        const i = this.length;\n        return this.resize(i + 1), this.emplace(i, t, e, r, n);\n      }\n      emplace(t, e, r, n, i) {\n        const s = 6 * t;\n        return this.uint32[3 * t + 0] = e, this.uint16[s + 2] = r, this.uint16[s + 3] = n, this.uint16[s + 4] = i, t;\n      }\n    }\n    Wa.prototype.bytesPerElement = 12, us(Wa, \"StructArrayLayout1ul3ui12\");\n    class Ka extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);\n      }\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n      emplace(t, e) {\n        return this.uint16[1 * t + 0] = e, t;\n      }\n    }\n    Ka.prototype.bytesPerElement = 2, us(Ka, \"StructArrayLayout1ui2\");\n    class Ja extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m) {\n        const y = this.length;\n        return this.resize(y + 1), this.emplace(y, t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m);\n      }\n      emplace(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y) {\n        const g = 16 * t;\n        return this.float32[g + 0] = e, this.float32[g + 1] = r, this.float32[g + 2] = n, this.float32[g + 3] = i, this.float32[g + 4] = s, this.float32[g + 5] = a, this.float32[g + 6] = o, this.float32[g + 7] = l, this.float32[g + 8] = u, this.float32[g + 9] = c, this.float32[g + 10] = h, this.float32[g + 11] = p, this.float32[g + 12] = f, this.float32[g + 13] = d, this.float32[g + 14] = m, this.float32[g + 15] = y, t;\n      }\n    }\n    Ja.prototype.bytesPerElement = 64, us(Ja, \"StructArrayLayout16f64\");\n    class Qa extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);\n      }\n      emplaceBack(t, e, r, n, i, s, a) {\n        const o = this.length;\n        return this.resize(o + 1), this.emplace(o, t, e, r, n, i, s, a);\n      }\n      emplace(t, e, r, n, i, s, a, o) {\n        const l = 10 * t,\n          u = 5 * t;\n        return this.uint16[l + 0] = e, this.uint16[l + 1] = r, this.uint16[l + 2] = n, this.uint16[l + 3] = i, this.float32[u + 2] = s, this.float32[u + 3] = a, this.float32[u + 4] = o, t;\n      }\n    }\n    Qa.prototype.bytesPerElement = 20, us(Qa, \"StructArrayLayout4ui3f20\");\n    class to extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);\n      }\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n      emplace(t, e) {\n        return this.int16[1 * t + 0] = e, t;\n      }\n    }\n    to.prototype.bytesPerElement = 2, us(to, \"StructArrayLayout1i2\");\n    class eo extends xa {\n      _refreshViews() {\n        this.uint8 = new Uint8Array(this.arrayBuffer);\n      }\n      emplaceBack(t) {\n        const e = this.length;\n        return this.resize(e + 1), this.emplace(e, t);\n      }\n      emplace(t, e) {\n        return this.uint8[1 * t + 0] = e, t;\n      }\n    }\n    eo.prototype.bytesPerElement = 1, us(eo, \"StructArrayLayout1ub1\");\n    class ro extends ga {\n      get projectedAnchorX() {\n        return this._structArray.int16[this._pos2 + 0];\n      }\n      get projectedAnchorY() {\n        return this._structArray.int16[this._pos2 + 1];\n      }\n      get projectedAnchorZ() {\n        return this._structArray.int16[this._pos2 + 2];\n      }\n      get tileAnchorX() {\n        return this._structArray.int16[this._pos2 + 3];\n      }\n      get tileAnchorY() {\n        return this._structArray.int16[this._pos2 + 4];\n      }\n      get x1() {\n        return this._structArray.float32[this._pos4 + 3];\n      }\n      get y1() {\n        return this._structArray.float32[this._pos4 + 4];\n      }\n      get x2() {\n        return this._structArray.float32[this._pos4 + 5];\n      }\n      get y2() {\n        return this._structArray.float32[this._pos4 + 6];\n      }\n      get padding() {\n        return this._structArray.int16[this._pos2 + 14];\n      }\n      get featureIndex() {\n        return this._structArray.uint32[this._pos4 + 8];\n      }\n      get sourceLayerIndex() {\n        return this._structArray.uint16[this._pos2 + 18];\n      }\n      get bucketIndex() {\n        return this._structArray.uint16[this._pos2 + 19];\n      }\n    }\n    ro.prototype.size = 40;\n    class no extends Fa {\n      get(t) {\n        return new ro(this, t);\n      }\n    }\n    us(no, \"CollisionBoxArray\");\n    class io extends ga {\n      get projectedAnchorX() {\n        return this._structArray.int16[this._pos2 + 0];\n      }\n      get projectedAnchorY() {\n        return this._structArray.int16[this._pos2 + 1];\n      }\n      get projectedAnchorZ() {\n        return this._structArray.int16[this._pos2 + 2];\n      }\n      get tileAnchorX() {\n        return this._structArray.float32[this._pos4 + 2];\n      }\n      get tileAnchorY() {\n        return this._structArray.float32[this._pos4 + 3];\n      }\n      get glyphStartIndex() {\n        return this._structArray.uint16[this._pos2 + 8];\n      }\n      get numGlyphs() {\n        return this._structArray.uint16[this._pos2 + 9];\n      }\n      get vertexStartIndex() {\n        return this._structArray.uint32[this._pos4 + 5];\n      }\n      get lineStartIndex() {\n        return this._structArray.uint32[this._pos4 + 6];\n      }\n      get lineLength() {\n        return this._structArray.uint32[this._pos4 + 7];\n      }\n      get segment() {\n        return this._structArray.uint16[this._pos2 + 16];\n      }\n      get lowerSize() {\n        return this._structArray.uint16[this._pos2 + 17];\n      }\n      get upperSize() {\n        return this._structArray.uint16[this._pos2 + 18];\n      }\n      get lineOffsetX() {\n        return this._structArray.float32[this._pos4 + 10];\n      }\n      get lineOffsetY() {\n        return this._structArray.float32[this._pos4 + 11];\n      }\n      get writingMode() {\n        return this._structArray.uint8[this._pos1 + 48];\n      }\n      get placedOrientation() {\n        return this._structArray.uint8[this._pos1 + 49];\n      }\n      set placedOrientation(t) {\n        this._structArray.uint8[this._pos1 + 49] = t;\n      }\n      get hidden() {\n        return this._structArray.uint8[this._pos1 + 50];\n      }\n      set hidden(t) {\n        this._structArray.uint8[this._pos1 + 50] = t;\n      }\n      get crossTileID() {\n        return this._structArray.uint32[this._pos4 + 13];\n      }\n      set crossTileID(t) {\n        this._structArray.uint32[this._pos4 + 13] = t;\n      }\n      get associatedIconIndex() {\n        return this._structArray.int16[this._pos2 + 28];\n      }\n      get flipState() {\n        return this._structArray.uint8[this._pos1 + 58];\n      }\n      set flipState(t) {\n        this._structArray.uint8[this._pos1 + 58] = t;\n      }\n    }\n    io.prototype.size = 60;\n    class so extends qa {\n      get(t) {\n        return new io(this, t);\n      }\n    }\n    us(so, \"PlacedSymbolArray\");\n    class ao extends ga {\n      get tileAnchorX() {\n        return this._structArray.float32[this._pos4 + 0];\n      }\n      get tileAnchorY() {\n        return this._structArray.float32[this._pos4 + 1];\n      }\n      get projectedAnchorX() {\n        return this._structArray.int16[this._pos2 + 4];\n      }\n      get projectedAnchorY() {\n        return this._structArray.int16[this._pos2 + 5];\n      }\n      get projectedAnchorZ() {\n        return this._structArray.int16[this._pos2 + 6];\n      }\n      get rightJustifiedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 7];\n      }\n      get centerJustifiedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 8];\n      }\n      get leftJustifiedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 9];\n      }\n      get verticalPlacedTextSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 10];\n      }\n      get placedIconSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 11];\n      }\n      get verticalPlacedIconSymbolIndex() {\n        return this._structArray.int16[this._pos2 + 12];\n      }\n      get key() {\n        return this._structArray.uint16[this._pos2 + 13];\n      }\n      get textBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 14];\n      }\n      get textBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 15];\n      }\n      get verticalTextBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 16];\n      }\n      get verticalTextBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 17];\n      }\n      get iconBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 18];\n      }\n      get iconBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 19];\n      }\n      get verticalIconBoxStartIndex() {\n        return this._structArray.uint16[this._pos2 + 20];\n      }\n      get verticalIconBoxEndIndex() {\n        return this._structArray.uint16[this._pos2 + 21];\n      }\n      get featureIndex() {\n        return this._structArray.uint16[this._pos2 + 22];\n      }\n      get numHorizontalGlyphVertices() {\n        return this._structArray.uint16[this._pos2 + 23];\n      }\n      get numVerticalGlyphVertices() {\n        return this._structArray.uint16[this._pos2 + 24];\n      }\n      get numIconVertices() {\n        return this._structArray.uint16[this._pos2 + 25];\n      }\n      get numVerticalIconVertices() {\n        return this._structArray.uint16[this._pos2 + 26];\n      }\n      get useRuntimeCollisionCircles() {\n        return this._structArray.uint16[this._pos2 + 27];\n      }\n      get crossTileID() {\n        return this._structArray.uint32[this._pos4 + 14];\n      }\n      set crossTileID(t) {\n        this._structArray.uint32[this._pos4 + 14] = t;\n      }\n      get textOffset0() {\n        return this._structArray.float32[this._pos4 + 15];\n      }\n      get textOffset1() {\n        return this._structArray.float32[this._pos4 + 16];\n      }\n      get collisionCircleDiameter() {\n        return this._structArray.float32[this._pos4 + 17];\n      }\n      get zOffset() {\n        return this._structArray.float32[this._pos4 + 18];\n      }\n      set zOffset(t) {\n        this._structArray.float32[this._pos4 + 18] = t;\n      }\n      get hasIconTextFit() {\n        return this._structArray.uint8[this._pos1 + 76];\n      }\n      get elevationFeatureIndex() {\n        return this._structArray.uint16[this._pos2 + 39];\n      }\n    }\n    ao.prototype.size = 80;\n    class oo extends $a {\n      get(t) {\n        return new ao(this, t);\n      }\n    }\n    us(oo, \"SymbolInstanceArray\");\n    class lo extends Aa {\n      getoffsetX(t) {\n        return this.float32[1 * t + 0];\n      }\n    }\n    us(lo, \"GlyphOffsetArray\");\n    class uo extends _a {\n      getx(t) {\n        return this.int16[2 * t + 0];\n      }\n      gety(t) {\n        return this.int16[2 * t + 1];\n      }\n    }\n    us(uo, \"SymbolLineVertexArray\");\n    class co extends ga {\n      get featureIndex() {\n        return this._structArray.uint32[this._pos4 + 0];\n      }\n      get sourceLayerIndex() {\n        return this._structArray.uint16[this._pos2 + 2];\n      }\n      get bucketIndex() {\n        return this._structArray.uint16[this._pos2 + 3];\n      }\n      get layoutVertexArrayOffset() {\n        return this._structArray.uint16[this._pos2 + 4];\n      }\n    }\n    co.prototype.size = 12;\n    class ho extends Wa {\n      get(t) {\n        return new co(this, t);\n      }\n    }\n    us(ho, \"FeatureIndexArray\");\n    class po extends La {\n      geta_centroid_pos0(t) {\n        return this.uint16[2 * t + 0];\n      }\n      geta_centroid_pos1(t) {\n        return this.uint16[2 * t + 1];\n      }\n    }\n    us(po, \"FillExtrusionCentroidArray\");\n    class fo extends ga {\n      get a_join_normal_inside0() {\n        return this._structArray.int16[this._pos2 + 0];\n      }\n      get a_join_normal_inside1() {\n        return this._structArray.int16[this._pos2 + 1];\n      }\n      get a_join_normal_inside2() {\n        return this._structArray.int16[this._pos2 + 2];\n      }\n    }\n    fo.prototype.size = 6;\n    class mo extends wa {\n      get(t) {\n        return new fo(this, t);\n      }\n    }\n    us(mo, \"FillExtrusionWallArray\");\n    const yo = va([{\n        name: \"a_pos\",\n        components: 2,\n        type: \"Int16\"\n      }], 4),\n      go = va([{\n        name: \"a_pos_3\",\n        components: 3,\n        type: \"Int16\"\n      }, {\n        name: \"a_pos_normal_3\",\n        components: 3,\n        type: \"Int16\"\n      }]);\n    class xo {\n      constructor(t = []) {\n        this.segments = t;\n      }\n      _prepareSegment(t, e, r, n) {\n        let i = this.segments[this.segments.length - 1];\n        return t > xo.MAX_VERTEX_ARRAY_LENGTH && pt(`Max vertices per segment is ${xo.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`), (!i || i.vertexLength + t > xo.MAX_VERTEX_ARRAY_LENGTH || i.sortKey !== n) && (i = {\n          vertexOffset: e,\n          primitiveOffset: r,\n          vertexLength: 0,\n          primitiveLength: 0\n        }, void 0 !== n && (i.sortKey = n), this.segments.push(i)), i;\n      }\n      prepareSegment(t, e, r, n) {\n        return this._prepareSegment(t, e.length, r.length, n);\n      }\n      get() {\n        return this.segments;\n      }\n      destroy() {\n        for (const t of this.segments) for (const e in t.vaos) t.vaos[e].destroy();\n      }\n      static simpleSegment(t, e, r, n) {\n        return new xo([{\n          vertexOffset: t,\n          primitiveOffset: e,\n          vertexLength: r,\n          primitiveLength: n,\n          vaos: {},\n          sortKey: 0\n        }]);\n      }\n    }\n    function vo(t, e) {\n      return 256 * (t = Q(Math.floor(t), 0, 255)) + Q(Math.floor(e), 0, 255);\n    }\n    xo.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, us(xo, \"SegmentVector\");\n    const bo = va([{\n        name: \"a_pattern\",\n        components: 4,\n        type: \"Uint16\"\n      }, {\n        name: \"a_pixel_ratio\",\n        components: 1,\n        type: \"Float32\"\n      }]),\n      _o = va([{\n        name: \"a_dash\",\n        components: 4,\n        type: \"Uint16\"\n      }]);\n    class wo {\n      constructor() {\n        this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = !1;\n      }\n      add(t, e, r, n) {\n        this.ids.push(Mo(t)), this.positions.push(e, r, n);\n      }\n      eachPosition(t, e) {\n        const r = Mo(t);\n        let n = 0,\n          i = this.ids.length - 1;\n        for (; n < i;) {\n          const t = n + i >> 1;\n          this.ids[t] >= r ? i = t : n = t + 1;\n        }\n        for (; this.ids[n] === r;) e(this.positions[3 * n], this.positions[3 * n + 1], this.positions[3 * n + 2]), n++;\n      }\n      static serialize(t, e) {\n        const r = new Float64Array(t.ids),\n          n = new Uint32Array(t.positions);\n        return Ao(r, n, 0, r.length - 1), e && (e.add(r.buffer), e.add(n.buffer)), {\n          ids: r,\n          positions: n\n        };\n      }\n      static deserialize(t) {\n        const e = new wo();\n        let r;\n        e.ids = t.ids, e.positions = t.positions;\n        for (const t of e.ids) t !== r && e.uniqueIds.push(t), r = t;\n        return e.indexed = !0, e;\n      }\n    }\n    function Mo(t) {\n      const e = +t;\n      return !isNaN(e) && Number.MIN_SAFE_INTEGER <= e && e <= Number.MAX_SAFE_INTEGER ? e : ye(String(t));\n    }\n    function Ao(t, e, r, n) {\n      for (; r < n;) {\n        const i = t[r + n >> 1];\n        let s = r - 1,\n          a = n + 1;\n        for (;;) {\n          do {\n            s++;\n          } while (t[s] < i);\n          do {\n            a--;\n          } while (t[a] > i);\n          if (s >= a) break;\n          Io(t, s, a), Io(e, 3 * s, 3 * a), Io(e, 3 * s + 1, 3 * a + 1), Io(e, 3 * s + 2, 3 * a + 2);\n        }\n        a - r < n - a ? (Ao(t, e, r, a), r = a + 1) : (Ao(t, e, a + 1, n), n = a);\n      }\n    }\n    function Io(t, e, r) {\n      const n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n    us(wo, \"FeaturePositionMap\");\n    class So {\n      constructor(t) {\n        this.gl = t.gl, this.initialized = !1;\n      }\n      fetchUniformLocation(t, e) {\n        return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t, e), this.initialized = !0), !!this.location;\n      }\n      set(t, e, r) {\n        throw new Error(\"Uniform#set() must be implemented by each concrete Uniform\");\n      }\n    }\n    class Po extends So {\n      constructor(t) {\n        super(t), this.current = 0;\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && this.current !== r && (this.current = r, this.gl.uniform1i(this.location, r));\n      }\n    }\n    class Eo extends So {\n      constructor(t) {\n        super(t), this.current = 0;\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && this.current !== r && (this.current = r, this.gl.uniform1f(this.location, r));\n      }\n    }\n    class zo extends So {\n      constructor(t) {\n        super(t), this.current = [0, 0];\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] || (this.current = r, this.gl.uniform2f(this.location, r[0], r[1])));\n      }\n    }\n    class ko extends So {\n      constructor(t) {\n        super(t), this.current = [0, 0, 0];\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] || (this.current = r, this.gl.uniform3f(this.location, r[0], r[1], r[2])));\n      }\n    }\n    class To extends So {\n      constructor(t) {\n        super(t), this.current = [0, 0, 0, 0];\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && (r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] && r[3] === this.current[3] || (this.current = r, this.gl.uniform4f(this.location, r[0], r[1], r[2], r[3])));\n      }\n    }\n    class Bo extends So {\n      constructor(t) {\n        super(t), this.current = Se.transparent.toRenderColor(null);\n      }\n      set(t, e, r) {\n        this.fetchUniformLocation(t, e) && (r.r === this.current.r && r.g === this.current.g && r.b === this.current.b && r.a === this.current.a || (this.current = r, this.gl.uniform4f(this.location, r.r, r.g, r.b, r.a)));\n      }\n    }\n    const Vo = new Float32Array(16);\n    class Co extends So {\n      constructor(t) {\n        super(t), this.current = Vo;\n      }\n      set(t, e, r) {\n        if (this.fetchUniformLocation(t, e)) {\n          if (r[12] !== this.current[12] || r[0] !== this.current[0]) return this.current = r, void this.gl.uniformMatrix4fv(this.location, !1, r);\n          for (let t = 1; t < 16; t++) if (r[t] !== this.current[t]) {\n            this.current = r, this.gl.uniformMatrix4fv(this.location, !1, r);\n            break;\n          }\n        }\n      }\n    }\n    const Do = new Float32Array(9),\n      Ro = new Float32Array(4);\n    class Lo extends So {\n      constructor(t) {\n        super(t), this.current = Ro;\n      }\n      set(t, e, r) {\n        if (this.fetchUniformLocation(t, e)) for (let t = 0; t < 4; t++) if (r[t] !== this.current[t]) {\n          this.current = r, this.gl.uniformMatrix2fv(this.location, !1, r);\n          break;\n        }\n      }\n    }\n    function Fo(t) {\n      return [vo(255 * t.r, 255 * t.g), vo(255 * t.b, 255 * t.a)];\n    }\n    class Oo {\n      constructor(t, e, r, n) {\n        this.value = t, this.uniformNames = e.map(t => `u_${t}`), this.type = r, this.context = n;\n      }\n      setUniform(t, e, r, n, i) {\n        const s = n.constantOr(this.value);\n        e.set(t, i, s instanceof Se ? s.toRenderColor(this.lutExpression && \"none\" === this.lutExpression.value ? null : this.context.lut) : s);\n      }\n      getBinding(t, e) {\n        return \"color\" === this.type ? new Bo(t) : new Eo(t);\n      }\n    }\n    class No {\n      constructor(t, e) {\n        this.uniformNames = e.map(t => `u_${t}`), this.pattern = null, this.pixelRatio = 1;\n      }\n      setConstantPatternPositions(t) {\n        this.pixelRatio = t.pixelRatio || 1, this.pattern = t.tl.concat(t.br);\n      }\n      setUniform(t, e, r, n, i) {\n        const s = \"u_pattern\" === i || \"u_dash\" === i ? this.pattern : \"u_pixel_ratio\" === i ? this.pixelRatio : null;\n        s && e.set(t, i, s);\n      }\n      getBinding(t, e) {\n        return \"u_pattern\" === e || \"u_dash\" === e ? new To(t) : new Eo(t);\n      }\n    }\n    class Uo {\n      constructor(t, e, r, n) {\n        this.expression = t, this.type = r, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({\n          name: `a_${t}`,\n          type: \"Float32\",\n          components: \"color\" === r ? 2 : 1,\n          offset: 0\n        })), this.paintVertexArray = new n();\n      }\n      populatePaintArray(t, e, r, n, i, s, a) {\n        const o = this.paintVertexArray.length,\n          l = \"composite\" === this.expression.kind || \"source\" === this.expression.kind ? this.expression.evaluate(new Rs(0, {\n            brightness: s\n          }), e, {}, i, n, a) : \"constant\" === this.expression.kind && this.expression.value,\n          u = !!this.lutExpression && \"none\" === (\"composite\" === this.lutExpression.kind || \"source\" === this.lutExpression.kind ? this.lutExpression.evaluate(new Rs(0, {\n            brightness: s\n          }), e, {}, i, n, a) : this.lutExpression.value);\n        this.paintVertexArray.resize(t), this._setPaintValue(o, t, l, u ? null : this.context.lut);\n      }\n      updatePaintArray(t, e, r, n, i, s, a) {\n        const o = \"composite\" === this.expression.kind || \"source\" === this.expression.kind ? this.expression.evaluate({\n            zoom: 0,\n            brightness: a\n          }, r, n, void 0, i) : \"constant\" === this.expression.kind && this.expression.value,\n          l = !!this.lutExpression && \"none\" === (\"composite\" === this.lutExpression.kind || \"source\" === this.lutExpression.kind ? this.lutExpression.evaluate(new Rs(0, {\n            brightness: a\n          }), r, n, void 0, i) : this.lutExpression.value);\n        this._setPaintValue(t, e, o, l ? null : this.context.lut);\n      }\n      _setPaintValue(t, e, r, n) {\n        if (\"color\" === this.type) {\n          const i = Fo(r.toRenderColor(n));\n          for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, i[0], i[1]);\n        } else {\n          for (let n = t; n < e; n++) this.paintVertexArray.emplace(n, r);\n          this.maxValue = Math.max(this.maxValue, Math.abs(r));\n        }\n      }\n      upload(t) {\n        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.lutExpression && \"constant\" !== this.lutExpression.kind && (this.lutExpression.isStateDependent || !this.lutExpression.isLightConstant) || \"constant\" !== this.expression.kind && (this.expression.isStateDependent || !this.expression.isLightConstant)));\n      }\n      destroy() {\n        this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n      }\n    }\n    class jo {\n      constructor(t, e, r, n, i, s) {\n        this.expression = t, this.uniformNames = e.map(t => `u_${t}_t`), this.type = r, this.useIntegerZoom = n, this.context = i, this.maxValue = 0, this.paintVertexAttributes = e.map(t => ({\n          name: `a_${t}`,\n          type: \"Float32\",\n          components: \"color\" === r ? 4 : 2,\n          offset: 0\n        })), this.paintVertexArray = new s();\n      }\n      populatePaintArray(t, e, r, n, i, s, a) {\n        const o = this.expression.evaluate(new Rs(this.context.zoom, {\n            brightness: s\n          }), e, {}, i, n, a),\n          l = this.expression.evaluate(new Rs(this.context.zoom + 1, {\n            brightness: s\n          }), e, {}, i, n, a),\n          u = !!this.lutExpression && \"none\" === (\"composite\" === this.lutExpression.kind || \"source\" === this.lutExpression.kind ? this.lutExpression.evaluate(new Rs(0, {\n            brightness: s\n          }), e, {}, i, n, a) : this.lutExpression.value),\n          c = this.paintVertexArray.length;\n        this.paintVertexArray.resize(t), this._setPaintValue(c, t, o, l, u ? null : this.context.lut);\n      }\n      updatePaintArray(t, e, r, n, i, s, a) {\n        const o = this.expression.evaluate({\n            zoom: this.context.zoom,\n            brightness: a\n          }, r, n, void 0, i),\n          l = this.expression.evaluate({\n            zoom: this.context.zoom + 1,\n            brightness: a\n          }, r, n, void 0, i),\n          u = !!this.lutExpression && \"none\" === (\"composite\" === this.lutExpression.kind || \"source\" === this.lutExpression.kind ? this.lutExpression.evaluate(new Rs(0, {\n            brightness: a\n          }), r, n, void 0, i) : this.lutExpression.value);\n        this._setPaintValue(t, e, o, l, u ? null : this.context.lut);\n      }\n      _setPaintValue(t, e, r, n, i) {\n        if (\"color\" === this.type) {\n          const n = Fo(r.toRenderColor(i)),\n            s = Fo(r.toRenderColor(i));\n          for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, n[0], n[1], s[0], s[1]);\n        } else {\n          for (let i = t; i < e; i++) this.paintVertexArray.emplace(i, r, n);\n          this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));\n        }\n      }\n      upload(t) {\n        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));\n      }\n      destroy() {\n        this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n      }\n      setUniform(t, e, r, n, i) {\n        const s = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom,\n          a = Q(this.expression.interpolationFactor(s, this.context.zoom, this.context.zoom + 1), 0, 1);\n        e.set(t, i, a);\n      }\n      getBinding(t, e) {\n        return new Eo(t);\n      }\n    }\n    class qo {\n      constructor(t, e, r, n, i) {\n        this.expression = t, this.layerId = i, this.paintVertexAttributes = (\"array\" === r ? _o : bo).members;\n        for (let t = 0; t < e.length; ++t);\n        this.paintVertexArray = new n();\n      }\n      populatePaintArray(t, e, r, n) {\n        const i = this.paintVertexArray.length;\n        this.paintVertexArray.resize(t), this._setPaintValues(i, t, e.patterns && e.patterns[this.layerId], r);\n      }\n      updatePaintArray(t, e, r, n, i, s, a) {\n        this._setPaintValues(t, e, r.patterns && r.patterns[this.layerId], s);\n      }\n      _setPaintValues(t, e, r, n) {\n        if (!n || !r) return;\n        const i = n[r];\n        if (!i) return;\n        const {\n          tl: s,\n          br: a,\n          pixelRatio: o\n        } = i;\n        for (let r = t; r < e; r++) this.paintVertexArray.emplace(r, s[0], s[1], a[0], a[1], o);\n      }\n      upload(t) {\n        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));\n      }\n      destroy() {\n        this.paintVertexBuffer && this.paintVertexBuffer.destroy();\n      }\n    }\n    class $o {\n      constructor(t, e, r = () => !0) {\n        this.binders = {}, this._buffers = [], this.context = e;\n        const n = [];\n        for (const i in t.paint._values) {\n          const s = t.paint.get(i);\n          if (i.endsWith(\"-use-theme\")) continue;\n          if (!r(i)) continue;\n          if (!(s instanceof qs && Fi(s.property.specification))) continue;\n          const a = Ho(i, t.type),\n            o = s.value,\n            l = s.property.specification.type,\n            u = !!s.property.useIntegerZoom,\n            c = \"line-dasharray\" === i || i.endsWith(\"pattern\"),\n            h = t.paint.get(`${i}-use-theme`),\n            p = \"line-dasharray\" === i && \"constant\" !== t.layout.get(\"line-cap\").value.kind || h && \"constant\" !== h.value.kind;\n          if (\"constant\" !== o.kind || p) {\n            if (\"source\" === o.kind || p || c) {\n              const e = Wo(i, l, \"source\");\n              this.binders[i] = c ? new qo(o, a, l, e, t.id) : new Uo(o, a, l, e), n.push(`/a_${i}`);\n            } else {\n              const t = Wo(i, l, \"composite\");\n              this.binders[i] = new jo(o, a, l, u, e, t), n.push(`/z_${i}`);\n            }\n          } else this.binders[i] = c ? new No(o.value, a) : new Oo(o.value, a, l, e), n.push(`/u_${i}`);\n          h && (this.binders[i].lutExpression = h.value);\n        }\n        this.cacheKey = n.sort().join(\"\");\n      }\n      getMaxValue(t) {\n        const e = this.binders[t];\n        return e instanceof Uo || e instanceof jo ? e.maxValue : 0;\n      }\n      populatePaintArrays(t, e, r, n, i, s, a) {\n        for (const o in this.binders) {\n          const l = this.binders[o];\n          l.context = this.context, (l instanceof Uo || l instanceof jo || l instanceof qo) && l.populatePaintArray(t, e, r, n, i, s, a);\n        }\n      }\n      setConstantPatternPositions(t) {\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          r instanceof No && r.setConstantPatternPositions(t);\n        }\n      }\n      updatePaintArrays(t, e, r, n, i, s, a, o, l) {\n        let u = !1;\n        const c = Object.keys(t),\n          h = 0 !== c.length && !o,\n          p = h ? c : e.uniqueIds;\n        this.context.lut = i.lut;\n        for (const o in this.binders) {\n          const c = this.binders[o];\n          if (c.context = this.context, (c instanceof Uo || c instanceof jo || c instanceof qo) && c.expression && c.expression.kind && \"constant\" !== c.expression.kind && (!0 === c.expression.isStateDependent || !1 === c.expression.isLightConstant)) {\n            const f = i.paint.get(o);\n            c.expression = f.value;\n            for (const r of p) {\n              const i = t[r.toString()];\n              e.eachPosition(r, (t, e, r) => {\n                const o = n.feature(t);\n                c.updatePaintArray(e, r, o, i, s, a, l);\n              });\n            }\n            if (!h) for (const e of r.uniqueIds) {\n              const i = t[e.toString()];\n              r.eachPosition(e, (t, e, r) => {\n                const o = n.feature(t);\n                c.updatePaintArray(e, r, o, i, s, a, l);\n              });\n            }\n            u = !0;\n          }\n        }\n        return u;\n      }\n      defines() {\n        const t = [];\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          (r instanceof Oo || r instanceof No) && t.push(...r.uniformNames.map(t => `#define HAS_UNIFORM_${t}`));\n        }\n        return t;\n      }\n      getBinderAttributes() {\n        const t = [];\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          if (r instanceof Uo || r instanceof jo || r instanceof qo) for (let e = 0; e < r.paintVertexAttributes.length; e++) t.push(r.paintVertexAttributes[e].name);\n        }\n        return t;\n      }\n      getBinderUniforms() {\n        const t = [];\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          if (r instanceof Oo || r instanceof No || r instanceof jo) for (const e of r.uniformNames) t.push(e);\n        }\n        return t;\n      }\n      getPaintVertexBuffers() {\n        return this._buffers;\n      }\n      getUniforms(t) {\n        const e = [];\n        for (const r in this.binders) {\n          const n = this.binders[r];\n          if (n instanceof Oo || n instanceof No || n instanceof jo) for (const i of n.uniformNames) e.push({\n            name: i,\n            property: r,\n            binding: n.getBinding(t, i)\n          });\n        }\n        return e;\n      }\n      setUniforms(t, e, r, n, i) {\n        for (const {\n          name: e,\n          property: s,\n          binding: a\n        } of r) this.binders[s].setUniform(t, a, i, n.get(s), e);\n      }\n      updatePaintBuffers() {\n        this._buffers = [];\n        for (const t in this.binders) {\n          const e = this.binders[t];\n          (e instanceof Uo || e instanceof jo || e instanceof qo) && e.paintVertexBuffer && this._buffers.push(e.paintVertexBuffer);\n        }\n      }\n      upload(t) {\n        for (const e in this.binders) {\n          const r = this.binders[e];\n          (r instanceof Uo || r instanceof jo || r instanceof qo) && r.upload(t);\n        }\n        this.updatePaintBuffers();\n      }\n      destroy() {\n        for (const t in this.binders) {\n          const e = this.binders[t];\n          (e instanceof Uo || e instanceof jo || e instanceof qo) && e.destroy();\n        }\n      }\n    }\n    class Go {\n      constructor(t, e, r = () => !0) {\n        this.programConfigurations = {};\n        for (const n of t) this.programConfigurations[n.id] = new $o(n, e, r);\n        this.needsUpload = !1, this._featureMap = new wo(), this._featureMapWithoutIds = new wo(), this._bufferOffset = 0, this._idlessCounter = 0;\n      }\n      populatePaintArrays(t, e, r, n, i, s, a, o) {\n        for (const r in this.programConfigurations) this.programConfigurations[r].populatePaintArrays(t, e, n, i, s, a, o);\n        void 0 !== e.id ? this._featureMap.add(e.id, r, this._bufferOffset, t) : (this._featureMapWithoutIds.add(this._idlessCounter, r, this._bufferOffset, t), this._idlessCounter += 1), this._bufferOffset = t, this.needsUpload = !0;\n      }\n      updatePaintArrays(t, e, r, n, i, s, a) {\n        for (const o of r) this.needsUpload = this.programConfigurations[o.id].updatePaintArrays(t, this._featureMap, this._featureMapWithoutIds, e, o, n, i, s, a || 0) || this.needsUpload;\n      }\n      get(t) {\n        return this.programConfigurations[t];\n      }\n      upload(t) {\n        if (this.needsUpload) {\n          for (const e in this.programConfigurations) this.programConfigurations[e].upload(t);\n          this.needsUpload = !1;\n        }\n      }\n      destroy() {\n        for (const t in this.programConfigurations) this.programConfigurations[t].destroy();\n      }\n    }\n    const Yo = {\n      \"text-opacity\": [\"opacity\"],\n      \"icon-opacity\": [\"opacity\"],\n      \"text-occlusion-opacity\": [\"occlusion_opacity\"],\n      \"icon-occlusion-opacity\": [\"occlusion_opacity\"],\n      \"text-color\": [\"fill_color\"],\n      \"icon-color\": [\"fill_color\"],\n      \"text-emissive-strength\": [\"emissive_strength\"],\n      \"icon-emissive-strength\": [\"emissive_strength\"],\n      \"text-halo-color\": [\"halo_color\"],\n      \"icon-halo-color\": [\"halo_color\"],\n      \"text-halo-blur\": [\"halo_blur\"],\n      \"icon-halo-blur\": [\"halo_blur\"],\n      \"text-halo-width\": [\"halo_width\"],\n      \"icon-halo-width\": [\"halo_width\"],\n      \"symbol-z-offset\": [\"z_offset\"],\n      \"line-gap-width\": [\"gapwidth\"],\n      \"line-pattern\": [\"pattern\", \"pixel_ratio\"],\n      \"fill-pattern\": [\"pattern\", \"pixel_ratio\"],\n      \"fill-extrusion-pattern\": [\"pattern\", \"pixel_ratio\"],\n      \"line-dasharray\": [\"dash\"]\n    };\n    function Ho(t, e) {\n      return Yo[t] || [t.replace(`${e}-`, \"\").replace(/-/g, \"_\")];\n    }\n    const Xo = {\n        \"line-pattern\": {\n          source: ka,\n          composite: ka\n        },\n        \"fill-pattern\": {\n          source: ka,\n          composite: ka\n        },\n        \"fill-extrusion-pattern\": {\n          source: ka,\n          composite: ka\n        },\n        \"line-dasharray\": {\n          source: Ta,\n          composite: Ta\n        }\n      },\n      Zo = {\n        color: {\n          source: Za,\n          composite: Da\n        },\n        number: {\n          source: Aa,\n          composite: Za\n        }\n      };\n    function Wo(t, e, r) {\n      const n = Xo[t];\n      return n && n[r] || Zo[e][r];\n    }\n    us(Oo, \"ConstantBinder\"), us(No, \"PatternConstantBinder\"), us(Uo, \"SourceExpressionBinder\"), us(qo, \"PatternCompositeBinder\"), us(jo, \"CompositeExpressionBinder\"), us($o, \"ProgramConfiguration\", {\n      omit: [\"_buffers\"]\n    }), us(Go, \"ProgramConfigurationSet\");\n    const Ko = Kr / Math.PI / 2,\n      Jo = 5,\n      Qo = 6,\n      tl = 16383,\n      el = 64,\n      rl = [el, 32, 16],\n      nl = -Ko,\n      il = Ko;\n    function sl(t, e, r, n = Ko) {\n      return r = H(r), [t * Math.sin(r) * n, -e * n, t * Math.cos(r) * n];\n    }\n    function al(t, e, r) {\n      return sl(Math.cos(H(t)), Math.sin(H(t)), e, r);\n    }\n    const ol = 6371008.8,\n      ll = 2 * Math.PI * ol;\n    class ul {\n      constructor(t, e) {\n        if (isNaN(t) || isNaN(e)) throw new Error(`Invalid LngLat object: (${t}, ${e})`);\n        if (this.lng = +t, this.lat = +e, this.lat > 90 || this.lat < -90) throw new Error(\"Invalid LngLat latitude value: must be between -90 and 90\");\n      }\n      wrap() {\n        return new ul(et(this.lng, -180, 180), this.lat);\n      }\n      toArray() {\n        return [this.lng, this.lat];\n      }\n      toString() {\n        return `LngLat(${this.lng}, ${this.lat})`;\n      }\n      distanceTo(t) {\n        const e = Math.PI / 180,\n          r = this.lat * e,\n          n = t.lat * e,\n          i = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t.lng - this.lng) * e);\n        return ol * Math.acos(Math.min(i, 1));\n      }\n      toBounds(t = 0) {\n        const e = 360 * t / 40075017,\n          r = e / Math.cos(Math.PI / 180 * this.lat);\n        return new cl({\n          lng: this.lng - r,\n          lat: this.lat - e\n        }, {\n          lng: this.lng + r,\n          lat: this.lat + e\n        });\n      }\n      toEcef(t) {\n        return al(this.lat, this.lng, Ko + t * Ko / ol);\n      }\n      static convert(t) {\n        if (t instanceof ul) return t;\n        if (Array.isArray(t) && (2 === t.length || 3 === t.length)) return new ul(Number(t[0]), Number(t[1]));\n        if (!Array.isArray(t) && \"object\" == typeof t && null !== t) return new ul(Number(\"lng\" in t ? t.lng : t.lon), Number(t.lat));\n        throw new Error(\"`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]\");\n      }\n    }\n    class cl {\n      constructor(t, e) {\n        if (t) if (e) this.setSouthWest(t).setNorthEast(e);else if (4 === t.length) {\n          const e = t;\n          this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]);\n        } else {\n          const e = t;\n          this.setSouthWest(e[0]).setNorthEast(e[1]);\n        }\n      }\n      setNorthEast(t) {\n        return this._ne = t instanceof ul ? new ul(t.lng, t.lat) : ul.convert(t), this;\n      }\n      setSouthWest(t) {\n        return this._sw = t instanceof ul ? new ul(t.lng, t.lat) : ul.convert(t), this;\n      }\n      extend(t) {\n        const e = this._sw,\n          r = this._ne;\n        let n, i;\n        if (t instanceof ul) n = t, i = t;else {\n          if (!(t instanceof cl)) return Array.isArray(t) ? 4 === t.length || t.every(Array.isArray) ? this.extend(cl.convert(t)) : this.extend(ul.convert(t)) : \"object\" == typeof t && null !== t && t.hasOwnProperty(\"lat\") && (t.hasOwnProperty(\"lon\") || t.hasOwnProperty(\"lng\")) ? this.extend(ul.convert(t)) : this;\n          if (n = t._sw, i = t._ne, !n || !i) return this;\n        }\n        return e || r ? (e.lng = Math.min(n.lng, e.lng), e.lat = Math.min(n.lat, e.lat), r.lng = Math.max(i.lng, r.lng), r.lat = Math.max(i.lat, r.lat)) : (this._sw = new ul(n.lng, n.lat), this._ne = new ul(i.lng, i.lat)), this;\n      }\n      getCenter() {\n        return new ul((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);\n      }\n      getSouthWest() {\n        return this._sw;\n      }\n      getNorthEast() {\n        return this._ne;\n      }\n      getNorthWest() {\n        return new ul(this.getWest(), this.getNorth());\n      }\n      getSouthEast() {\n        return new ul(this.getEast(), this.getSouth());\n      }\n      getWest() {\n        return this._sw.lng;\n      }\n      getSouth() {\n        return this._sw.lat;\n      }\n      getEast() {\n        return this._ne.lng;\n      }\n      getNorth() {\n        return this._ne.lat;\n      }\n      toArray() {\n        return [this._sw.toArray(), this._ne.toArray()];\n      }\n      toString() {\n        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n      }\n      isEmpty() {\n        return !(this._sw && this._ne);\n      }\n      contains(t) {\n        const {\n          lng: e,\n          lat: r\n        } = ul.convert(t);\n        let n = this._sw.lng <= e && e <= this._ne.lng;\n        return this._sw.lng > this._ne.lng && (n = this._sw.lng >= e && e >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n;\n      }\n      static convert(t) {\n        if (t) return t instanceof cl ? t : new cl(t);\n      }\n    }\n    const hl = 0,\n      pl = 25.5;\n    function fl(t) {\n      return ll * Math.cos(t * Math.PI / 180);\n    }\n    function dl(t) {\n      return (180 + t) / 360;\n    }\n    function ml(t) {\n      return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t * Math.PI / 360))) / 360;\n    }\n    function yl(t, e) {\n      return t / fl(e);\n    }\n    function gl(t) {\n      return 360 * t - 180;\n    }\n    function xl(t) {\n      return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t) * Math.PI / 180)) - 90;\n    }\n    function vl(t, e) {\n      return t * fl(xl(e));\n    }\n    const bl = 85.051129;\n    function _l(t) {\n      return Math.cos(H(Q(t, -bl, bl)));\n    }\n    function wl(t, e) {\n      const r = Q(e, hl, pl),\n        n = Math.pow(2, r);\n      return _l(t) * ll / (512 * n);\n    }\n    function Ml(t) {\n      return 1 / Math.cos(t * Math.PI / 180);\n    }\n    function Al(t, e = 0) {\n      const r = Math.exp(Math.PI * (1 - (t.y + e / Kr) / (1 << t.z) * 2));\n      return 80150034 * r / (r * r + 1) / Kr / (1 << t.z);\n    }\n    class Il {\n      constructor(t, e, r = 0) {\n        this.x = +t, this.y = +e, this.z = +r;\n      }\n      static fromLngLat(t, e = 0) {\n        const r = ul.convert(t);\n        return new Il(dl(r.lng), ml(r.lat), yl(e, r.lat));\n      }\n      toLngLat() {\n        return new ul(gl(this.x), xl(this.y));\n      }\n      toAltitude() {\n        return vl(this.z, this.y);\n      }\n      meterInMercatorCoordinateUnits() {\n        return 1 / ll * Ml(xl(this.y));\n      }\n    }\n    function Sl(t, e, r, n, i, s, a, o, l) {\n      const u = (e + n) / 2,\n        c = (r + i) / 2,\n        h = new q(u, c);\n      o(h), function (t, e, r, n, i, s) {\n        const a = r - i,\n          o = n - s;\n        return Math.abs((n - e) * a - (r - t) * o) / Math.hypot(a, o);\n      }(h.x, h.y, s.x, s.y, a.x, a.y) >= l ? (Sl(t, e, r, u, c, s, h, o, l), Sl(t, u, c, n, i, h, a, o, l)) : t.push(a);\n    }\n    function Pl(t, e, r) {\n      let n = t[0],\n        i = n.x,\n        s = n.y;\n      e(n);\n      const a = [n];\n      for (let o = 1; o < t.length; o++) {\n        const l = t[o],\n          {\n            x: u,\n            y: c\n          } = l;\n        e(l), Sl(a, i, s, u, c, n, l, e, r), i = u, s = c, n = l;\n      }\n      return a;\n    }\n    function El(t, e, r, n) {\n      if (n(e, r)) {\n        const i = e.add(r)._mult(.5);\n        El(t, e, i, n), El(t, i, r, n);\n      } else t.push(r);\n    }\n    function zl(t, e) {\n      let r = t[0];\n      const n = [r];\n      for (let i = 1; i < t.length; i++) {\n        const s = t[i];\n        El(n, r, s, e), r = s;\n      }\n      return n;\n    }\n    const kl = Math.pow(2, 14) - 1,\n      Tl = -kl - 1;\n    function Bl(t, e) {\n      const r = Math.round(t.x * e),\n        n = Math.round(t.y * e);\n      return t.x = Q(r, Tl, kl), t.y = Q(n, Tl, kl), (r < t.x || r > t.x + 1 || n < t.y || n > t.y + 1) && pt(\"Geometry exceeds allowed extent, reduce your vector tile buffer size\"), t;\n    }\n    function Vl(t, e, r) {\n      const n = t.loadGeometry(),\n        i = t.extent,\n        s = Kr / i;\n      if (e && r && r.projection.isReprojectedInTileSpace) {\n        const s = 1 << e.z,\n          {\n            scale: a,\n            x: o,\n            y: l,\n            projection: u\n          } = r,\n          c = t => {\n            const r = gl((e.x + t.x / i) / s),\n              n = xl((e.y + t.y / i) / s),\n              c = u.project(r, n);\n            t.x = (c.x * a - o) * i, t.y = (c.y * a - l) * i;\n          };\n        for (let e = 0; e < n.length; e++) if (1 !== t.type) n[e] = Pl(n[e], c, 1);else {\n          const t = [];\n          for (const r of n[e]) r.x < 0 || r.x >= i || r.y < 0 || r.y >= i || (c(r), t.push(r));\n          n[e] = t;\n        }\n      }\n      for (const t of n) for (const e of t) Bl(e, s);\n      return n;\n    }\n    function Cl(t, e) {\n      return {\n        type: t.type,\n        id: t.id,\n        properties: t.properties,\n        geometry: e ? Vl(t) : []\n      };\n    }\n    function Dl(t, e, r, n, i) {\n      t.emplaceBack(2 * e + (n + 1) / 2, 2 * r + (i + 1) / 2);\n    }\n    function Rl(t, e, r) {\n      const n = 16384;\n      t.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);\n    }\n    class Ll {\n      constructor(t) {\n        this.zoom = t.zoom, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.fqid), this.index = t.index, this.hasPattern = !1, this.projection = t.projection, this.layoutVertexArray = new _a(), this.indexArray = new ja(), this.segments = new xo(), this.programConfigurations = new Go(t.layers, {\n          zoom: t.zoom,\n          lut: t.lut\n        }), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id);\n      }\n      updateFootprints(t, e) {}\n      populate(t, e, r, n) {\n        const i = this.layers[0],\n          s = [];\n        let a = null;\n        \"circle\" === i.type && (a = i.layout.get(\"circle-sort-key\"));\n        for (const {\n          feature: e,\n          id: i,\n          index: o,\n          sourceLayerIndex: l\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n            u = Cl(e, t);\n          if (!this.layers[0]._featureFilter.filter(new Rs(this.zoom), u, r)) continue;\n          const c = a ? a.evaluate(u, {}, r) : void 0,\n            h = {\n              id: i,\n              properties: e.properties,\n              type: e.type,\n              sourceLayerIndex: l,\n              index: o,\n              geometry: t ? u.geometry : Vl(e, r, n),\n              patterns: {},\n              sortKey: c\n            };\n          s.push(h);\n        }\n        a && s.sort((t, e) => t.sortKey - e.sortKey);\n        let o = null;\n        \"globe\" === n.projection.name && (this.globeExtVertexArray = new Ba(), o = n.projection);\n        for (const n of s) {\n          const {\n              geometry: i,\n              index: s,\n              sourceLayerIndex: a\n            } = n,\n            l = t[s].feature;\n          this.addFeature(n, i, s, e.availableImages, r, o, e.brightness), e.featureIndex.insert(l, i, s, a, this.index);\n        }\n      }\n      update(t, e, r, n, i, s, a) {\n        this.programConfigurations.updatePaintArrays(t, e, i, r, n, s, a);\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, yo.members), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, go.members))), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());\n      }\n      addFeature(t, e, r, n, i, s, a) {\n        for (const r of e) for (const e of r) {\n          const r = e.x,\n            n = e.y;\n          if (r < 0 || r >= Kr || n < 0 || n >= Kr) continue;\n          if (s) {\n            const t = s.projectTilePoint(r, n, i),\n              e = s.upVector(i, r, n),\n              a = this.globeExtVertexArray;\n            Rl(a, t, e), Rl(a, t, e), Rl(a, t, e), Rl(a, t, e);\n          }\n          const a = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey),\n            o = a.vertexLength;\n          Dl(this.layoutVertexArray, r, n, -1, -1), Dl(this.layoutVertexArray, r, n, 1, -1), Dl(this.layoutVertexArray, r, n, 1, 1), Dl(this.layoutVertexArray, r, n, -1, 1), this.indexArray.emplaceBack(o, o + 1, o + 2), this.indexArray.emplaceBack(o, o + 2, o + 3), a.vertexLength += 4, a.primitiveLength += 2;\n        }\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, {}, n, i, a);\n      }\n    }\n    function Fl(t, e) {\n      for (let r = 0; r < t.length; r++) if (Hl(e, t[r])) return !0;\n      for (let r = 0; r < e.length; r++) if (Hl(t, e[r])) return !0;\n      return !!jl(t, e);\n    }\n    function Ol(t, e, r) {\n      return !!Hl(t, e) || !!$l(e, t, r);\n    }\n    function Nl(t, e) {\n      if (1 === t.length) return Yl(e, t[0]);\n      for (let r = 0; r < e.length; r++) {\n        const n = e[r];\n        for (let e = 0; e < n.length; e++) if (Hl(t, n[e])) return !0;\n      }\n      for (let r = 0; r < t.length; r++) if (Yl(e, t[r])) return !0;\n      for (let r = 0; r < e.length; r++) if (jl(t, e[r])) return !0;\n      return !1;\n    }\n    function Ul(t, e, r) {\n      if (t.length > 1) {\n        if (jl(t, e)) return !0;\n        for (let n = 0; n < e.length; n++) if ($l(e[n], t, r)) return !0;\n      }\n      for (let n = 0; n < t.length; n++) if ($l(t[n], e, r)) return !0;\n      return !1;\n    }\n    function jl(t, e) {\n      if (0 === t.length || 0 === e.length) return !1;\n      for (let r = 0; r < t.length - 1; r++) {\n        const n = t[r],\n          i = t[r + 1];\n        for (let t = 0; t < e.length - 1; t++) if (ql(n, i, e[t], e[t + 1])) return !0;\n      }\n      return !1;\n    }\n    function ql(t, e, r, n) {\n      return ft(t, r, n) !== ft(e, r, n) && ft(t, e, r) !== ft(t, e, n);\n    }\n    function $l(t, e, r) {\n      const n = r * r;\n      if (1 === e.length) return t.distSqr(e[0]) < n;\n      for (let r = 1; r < e.length; r++) if (Gl(t, e[r - 1], e[r]) < n) return !0;\n      return !1;\n    }\n    function Gl(t, e, r) {\n      const n = e.distSqr(r);\n      if (0 === n) return t.distSqr(e);\n      const i = ((t.x - e.x) * (r.x - e.x) + (t.y - e.y) * (r.y - e.y)) / n;\n      return t.distSqr(i < 0 ? e : i > 1 ? r : r.sub(e)._mult(i)._add(e));\n    }\n    function Yl(t, e) {\n      let r,\n        n,\n        i,\n        s = !1;\n      for (let a = 0; a < t.length; a++) {\n        r = t[a];\n        for (let t = 0, a = r.length - 1; t < r.length; a = t++) n = r[t], i = r[a], n.y > e.y != i.y > e.y && e.x < (i.x - n.x) * (e.y - n.y) / (i.y - n.y) + n.x && (s = !s);\n      }\n      return s;\n    }\n    function Hl(t, e) {\n      let r = !1;\n      for (let n = 0, i = t.length - 1; n < t.length; i = n++) {\n        const s = t[n],\n          a = t[i];\n        s.y > e.y != a.y > e.y && e.x < (a.x - s.x) * (e.y - s.y) / (a.y - s.y) + s.x && (r = !r);\n      }\n      return r;\n    }\n    function Xl(t, e, r, n, i) {\n      for (const s of t) if (e <= s.x && r <= s.y && n >= s.x && i >= s.y) return !0;\n      const s = [new q(e, r), new q(e, i), new q(n, i), new q(n, r)];\n      if (t.length > 2) for (const e of s) if (Hl(t, e)) return !0;\n      for (let e = 0; e < t.length - 1; e++) if (Zl(t[e], t[e + 1], s)) return !0;\n      return !1;\n    }\n    function Zl(t, e, r) {\n      const n = r[0],\n        i = r[2];\n      if (t.x < n.x && e.x < n.x || t.x > i.x && e.x > i.x || t.y < n.y && e.y < n.y || t.y > i.y && e.y > i.y) return !1;\n      const s = ft(t, e, r[0]);\n      return s !== ft(t, e, r[1]) || s !== ft(t, e, r[2]) || s !== ft(t, e, r[3]);\n    }\n    function Wl(t, e, r, n, i, s) {\n      let a = e.y - t.y,\n        o = t.x - e.x;\n      if (s = s || 0) {\n        const t = a * a + o * o;\n        if (0 === t) return !0;\n        const e = Math.sqrt(t);\n        a /= e, o /= e;\n      }\n      return !((r.x - t.x) * a + (r.y - t.y) * o - s < 0 || (n.x - t.x) * a + (n.y - t.y) * o - s < 0 || (i.x - t.x) * a + (i.y - t.y) * o - s < 0);\n    }\n    function Kl(t, e, r, n, i, s, a) {\n      return !(Wl(t, e, n, i, s, a) || Wl(e, r, n, i, s, a) || Wl(r, t, n, i, s, a) || Wl(n, i, t, e, r, a) || Wl(i, s, t, e, r, a) || Wl(s, n, t, e, r, a));\n    }\n    function Jl(t, e, r) {\n      const n = e.paint.get(t).value;\n      return \"constant\" === n.kind ? n.value : r.programConfigurations.get(e.id).getMaxValue(t);\n    }\n    function Ql(t) {\n      return Math.sqrt(t[0] * t[0] + t[1] * t[1]);\n    }\n    function tu(t, e, r, n, i) {\n      if (!e[0] && !e[1]) return t;\n      const s = q.convert(e)._mult(i);\n      \"viewport\" === r && s._rotate(-n);\n      const a = [];\n      for (let e = 0; e < t.length; e++) a.push(t[e].sub(s));\n      return a;\n    }\n    function eu(t, e, r, n) {\n      const i = q.convert(t)._mult(n);\n      return \"viewport\" === e && i._rotate(-r), i;\n    }\n    let ru, nu;\n    us(Ll, \"CircleBucket\", {\n      omit: [\"layers\"]\n    });\n    var iu,\n      su = {\n        exports: {}\n      },\n      au = (iu || (iu = 1, function (t, e) {\n        !function (t) {\n          function e(t, e, n) {\n            var i = r(256 * t, 256 * (e = Math.pow(2, n) - e - 1), n),\n              s = r(256 * (t + 1), 256 * (e + 1), n);\n            return i[0] + \",\" + i[1] + \",\" + s[0] + \",\" + s[1];\n          }\n          function r(t, e, r) {\n            var n = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r);\n            return [t * n - 2 * Math.PI * 6378137 / 2, e * n - 2 * Math.PI * 6378137 / 2];\n          }\n          t.getURL = function (t, r, n, i, s, a) {\n            return a = a || {}, t + \"?\" + [\"bbox=\" + e(n, i, s), \"format=\" + (a.format || \"image/png\"), \"service=\" + (a.service || \"WMS\"), \"version=\" + (a.version || \"1.1.1\"), \"request=\" + (a.request || \"GetMap\"), \"srs=\" + (a.srs || \"EPSG:3857\"), \"width=\" + (a.width || 256), \"height=\" + (a.height || 256), \"layers=\" + r].join(\"&\");\n          }, t.getTileBBox = e, t.getMercCoords = r, Object.defineProperty(t, \"__esModule\", {\n            value: !0\n          });\n        }(e);\n      }(0, su.exports)), su.exports);\n    class ou {\n      constructor(t, e, r) {\n        this.z = t, this.x = e, this.y = r, this.key = cu(0, t, t, e, r);\n      }\n      equals(t) {\n        return this.z === t.z && this.x === t.x && this.y === t.y;\n      }\n      url(t, e) {\n        const r = au.getTileBBox(this.x, this.y, this.z),\n          n = function (t, e, r) {\n            let n,\n              i = \"\";\n            for (let s = t; s > 0; s--) n = 1 << s - 1, i += (e & n ? 1 : 0) + (r & n ? 2 : 0);\n            return i;\n          }(this.z, this.x, this.y);\n        return t[(this.x + this.y) % t.length].replace(\"{prefix}\", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(\"tms\" === e ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(\"{quadkey}\", n).replace(\"{bbox-epsg-3857}\", r);\n      }\n      toString() {\n        return `${this.z}/${this.x}/${this.y}`;\n      }\n    }\n    class lu {\n      constructor(t, e) {\n        this.wrap = t, this.canonical = e, this.key = cu(t, e.z, e.z, e.x, e.y);\n      }\n    }\n    class uu {\n      constructor(t, e, r, n, i) {\n        this.overscaledZ = t, this.wrap = e, this.canonical = new ou(r, +n, +i), this.key = 0 === e && t === r ? this.canonical.key : cu(e, t, r, n, i);\n      }\n      equals(t) {\n        return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);\n      }\n      scaledTo(t) {\n        const e = this.canonical.z - t;\n        return t > this.canonical.z ? new uu(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new uu(t, this.wrap, t, this.canonical.x >> e, this.canonical.y >> e);\n      }\n      calculateScaledKey(t, e = !0) {\n        if (this.overscaledZ === t && e) return this.key;\n        if (t > this.canonical.z) return cu(this.wrap * +e, t, this.canonical.z, this.canonical.x, this.canonical.y);\n        {\n          const r = this.canonical.z - t;\n          return cu(this.wrap * +e, t, t, this.canonical.x >> r, this.canonical.y >> r);\n        }\n      }\n      isChildOf(t) {\n        if (t.wrap !== this.wrap) return !1;\n        const e = this.canonical.z - t.canonical.z;\n        return 0 === t.overscaledZ || t.overscaledZ < this.overscaledZ && t.canonical.z < this.canonical.z && t.canonical.x === this.canonical.x >> e && t.canonical.y === this.canonical.y >> e;\n      }\n      children(t) {\n        if (this.overscaledZ >= t) return [new uu(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];\n        const e = this.canonical.z + 1,\n          r = 2 * this.canonical.x,\n          n = 2 * this.canonical.y;\n        return [new uu(e, this.wrap, e, r, n), new uu(e, this.wrap, e, r + 1, n), new uu(e, this.wrap, e, r, n + 1), new uu(e, this.wrap, e, r + 1, n + 1)];\n      }\n      isLessThan(t) {\n        return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y));\n      }\n      wrapped() {\n        return new uu(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);\n      }\n      unwrapTo(t) {\n        return new uu(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);\n      }\n      overscaleFactor() {\n        return Math.pow(2, this.overscaledZ - this.canonical.z);\n      }\n      toUnwrapped() {\n        return new lu(this.wrap, this.canonical);\n      }\n      toString() {\n        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;\n      }\n    }\n    function cu(t, e, r, n, i) {\n      const s = 1 << Math.min(r, 22);\n      let a = s * (i % s) + n % s;\n      return t && r < 22 && (a += s * s * ((t < 0 ? -2 * t - 1 : 2 * t) % (1 << 2 * (22 - r)))), 16 * (32 * a + r) + (e - r);\n    }\n    const hu = [t => {\n      let e = t.canonical.x - 1,\n        r = t.wrap;\n      return e < 0 && (e = (1 << t.canonical.z) - 1, r--), new uu(t.overscaledZ, r, t.canonical.z, e, t.canonical.y);\n    }, t => {\n      let e = t.canonical.x + 1,\n        r = t.wrap;\n      return e === 1 << t.canonical.z && (e = 0, r++), new uu(t.overscaledZ, r, t.canonical.z, e, t.canonical.y);\n    }, t => new uu(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, (0 === t.canonical.y ? 1 << t.canonical.z : t.canonical.y) - 1), t => new uu(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y === (1 << t.canonical.z) - 1 ? 0 : t.canonical.y + 1)];\n    us(ou, \"CanonicalTileID\"), us(uu, \"OverscaledTileID\", {\n      omit: [\"projMatrix\", \"expandedProjMatrix\"]\n    });\n    const pu = va([{\n        type: \"Float32\",\n        name: \"a_globe_pos\",\n        components: 3\n      }, {\n        type: \"Float32\",\n        name: \"a_uv\",\n        components: 2\n      }]),\n      {\n        members: fu\n      } = pu,\n      du = va([{\n        name: \"a_pos_3\",\n        components: 3,\n        type: \"Int16\"\n      }]);\n    var mu = va([{\n      name: \"a_pos\",\n      type: \"Int16\",\n      components: 2\n    }]);\n    class yu {\n      constructor(t, e) {\n        this.pos = t, this.dir = e;\n      }\n      intersectsPlane(t, e, r) {\n        const n = O.vec2.dot(e, this.dir);\n        if (Math.abs(n) < 1e-6) return !1;\n        const i = ((t[0] - this.pos[0]) * e[0] + (t[1] - this.pos[1]) * e[1]) / n;\n        return r[0] = this.pos[0] + this.dir[0] * i, r[1] = this.pos[1] + this.dir[1] * i, !0;\n      }\n    }\n    class gu {\n      constructor(t, e) {\n        this.pos = t, this.dir = e;\n      }\n      intersectsPlane(t, e, r) {\n        const n = O.vec3.dot(e, this.dir);\n        if (Math.abs(n) < 1e-6) return !1;\n        const i = ((t[0] - this.pos[0]) * e[0] + (t[1] - this.pos[1]) * e[1] + (t[2] - this.pos[2]) * e[2]) / n;\n        return r[0] = this.pos[0] + this.dir[0] * i, r[1] = this.pos[1] + this.dir[1] * i, r[2] = this.pos[2] + this.dir[2] * i, !0;\n      }\n      closestPointOnSphere(t, e, r) {\n        if (O.vec3.equals(this.pos, t) || 0 === e) return r[0] = r[1] = r[2] = 0, !1;\n        const [n, i, s] = this.dir,\n          a = this.pos[0] - t[0],\n          o = this.pos[1] - t[1],\n          l = this.pos[2] - t[2],\n          u = n * n + i * i + s * s,\n          c = 2 * (a * n + o * i + l * s),\n          h = c * c - 4 * u * (a * a + o * o + l * l - e * e);\n        if (h < 0) {\n          const t = Math.max(-c / 2, 0),\n            u = a + n * t,\n            h = o + i * t,\n            p = l + s * t,\n            f = Math.hypot(u, h, p);\n          return r[0] = u * e / f, r[1] = h * e / f, r[2] = p * e / f, !1;\n        }\n        {\n          const t = (-c - Math.sqrt(h)) / (2 * u);\n          if (t < 0) {\n            const t = Math.hypot(a, o, l);\n            return r[0] = a * e / t, r[1] = o * e / t, r[2] = l * e / t, !1;\n          }\n          return r[0] = a + n * t, r[1] = o + i * t, r[2] = l + s * t, !0;\n        }\n      }\n    }\n    class xu {\n      constructor(t, e, r, n, i) {\n        this.TL = t, this.TR = e, this.BR = r, this.BL = n, this.horizon = i;\n      }\n      static fromInvProjectionMatrix(t, e, r) {\n        const n = [-1, 1, 1],\n          i = [1, 1, 1],\n          s = [1, -1, 1],\n          a = [-1, -1, 1],\n          o = O.vec3.transformMat4(n, n, t),\n          l = O.vec3.transformMat4(i, i, t),\n          u = O.vec3.transformMat4(s, s, t),\n          c = O.vec3.transformMat4(a, a, t);\n        return new xu(o, l, u, c, e / r);\n      }\n    }\n    function vu(t, e, r) {\n      let n = 1 / 0,\n        i = -1 / 0;\n      const s = [];\n      for (const a of t) {\n        O.vec3.sub(s, a, e);\n        const t = O.vec3.dot(s, r);\n        n = Math.min(n, t), i = Math.max(i, t);\n      }\n      return [n, i];\n    }\n    function bu(t, e) {\n      let r = !0;\n      for (let n = 0; n < t.planes.length; n++) {\n        const i = t.planes[n];\n        let s = 0;\n        for (let t = 0; t < e.length; t++) s += O.vec3.dot(i, e[t]) + i[3] >= 0;\n        if (0 === s) return 0;\n        s !== e.length && (r = !1);\n      }\n      return r ? 2 : 1;\n    }\n    function _u(t, e) {\n      for (const r of t.projections) {\n        const n = vu(e, t.points[0], r.axis);\n        if (r.projection[1] < n[0] || r.projection[0] > n[1]) return 0;\n      }\n      return 1;\n    }\n    function wu(t, e) {\n      let r = 0;\n      const n = [0, 0, 0, 0];\n      for (let i = 0; i < t.length; i++) n[0] = t[i][0], n[1] = t[i][1], n[2] = t[i][2], n[3] = 1, O.vec4.dot(n, e) >= 0 && r++;\n      return r;\n    }\n    class Mu {\n      constructor(t, e) {\n        this.points = t || new Array(8).fill([0, 0, 0]), this.planes = e || new Array(6).fill([0, 0, 0, 0]), this.bounds = Au.fromPoints(this.points), this.projections = [], this.frustumEdges = [O.vec3.sub([], this.points[2], this.points[3]), O.vec3.sub([], this.points[0], this.points[3]), O.vec3.sub([], this.points[4], this.points[0]), O.vec3.sub([], this.points[5], this.points[1]), O.vec3.sub([], this.points[6], this.points[2]), O.vec3.sub([], this.points[7], this.points[3])];\n        for (const t of this.frustumEdges) {\n          const e = [0, -t[2], t[1]],\n            r = [t[2], 0, -t[0]];\n          this.projections.push({\n            axis: e,\n            projection: vu(this.points, this.points[0], e)\n          }), this.projections.push({\n            axis: r,\n            projection: vu(this.points, this.points[0], r)\n          });\n        }\n      }\n      static fromInvProjectionMatrix(t, e, r, n) {\n        const i = Math.pow(2, r),\n          s = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(r => {\n            const s = O.vec4.transformMat4([], r, t),\n              a = 1 / s[3] / e * i;\n            return O.vec4.mul(s, s, [a, a, n ? 1 / s[3] : a, a]);\n          }),\n          a = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(t => {\n            const e = O.vec3.sub([], s[t[0]], s[t[1]]),\n              r = O.vec3.sub([], s[t[2]], s[t[1]]),\n              n = O.vec3.normalize([], O.vec3.cross([], e, r)),\n              i = -O.vec3.dot(n, s[t[1]]);\n            return n.concat(i);\n          }),\n          o = [];\n        for (let t = 0; t < s.length; t++) o.push([s[t][0], s[t][1], s[t][2]]);\n        return new Mu(o, a);\n      }\n      intersectsPrecise(t, e, r) {\n        for (let r = 0; r < e.length; r++) if (!wu(t, e[r])) return 0;\n        for (let e = 0; e < this.planes.length; e++) if (!wu(t, this.planes[e])) return 0;\n        for (const e of r) for (const r of this.frustumEdges) {\n          const n = O.vec3.cross([], e, r),\n            i = O.vec3.length(n);\n          if (0 === i) continue;\n          O.vec3.scale(n, n, 1 / i);\n          const s = vu(this.points, this.points[0], n),\n            a = vu(t, this.points[0], n);\n          if (s[0] > a[1] || a[0] > s[1]) return 0;\n        }\n        return 1;\n      }\n      containsPoint(t) {\n        for (const e of this.planes) {\n          const r = e[3];\n          if (O.vec3.dot([e[0], e[1], e[2]], t) + r < 0) return !1;\n        }\n        return !0;\n      }\n    }\n    class Au {\n      static fromPoints(t) {\n        const e = [1 / 0, 1 / 0, 1 / 0],\n          r = [-1 / 0, -1 / 0, -1 / 0];\n        for (const n of t) O.vec3.min(e, e, n), O.vec3.max(r, r, n);\n        return new Au(e, r);\n      }\n      static fromTileIdAndHeight(t, e, r) {\n        const n = 1 << t.canonical.z,\n          i = t.canonical.x,\n          s = t.canonical.y;\n        return new Au([i / n, s / n, e], [(i + 1) / n, (s + 1) / n, r]);\n      }\n      static applyTransform(t, e) {\n        const r = t.getCorners();\n        for (let t = 0; t < r.length; ++t) O.vec3.transformMat4(r[t], r[t], e);\n        return Au.fromPoints(r);\n      }\n      static applyTransformFast(t, e) {\n        const r = [e[12], e[13], e[14]],\n          n = [...r];\n        for (let i = 0; i < 3; i++) for (let s = 0; s < 3; s++) {\n          const a = e[4 * s + i],\n            o = a * t.min[s],\n            l = a * t.max[s];\n          r[i] += Math.min(o, l), n[i] += Math.max(o, l);\n        }\n        return new Au(r, n);\n      }\n      static projectAabbCorners(t, e) {\n        const r = t.getCorners();\n        for (let t = 0; t < r.length; ++t) O.vec3.transformMat4(r[t], r[t], e);\n        return r;\n      }\n      constructor(t, e) {\n        this.min = t, this.max = e, this.center = O.vec3.scale([], O.vec3.add([], this.min, this.max), .5);\n      }\n      quadrant(t) {\n        const e = [t % 2 == 0, t < 2],\n          r = O.vec3.clone(this.min),\n          n = O.vec3.clone(this.max);\n        for (let t = 0; t < e.length; t++) r[t] = e[t] ? this.min[t] : this.center[t], n[t] = e[t] ? this.center[t] : this.max[t];\n        return n[2] = this.max[2], new Au(r, n);\n      }\n      distanceX(t) {\n        return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];\n      }\n      distanceY(t) {\n        return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];\n      }\n      distanceZ(t) {\n        return Math.max(Math.min(this.max[2], t[2]), this.min[2]) - t[2];\n      }\n      getCorners() {\n        const t = this.min,\n          e = this.max;\n        return [[t[0], t[1], t[2]], [e[0], t[1], t[2]], [e[0], e[1], t[2]], [t[0], e[1], t[2]], [t[0], t[1], e[2]], [e[0], t[1], e[2]], [e[0], e[1], e[2]], [t[0], e[1], e[2]]];\n      }\n      intersects(t) {\n        return this.intersectsAabb(t.bounds) ? bu(t, this.getCorners()) : 0;\n      }\n      intersectsFlat(t) {\n        return this.intersectsAabb(t.bounds) ? bu(t, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;\n      }\n      intersectsPrecise(t, e) {\n        return e || this.intersects(t) ? _u(t, this.getCorners()) : 0;\n      }\n      intersectsPreciseFlat(t, e) {\n        return e || this.intersectsFlat(t) ? _u(t, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;\n      }\n      intersectsAabb(t) {\n        for (let e = 0; e < 3; ++e) if (this.min[e] > t.max[e] || t.min[e] > this.max[e]) return !1;\n        return !0;\n      }\n      intersectsAabbXY(t) {\n        return !(this.min[0] > t.max[0] || t.min[0] > this.max[0] || this.min[1] > t.max[1] || t.min[1] > this.max[1]);\n      }\n      encapsulate(t) {\n        for (let e = 0; e < 3; e++) this.min[e] = Math.min(this.min[e], t.min[e]), this.max[e] = Math.max(this.max[e], t.max[e]);\n      }\n      encapsulatePoint(t) {\n        for (let e = 0; e < 3; e++) this.min[e] = Math.min(this.min[e], t[e]), this.max[e] = Math.max(this.max[e], t[e]);\n      }\n      closestPoint(t) {\n        return [Math.max(Math.min(this.max[0], t[0]), this.min[0]), Math.max(Math.min(this.max[1], t[1]), this.min[1]), Math.max(Math.min(this.max[2], t[2]), this.min[2])];\n      }\n    }\n    function Iu(t) {\n      return t * Ko / ol;\n    }\n    us(Au, \"Aabb\");\n    const Su = [new Au([nl, nl, nl], [il, il, il]), new Au([nl, nl, nl], [0, 0, il]), new Au([0, nl, nl], [il, 0, il]), new Au([nl, 0, nl], [0, il, il]), new Au([0, 0, nl], [il, il, il])];\n    function Pu(t, e, r, n = !0) {\n      const i = O.vec3.scale([], t._camera.position, t.worldSize),\n        s = [e, r, 1, 1];\n      O.vec4.transformMat4(s, s, t.pixelMatrixInverse), O.vec4.scale(s, s, 1 / s[3]);\n      const a = O.vec3.sub([], s, i),\n        o = O.vec3.normalize([], a),\n        l = t.globeMatrix,\n        u = [l[12], l[13], l[14]],\n        c = O.vec3.sub([], u, i),\n        h = O.vec3.length(c),\n        p = O.vec3.normalize([], c),\n        f = t.worldSize / (2 * Math.PI),\n        d = O.vec3.dot(p, o),\n        m = Math.asin(f / h);\n      if (m < Math.acos(d)) {\n        if (!n) return null;\n        const t = [],\n          e = [];\n        O.vec3.scale(t, o, h / d), O.vec3.normalize(e, O.vec3.sub(e, t, c)), O.vec3.normalize(o, O.vec3.add(o, c, O.vec3.scale(o, e, Math.tan(m) * h)));\n      }\n      const y = [];\n      new gu(i, o).closestPointOnSphere(u, f, y);\n      const g = O.vec3.normalize([], vt(l, 0)),\n        x = O.vec3.normalize([], vt(l, 1)),\n        v = O.vec3.normalize([], vt(l, 2)),\n        b = O.vec3.dot(g, y),\n        _ = O.vec3.dot(x, y),\n        w = O.vec3.dot(v, y),\n        M = X(Math.asin(-_ / f));\n      let A = X(Math.atan2(b, w));\n      A = t.center.lng + function (t, e) {\n        const r = (e - t + 180) % 360 - 180;\n        return r < -180 ? r + 360 : r;\n      }(t.center.lng, A);\n      const I = dl(A),\n        S = Q(ml(M), 0, 1);\n      return new Il(I, S);\n    }\n    class Eu {\n      constructor(t, e, r) {\n        this.a = O.vec3.sub([], t, r), this.b = O.vec3.sub([], e, r), this.center = r;\n        const n = O.vec3.normalize([], this.a),\n          i = O.vec3.normalize([], this.b);\n        this.angle = Math.acos(O.vec3.dot(n, i));\n      }\n    }\n    function zu(t, e) {\n      if (0 === t.angle) return null;\n      let r;\n      return r = 0 === t.a[e] ? 1 / t.angle * .5 * Math.PI : 1 / t.angle * Math.atan(t.b[e] / t.a[e] / Math.sin(t.angle) - 1 / Math.tan(t.angle)), r < 0 || r > 1 ? null : function (t, e, r, n) {\n        const i = Math.sin(r);\n        return t * (Math.sin((1 - n) * r) / i) + e * (Math.sin(n * r) / i);\n      }(t.a[e], t.b[e], t.angle, Q(r, 0, 1)) + t.center[e];\n    }\n    function ku(t) {\n      if (t.z <= 1) return Su[t.z + 2 * t.y + t.x];\n      const e = Du(Cu(t));\n      return Au.fromPoints(e);\n    }\n    function Tu(t, e, r) {\n      return O.vec3.scale(t, t, 1 - r), O.vec3.scaleAndAdd(t, t, e, r);\n    }\n    function Bu(t, e, r) {\n      for (const n of t) O.vec3.transformMat4(n, n, e), O.vec3.scale(n, n, r);\n    }\n    function Vu(t, e, r, n) {\n      const i = e / t.worldSize,\n        s = t.globeMatrix;\n      if (r.z <= 1) {\n        const t = ku(r).getCorners();\n        return Bu(t, s, i), Au.fromPoints(t);\n      }\n      const a = Cu(r, n),\n        o = Du(a, Ko + Iu(t._tileCoverLift));\n      Bu(o, s, i);\n      const l = Number.MAX_VALUE,\n        u = [-l, -l, -l],\n        c = [l, l, l];\n      if (a.contains(t.center)) {\n        for (const t of o) O.vec3.min(c, c, t), O.vec3.max(u, u, t);\n        u[2] = 0;\n        const e = t.point,\n          r = [e.x * i, e.y * i, 0];\n        return O.vec3.min(c, c, r), O.vec3.max(u, u, r), new Au(c, u);\n      }\n      if (t._tileCoverLift > 0) {\n        for (const t of o) O.vec3.min(c, c, t), O.vec3.max(u, u, t);\n        return new Au(c, u);\n      }\n      const h = [s[12] * i, s[13] * i, s[14] * i],\n        p = a.getCenter(),\n        f = Q(t.center.lat, -bl, bl),\n        d = Q(p.lat, -bl, bl),\n        m = dl(t.center.lng),\n        y = ml(f);\n      let g = m - dl(p.lng);\n      const x = y - ml(d);\n      g > .5 ? g -= 1 : g < -.5 && (g += 1);\n      let v = 0;\n      if (Math.abs(g) > Math.abs(x)) v = g >= 0 ? 1 : 3;else {\n        v = x >= 0 ? 0 : 2;\n        const t = [s[4] * i, s[5] * i, s[6] * i],\n          e = -Math.sin(H(x >= 0 ? a.getSouth() : a.getNorth())) * Ko;\n        O.vec3.scaleAndAdd(h, h, t, e);\n      }\n      const b = o[v],\n        _ = o[(v + 1) % 4],\n        w = new Eu(b, _, h),\n        M = [zu(w, 0) || b[0], zu(w, 1) || b[1], zu(w, 2) || b[2]],\n        A = $u(t.zoom);\n      if (A > 0) {\n        const n = function ({\n          x: t,\n          y: e,\n          z: r\n        }, n, i, s, a) {\n          const o = 1 / (1 << r);\n          let l = t * o,\n            u = l + o,\n            c = e * o,\n            h = c + o,\n            p = 0;\n          const f = (l + u) / 2 - s;\n          return f > .5 ? p = -1 : f < -.5 && (p = 1), l = ((l + p) * n - (s *= n)) * i + s, u = ((u + p) * n - s) * i + s, c = (c * n - (a *= n)) * i + a, h = (h * n - a) * i + a, [[l, h, 0], [u, h, 0], [u, c, 0], [l, c, 0]];\n        }(r, e, t._pixelsPerMercatorPixel, m, y);\n        for (let t = 0; t < o.length; t++) Tu(o[t], n[t], A);\n        const i = O.vec3.add([], n[v], n[(v + 1) % 4]);\n        O.vec3.scale(i, i, .5), Tu(M, i, A);\n      }\n      for (const t of o) O.vec3.min(c, c, t), O.vec3.max(u, u, t);\n      return c[2] = Math.min(b[2], _[2]), O.vec3.min(c, c, M), O.vec3.max(u, u, M), new Au(c, u);\n    }\n    function Cu({\n      x: t,\n      y: e,\n      z: r\n    }, n = !1) {\n      const i = 1 / (1 << r),\n        s = new ul(gl(t * i), e === (1 << r) - 1 && n ? -90 : xl((e + 1) * i)),\n        a = new ul(gl((t + 1) * i), 0 === e && n ? 90 : xl(e * i));\n      return new cl(s, a);\n    }\n    function Du(t, e = Ko) {\n      const r = H(t.getNorth()),\n        n = H(t.getSouth()),\n        i = Math.cos(r),\n        s = Math.cos(n),\n        a = Math.sin(r),\n        o = Math.sin(n),\n        l = t.getWest(),\n        u = t.getEast();\n      return [sl(s, o, l, e), sl(s, o, u, e), sl(i, a, u, e), sl(i, a, l, e)];\n    }\n    function Ru(t, e, r, n) {\n      const i = 1 << r.z,\n        s = (t / Kr + r.x) / i;\n      return al(xl((e / Kr + r.y) / i), gl(s), n);\n    }\n    function Lu({\n      min: t,\n      max: e\n    }) {\n      return tl / Math.max(e[0] - t[0], e[1] - t[1], e[2] - t[2]);\n    }\n    const Fu = new Float64Array(16);\n    function Ou(t) {\n      const e = Lu(t),\n        r = O.mat4.fromScaling(Fu, [e, e, e]);\n      return O.mat4.translate(r, r, O.vec3.negate([], t.min));\n    }\n    function Nu(t) {\n      const e = O.mat4.fromTranslation(Fu, t.min),\n        r = 1 / Lu(t);\n      return O.mat4.scale(e, e, [r, r, r]);\n    }\n    function Uu(t) {\n      const e = Kr / (2 * Math.PI);\n      return t / (2 * Math.PI) / e;\n    }\n    function ju(t, e) {\n      return Kr / (512 * Math.pow(2, t)) * Lu(ku(e));\n    }\n    function qu(t, e, r, n, i) {\n      const s = Uu(r),\n        a = [t, e, -r / (2 * Math.PI)],\n        o = O.mat4.identity(new Float64Array(16));\n      return O.mat4.translate(o, o, a), O.mat4.scale(o, o, [s, s, s]), O.mat4.rotateX(o, o, H(-i)), O.mat4.rotateY(o, o, H(-n)), o;\n    }\n    function $u(t) {\n      return tt(Jo, Qo, t);\n    }\n    function Gu(t, e) {\n      const r = al(e.lat, e.lng),\n        n = function (t) {\n          const e = al(t._center.lat, t._center.lng),\n            r = O.vec3.fromValues(0, 1, 0);\n          let n = O.vec3.cross([], r, e);\n          const i = O.mat4.fromRotation([], -t.angle, e);\n          n = O.vec3.transformMat4(n, n, i), O.mat4.fromRotation(i, -t._pitch, n);\n          const s = O.vec3.normalize([], e);\n          return O.vec3.scale(s, s, Iu(t.cameraToCenterDistance / t.pixelsPerMeter)), O.vec3.transformMat4(s, s, i), O.vec3.add([], e, s);\n        }(t),\n        i = O.vec3.subtract([], n, r);\n      return O.vec3.angle(i, r);\n    }\n    function Yu(t, e) {\n      return Gu(t, e) > Math.PI / 2 * 1.01;\n    }\n    const Hu = H(85),\n      Xu = Math.cos(Hu),\n      Zu = Math.sin(Hu),\n      Wu = O.mat4.create(),\n      Ku = t => {\n        const e = [];\n        return \"map\" === t.paint.get(\"circle-pitch-alignment\") && e.push(\"PITCH_WITH_MAP\"), \"map\" === t.paint.get(\"circle-pitch-scale\") && e.push(\"SCALE_WITH_MAP\"), e;\n      };\n    function Ju(t, e, r, n, i, s, a, o, l) {\n      if (s && t.queryGeometry.isAboveHorizon) return !1;\n      s && (l *= t.pixelToTileUnitsFactor);\n      const u = t.tileID.canonical,\n        c = r.projection.upVectorScale(u, r.center.lat, r.worldSize).metersToTile;\n      for (const h of e) for (const e of h) {\n        const h = e.add(o),\n          p = i && r.elevation ? r.elevation.exaggeration() * i.getElevationAt(h.x, h.y, !0) : 0,\n          f = r.projection.projectTilePoint(h.x, h.y, u);\n        if (p > 0) {\n          const t = r.projection.upVector(u, h.x, h.y);\n          f.x += t[0] * c * p, f.y += t[1] * c * p, f.z += t[2] * c * p;\n        }\n        const d = s ? h : Qu(f.x, f.y, f.z, n),\n          m = s ? t.tilespaceRays.map(t => rc(t, p)) : t.queryGeometry.screenGeometry,\n          y = O.vec4.transformMat4([], [f.x, f.y, f.z, 1], n);\n        if (!a && s ? l *= y[3] / r.cameraToCenterDistance : a && !s && (l *= r.cameraToCenterDistance / y[3]), s) {\n          const t = xl((e.y / Kr + u.y) / (1 << u.z));\n          l /= r.projection.pixelsPerMeter(t, 1) / yl(1, t);\n        }\n        if (Ol(m, d, l)) return !0;\n      }\n      return !1;\n    }\n    function Qu(t, e, r, n) {\n      const i = O.vec4.transformMat4([], [t, e, r, 1], n);\n      return new q(i[0] / i[3], i[1] / i[3]);\n    }\n    const tc = O.vec3.fromValues(0, 0, 0),\n      ec = O.vec3.fromValues(0, 0, 1);\n    function rc(t, e) {\n      const r = O.vec3.create();\n      return tc[2] = e, t.intersectsPlane(tc, ec, r), new q(r[0], r[1]);\n    }\n    class nc extends Ll {}\n    let ic, sc, ac, oc;\n    function lc(t, {\n      width: e,\n      height: r\n    }, n, i) {\n      if (i) {\n        if (i instanceof Uint8ClampedArray) i = new Uint8Array(i.buffer);else if (i.length !== e * r * n) throw new RangeError(\"mismatched image size\");\n      } else i = new Uint8Array(e * r * n);\n      return t.width = e, t.height = r, t.data = i, t;\n    }\n    function uc(t, e, r) {\n      const {\n        width: n,\n        height: i\n      } = e;\n      n === t.width && i === t.height || (cc(t, e, {\n        x: 0,\n        y: 0\n      }, {\n        x: 0,\n        y: 0\n      }, {\n        width: Math.min(t.width, n),\n        height: Math.min(t.height, i)\n      }, r, null), t.width = n, t.height = i, t.data = e.data);\n    }\n    function cc(t, e, r, n, i, s, a, o) {\n      if (0 === i.width || 0 === i.height) return e;\n      if (i.width > t.width || i.height > t.height || r.x > t.width - i.width || r.y > t.height - i.height) throw new RangeError(\"out of range source coordinates for image copy\");\n      if (i.width > e.width || i.height > e.height || n.x > e.width - i.width || n.y > e.height - i.height) throw new RangeError(\"out of range destination coordinates for image copy\");\n      const l = t.data,\n        u = e.data,\n        c = 4 === s && o;\n      for (let o = 0; o < i.height; o++) {\n        const h = ((r.y + o) * t.width + r.x) * s,\n          p = ((n.y + o) * e.width + n.x) * s;\n        if (c) for (let t = 0; t < i.width; t++) {\n          const e = h + t * s + 3,\n            r = p + t * s;\n          u[r + 0] = 255, u[r + 1] = 255, u[r + 2] = 255, u[r + 3] = l[e];\n        } else if (a) for (let t = 0; t < i.width; t++) {\n          const e = h + t * s,\n            r = p + t * s,\n            n = l[e + 3],\n            i = new Se(l[e + 0] / 255 * n, l[e + 1] / 255 * n, l[e + 2] / 255 * n, n).toRenderColor(a).toArray();\n          u[r + 0] = i[0], u[r + 1] = i[1], u[r + 2] = i[2], u[r + 3] = i[3];\n        } else for (let t = 0; t < i.width * s; t++) u[p + t] = l[h + t];\n      }\n      return e;\n    }\n    us(nc, \"HeatmapBucket\", {\n      omit: [\"layers\"]\n    });\n    class hc {\n      constructor(t, e) {\n        lc(this, t, 1, e);\n      }\n      resize(t) {\n        uc(this, new hc(t), 1);\n      }\n      clone() {\n        return new hc({\n          width: this.width,\n          height: this.height\n        }, new Uint8Array(this.data));\n      }\n      static copy(t, e, r, n, i) {\n        cc(t, e, r, n, i, 1, null);\n      }\n    }\n    class pc {\n      constructor(t, e) {\n        lc(this, t, 4, e);\n      }\n      resize(t) {\n        uc(this, new pc(t), 4);\n      }\n      replace(t, e) {\n        e ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t;\n      }\n      clone() {\n        return new pc({\n          width: this.width,\n          height: this.height\n        }, new Uint8Array(this.data));\n      }\n      static copy(t, e, r, n, i, s, a) {\n        cc(t, e, r, n, i, 4, s, a);\n      }\n    }\n    class fc {\n      constructor(t, e) {\n        this.width = t.width, this.height = t.height, this.data = e instanceof Uint8Array ? new Float32Array(e.buffer) : e;\n      }\n    }\n    function dc(t) {\n      const e = {},\n        r = t.resolution || 256,\n        n = t.clips ? t.clips.length : 1,\n        i = t.image || new pc({\n          width: r,\n          height: n\n        }),\n        s = (r, n, s) => {\n          e[t.evaluationKey] = s;\n          const a = t.expression.evaluate(e);\n          a && (i.data[r + n + 0] = Math.floor(255 * a.r / a.a), i.data[r + n + 1] = Math.floor(255 * a.g / a.a), i.data[r + n + 2] = Math.floor(255 * a.b / a.a), i.data[r + n + 3] = Math.floor(255 * a.a));\n        };\n      if (t.clips) for (let e = 0, i = 0; e < n; ++e, i += 4 * r) for (let n = 0, a = 0; n < r; n++, a += 4) {\n        const o = n / (r - 1),\n          {\n            start: l,\n            end: u\n          } = t.clips[e];\n        s(i, a, l * (1 - o) + u * o);\n      } else for (let t = 0, e = 0; t < r; t++, e += 4) s(0, e, t / (r - 1));\n      return i;\n    }\n    us(hc, \"AlphaImage\"), us(pc, \"RGBAImage\");\n    const mc = va([{\n        name: \"a_pos\",\n        components: 2,\n        type: \"Int16\"\n      }], 4),\n      yc = va([{\n        name: \"a_road_z_offset\",\n        components: 1,\n        type: \"Float32\"\n      }], 4),\n      gc = va([{\n        name: \"a_pos\",\n        components: 2,\n        type: \"Int16\"\n      }, {\n        name: \"a_height\",\n        components: 1,\n        type: \"Float32\"\n      }], 4),\n      xc = va([{\n        name: \"a_pos_normal_3\",\n        components: 3,\n        type: \"Int16\"\n      }], 4);\n    function vc(t, e, r = 2) {\n      const n = e && e.length,\n        i = n ? e[0] * r : t.length;\n      let s = bc(t, 0, i, r, !0);\n      const a = [];\n      if (!s || s.next === s.prev) return a;\n      let o, l, u;\n      if (n && (s = function (t, e, r, n) {\n        const i = [];\n        for (let r = 0, s = e.length; r < s; r++) {\n          const a = bc(t, e[r] * n, r < s - 1 ? e[r + 1] * n : t.length, n, !1);\n          a === a.next && (a.steiner = !0), i.push(Tc(a));\n        }\n        i.sort(Pc);\n        for (let t = 0; t < i.length; t++) r = Ec(i[t], r);\n        return r;\n      }(t, e, s, r)), t.length > 80 * r) {\n        o = 1 / 0, l = 1 / 0;\n        let e = -1 / 0,\n          n = -1 / 0;\n        for (let s = r; s < i; s += r) {\n          const r = t[s],\n            i = t[s + 1];\n          r < o && (o = r), i < l && (l = i), r > e && (e = r), i > n && (n = i);\n        }\n        u = Math.max(e - o, n - l), u = 0 !== u ? 32767 / u : 0;\n      }\n      return wc(s, a, r, o, l, u, 0), a;\n    }\n    function bc(t, e, r, n, i) {\n      let s;\n      if (i === function (t, e, r, n) {\n        let i = 0;\n        for (let s = e, a = r - n; s < r; s += n) i += (t[a] - t[s]) * (t[s + 1] + t[a + 1]), a = s;\n        return i;\n      }(t, e, r, n) > 0) for (let i = e; i < r; i += n) s = Uc(i / n | 0, t[i], t[i + 1], s);else for (let i = r - n; i >= e; i -= n) s = Uc(i / n | 0, t[i], t[i + 1], s);\n      return s && Dc(s, s.next) && (jc(s), s = s.next), s;\n    }\n    function _c(t, e) {\n      if (!t) return t;\n      e || (e = t);\n      let r,\n        n = t;\n      do {\n        if (r = !1, n.steiner || !Dc(n, n.next) && 0 !== Cc(n.prev, n, n.next)) n = n.next;else {\n          if (jc(n), n = e = n.prev, n === n.next) break;\n          r = !0;\n        }\n      } while (r || n !== e);\n      return e;\n    }\n    function wc(t, e, r, n, i, s, a) {\n      if (!t) return;\n      !a && s && function (t, e, r, n) {\n        let i = t;\n        do {\n          0 === i.z && (i.z = kc(i.x, i.y, e, r, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next;\n        } while (i !== t);\n        i.prevZ.nextZ = null, i.prevZ = null, function (t) {\n          let e,\n            r = 1;\n          do {\n            let n,\n              i = t;\n            t = null;\n            let s = null;\n            for (e = 0; i;) {\n              e++;\n              let a = i,\n                o = 0;\n              for (let t = 0; t < r && (o++, a = a.nextZ, a); t++);\n              let l = r;\n              for (; o > 0 || l > 0 && a;) 0 !== o && (0 === l || !a || i.z <= a.z) ? (n = i, i = i.nextZ, o--) : (n = a, a = a.nextZ, l--), s ? s.nextZ = n : t = n, n.prevZ = s, s = n;\n              i = a;\n            }\n            s.nextZ = null, r *= 2;\n          } while (e > 1);\n        }(i);\n      }(t, n, i, s);\n      let o = t;\n      for (; t.prev !== t.next;) {\n        const l = t.prev,\n          u = t.next;\n        if (s ? Ac(t, n, i, s) : Mc(t)) e.push(l.i, t.i, u.i), jc(t), t = u.next, o = u.next;else if ((t = u) === o) {\n          a ? 1 === a ? wc(t = Ic(_c(t), e), e, r, n, i, s, 2) : 2 === a && Sc(t, e, r, n, i, s) : wc(_c(t), e, r, n, i, s, 1);\n          break;\n        }\n      }\n    }\n    function Mc(t) {\n      const e = t.prev,\n        r = t,\n        n = t.next;\n      if (Cc(e, r, n) >= 0) return !1;\n      const i = e.x,\n        s = r.x,\n        a = n.x,\n        o = e.y,\n        l = r.y,\n        u = n.y,\n        c = i < s ? i < a ? i : a : s < a ? s : a,\n        h = o < l ? o < u ? o : u : l < u ? l : u,\n        p = i > s ? i > a ? i : a : s > a ? s : a,\n        f = o > l ? o > u ? o : u : l > u ? l : u;\n      let d = n.next;\n      for (; d !== e;) {\n        if (d.x >= c && d.x <= p && d.y >= h && d.y <= f && Bc(i, o, s, l, a, u, d.x, d.y) && Cc(d.prev, d, d.next) >= 0) return !1;\n        d = d.next;\n      }\n      return !0;\n    }\n    function Ac(t, e, r, n) {\n      const i = t.prev,\n        s = t,\n        a = t.next;\n      if (Cc(i, s, a) >= 0) return !1;\n      const o = i.x,\n        l = s.x,\n        u = a.x,\n        c = i.y,\n        h = s.y,\n        p = a.y,\n        f = o < l ? o < u ? o : u : l < u ? l : u,\n        d = c < h ? c < p ? c : p : h < p ? h : p,\n        m = o > l ? o > u ? o : u : l > u ? l : u,\n        y = c > h ? c > p ? c : p : h > p ? h : p,\n        g = kc(f, d, e, r, n),\n        x = kc(m, y, e, r, n);\n      let v = t.prevZ,\n        b = t.nextZ;\n      for (; v && v.z >= g && b && b.z <= x;) {\n        if (v.x >= f && v.x <= m && v.y >= d && v.y <= y && v !== i && v !== a && Bc(o, c, l, h, u, p, v.x, v.y) && Cc(v.prev, v, v.next) >= 0) return !1;\n        if (v = v.prevZ, b.x >= f && b.x <= m && b.y >= d && b.y <= y && b !== i && b !== a && Bc(o, c, l, h, u, p, b.x, b.y) && Cc(b.prev, b, b.next) >= 0) return !1;\n        b = b.nextZ;\n      }\n      for (; v && v.z >= g;) {\n        if (v.x >= f && v.x <= m && v.y >= d && v.y <= y && v !== i && v !== a && Bc(o, c, l, h, u, p, v.x, v.y) && Cc(v.prev, v, v.next) >= 0) return !1;\n        v = v.prevZ;\n      }\n      for (; b && b.z <= x;) {\n        if (b.x >= f && b.x <= m && b.y >= d && b.y <= y && b !== i && b !== a && Bc(o, c, l, h, u, p, b.x, b.y) && Cc(b.prev, b, b.next) >= 0) return !1;\n        b = b.nextZ;\n      }\n      return !0;\n    }\n    function Ic(t, e) {\n      let r = t;\n      do {\n        const n = r.prev,\n          i = r.next.next;\n        !Dc(n, i) && Rc(n, r, r.next, i) && Oc(n, i) && Oc(i, n) && (e.push(n.i, r.i, i.i), jc(r), jc(r.next), r = t = i), r = r.next;\n      } while (r !== t);\n      return _c(r);\n    }\n    function Sc(t, e, r, n, i, s) {\n      let a = t;\n      do {\n        let t = a.next.next;\n        for (; t !== a.prev;) {\n          if (a.i !== t.i && Vc(a, t)) {\n            let o = Nc(a, t);\n            return a = _c(a, a.next), o = _c(o, o.next), wc(a, e, r, n, i, s, 0), void wc(o, e, r, n, i, s, 0);\n          }\n          t = t.next;\n        }\n        a = a.next;\n      } while (a !== t);\n    }\n    function Pc(t, e) {\n      return t.x - e.x;\n    }\n    function Ec(t, e) {\n      const r = function (t, e) {\n        let r = e;\n        const n = t.x,\n          i = t.y;\n        let s,\n          a = -1 / 0;\n        do {\n          if (i <= r.y && i >= r.next.y && r.next.y !== r.y) {\n            const t = r.x + (i - r.y) * (r.next.x - r.x) / (r.next.y - r.y);\n            if (t <= n && t > a && (a = t, s = r.x < r.next.x ? r : r.next, t === n)) return s;\n          }\n          r = r.next;\n        } while (r !== e);\n        if (!s) return null;\n        const o = s,\n          l = s.x,\n          u = s.y;\n        let c = 1 / 0;\n        r = s;\n        do {\n          if (n >= r.x && r.x >= l && n !== r.x && Bc(i < u ? n : a, i, l, u, i < u ? a : n, i, r.x, r.y)) {\n            const e = Math.abs(i - r.y) / (n - r.x);\n            Oc(r, t) && (e < c || e === c && (r.x > s.x || r.x === s.x && zc(s, r))) && (s = r, c = e);\n          }\n          r = r.next;\n        } while (r !== o);\n        return s;\n      }(t, e);\n      if (!r) return e;\n      const n = Nc(r, t);\n      return _c(n, n.next), _c(r, r.next);\n    }\n    function zc(t, e) {\n      return Cc(t.prev, t, e.prev) < 0 && Cc(e.next, t, t.next) < 0;\n    }\n    function kc(t, e, r, n, i) {\n      return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - r) * i | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1;\n    }\n    function Tc(t) {\n      let e = t,\n        r = t;\n      do {\n        (e.x < r.x || e.x === r.x && e.y < r.y) && (r = e), e = e.next;\n      } while (e !== t);\n      return r;\n    }\n    function Bc(t, e, r, n, i, s, a, o) {\n      return (i - a) * (e - o) >= (t - a) * (s - o) && (t - a) * (n - o) >= (r - a) * (e - o) && (r - a) * (s - o) >= (i - a) * (n - o);\n    }\n    function Vc(t, e) {\n      return t.next.i !== e.i && t.prev.i !== e.i && !function (t, e) {\n        let r = t;\n        do {\n          if (r.i !== t.i && r.next.i !== t.i && r.i !== e.i && r.next.i !== e.i && Rc(r, r.next, t, e)) return !0;\n          r = r.next;\n        } while (r !== t);\n        return !1;\n      }(t, e) && (Oc(t, e) && Oc(e, t) && function (t, e) {\n        let r = t,\n          n = !1;\n        const i = (t.x + e.x) / 2,\n          s = (t.y + e.y) / 2;\n        do {\n          r.y > s != r.next.y > s && r.next.y !== r.y && i < (r.next.x - r.x) * (s - r.y) / (r.next.y - r.y) + r.x && (n = !n), r = r.next;\n        } while (r !== t);\n        return n;\n      }(t, e) && (Cc(t.prev, t, e.prev) || Cc(t, e.prev, e)) || Dc(t, e) && Cc(t.prev, t, t.next) > 0 && Cc(e.prev, e, e.next) > 0);\n    }\n    function Cc(t, e, r) {\n      return (e.y - t.y) * (r.x - e.x) - (e.x - t.x) * (r.y - e.y);\n    }\n    function Dc(t, e) {\n      return t.x === e.x && t.y === e.y;\n    }\n    function Rc(t, e, r, n) {\n      const i = Fc(Cc(t, e, r)),\n        s = Fc(Cc(t, e, n)),\n        a = Fc(Cc(r, n, t)),\n        o = Fc(Cc(r, n, e));\n      return i !== s && a !== o || !(0 !== i || !Lc(t, r, e)) || !(0 !== s || !Lc(t, n, e)) || !(0 !== a || !Lc(r, t, n)) || !(0 !== o || !Lc(r, e, n));\n    }\n    function Lc(t, e, r) {\n      return e.x <= Math.max(t.x, r.x) && e.x >= Math.min(t.x, r.x) && e.y <= Math.max(t.y, r.y) && e.y >= Math.min(t.y, r.y);\n    }\n    function Fc(t) {\n      return t > 0 ? 1 : t < 0 ? -1 : 0;\n    }\n    function Oc(t, e) {\n      return Cc(t.prev, t, t.next) < 0 ? Cc(t, e, t.next) >= 0 && Cc(t, t.prev, e) >= 0 : Cc(t, e, t.prev) < 0 || Cc(t, t.next, e) < 0;\n    }\n    function Nc(t, e) {\n      const r = qc(t.i, t.x, t.y),\n        n = qc(e.i, e.x, e.y),\n        i = t.next,\n        s = e.prev;\n      return t.next = e, e.prev = t, r.next = i, i.prev = r, n.next = r, r.prev = n, s.next = n, n.prev = s, n;\n    }\n    function Uc(t, e, r, n) {\n      const i = qc(t, e, r);\n      return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i;\n    }\n    function jc(t) {\n      t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ);\n    }\n    function qc(t, e, r) {\n      return {\n        i: t,\n        x: e,\n        y: r,\n        prev: null,\n        next: null,\n        z: 0,\n        prevZ: null,\n        nextZ: null,\n        steiner: !1\n      };\n    }\n    function $c(t, e) {\n      const r = t.length;\n      if (r <= 1) return [t];\n      const n = [];\n      let i, s;\n      for (let e = 0; e < r; e++) {\n        const r = dt(t[e]);\n        0 !== r && (t[e].area = Math.abs(r), void 0 === s && (s = r < 0), s === r < 0 ? (i && n.push(i), i = [t[e]]) : i.push(t[e]));\n      }\n      if (i && n.push(i), e > 1) for (let t = 0; t < n.length; t++) n[t].length <= e || (br(n[t], e, 1, n[t].length - 1, Gc), n[t] = n[t].slice(0, e));\n      return n;\n    }\n    function Gc(t, e) {\n      return e.area - t.area;\n    }\n    function Yc(t, e, r = 1) {\n      if (!t) return null;\n      const n = \"string\" == typeof t ? er.from(t).getPrimary() : t.getPrimary(),\n        i = n.id.toString();\n      return e.has(i) || e.set(i, []), n.scaleSelf(r), e.get(i).push(n), n.toString();\n    }\n    function Hc(t, e, r, n) {\n      const i = n.patternDependencies;\n      let s = !1;\n      for (const n of e) {\n        const e = n.paint.get(`${t}-pattern`);\n        e.isConstant() || (s = !0), Yc(e.constantOr(null), i, r) && (s = !0);\n      }\n      return s;\n    }\n    function Xc(t, e, r, n, i, s) {\n      const a = s.patternDependencies;\n      for (const o of e) {\n        const e = o.paint.get(`${t}-pattern`).value;\n        if (\"constant\" !== e.kind) {\n          let t = e.evaluate({\n            zoom: n\n          }, r, {}, s.availableImages);\n          t = t && t.name ? t.name : t;\n          const l = Yc(t, a, i);\n          l && (r.patterns[o.id] = l);\n        }\n      }\n      return r;\n    }\n    var Zc,\n      Wc,\n      Kc,\n      Jc,\n      Qc,\n      th,\n      eh,\n      rh = {};\n    function nh() {\n      if (Wc) return Zc;\n      Wc = 1;\n      var t = j();\n      function e(t, e, n, i, s) {\n        this.properties = {}, this.extent = n, this.type = 0, this._pbf = t, this._geometry = -1, this._keys = i, this._values = s, t.readFields(r, this, e);\n      }\n      function r(t, e, r) {\n        1 == t ? e.id = r.readVarint() : 2 == t ? function (t, e) {\n          for (var r = t.readVarint() + t.pos; t.pos < r;) {\n            var n = e._keys[t.readVarint()],\n              i = e._values[t.readVarint()];\n            e.properties[n] = i;\n          }\n        }(r, e) : 3 == t ? e.type = r.readVarint() : 4 == t && (e._geometry = r.pos);\n      }\n      function n(t) {\n        for (var e, r, n = 0, i = 0, s = t.length, a = s - 1; i < s; a = i++) n += ((r = t[a]).x - (e = t[i]).x) * (e.y + r.y);\n        return n;\n      }\n      return Zc = e, e.types = [\"Unknown\", \"Point\", \"LineString\", \"Polygon\"], e.prototype.loadGeometry = function () {\n        var e = this._pbf;\n        e.pos = this._geometry;\n        for (var r, n = e.readVarint() + e.pos, i = 1, s = 0, a = 0, o = 0, l = []; e.pos < n;) {\n          if (s <= 0) {\n            var u = e.readVarint();\n            i = 7 & u, s = u >> 3;\n          }\n          if (s--, 1 === i || 2 === i) a += e.readSVarint(), o += e.readSVarint(), 1 === i && (r && l.push(r), r = []), r.push(new t(a, o));else {\n            if (7 !== i) throw new Error(\"unknown command \" + i);\n            r && r.push(r[0].clone());\n          }\n        }\n        return r && l.push(r), l;\n      }, e.prototype.bbox = function () {\n        var t = this._pbf;\n        t.pos = this._geometry;\n        for (var e = t.readVarint() + t.pos, r = 1, n = 0, i = 0, s = 0, a = 1 / 0, o = -1 / 0, l = 1 / 0, u = -1 / 0; t.pos < e;) {\n          if (n <= 0) {\n            var c = t.readVarint();\n            r = 7 & c, n = c >> 3;\n          }\n          if (n--, 1 === r || 2 === r) (i += t.readSVarint()) < a && (a = i), i > o && (o = i), (s += t.readSVarint()) < l && (l = s), s > u && (u = s);else if (7 !== r) throw new Error(\"unknown command \" + r);\n        }\n        return [a, l, o, u];\n      }, e.prototype.toGeoJSON = function (t, r, i) {\n        var s,\n          a,\n          o = this.extent * Math.pow(2, i),\n          l = this.extent * t,\n          u = this.extent * r,\n          c = this.loadGeometry(),\n          h = e.types[this.type];\n        function p(t) {\n          for (var e = 0; e < t.length; e++) {\n            var r = t[e];\n            t[e] = [360 * (r.x + l) / o - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r.y + u) / o) * Math.PI / 180)) - 90];\n          }\n        }\n        switch (this.type) {\n          case 1:\n            var f = [];\n            for (s = 0; s < c.length; s++) f[s] = c[s][0];\n            p(c = f);\n            break;\n          case 2:\n            for (s = 0; s < c.length; s++) p(c[s]);\n            break;\n          case 3:\n            for (c = function (t) {\n              var e = t.length;\n              if (e <= 1) return [t];\n              for (var r, i, s = [], a = 0; a < e; a++) {\n                var o = n(t[a]);\n                0 !== o && (void 0 === i && (i = o < 0), i === o < 0 ? (r && s.push(r), r = [t[a]]) : r.push(t[a]));\n              }\n              return r && s.push(r), s;\n            }(c), s = 0; s < c.length; s++) for (a = 0; a < c[s].length; a++) p(c[s][a]);\n        }\n        1 === c.length ? c = c[0] : h = \"Multi\" + h;\n        var d = {\n          type: \"Feature\",\n          geometry: {\n            type: h,\n            coordinates: c\n          },\n          properties: this.properties\n        };\n        return \"id\" in this && (d.id = this.id), d;\n      }, Zc;\n    }\n    function ih() {\n      if (Jc) return Kc;\n      Jc = 1;\n      var t = nh();\n      function e(t, e) {\n        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t, this._keys = [], this._values = [], this._features = [], t.readFields(r, this, e), this.length = this._features.length;\n      }\n      function r(t, e, r) {\n        15 === t ? e.version = r.readVarint() : 1 === t ? e.name = r.readString() : 5 === t ? e.extent = r.readVarint() : 2 === t ? e._features.push(r.pos) : 3 === t ? e._keys.push(r.readString()) : 4 === t && e._values.push(function (t) {\n          for (var e = null, r = t.readVarint() + t.pos; t.pos < r;) {\n            var n = t.readVarint() >> 3;\n            e = 1 === n ? t.readString() : 2 === n ? t.readFloat() : 3 === n ? t.readDouble() : 4 === n ? t.readVarint64() : 5 === n ? t.readVarint() : 6 === n ? t.readSVarint() : 7 === n ? t.readBoolean() : null;\n          }\n          return e;\n        }(r));\n      }\n      return Kc = e, e.prototype.feature = function (e) {\n        if (e < 0 || e >= this._features.length) throw new Error(\"feature index out of bounds\");\n        this._pbf.pos = this._features[e];\n        var r = this._pbf.readVarint() + this._pbf.pos;\n        return new t(this._pbf, r, this.extent, this._keys, this._values);\n      }, Kc;\n    }\n    function sh() {\n      return eh || (eh = 1, rh.VectorTile = function () {\n        if (th) return Qc;\n        th = 1;\n        var t = ih();\n        function e(e, r, n) {\n          if (3 === e) {\n            var i = new t(n, n.readVarint() + n.pos);\n            i.length && (r[i.name] = i);\n          }\n        }\n        return Qc = function (t, r) {\n          this.layers = t.readFields(e, {}, r);\n        }, Qc;\n      }(), rh.VectorTileFeature = nh(), rh.VectorTileLayer = ih()), rh;\n    }\n    var ah = sh();\n    const oh = \"3d_elevation_id\",\n      lh = \"level\";\n    class uh {\n      constructor() {\n        this._valid = !1;\n      }\n      reset(t) {\n        return this.feature = t, this._valid = !0, this._geometry = t.loadGeometry(), 0 !== this._geometry.length && 0 !== this._geometry[0].length || (this._valid = !1), this;\n      }\n      geometry(t, e) {\n        return this._valid && t(e(this._geometry)), this;\n      }\n      require(t, e, r) {\n        return this.get(t, !0, e, r);\n      }\n      optional(t, e, r) {\n        return this.get(t, !1, e, r);\n      }\n      success() {\n        return this._valid;\n      }\n      get(t, e, r, n) {\n        const i = this.feature.properties.hasOwnProperty(t) ? +this.feature.properties[t] : void 0;\n        return this._valid && void 0 !== i ? r(n ? n(i) : i) : e && (this._valid = !1), this;\n      }\n    }\n    class ch {\n      constructor(t, e) {\n        this.featureFunc = t, this.vertexFunc = e;\n      }\n      parseFeature(t, e, r) {\n        return this.featureFunc(t, e, r);\n      }\n      parseVertex(t, e, r) {\n        return this.vertexFunc(t, e, r);\n      }\n    }\n    const hh = new ch((t, e, r) => t.reset(e).require(oh, t => {\n        r.id = t;\n      }).optional(\"fixed_height_relative\", t => {\n        r.constantHeight = t;\n      }, fh.decodeRelativeHeight).geometry(t => {\n        r.bounds = t;\n      }, fh.computeBounds).success(), (t, e, r) => t.reset(e).require(oh, t => {\n        r.id = t;\n      }).require(\"elevation_idx\", t => {\n        r.idx = t;\n      }).require(\"extent\", t => {\n        r.extent = t;\n      }).require(\"height_relative\", t => {\n        r.height = t;\n      }, fh.decodeRelativeHeight).geometry(t => {\n        r.position = t;\n      }, fh.getPoint).success()),\n      ph = new ch((t, e, r) => t.reset(e).require(oh, t => {\n        r.id = t;\n      }).optional(\"fixed_height\", t => {\n        r.constantHeight = t;\n      }, fh.decodeMetricHeight).geometry(t => {\n        r.bounds = t;\n      }, fh.computeBounds).success(), (t, e, r) => t.reset(e).require(oh, t => {\n        r.id = t;\n      }).require(\"elevation_idx\", t => {\n        r.idx = t;\n      }).require(\"extent\", t => {\n        r.extent = t;\n      }).require(\"height\", t => {\n        r.height = t;\n      }, fh.decodeMetricHeight).geometry(t => {\n        r.position = t;\n      }, fh.getPoint).success());\n    class fh {\n      static computeBounds(t) {\n        const e = new q(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY),\n          r = new q(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);\n        for (const n of t[0]) e.x > n.x && (e.x = n.x), e.y > n.y && (e.y = n.y), r.x < n.x && (r.x = n.x), r.y < n.y && (r.y = n.y);\n        return {\n          min: e,\n          max: r\n        };\n      }\n      static getPoint(t) {\n        return O.vec2.fromValues(t[0][0].x, t[0][0].y);\n      }\n      static decodeRelativeHeight(t) {\n        return 1e-4 * t * 5;\n      }\n      static decodeMetricHeight(t) {\n        return 1e-4 * t;\n      }\n      static parse(t) {\n        const e = [],\n          r = [],\n          n = t.length,\n          i = new uh();\n        for (let a = 0; a < n; a++) {\n          const n = t.feature(a),\n            o = n.properties.hasOwnProperty(\"version\") ? String(n.properties.version) : void 0,\n            l = (s = o) ? \"1.0.1\" === s ? ph : void 0 : hh;\n          if (void 0 === l) {\n            pt(`Unknown elevation feature version number ${o || \"(unknown)\"}`);\n            continue;\n          }\n          const u = n.properties.hasOwnProperty(\"type\") ? n.properties.type : void 0;\n          if (u) if (\"Point\" === ah.VectorTileFeature.types[n.type] && \"curve_point\" === u) {\n            const t = {};\n            l.parseVertex(i, n, t) && e.push(t);\n          } else if (\"Polygon\" === ah.VectorTileFeature.types[n.type] && \"curve_meta\" === u) {\n            const t = {};\n            l.parseFeature(i, n, t) && r.push(t);\n          }\n        }\n        var s;\n        return {\n          vertices: e,\n          features: r\n        };\n      }\n    }\n    class dh {\n      constructor(t, e, r, n, i, s) {\n        if (this.vertices = new Array(), this.vertexProps = new Array(), this.edges = new Array(), this.edgeProps = new Array(), this.id = t, this.heightRange = {\n          min: r,\n          max: r\n        }, this.safeArea = e, this.constantHeight = r, null == this.constantHeight && (null != this.constantHeight || 0 !== n.length)) {\n          this.vertices = n, this.edges = i, this.edges = this.edges.filter(t => t.a < this.vertices.length && t.b < this.vertices.length && !O.vec2.exactEquals(this.vertices[t.a].position, this.vertices[t.b].position)), this.heightRange = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n          };\n          for (const t of this.vertices) this.vertexProps.push({\n            dir: O.vec2.fromValues(0, 0)\n          }), this.heightRange.min = Math.min(this.heightRange.min, t.height), this.heightRange.max = Math.max(this.heightRange.max, t.height);\n          for (const t of this.edges) {\n            const e = this.vertices[t.a].position,\n              r = this.vertices[t.b].position,\n              n = O.vec2.subtract(O.vec2.create(), r, e),\n              i = O.vec2.length(n),\n              s = O.vec2.scale(O.vec2.create(), n, 1 / i);\n            this.edgeProps.push({\n              vec: n,\n              dir: s,\n              len: i\n            });\n            const a = this.vertexProps[t.a].dir,\n              o = this.vertexProps[t.b].dir;\n            O.vec2.add(a, a, s), O.vec2.add(o, o, s);\n          }\n          for (const t of this.vertexProps) 0 === t.dir[0] && 0 === t.dir[1] || O.vec2.normalize(t.dir, t.dir);\n          this.tessellate(s);\n        }\n      }\n      pointElevation(t) {\n        if (null != this.constantHeight) return this.constantHeight;\n        const e = this.getClosestEdge(t);\n        if (null == e) return 0;\n        const [r, n] = e;\n        return ((t, e, r) => (1 - r) * t + r * e)(this.vertices[this.edges[r].a].height, this.vertices[this.edges[r].b].height, n);\n      }\n      getSafeArea() {\n        return this.safeArea;\n      }\n      isTunnel() {\n        return this.heightRange.max <= -5;\n      }\n      getClosestEdge(t) {\n        if (0 === this.edges.length) return;\n        let e = 0,\n          r = Number.POSITIVE_INFINITY,\n          n = 0;\n        const i = O.vec2.fromValues(t.x, t.y);\n        for (let t = 0; t < this.edges.length; t++) {\n          const s = this.edges[t],\n            a = this.edgeProps[t].dir,\n            o = new yu(i, this.edgeProps[t].dir),\n            l = this.vertices[s.a].position,\n            u = this.vertices[s.b].position,\n            c = O.vec2.create(),\n            h = O.vec2.create(),\n            p = o.intersectsPlane(l, this.vertexProps[s.a].dir, c),\n            f = o.intersectsPlane(u, this.vertexProps[s.b].dir, h);\n          if (!p || !f) continue;\n          const d = O.vec2.subtract(O.vec2.create(), h, c),\n            m = O.vec2.subtract(O.vec2.create(), i, c),\n            y = O.vec2.dot(d, d),\n            g = y > 0 ? O.vec2.dot(m, d) / y : 0,\n            x = Q(g, 0, 1),\n            v = Math.abs((g - x) * this.edgeProps[t].len),\n            b = O.vec2.subtract(O.vec2.create(), i, l),\n            _ = v + Math.abs(O.vec2.dot(b, O.vec2.fromValues(a[1], -a[0])));\n          _ < r && (e = t, r = _, n = x);\n        }\n        return [e, n];\n      }\n      tessellate(t) {\n        for (let e = this.edges.length - 1; e >= 0; --e) {\n          const r = this.edges[e].a,\n            n = this.edges[e].b,\n            {\n              position: i,\n              height: s,\n              extent: a\n            } = this.vertices[r],\n            {\n              position: o,\n              height: l,\n              extent: u\n            } = this.vertices[n],\n            c = this.vertexProps[r].dir,\n            h = this.vertexProps[n].dir,\n            p = O.vec3.fromValues(i[0] / t, i[1] / t, s),\n            f = O.vec3.fromValues(o[0] / t, o[1] / t, l),\n            d = O.vec3.fromValues(c[1], -c[0], 0);\n          O.vec3.scale(d, d, a);\n          const m = O.vec3.fromValues(h[1], -h[0], 0);\n          if (O.vec3.scale(m, m, u), this.distSqLines(O.vec3.fromValues(p[0] + .5 * d[0], p[1] + .5 * d[1], p[2] + .5 * d[2]), O.vec3.fromValues(f[0] - .5 * m[0], f[1] - .5 * m[1], f[2] - .5 * m[2]), O.vec3.fromValues(p[0] - .5 * d[0], p[1] - .5 * d[1], p[2] - .5 * d[2]), O.vec3.fromValues(f[0] + .5 * m[0], f[1] + .5 * m[1], f[2] + .5 * m[2])) <= .05 * .05) continue;\n          const y = this.vertices.length,\n            g = O.vec2.add(O.vec2.create(), i, o);\n          this.vertices.push({\n            position: O.vec2.scale(g, g, .5),\n            height: .5 * (s + l),\n            extent: .5 * (a + u)\n          });\n          const x = O.vec2.add(O.vec2.create(), c, h);\n          this.vertexProps.push({\n            dir: O.vec2.normalize(x, x)\n          }), this.edges.splice(e, 1), this.edgeProps.splice(e, 1), this.edges.push({\n            a: r,\n            b: y\n          }), this.edges.push({\n            a: y,\n            b: n\n          });\n          const v = O.vec2.subtract(O.vec2.create(), this.vertices[y].position, i),\n            b = O.vec2.length(v),\n            _ = {\n              vec: v,\n              dir: O.vec2.scale(O.vec2.create(), v, 1 / b),\n              len: b\n            };\n          this.edgeProps.push(_), this.edgeProps.push(_);\n        }\n      }\n      distSqLines(t, e, r, n) {\n        const i = O.vec3.subtract(O.vec3.create(), e, t),\n          s = O.vec3.subtract(O.vec3.create(), n, r),\n          a = O.vec3.subtract(O.vec3.create(), t, r),\n          o = O.vec3.dot(i, i),\n          l = O.vec3.dot(i, s),\n          u = O.vec3.dot(i, a),\n          c = O.vec3.dot(s, s),\n          h = O.vec3.dot(s, a),\n          p = o * c - l * l;\n        if (0 === p) {\n          const e = O.vec3.dot(a, s) / O.vec3.dot(s, s),\n            i = O.vec3.lerp(O.vec3.create(), r, n, e);\n          return O.vec3.squaredDistance(i, t);\n        }\n        const f = (l * h - u * c) / p,\n          d = (o * h - l * u) / p,\n          m = O.vec3.lerp(O.vec3.create(), t, e, f),\n          y = O.vec3.lerp(O.vec3.create(), r, n, d);\n        return O.vec3.squaredDistance(m, y);\n      }\n    }\n    class mh {\n      constructor(t, e) {\n        this.zScale = 1, this.xOffset = 0, this.yOffset = 0, t.equals(e) || (this.zScale = Math.pow(2, e.z - t.z), this.xOffset = (t.x * this.zScale - e.x) * Kr, this.yOffset = (t.y * this.zScale - e.y) * Kr);\n      }\n      constantElevation(t, e) {\n        if (null != t.constantHeight) return this.computeBiasedHeight(t.constantHeight, e);\n      }\n      pointElevation(t, e, r) {\n        const n = this.constantElevation(e, r);\n        return null != n ? n : (t.x = t.x * this.zScale + this.xOffset, t.y = t.y * this.zScale + this.yOffset, this.computeBiasedHeight(e.pointElevation(t), r));\n      }\n      computeBiasedHeight(t, e) {\n        return e <= 0 ? t : t + e * tt(0, e, t >= 0 ? t : Math.abs(.5 * t));\n      }\n    }\n    us(dh, \"ElevationFeature\");\n    class yh {\n      constructor() {\n        this.polygons = new Map();\n      }\n      add(t, ...e) {\n        this.polygons.has(t) ? this.polygons.get(t).push(...e) : this.polygons.set(t, e);\n      }\n      merge(t) {\n        for (const [e, r] of t.polygons) this.add(e, ...r);\n      }\n    }\n    class gh {\n      constructor() {\n        this.portals = [];\n      }\n      static evaluate(t) {\n        if (0 === t.length) return new gh();\n        let e = [];\n        for (const r of t) e.push(...r.portals);\n        if (0 === e.length) return new gh();\n        const r = (t, e) => t <= 0 && e <= 0 || t >= Kr && e >= Kr;\n        for (const t of e) {\n          const e = t.va,\n            n = t.vb;\n          (r(e.x, n.x) || r(e.y, n.y)) && (t.type = \"border\");\n        }\n        const n = e.filter(t => \"unevaluated\" !== t.type),\n          i = e.filter(t => \"unevaluated\" === t.type);\n        if (0 === i.length) return new gh();\n        i.sort((t, e) => t.hash === e.hash ? t.isTunnel === e.isTunnel ? 0 : t.isTunnel ? -1 : 1 : t.hash < e.hash ? 1 : -1), e = n.concat(i);\n        let s = n.length,\n          a = s,\n          o = s;\n        do {\n          if (a++, a === e.length || e[s].hash !== e[a].hash) {\n            if (a - s == 2) {\n              o < s && (e[o] = e[s], e[s] = null);\n              const t = e[o],\n                r = e[a - 1];\n              t.type = t.isTunnel !== r.isTunnel ? \"tunnel\" : \"polygon\", t.connection = {\n                a: t.connection.a,\n                b: r.connection.a\n              }, o++;\n            }\n            s = a;\n          }\n        } while (s !== e.length);\n        return e.splice(o), e.sort((t, e) => t.hash < e.hash ? 1 : -1), {\n          portals: e\n        };\n      }\n    }\n    us(gh, \"ElevationPortalGraph\"), us(yh, \"ElevationPolygons\");\n    class xh {\n      constructor(t, e, r) {\n        this.outPositions = t, this.outNormals = e, this.outIndices = r, this.vertexLookup = new Map(), this.buffer = new ArrayBuffer(4), this.view = new DataView(this.buffer);\n      }\n      addVertex(t, e, r) {\n        let n = t[2];\n        null != r && (n *= r);\n        const i = this.getVec3Bits(t) << 96n | this.getVec3Bits(e),\n          s = this.vertexLookup.get(i);\n        if (null != s) return s;\n        const a = this.outPositions.length;\n        this.vertexLookup.set(i, a);\n        const o = Math.trunc(16384 * e[0]),\n          l = Math.trunc(16384 * e[1]),\n          u = Math.trunc(16384 * e[2]);\n        return this.outPositions.emplaceBack(t[0], t[1], n), this.outNormals.emplaceBack(o, l, u), a;\n      }\n      addVertices(t, e, ...r) {\n        const n = [];\n        for (const i of r) {\n          const r = this.addVertex(i, t, e);\n          n.push(r);\n        }\n        return n;\n      }\n      addTriangles(t, e, r) {\n        if (e && r) {\n          const n = 1 === r.length,\n            i = O.vec3.fromValues(0, 0, 0);\n          for (let s = 0; s < t.length; s += 3) {\n            const a = e[t[s + 0]],\n              o = e[t[s + 1]],\n              l = e[t[s + 2]],\n              u = n ? r[0] : r[t[s + 1]],\n              c = n ? r[0] : r[t[s + 2]],\n              h = this.addVertex(O.vec3.fromValues(a.x, a.y, n ? r[0] : r[t[s + 0]]), i),\n              p = this.addVertex(O.vec3.fromValues(o.x, o.y, u), i),\n              f = this.addVertex(O.vec3.fromValues(l.x, l.y, c), i);\n            this.outIndices.emplaceBack(h, p, f);\n          }\n        } else for (let e = 0; e < t.length; e += 3) this.outIndices.emplaceBack(t[e + 0], t[e + 1], t[e + 2]);\n      }\n      addQuad(t, e) {\n        const r = this.addVertices(e, void 0, ...t.map(t => O.vec3.fromValues(t.coord.x, t.coord.y, t.height))),\n          [n, i, s, a] = r;\n        this.addTriangles([n, i, s, s, a, n]);\n      }\n      getBits(t) {\n        return this.view.setFloat32(0, t), BigInt(this.view.getUint32(0));\n      }\n      getVec3Bits(t) {\n        return this.getBits(t[0]) << 64n | this.getBits(t[1]) << 32n | this.getBits(t[2]);\n      }\n    }\n    class vh {\n      constructor(t) {\n        this.unevaluatedPortals = new gh(), this.portalPolygons = new yh(), this.vertexHashLookup = new Map(), this.unevalVertices = [], this.unevalHeights = [], this.unevalTriangles = [], this.unevalTunnelTriangles = [], this.unevalEdges = [], this.vertexPositions = new Ia(), this.vertexNormals = new Sa(), this.indexArray = new ja(), this.tileToMeters = Al(t);\n      }\n      addVertices(t, e) {\n        const r = this.unevalVertices.length;\n        for (let r = 0; r < t.length; r++) this.unevalVertices.push(t[r]), this.unevalHeights.push(e[r]);\n        return r;\n      }\n      addTriangles(t, e, r) {\n        const n = r ? this.unevalTunnelTriangles : this.unevalTriangles;\n        for (const r of t) n.push(r + e);\n      }\n      addRenderableRing(t, e, r, n, i) {\n        const s = [new q(i.min.x, i.min.y), new q(i.max.x, i.min.y), new q(i.max.x, i.max.y), new q(i.min.x, i.max.y)];\n        for (let a = 0; a < r - 1; a++) {\n          const r = e + a,\n            o = r + 1,\n            l = this.unevalVertices[r],\n            u = this.unevalVertices[o];\n          if (!(l.x >= i.min.x && l.x <= i.max.x && l.y >= i.min.y && l.y <= i.max.y || u.x >= i.min.x && u.x <= i.max.x && u.y >= i.min.y && u.y <= i.max.y || Zl(l, u, s))) continue;\n          if (this.isOnBorder(l.x, u.x) || this.isOnBorder(l.y, u.y)) continue;\n          const c = vh.computeEdgeHash(this.unevalVertices[r], this.unevalVertices[o]);\n          let h,\n            p = this.vertexHashLookup.get(vh.computePosHash(l));\n          null != p ? h = p.next : (p = this.vertexHashLookup.get(vh.computePosHash(u)), h = null != p ? p.prev : c), this.unevalEdges.push({\n            polygonIdx: t,\n            a: r,\n            b: o,\n            hash: c,\n            portalHash: h,\n            isTunnel: n,\n            type: \"unevaluated\"\n          });\n        }\n      }\n      addPortalCandidates(t, e, r, n, i) {\n        if (0 === e.length) return;\n        this.portalPolygons.add(t, {\n          geometry: e,\n          zLevel: i\n        });\n        const s = e[0];\n        this.vertexHashLookup.clear();\n        let a = vh.computeEdgeHash(s[s.length - 2], s[s.length - 1]);\n        for (let e = 0; e < s.length - 1; e++) {\n          const i = s[e + 0],\n            o = s[e + 1],\n            l = O.vec2.fromValues(o.x - i.x, o.y - i.y),\n            u = O.vec2.length(l);\n          if (0 === u) continue;\n          let c = \"unevaluated\";\n          const h = n.pointElevation(i),\n            p = n.pointElevation(o);\n          Math.abs(h) < .01 && Math.abs(p) < .01 ? c = \"entrance\" : (this.isOnBorder(i.x, o.x) || this.isOnBorder(i.y, o.y)) && (c = \"border\");\n          const f = vh.computeEdgeHash(i, o);\n          this.unevaluatedPortals.portals.push({\n            connection: {\n              a: t,\n              b: void 0\n            },\n            va: i,\n            vb: o,\n            vab: l,\n            length: u,\n            hash: f,\n            isTunnel: r,\n            type: c\n          });\n          const d = vh.computePosHash(i);\n          this.vertexHashLookup.set(d, {\n            prev: a,\n            next: f\n          }), a = f;\n        }\n      }\n      construct(t) {\n        if (0 === this.unevalVertices.length) return;\n        const e = () => ({\n            vertexOffset: 0,\n            primitiveOffset: this.indexArray.length\n          }),\n          r = t => {\n            t.primitiveLength = this.indexArray.length - t.primitiveOffset;\n          },\n          n = new xh(this.vertexPositions, this.vertexNormals, this.indexArray);\n        this.prepareEdges(t.portals, this.unevalEdges);\n        const i = e(),\n          s = e(),\n          a = e(),\n          o = (t, e) => {\n            t.sort((t, r) => t.type === e && r.type !== e ? -1 : t.type !== e && r.type === e ? 1 : 0);\n            const r = t.findIndex(t => t.type !== e);\n            return r >= 0 ? r : t.length;\n          };\n        let l = 0;\n        this.unevalEdges.length > 0 && (l = o(this.unevalEdges, \"none\"), this.constructBridgeStructures(n, this.unevalVertices, this.unevalHeights, this.unevalEdges, {\n          min: 0,\n          max: l\n        }, this.tileToMeters));\n        const u = e();\n        if (this.unevalEdges.length > 0) {\n          const t = this.unevalEdges.splice(l),\n            e = o(t, \"tunnel\") + l;\n          this.unevalEdges.push(...t), this.constructTunnelStructures(n, this.unevalVertices, this.unevalHeights, this.unevalEdges, {\n            min: 0,\n            max: l\n          }, {\n            min: l,\n            max: e\n          });\n        }\n        r(a), n.addTriangles(this.unevalTriangles, this.unevalVertices, this.unevalHeights), r(u), n.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, this.unevalHeights), r(s), n.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, [-.1]), r(i), this.maskSegments = xo.simpleSegment(0, u.primitiveOffset, 0, u.primitiveLength), this.depthSegments = xo.simpleSegment(0, s.primitiveOffset, 0, s.primitiveLength), this.renderableSegments = xo.simpleSegment(0, a.primitiveOffset, 0, a.primitiveLength), this.shadowCasterSegments = xo.simpleSegment(0, i.primitiveOffset, 0, i.primitiveLength);\n      }\n      upload(t) {\n        this.vertexBuffer || 0 === this.vertexPositions.length || 0 === this.vertexNormals.length || 0 === this.indexArray.length || (this.vertexBuffer = t.createVertexBuffer(this.vertexPositions, gc.members), this.vertexBufferNormal = t.createVertexBuffer(this.vertexNormals, xc.members), this.indexBuffer = t.createIndexBuffer(this.indexArray));\n      }\n      destroy() {\n        this.vertexBuffer && (this.vertexBuffer.destroy(), this.vertexBufferNormal.destroy(), this.indexBuffer.destroy()), this.maskSegments && (this.maskSegments.destroy(), this.depthSegments.destroy(), this.renderableSegments.destroy(), this.shadowCasterSegments.destroy());\n      }\n      computeVertexConnections(t, e, r, n) {\n        const i = new Map();\n        for (let s = r; s < n; s++) {\n          const r = e[s],\n            n = r.a,\n            a = r.b;\n          i.has(n) || i.set(n, {}), i.has(a) || i.set(a, {});\n          const o = i.get(n),\n            l = i.get(a);\n          t[a] > 0 && (o.to = a), t[n] > 0 && (l.from = n);\n        }\n        return i;\n      }\n      constructBridgeStructures(t, e, r, n, i, s) {\n        const a = this.computeVertexConnections(r, n, i.min, i.max),\n          o = 1 / s,\n          l = .5 * o,\n          u = t => O.vec3.fromValues(e[t].x, e[t].y, r[t] * o),\n          c = t => {\n            const e = a.get(t),\n              r = e.from,\n              n = e.to;\n            if (!r || !n) return;\n            const i = u(r),\n              s = u(t),\n              o = u(n),\n              l = O.vec3.fromValues(0, 0, 0);\n            if (!O.vec3.exactEquals(i, s)) {\n              const t = O.vec3.sub(O.vec3.create(), s, i);\n              O.vec3.add(l, l, O.vec3.normalize(t, t));\n            }\n            if (!O.vec3.exactEquals(o, s)) {\n              const t = O.vec3.sub(O.vec3.create(), o, s);\n              O.vec3.add(l, l, O.vec3.normalize(t, t));\n            }\n            const c = O.vec3.len(l);\n            return c > 0 ? O.vec3.scale(l, l, 1 / c) : void 0;\n          };\n        for (let a = i.min; a < i.max; a++) {\n          const i = n[a],\n            u = this.prepareEdgePoints(e, r, i, (t, e) => t >= e);\n          if (null == u) continue;\n          const h = u[0],\n            p = u[1],\n            f = O.vec3.fromValues(h.coord.x, h.coord.y, o * h.height),\n            d = O.vec3.fromValues(p.coord.x, p.coord.y, o * p.height);\n          if (O.vec3.exactEquals(f, d)) continue;\n          const m = O.vec3.sub(O.vec3.create(), d, f);\n          O.vec3.normalize(m, m);\n          const y = t => O.vec3.normalize(t, t),\n            g = c(i.a) || m,\n            x = c(i.b) || m,\n            v = y(O.vec3.fromValues(g[1], -g[0], 0)),\n            b = y(O.vec3.fromValues(x[1], -x[0], 0)),\n            _ = y(O.vec3.cross(O.vec3.create(), v, g)),\n            w = y(O.vec3.cross(O.vec3.create(), b, x)),\n            M = O.vec3.create(),\n            A = [O.vec3.add(O.vec3.create(), f, O.vec3.scale(M, O.vec3.sub(M, v, _), l)), O.vec3.add(O.vec3.create(), f, O.vec3.scale(M, O.vec3.add(M, v, _), l)), O.vec3.add(O.vec3.create(), f, O.vec3.scale(M, _, l)), f],\n            I = [O.vec3.add(O.vec3.create(), d, O.vec3.scale(M, O.vec3.sub(M, b, w), l)), O.vec3.add(O.vec3.create(), d, O.vec3.scale(M, O.vec3.add(M, b, w), l)), O.vec3.add(O.vec3.create(), d, O.vec3.scale(M, w, l)), d],\n            [S, P] = t.addVertices(v, s, A[0], A[1]),\n            [E, z] = t.addVertices(b, s, I[0], I[1]);\n          t.addTriangles([S, P, E, P, z, E]);\n          const [k, T] = t.addVertices(_, s, A[1], A[2]),\n            [B, V] = t.addVertices(w, s, I[1], I[2]);\n          t.addTriangles([k, T, B, T, V, B]);\n          const [C, D] = t.addVertices(O.vec3.negate(v, v), s, A[2], A[3]),\n            [R, L] = t.addVertices(O.vec3.negate(b, b), s, I[2], I[3]);\n          t.addTriangles([C, D, R, D, L, R]);\n        }\n      }\n      constructTunnelStructures(t, e, r, n, i, s) {\n        const a = t => O.vec3.normalize(t, t);\n        for (let s = i.min; s < i.max; s++) {\n          const i = this.prepareEdgePoints(e, r, n[s], (t, e) => t <= e);\n          if (null == i) continue;\n          const [o, l] = i,\n            u = a(O.vec3.fromValues(l.coord.y - o.coord.y, -(l.coord.x - o.coord.x), 0));\n          t.addQuad([o, l, {\n            coord: l.coord,\n            height: n[s].isTunnel ? -.1 : 0\n          }, {\n            coord: o.coord,\n            height: n[s].isTunnel ? -.1 : 0\n          }], u);\n        }\n        for (let i = s.min; i < s.max; i++) {\n          const s = n[i],\n            o = e[s.a],\n            l = e[s.b],\n            u = a(O.vec3.fromValues(l.y - o.y, -(l.x - o.x), 0));\n          t.addQuad([{\n            coord: l,\n            height: 0\n          }, {\n            coord: o,\n            height: 0\n          }, {\n            coord: o,\n            height: r[s.a] + 4\n          }, {\n            coord: l,\n            height: r[s.b] + 4\n          }], u), t.addQuad([{\n            coord: o,\n            height: 0\n          }, {\n            coord: l,\n            height: 0\n          }, {\n            coord: l,\n            height: r[s.b] + 4\n          }, {\n            coord: o,\n            height: r[s.a] + 4\n          }], u);\n        }\n      }\n      prepareEdgePoints(t, e, r, n) {\n        const i = t[r.a],\n          s = t[r.b];\n        let a = e[r.a],\n          o = e[r.b];\n        if (!(0 !== a && n(a, 0) || 0 !== o && n(o, 0))) return;\n        const l = i.clone(),\n          u = s.clone();\n        if (n(a, 0)) {\n          if (!n(o, 0)) {\n            const t = o / (o - a);\n            u.x = Ee(u.x, l.x, t), u.y = Ee(u.y, l.y, t), o = Ee(o, a, t);\n          }\n        } else {\n          const t = a / (a - o);\n          l.x = Ee(l.x, u.x, t), l.y = Ee(l.y, u.y, t), a = Ee(a, o, t);\n        }\n        return [{\n          coord: l,\n          height: a\n        }, {\n          coord: u,\n          height: o\n        }];\n      }\n      prepareEdges(t, e) {\n        if (0 === e.length) return;\n        e.sort((t, e) => t.hash === e.hash ? e.polygonIdx - t.polygonIdx : e.hash > t.hash ? 1 : -1);\n        let r = 0,\n          n = 0,\n          i = 0,\n          s = e[r].polygonIdx;\n        do {\n          n++, (n === e.length || e[r].hash !== e[n].hash) && ((1 == n - r || e[n - 1].polygonIdx !== s) && (i < r && (e[i] = e[r], e[r] = null), e[i].type = \"none\", i++), r = n, r !== e.length && (s = e[r].polygonIdx));\n        } while (r !== e.length);\n        if (e.splice(i), 0 !== e.length && 0 !== t.length) {\n          e.sort((t, e) => t.hash < e.hash ? 1 : -1);\n          let r = 0,\n            n = 0;\n          for (; r !== e.length && n !== t.length;) {\n            const i = e[r],\n              s = t[n];\n            i.portalHash > s.hash ? r++ : s.hash > i.portalHash ? n++ : (i.type = s.type, r++);\n          }\n        }\n      }\n      isOnBorder(t, e) {\n        return t <= 0 && e <= 0 || t >= Kr && e >= Kr;\n      }\n      static computeEdgeHash(t, e) {\n        return (t.y === e.y && t.x > e.x || t.y > e.y) && ([t, e] = [e, t]), BigInt(vh.computePosHash(t)) << 32n | BigInt(vh.computePosHash(e));\n      }\n      static computePosHash(t) {\n        return ((65535 & t.x) << 16 | 65535 & t.y) >>> 0;\n      }\n    }\n    class bh {\n      constructor(t, e) {\n        this.layoutVertexArray = new _a(), this.indexArray = new ja(), this.lineIndexArray = new La(), this.triangleSegments = new xo(), this.lineSegments = new xo(), this.programConfigurations = new Go(t.layers, {\n          zoom: t.zoom,\n          lut: t.lut\n        }), this.uploaded = !1, e && (this.elevatedLayoutVertexArray = new Aa());\n      }\n      update(t, e, r, n, i, s, a) {\n        this.programConfigurations.updatePaintArrays(t, e, i, r, n, s, a);\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n      needsUpload() {\n        return this.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, mc.members), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.lineIndexBuffer = t.createIndexBuffer(this.lineIndexArray), this.elevatedLayoutVertexArray && this.elevatedLayoutVertexArray.length > 0 && (this.elevatedLayoutVertexBuffer = t.createVertexBuffer(this.elevatedLayoutVertexArray, yc.members))), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.elevatedLayoutVertexBuffer && this.elevatedLayoutVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.lineIndexBuffer.destroy(), this.programConfigurations.destroy(), this.triangleSegments.destroy(), this.lineSegments.destroy());\n      }\n      populatePaintArrays(t, e, r, n, i, s) {\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, e, r, n, i, s);\n      }\n    }\n    class _h {\n      constructor(t) {\n        this.zoom = t.zoom, this.pixelRatio = t.pixelRatio, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.fqid), this.index = t.index, this.hasPattern = !1, this.patternFeatures = [], this.bufferData = new bh(t, !1), this.elevationBufferData = new bh(t, !0), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.projection = t.projection, this.elevationMode = this.layers[0].layout.get(\"fill-elevation-reference\");\n      }\n      updateFootprints(t, e) {}\n      populate(t, e, r, n) {\n        this.hasPattern = Hc(\"fill\", this.layers, this.pixelRatio, e);\n        const i = this.layers[0].layout.get(\"fill-sort-key\"),\n          s = [];\n        for (const {\n          feature: a,\n          id: o,\n          index: l,\n          sourceLayerIndex: u\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n            c = Cl(a, t);\n          if (!this.layers[0]._featureFilter.filter(new Rs(this.zoom), c, r)) continue;\n          const h = i ? i.evaluate(c, {}, r, e.availableImages) : void 0,\n            p = {\n              id: o,\n              properties: a.properties,\n              type: a.type,\n              sourceLayerIndex: u,\n              index: l,\n              geometry: t ? c.geometry : Vl(a, r, n),\n              patterns: {},\n              sortKey: h\n            };\n          s.push(p);\n        }\n        i && s.sort((t, e) => t.sortKey - e.sortKey);\n        for (const n of s) {\n          const {\n            geometry: i,\n            index: s,\n            sourceLayerIndex: a\n          } = n;\n          if (this.hasPattern) {\n            const t = Xc(\"fill\", this.layers, n, this.zoom, this.pixelRatio, e);\n            this.patternFeatures.push(t);\n          } else this.addFeature(n, i, s, r, {}, e.availableImages, e.brightness, e.elevationFeatures);\n          e.featureIndex.insert(t[s].feature, i, s, a, this.index);\n        }\n      }\n      update(t, e, r, n, i, s, a) {\n        this.bufferData.update(t, e, r, n, i, s, a), this.elevationBufferData.update(t, e, r, n, i, s, a);\n      }\n      addFeatures(t, e, r, n, i, s) {\n        for (const i of this.patternFeatures) this.addFeature(i, i.geometry, i.index, e, r, n, s, t.elevationFeatures);\n      }\n      isEmpty() {\n        return this.bufferData.isEmpty() && this.elevationBufferData.isEmpty();\n      }\n      uploadPending() {\n        return !this.uploaded || this.bufferData.needsUpload() || this.elevationBufferData.needsUpload();\n      }\n      upload(t) {\n        this.bufferData.upload(t), this.elevationBufferData.upload(t), this.elevatedStructures && this.elevatedStructures.upload(t);\n      }\n      destroy() {\n        this.bufferData.destroy(), this.elevationBufferData.destroy(), this.elevatedStructures && this.elevatedStructures.destroy();\n      }\n      addFeature(t, e, r, n, i, s = [], a, o) {\n        const l = $c(e, 500);\n        \"none\" !== this.elevationMode ? this.addElevatedRoadFeature(t, l, n, r, o) : this.addGeometry(l, this.bufferData), this.bufferData.populatePaintArrays(t, r, i, s, n, a), this.elevationBufferData.populatePaintArrays(t, r, i, s, n, a);\n      }\n      getUnevaluatedPortalGraph() {\n        return this.elevatedStructures ? this.elevatedStructures.unevaluatedPortals : void 0;\n      }\n      getElevationPolygons() {\n        return this.elevatedStructures ? this.elevatedStructures.portalPolygons : void 0;\n      }\n      setEvaluatedPortalGraph(t) {\n        this.elevatedStructures && this.elevatedStructures.construct(t);\n      }\n      addElevatedRoadFeature(t, e, r, n, i) {\n        const s = new Array(),\n          a = this.getElevationFeature(t, i);\n        if (a) {\n          s.push({\n            polygons: e,\n            elevationFeature: a,\n            elevationTileID: r\n          });\n          for (const e of s) if (e.elevationFeature) {\n            if (\"hd-road-base\" === this.elevationMode) {\n              this.elevatedStructures || (this.elevatedStructures = new vh(e.elevationTileID));\n              const r = e.elevationFeature.isTunnel();\n              let n = 0;\n              t.properties.hasOwnProperty(lh) && (n = +t.properties[lh]);\n              for (const t of e.polygons) this.elevatedStructures.addPortalCandidates(e.elevationFeature.id, t, r, e.elevationFeature, n);\n            }\n            const i = new mh(r, e.elevationTileID);\n            this.addElevatedGeometry(e.polygons, i, e.elevationFeature, \"hd-road-base\" === this.elevationMode ? 0 : .05, n);\n          }\n        } else this.addGeometry(e, this.bufferData);\n      }\n      addElevatedGeometry(t, e, r, n, i) {\n        const s = {\n            elevation: r,\n            elevationSampler: e,\n            bias: n,\n            index: i\n          },\n          [a, o] = this.addGeometry(t, this.elevationBufferData, s);\n        null == this.elevationBufferData.heightRange ? this.elevationBufferData.heightRange = {\n          min: a,\n          max: o\n        } : (this.elevationBufferData.heightRange.min = Math.min(this.elevationBufferData.heightRange.min, a), this.elevationBufferData.heightRange.max = Math.max(this.elevationBufferData.heightRange.max, o));\n      }\n      addGeometry(t, e, r) {\n        let n = Number.POSITIVE_INFINITY,\n          i = Number.NEGATIVE_INFINITY,\n          s = null;\n        r && (s = r.elevationSampler.constantElevation(r.elevation, r.bias), null != s && (n = s, i = s));\n        const a = (t, a, o) => {\n          if (null != r) if (a.push(t), null != s) e.elevatedLayoutVertexArray.emplaceBack(s), o.push(s);else {\n            const s = r.elevationSampler.pointElevation(t, r.elevation, r.bias);\n            e.elevatedLayoutVertexArray.emplaceBack(s), o.push(s), n = Math.min(n, s), i = Math.max(i, s);\n          }\n        };\n        for (const n of t) {\n          let t = 0;\n          for (const e of n) t += e.length;\n          const i = e.triangleSegments.prepareSegment(t, e.layoutVertexArray, e.indexArray),\n            s = i.vertexLength,\n            o = [],\n            l = [],\n            u = [],\n            c = [],\n            h = [],\n            p = e.layoutVertexArray.length;\n          for (const t of n) {\n            if (0 === t.length) continue;\n            t !== n[0] && l.push(o.length / 2);\n            const i = e.lineSegments.prepareSegment(t.length, e.layoutVertexArray, e.lineIndexArray),\n              s = i.vertexLength;\n            r && h.push(e.layoutVertexArray.length - p), a(t[0], u, c), e.layoutVertexArray.emplaceBack(t[0].x, t[0].y), e.lineIndexArray.emplaceBack(s + t.length - 1, s), o.push(t[0].x), o.push(t[0].y);\n            for (let r = 1; r < t.length; r++) a(t[r], u, c), e.layoutVertexArray.emplaceBack(t[r].x, t[r].y), e.lineIndexArray.emplaceBack(s + r - 1, s + r), o.push(t[r].x), o.push(t[r].y);\n            i.vertexLength += t.length, i.primitiveLength += t.length;\n          }\n          const f = vc(o, l);\n          for (let t = 0; t < f.length; t += 3) e.indexArray.emplaceBack(s + f[t], s + f[t + 1], s + f[t + 2]);\n          if (r && \"hd-road-base\" === this.elevationMode) {\n            const t = r.elevation.isTunnel(),\n              e = r.elevation.safeArea,\n              n = this.elevatedStructures.addVertices(u, c);\n            this.elevatedStructures.addTriangles(f, n, t);\n            const i = h.length;\n            if (i > 0) {\n              for (let s = 0; s < i - 1; s++) this.elevatedStructures.addRenderableRing(r.index, h[s] + n, h[s + 1] - h[s], t, e);\n              this.elevatedStructures.addRenderableRing(r.index, h[i - 1] + n, u.length - h[i - 1], t, e);\n            }\n          }\n          i.vertexLength += t, i.primitiveLength += f.length / 3;\n        }\n        return [n, i];\n      }\n      getElevationFeature(t, e) {\n        if (!e) return;\n        const r = +t.properties[oh];\n        return null != r ? e.find(t => t.id === r) : void 0;\n      }\n    }\n    let wh, Mh, Ah, Ih;\n    us(_h, \"FillBucket\", {\n      omit: [\"layers\", \"patternFeatures\"]\n    }), us(bh, \"FillBufferData\"), us(vh, \"ElevatedStructures\");\n    class Sh {\n      constructor(t, e, r, n) {\n        if (this.triangleCount = e.length / 3, this.min = new q(0, 0), this.max = new q(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], 0 === this.triangleCount || 0 === t.length) return;\n        const [i, s] = [t[0].clone(), t[0].clone()];\n        for (let e = 1; e < t.length; ++e) {\n          const r = t[e];\n          i.x = Math.min(i.x, r.x), i.y = Math.min(i.y, r.y), s.x = Math.max(s.x, r.x), s.y = Math.max(s.y, r.y);\n        }\n        if (n) {\n          const t = Math.ceil(Math.max(s.x - i.x, s.y - i.y) / n);\n          r = Math.max(r, t);\n        }\n        if (0 === r) return;\n        this.min = i, this.max = s;\n        const a = this.max.sub(this.min);\n        a.x = Math.max(a.x, 1), a.y = Math.max(a.y, 1);\n        const o = Math.max(a.x, a.y) / r;\n        this.cellsX = Math.max(1, Math.ceil(a.x / o)), this.cellsY = Math.max(1, Math.ceil(a.y / o)), this.xScale = 1 / o, this.yScale = 1 / o;\n        const l = [];\n        for (let r = 0; r < this.triangleCount; r++) {\n          const n = t[e[3 * r + 0]].sub(this.min),\n            i = t[e[3 * r + 1]].sub(this.min),\n            s = t[e[3 * r + 2]].sub(this.min),\n            a = Ph(Math.floor(Math.min(n.x, i.x, s.x)), this.xScale, this.cellsX),\n            u = Ph(Math.floor(Math.max(n.x, i.x, s.x)), this.xScale, this.cellsX),\n            c = Ph(Math.floor(Math.min(n.y, i.y, s.y)), this.yScale, this.cellsY),\n            h = Ph(Math.floor(Math.max(n.y, i.y, s.y)), this.yScale, this.cellsY),\n            p = new q(0, 0),\n            f = new q(0, 0),\n            d = new q(0, 0),\n            m = new q(0, 0);\n          for (let t = c; t <= h; ++t) {\n            p.y = f.y = t * o, d.y = m.y = (t + 1) * o;\n            for (let e = a; e <= u; ++e) p.x = d.x = e * o, f.x = m.x = (e + 1) * o, (Kl(n, i, s, p, f, m) || Kl(n, i, s, p, m, d)) && l.push({\n              cellIdx: t * this.cellsX + e,\n              triIdx: r\n            });\n          }\n        }\n        if (0 === l.length) return;\n        l.sort((t, e) => t.cellIdx - e.cellIdx || t.triIdx - e.triIdx);\n        let u = 0;\n        for (; u < l.length;) {\n          const t = l[u].cellIdx,\n            e = {\n              start: this.payload.length,\n              len: 0\n            };\n          for (; u < l.length && l[u].cellIdx === t;) ++e.len, this.payload.push(l[u++].triIdx);\n          this.cells[t] = e;\n        }\n      }\n      _lazyInitLookup() {\n        this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8))), this.lookup.fill(0);\n      }\n      queryPoint(t, e) {\n        if (0 === this.triangleCount || 0 === this.cells.length) return;\n        if (t.x > this.max.x || this.min.x > t.x || t.y > this.max.y || this.min.y > t.y) return;\n        const r = Ph(t.x - this.min.x, this.xScale, this.cellsX),\n          n = Ph(t.y - this.min.y, this.yScale, this.cellsY),\n          i = this.cells[n * this.cellsX + r];\n        if (i) {\n          this._lazyInitLookup();\n          for (let t = 0; t < i.len; t++) {\n            const r = this.payload[i.start + t],\n              n = Math.floor(r / 8),\n              s = 1 << r % 8;\n            if (!(this.lookup[n] & s) && (this.lookup[n] |= s, e.push(r), e.length === this.triangleCount)) return;\n          }\n        }\n      }\n      query(t, e, r) {\n        if (0 === this.triangleCount || 0 === this.cells.length) return;\n        if (t.x > this.max.x || this.min.x > e.x) return;\n        if (t.y > this.max.y || this.min.y > e.y) return;\n        this._lazyInitLookup();\n        const n = Ph(t.x - this.min.x, this.xScale, this.cellsX),\n          i = Ph(e.x - this.min.x, this.xScale, this.cellsX),\n          s = Ph(t.y - this.min.y, this.yScale, this.cellsY),\n          a = Ph(e.y - this.min.y, this.yScale, this.cellsY);\n        for (let t = s; t <= a; t++) for (let e = n; e <= i; e++) {\n          const n = this.cells[t * this.cellsX + e];\n          if (n) for (let t = 0; t < n.len; t++) {\n            const e = this.payload[n.start + t],\n              i = Math.floor(e / 8),\n              s = 1 << e % 8;\n            if (!(this.lookup[i] & s) && (this.lookup[i] |= s, r.push(e), r.length === this.triangleCount)) return;\n          }\n        }\n      }\n    }\n    function Ph(t, e, r) {\n      return Math.max(0, Math.min(r - 1, Math.floor(t * e)));\n    }\n    us(Sh, \"TriangleGridIndex\");\n    class Eh {\n      constructor(t) {\n        this.zoom = t.zoom, this.layers = t.layers, this.layerIds = this.layers.map(t => t.fqid), this.index = t.index, this.hasPattern = !1, this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.footprints = [];\n      }\n      updateFootprints(t, e) {\n        for (const r of this.footprints) e.push({\n          footprint: r,\n          id: t\n        });\n      }\n      populate(t, e, r, n) {\n        const i = [];\n        for (const {\n          feature: e,\n          id: s,\n          index: a,\n          sourceLayerIndex: o\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n            l = Cl(e, t);\n          if (!this.layers[0]._featureFilter.filter(new Rs(this.zoom), l, r)) continue;\n          const u = {\n            id: s,\n            properties: e.properties,\n            type: e.type,\n            sourceLayerIndex: o,\n            index: a,\n            geometry: t ? l.geometry : Vl(e, r, n),\n            patterns: {}\n          };\n          i.push(u);\n        }\n        for (const n of i) {\n          const {\n            geometry: i,\n            index: s,\n            sourceLayerIndex: a\n          } = n;\n          this.addFeature(n, i, s, r, {}, e.availableImages, e.brightness), e.featureIndex.insert(t[s].feature, i, s, a, this.index);\n        }\n      }\n      isEmpty() {\n        return 0 === this.footprints.length;\n      }\n      uploadPending() {\n        return !1;\n      }\n      upload(t) {}\n      update(t, e, r, n, i, s, a) {}\n      destroy() {}\n      addFeature(t, e, r, n, i, s = [], a) {\n        for (const t of $c(e, 2)) {\n          const e = [],\n            r = [],\n            n = [],\n            i = new q(1 / 0, 1 / 0),\n            s = new q(-1 / 0, -1 / 0);\n          for (const a of t) if (0 !== a.length) {\n            a !== t[0] && n.push(r.length / 2);\n            for (let t = 0; t < a.length; t++) r.push(a[t].x), r.push(a[t].y), e.push(a[t]), i.x = Math.min(i.x, a[t].x), i.y = Math.min(i.y, a[t].y), s.x = Math.max(s.x, a[t].x), s.y = Math.max(s.y, a[t].y);\n          }\n          const a = vc(r, n),\n            o = new Sh(e, a, 8, 256);\n          this.footprints.push({\n            vertices: e,\n            indices: a,\n            grid: o,\n            min: i,\n            max: s\n          });\n        }\n      }\n    }\n    us(Eh, \"ClipBucket\", {\n      omit: [\"layers\"]\n    });\n    const zh = va([{\n        name: \"a_pos_normal_ed\",\n        components: 4,\n        type: \"Int16\"\n      }]),\n      kh = va([{\n        name: \"a_pos_end\",\n        components: 4,\n        type: \"Int16\"\n      }, {\n        name: \"a_angular_offset_factor\",\n        components: 1,\n        type: \"Int16\"\n      }]),\n      Th = va([{\n        name: \"a_centroid_pos\",\n        components: 2,\n        type: \"Uint16\"\n      }]),\n      Bh = va([{\n        name: \"a_join_normal_inside\",\n        components: 3,\n        type: \"Int16\"\n      }]),\n      Vh = va([{\n        name: \"a_hidden_by_landmark\",\n        components: 1,\n        type: \"Uint8\"\n      }]),\n      Ch = va([{\n        name: \"a_pos_3\",\n        components: 3,\n        type: \"Int16\"\n      }, {\n        name: \"a_pos_normal_3\",\n        components: 3,\n        type: \"Int16\"\n      }]),\n      {\n        members: Dh\n      } = zh;\n    class Rh extends q {\n      constructor(t, e, r) {\n        super(t, e), this.z = r;\n      }\n    }\n    class Lh extends Rh {\n      constructor(t, e, r, n) {\n        super(t, e, r), this.w = n;\n      }\n    }\n    function Fh(t, e, r, n) {\n      const i = [],\n        s = 0 === n ? (t, e, r, n, i, s) => {\n          t.push(new q(s, r + (s - e) / (n - e) * (i - r)));\n        } : (t, e, r, n, i, s) => {\n          t.push(new q(e + (s - r) / (i - r) * (n - e), s));\n        };\n      for (const a of t) {\n        const t = [];\n        for (const i of a) {\n          if (i.length <= 2) continue;\n          const a = [];\n          for (let t = 0; t < i.length - 1; t++) {\n            const o = i[t].x,\n              l = i[t].y,\n              u = i[t + 1].x,\n              c = i[t + 1].y,\n              h = 0 === n ? o : l,\n              p = 0 === n ? u : c;\n            h < e ? p > e && s(a, o, l, u, c, e) : h > r ? p < r && s(a, o, l, u, c, r) : a.push(i[t]), p < e && h >= e && s(a, o, l, u, c, e), p > r && h <= r && s(a, o, l, u, c, r);\n          }\n          let o = i[i.length - 1];\n          const l = 0 === n ? o.x : o.y;\n          l >= e && l <= r && a.push(o), a.length && (o = a[a.length - 1], a[0].x === o.x && a[0].y === o.y || a.push(a[0]), t.push(a));\n        }\n        t.length && i.push(t);\n      }\n      return i;\n    }\n    function Oh(t, e, r, n) {\n      const i = \"x\" === r ? \"y\" : \"x\",\n        s = (n - t[r]) / (e[r] - t[r]);\n      t[i] = t[i] + (e[i] - t[i]) * s, t[r] = n, t.hasOwnProperty(\"z\") && (t.z = Ee(t.z, e.z, s)), t.hasOwnProperty(\"w\") && (t.w = Ee(t.w, e.w, s));\n    }\n    function Nh(t, e, r, n) {\n      const i = r,\n        s = n;\n      for (const r of [\"x\", \"y\"]) {\n        let n = t,\n          a = e;\n        n[r] >= a[r] && (n = e, a = t), n[r] < i && a[r] > i && Oh(n, a, r, i), n[r] < s && a[r] > s && Oh(a, n, r, s);\n      }\n    }\n    const Uh = Number.MAX_SAFE_INTEGER;\n    function jh(t, e, r, n) {\n      return t.order < e || t.order === Uh || !(t.clipMask & r) || function (t, e) {\n        return 0 !== e.length && void 0 === e.find(e => e === t);\n      }(n, t.clipScope);\n    }\n    function qh(t, e) {\n      return t.x - e.x || t.y - e.y;\n    }\n    function $h(t, e) {\n      return 0 === qh(t.min, e.min) && 0 === qh(t.max, e.max);\n    }\n    function Gh(t, e) {\n      return !(t.min.x > e.max.x || t.max.x < e.min.x || t.min.y > e.max.y || t.max.y < e.min.y);\n    }\n    function Yh(t, e) {\n      if (t.length !== e.length) return !1;\n      for (let r = 0; r < t.length; r++) if (t[r].sourceId !== e[r].sourceId || !$h(t[r], e[r]) || t[r].order !== e[r].order || t[r].clipMask !== e[r].clipMask || !$(t[r].clipScope, e[r].clipScope)) return !1;\n      return !0;\n    }\n    function Hh(t, e, r) {\n      const n = 1 / Kr,\n        i = 1 / (1 << r.canonical.z),\n        s = (e.x * n + r.canonical.x) * i + r.wrap,\n        a = (e.y * n + r.canonical.y) * i;\n      return {\n        min: new q((t.x * n + r.canonical.x) * i + r.wrap, (t.y * n + r.canonical.y) * i),\n        max: new q(s, a)\n      };\n    }\n    function Xh(t, e, r) {\n      const n = 1 << r.canonical.z,\n        i = ((e.x - r.wrap) * n - r.canonical.x) * Kr,\n        s = (e.y * n - r.canonical.y) * Kr;\n      return {\n        min: new q(((t.x - r.wrap) * n - r.canonical.x) * Kr, (t.y * n - r.canonical.y) * Kr),\n        max: new q(i, s)\n      };\n    }\n    function Zh(t, e, r, n, i, s, a) {\n      const o = t.indices,\n        l = t.vertices,\n        u = [];\n      for (let c = n; c < n + i; c += 3) {\n        const n = e[r[c + 0] + s],\n          i = e[r[c + 1] + s],\n          h = e[r[c + 2] + s],\n          p = Math.min(n.x, i.x, h.x),\n          f = Math.max(n.x, i.x, h.x),\n          d = Math.min(n.y, i.y, h.y),\n          m = Math.max(n.y, i.y, h.y);\n        u.length = 0, t.grid.query(new q(p, d), new q(f, m), u);\n        for (let t = 0; t < u.length; t++) {\n          const e = u[t];\n          if (Kl(l[o[3 * e + 0]], l[o[3 * e + 1]], l[o[3 * e + 2]], n, i, h, a)) return !0;\n        }\n      }\n      return !1;\n    }\n    function Wh(t, e, r, n) {\n      if (!t || !r) return !1;\n      let i = t.vertices;\n      if (!e.canonical.equals(n.canonical) || e.wrap !== n.wrap) {\n        if (r.vertices.length < t.vertices.length) return Wh(r, n, t, e);\n        const s = e.canonical,\n          a = n.canonical,\n          o = Math.pow(2, a.z - s.z);\n        i = t.vertices.map(t => new q((t.x + s.x * Kr) * o - a.x * Kr, (t.y + s.y * Kr) * o - a.y * Kr));\n      }\n      return Zh(r, i, t.indices, 0, t.indices.length, 0, 0);\n    }\n    function Kh(t, e, r, n) {\n      const i = Math.pow(2, n.z - r.z);\n      return new q((t + r.x * Kr) * i - n.x * Kr, (e + r.y * Kr) * i - n.y * Kr);\n    }\n    function Jh(t, e) {\n      const r = [];\n      e.grid.queryPoint(t, r);\n      const n = e.indices,\n        i = e.vertices;\n      for (let e = 0; e < r.length; e++) {\n        const s = r[e];\n        if (Hl([i[n[3 * s + 0]], i[n[3 * s + 1]], i[n[3 * s + 2]]], t)) return !0;\n      }\n      return !1;\n    }\n    const Qh = [new q(0, 0), new q(Kr, 0), new q(Kr, Kr), new q(0, Kr)];\n    function tp(t, e) {\n      const r = [];\n      let n = [];\n      if (!e || t.length < 2) return [t];\n      if (2 === t.length) return Zl(t[0], t[1], Qh) ? [t] : [];\n      for (let e = 0; e < t.length + 2; e++) {\n        const i = t[e % t.length],\n          s = t[(e + 1) % t.length],\n          a = Zl(0 === e ? t[t.length - 1] : t[(e - 1) % t.length], i, Qh),\n          o = Zl(i, s, Qh),\n          l = a || o;\n        l && n.push(i), l && o || n.length > 0 && (n.length > 1 && r.push(n), n = []);\n      }\n      return n.length > 1 && r.push(n), r;\n    }\n    const ep = ah.VectorTileFeature.types,\n      rp = [\"fill-extrusion-base\", \"fill-extrusion-height\", \"fill-extrusion-color\", \"fill-extrusion-pattern\", \"fill-extrusion-flood-light-wall-radius\", \"fill-extrusion-line-width\", \"fill-extrusion-emissive-strength\"],\n      np = [\"fill-extrusion-flood-light-ground-radius\"],\n      ip = Math.pow(2, 13),\n      sp = Math.pow(2, 15) - 1,\n      ap = new q(0, 1),\n      op = 2147483648;\n    function lp(t, e, r, n, i, s, a, o) {\n      t.emplaceBack((e << 1) + a, (r << 1) + s, (Math.floor(n * ip) << 1) + i, Math.round(o));\n    }\n    function up(t, e, r) {\n      t.emplaceBack(e.x * Kr, e.y * Kr, r ? 1 : 0);\n    }\n    function cp(t, e, r, n, i, s) {\n      t.emplaceBack(e.x, e.y, (r.x << 1) + n, (r.y << 1) + i, s);\n    }\n    function hp(t, e, r) {\n      const n = 16384;\n      t.emplaceBack(e.x, e.y, e.z, r[0] * n, r[1] * n, r[2] * n);\n    }\n    class pp {\n      constructor() {\n        this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;\n      }\n    }\n    class fp {\n      constructor() {\n        this.centroidXY = new q(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new q(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new q(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0;\n      }\n      span() {\n        return new q(this.max.x - this.min.x, this.max.y - this.min.y);\n      }\n    }\n    class dp {\n      constructor() {\n        this.acc = new q(0, 0), this.accCount = 0, this.centroidDataIndex = 0;\n      }\n      startRing(t, e) {\n        t.min.x === Number.MAX_VALUE && (t.min.x = t.max.x = e.x, t.min.y = t.max.y = e.y);\n      }\n      appendEdge(t, e, r) {\n        this.accCount++, this.acc._add(e);\n        let n = !!this.borders;\n        e.x < t.min.x ? (t.min.x = e.x, n = !0) : e.x > t.max.x && (t.max.x = e.x, n = !0), e.y < t.min.y ? (t.min.y = e.y, n = !0) : e.y > t.max.y && (t.max.y = e.y, n = !0), ((0 === e.x || e.x === Kr) && e.x === r.x) != ((0 === e.y || e.y === Kr) && e.y === r.y) && this.processBorderOverlap(e, r), n && this.checkBorderIntersection(e, r);\n      }\n      checkBorderIntersection(t, e) {\n        e.x < 0 != t.x < 0 && this.addBorderIntersection(0, Ee(e.y, t.y, (0 - e.x) / (t.x - e.x))), e.x > Kr != t.x > Kr && this.addBorderIntersection(1, Ee(e.y, t.y, (Kr - e.x) / (t.x - e.x))), e.y < 0 != t.y < 0 && this.addBorderIntersection(2, Ee(e.x, t.x, (0 - e.y) / (t.y - e.y))), e.y > Kr != t.y > Kr && this.addBorderIntersection(3, Ee(e.x, t.x, (Kr - e.y) / (t.y - e.y)));\n      }\n      addBorderIntersection(t, e) {\n        this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);\n        const r = this.borders[t];\n        e < r[0] && (r[0] = e), e > r[1] && (r[1] = e);\n      }\n      processBorderOverlap(t, e) {\n        if (t.x === e.x) {\n          if (t.y === e.y) return;\n          const r = 0 === t.x ? 0 : 1;\n          this.addBorderIntersection(r, e.y), this.addBorderIntersection(r, t.y);\n        } else {\n          const r = 0 === t.y ? 2 : 3;\n          this.addBorderIntersection(r, e.x), this.addBorderIntersection(r, t.x);\n        }\n      }\n      centroid() {\n        return 0 === this.accCount ? new q(0, 0) : new q(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));\n      }\n      intersectsCount() {\n        return this.borders ? this.borders.reduce((t, e) => t + +(e[0] !== Number.MAX_VALUE), 0) : 0;\n      }\n    }\n    function mp(t, e) {\n      const r = t.add(e)._unit(),\n        n = Q(t.x * r.x + t.y * r.y, -1, 1);\n      var i, s, a;\n      return a = Math.acos(n), Math.min(4, Math.max(-4, Math.tan(a))) / 4 * sp * ((i = t).x * (s = e).y - i.y * s.x < 0 ? -1 : 1);\n    }\n    const yp = [t => t.x < 0, t => t.x > Kr, t => t.y < 0, t => t.y > Kr];\n    function gp(t, e, r, n) {\n      const i = [4];\n      if (0 === n) return i;\n      r._mult(n);\n      const s = t.sub(r),\n        a = e.sub(r),\n        o = [t, e, s, a];\n      for (let t = 0; t < 4; t++) for (const e of o) if (yp[t](e)) {\n        i.push(t);\n        break;\n      }\n      return i;\n    }\n    class xp {\n      constructor(t) {\n        this.vertexArray = new Pa(), this.indexArray = new ja(), this.programConfigurations = new Go(t.layers, {\n          zoom: t.zoom,\n          lut: t.lut\n        }, t => np.includes(t)), this._segments = new xo(), this.hiddenByLandmarkVertexArray = new eo(), this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0], this.regionSegments = {}, this.regionSegments[4] = new xo();\n      }\n      getDefaultSegment() {\n        return this.regionSegments[4];\n      }\n      hasData() {\n        return 0 !== this.vertexArray.length;\n      }\n      addData(t, e, r, n = !1) {\n        const i = t.length;\n        if (i > 2) {\n          let s = Math.max(0, this._segments.get().length - 1);\n          const a = this._segments._prepareSegment(4 * i, this.vertexArray.length, 2 * this._segmentToGroundQuads[s].length);\n          let o;\n          s !== this._segments.get().length - 1 && (s++, this._segmentToGroundQuads[s] = [], this._segmentToRegionTriCounts[s] = [0, 0, 0, 0, 0]);\n          {\n            const e = t[0],\n              r = t[1];\n            o = mp(e.sub(t[i - 1])._perp()._unit(), r.sub(e)._perp()._unit());\n          }\n          for (let l = 0; l < i; l++) {\n            const u = l === i - 1 ? 0 : l + 1,\n              c = t[l],\n              h = t[u],\n              p = t[u === i - 1 ? 0 : u + 1],\n              f = h.sub(c)._perp()._unit(),\n              d = mp(f, p.sub(h)._perp()._unit()),\n              m = o,\n              y = d;\n            if (Mp(c, h, e) || n && Ap(c, e) && Ap(h, e)) {\n              o = d;\n              continue;\n            }\n            const g = a.vertexLength;\n            cp(this.vertexArray, c, h, 1, 1, m), cp(this.vertexArray, c, h, 1, 0, m), cp(this.vertexArray, c, h, 0, 1, y), cp(this.vertexArray, c, h, 0, 0, y), a.vertexLength += 4;\n            const x = gp(c, h, f, r);\n            for (const t of x) this._segmentToGroundQuads[s].push({\n              id: g,\n              region: t\n            }), this._segmentToRegionTriCounts[s][t] += 2, a.primitiveLength += 2;\n            o = d;\n          }\n        }\n      }\n      prepareBorderSegments() {\n        if (!this.hasData()) return;\n        const t = this._segments.get(),\n          e = t.length;\n        for (let t = 0; t < e; t++) this._segmentToGroundQuads[t].sort((t, e) => t.region - e.region);\n        for (let r = 0; r < e; r++) {\n          const e = this._segmentToGroundQuads[r],\n            n = t[r],\n            i = this._segmentToRegionTriCounts[r];\n          i.reduce((t, e) => t + e, 0);\n          let s = 0;\n          for (let t = 0; t <= 4; t++) {\n            const e = i[t];\n            if (0 !== e) {\n              let r = this.regionSegments[t];\n              r || (r = this.regionSegments[t] = new xo());\n              const i = {\n                vertexOffset: n.vertexOffset,\n                primitiveOffset: n.primitiveOffset + s,\n                vertexLength: n.vertexLength,\n                primitiveLength: e\n              };\n              r.get().push(i);\n            }\n            s += e;\n          }\n          for (let t = 0; t < e.length; t++) {\n            const r = e[t].id;\n            this.indexArray.emplaceBack(r, r + 1, r + 3), this.indexArray.emplaceBack(r, r + 3, r + 2);\n          }\n        }\n        this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;\n      }\n      addPaintPropertiesData(t, e, r, n, i, s) {\n        this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, t, e, r, n, i, s);\n      }\n      upload(t) {\n        this.hasData() && (this.vertexBuffer = t.createVertexBuffer(this.vertexArray, kh.members), this.indexBuffer = t.createIndexBuffer(this.indexArray));\n      }\n      uploadPaintProperties(t) {\n        this.hasData() && this.programConfigurations.upload(t);\n      }\n      update(t, e, r, n, i, s, a) {\n        this.hasData() && this.programConfigurations.updatePaintArrays(t, e, r, n, i, s, a);\n      }\n      updateHiddenByLandmark(t) {\n        if (!this.hasData()) return;\n        const e = t.groundVertexCount + t.groundVertexArrayOffset;\n        if (0 === t.groundVertexCount) return;\n        const r = t.flags & op ? 1 : 0;\n        for (let n = t.groundVertexArrayOffset; n < e; ++n) this.hiddenByLandmarkVertexArray.emplace(n, r);\n        this._needsHiddenByLandmarkUpdate = !0;\n      }\n      uploadHiddenByLandmark(t) {\n        this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = t.createVertexBuffer(this.hiddenByLandmarkVertexArray, Vh.members, !0) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = !1);\n      }\n      destroy() {\n        if (this.vertexBuffer) {\n          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();\n          for (let t = 0; t <= 4; t++) {\n            const e = this.regionSegments[t];\n            e && e.destroy();\n          }\n        }\n      }\n    }\n    class vp {\n      constructor(t) {\n        this.zoom = t.zoom, this.canonical = t.canonical, this.overscaling = t.overscaling, this.layers = t.layers, this.pixelRatio = t.pixelRatio, this.layerIds = this.layers.map(t => t.fqid), this.index = t.index, this.hasPattern = !1, this.edgeRadius = 0, this.projection = t.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new ja(), this.footprintVertices = new _a(), this.footprintSegments = [], this.layoutVertexArray = new Ma(), this.centroidVertexArray = new po(), this.wallVertexArray = new mo(), this.indexArray = new ja(), this.programConfigurations = new Go(t.layers, {\n          zoom: t.zoom,\n          lut: t.lut\n        }, t => rp.includes(t)), this.segments = new xo(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.groundEffect = new xp(t), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [];\n      }\n      updateFootprints(t, e) {}\n      populate(t, e, r, n) {\n        this.features = [], this.hasPattern = Hc(\"fill-extrusion\", this.layers, this.pixelRatio, e), this.featuresOnBorder = [], this.borderFeatureIndices = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.selfDEMTileTimestamp = Number.MAX_VALUE, this.borderDEMTileTimestamp = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], this.tileToMeter = Al(r), this.edgeRadius = this.layers[0].layout.get(\"fill-extrusion-edge-radius\") / this.tileToMeter, this.wallMode = 0 !== this.layers[0].paint.get(\"fill-extrusion-line-width\").constantOr(1);\n        for (const {\n          feature: i,\n          id: s,\n          index: a,\n          sourceLayerIndex: o\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n            l = Cl(i, t);\n          if (!this.layers[0]._featureFilter.filter(new Rs(this.zoom), l, r)) continue;\n          const u = {\n              id: s,\n              sourceLayerIndex: o,\n              index: a,\n              geometry: t ? l.geometry : Vl(i, r, n),\n              properties: i.properties,\n              type: i.type,\n              patterns: {}\n            },\n            c = this.layoutVertexArray.length,\n            h = \"Polygon\" === ep[u.type];\n          if (this.hasPattern) this.features.push(Xc(\"fill-extrusion\", this.layers, u, this.zoom, this.pixelRatio, e));else if (this.wallMode) for (const t of u.geometry) for (const i of tp(t, h)) this.addFeature(u, [i], a, r, {}, e.availableImages, n, e.brightness);else this.addFeature(u, u.geometry, a, r, {}, e.availableImages, n, e.brightness);\n          e.featureIndex.insert(i, u.geometry, a, o, this.index, c);\n        }\n        this.sortBorders(), \"mercator\" === this.projection.name && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;\n      }\n      addFeatures(t, e, r, n, i, s) {\n        for (const t of this.features) {\n          const a = \"Polygon\" === ep[t.type],\n            {\n              geometry: o\n            } = t;\n          if (this.wallMode) for (const l of o) for (const o of tp(l, a)) this.addFeature(t, [o], t.index, e, r, n, i, s);else this.addFeature(t, o, t.index, e, r, n, i, s);\n        }\n        this.sortBorders(), \"mercator\" === this.projection.name && this.splitToSubtiles();\n      }\n      update(t, e, r, n, i, s, a) {\n        this.programConfigurations.updatePaintArrays(t, e, i, r, n, s, a), this.groundEffect.update(t, e, i, r, n, s, a);\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Dh), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.wallVertexBuffer = t.createVertexBuffer(this.wallVertexArray, Bh.members), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t.createVertexBuffer(this.layoutVertexExtArray, Ch.members, !0)), this.groundEffect.upload(t)), this.groundEffect.uploadPaintProperties(t), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n      uploadCentroid(t) {\n        this.groundEffect.uploadHiddenByLandmark(t), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, Th.members, !0) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = !1);\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n      }\n      addFeature(t, e, r, n, i, s, a, o) {\n        const l = this.layers[0].paint.get(\"fill-extrusion-flood-light-ground-radius\").evaluate(t, {}) / this.tileToMeter,\n          u = [new q(0, 0), new q(Kr, Kr)],\n          c = a.projection,\n          h = \"globe\" === c.name,\n          p = this.wallMode || \"Polygon\" === ep[t.type],\n          f = new dp();\n        f.centroidDataIndex = this.centroidData.length;\n        const d = new fp(),\n          m = this.layers[0].paint.get(\"fill-extrusion-base\").evaluate(t, {}, n) <= 0,\n          y = this.layers[0].paint.get(\"fill-extrusion-height\").evaluate(t, {}, n);\n        let g;\n        if (d.height = y, d.vertexArrayOffset = this.layoutVertexArray.length, d.groundVertexArrayOffset = this.groundEffect.vertexArray.length, h && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new Ba()), this.wallMode) {\n          if (h) return void pt(\"Non zero fill-extrusion-line-width is not yet supported on globe.\");\n          if (1 !== e.length) return;\n          g = function (t) {\n            const e = t[0].x === t[t.length - 1].x && t[0].y === t[t.length - 1].y,\n              r = function (t) {\n                let e = 0;\n                const r = t.length;\n                for (let n = 0; n < r; n++) e += (t[(n + 1) % r].x - t[n].x) * (t[(n + 1) % r].y + t[n].y);\n                return e >= 0;\n              }(t);\n            r || (t = t.reverse());\n            const n = {\n                geometry: [],\n                joinNormals: [],\n                indices: []\n              },\n              i = [],\n              s = [],\n              a = [];\n            let o = t.length;\n            for (; o >= 2 && t[o - 1].equals(t[o - 2]);) o--;\n            if (o < (e ? 3 : 2)) return n;\n            let l,\n              u,\n              c,\n              h,\n              p,\n              f = 0;\n            for (; f < o - 1 && t[f].equals(t[f + 1]);) f++;\n            e && (l = t[o - 2], p = t[f].sub(l)._unit()._perp());\n            for (let r = f; r < o; r++) {\n              if (c = r === o - 1 ? e ? t[f + 1] : void 0 : t[r + 1], c && t[r].equals(c)) continue;\n              p && (h = p), l && (u = l), l = t[r], p = c ? c.sub(l)._unit()._perp() : h, h = h || p;\n              let n = h.add(p);\n              0 === n.x && 0 === n.y || n._unit();\n              const d = n.x * p.x + n.y * p.y,\n                m = 0 !== d ? 1 / d : 1 / 0,\n                y = h.x * p.y - h.y * p.x > 0;\n              let g = \"miter\";\n              const x = 2;\n              \"miter\" === g && m > x && (g = \"bevel\"), \"bevel\" === g && (m > 100 && (g = \"flipbevel\"), m < x && (g = \"miter\"));\n              const v = (t, e, r, n) => {\n                const o = new q(t.x, t.y),\n                  l = new q(t.x, t.y);\n                o.x += e.x * n, o.y += e.y * n, l.x -= e.x * Math.max(r, 1), l.y -= e.y * Math.max(r, 1), a.push(e), i.push(o), s.push(l);\n              };\n              if (\"miter\" === g) n._mult(m), v(l, n, 0, 0);else if (\"flipbevel\" === g) n = p.mult(-1), v(l, n, 0, 0), v(l, n.mult(-1), 0, 0);else {\n                const t = -Math.sqrt(m * m - 1),\n                  e = y ? t : 0,\n                  r = y ? 0 : t;\n                u && v(l, h, e, r), c && v(l, p, e, r);\n              }\n            }\n            n.geometry = [...i, ...s.reverse(), i[0]], n.joinNormals = [...a, ...a.reverse(), a[a.length - 1]];\n            const d = n.geometry.length - 1;\n            for (let t = 0; t < d / 2; t++) if (t + 1 < d / 2) {\n              let e = t,\n                r = t + 1,\n                i = d - 1 - t,\n                s = d - 2 - t;\n              e = 0 === e ? d - 1 : e - 1, r = 0 === r ? d - 1 : r - 1, i = 0 === i ? d - 1 : i - 1, s = 0 === s ? d - 1 : s - 1, n.indices.push(i), n.indices.push(r), n.indices.push(e), n.indices.push(i), n.indices.push(s), n.indices.push(r);\n            }\n            return n;\n          }(e[0]), e = [g.geometry];\n        }\n        const x = (t, e) => t < (e.length - 1) / 2 || t === e.length - 1,\n          v = this.wallMode ? [e] : $c(e, 500);\n        for (let t = v.length - 1; t >= 0; t--) {\n          const e = v[t];\n          (0 === e.length || (b = e[0]).every(t => t.x <= 0) || b.every(t => t.x >= Kr) || b.every(t => t.y <= 0) || b.every(t => t.y >= Kr)) && v.splice(t, 1);\n        }\n        var b;\n        let _;\n        if (h) _ = Ep(v, u, n);else {\n          _ = [];\n          for (const t of v) _.push({\n            polygon: t,\n            bounds: u\n          });\n        }\n        const w = p ? this.edgeRadius : 0,\n          M = w > 0 && this.zoom < 17,\n          A = (t, e) => {\n            if (0 === t.length) return !1;\n            const r = t[t.length - 1];\n            return e.x === r.x && e.y === r.y;\n          };\n        for (const {\n          polygon: t,\n          bounds: e\n        } of _) {\n          let r = 0,\n            i = 0;\n          for (const e of t) p && !e[0].equals(e[e.length - 1]) && e.push(e[0]), i += p ? e.length - 1 : e.length;\n          const s = this.segments.prepareSegment((p ? 5 : 4) * i, this.layoutVertexArray, this.indexArray);\n          d.footprintSegIdx < 0 && (d.footprintSegIdx = this.footprintSegments.length), d.polygonSegIdx < 0 && (d.polygonSegIdx = this.polygonSegments.length);\n          const a = {\n              triangleArrayOffset: this.indexArray.length,\n              triangleCount: 0,\n              triangleSegIdx: this.segments.segments.length - 1\n            },\n            o = new pp();\n          if (o.vertexOffset = this.footprintVertices.length, o.indexOffset = 3 * this.footprintIndices.length, o.ringIndices = [], p) {\n            const i = [],\n              a = [];\n            r = s.vertexLength;\n            for (let r = 0; r < t.length; r++) {\n              const u = t[r];\n              u.length && 0 !== r && a.push(i.length / 2);\n              const p = [];\n              let f, d;\n              f = u[1].sub(u[0])._perp()._unit(), o.ringIndices.push(u.length - 1);\n              for (let t = 1; t < u.length; t++) {\n                const e = u[t],\n                  r = u[t === u.length - 1 ? 1 : t + 1],\n                  a = e.clone();\n                if (w) {\n                  d = r.sub(e)._perp()._unit();\n                  const t = f.add(d)._unit(),\n                    n = w * Math.min(4, 1 / (f.x * t.x + f.y * t.y));\n                  a.x += n * t.x, a.y += n * t.y, a.x = Math.round(a.x), a.y = Math.round(a.y), f = d;\n                }\n                if (!m || 0 !== w && !M || A(p, a) || p.push(a), lp(this.layoutVertexArray, a.x, a.y, 0, 0, 1, 1, 0), this.wallMode) {\n                  const e = x(t, u);\n                  up(this.wallVertexArray, g.joinNormals[t], !e);\n                }\n                s.vertexLength++, this.footprintVertices.emplaceBack(e.x, e.y), i.push(e.x, e.y), h && hp(this.layoutVertexExtArray, c.projectTilePoint(a.x, a.y, n), c.upVector(n, a.x, a.y));\n              }\n              m && (0 === w || M) && (0 !== p.length && A(p, p[0]) && p.pop(), this.groundEffect.addData(p, e, l));\n            }\n            const u = this.wallMode ? g.indices : vc(i, a);\n            for (let t = 0; t < u.length; t += 3) this.footprintIndices.emplaceBack(o.vertexOffset + u[t + 0], o.vertexOffset + u[t + 1], o.vertexOffset + u[t + 2]), this.indexArray.emplaceBack(r + u[t], r + u[t + 2], r + u[t + 1]), s.primitiveLength++;\n            o.indexCount += u.length, o.vertexCount += this.footprintVertices.length - o.vertexOffset;\n          }\n          for (let i = 0; i < t.length; i++) {\n            const a = t[i];\n            f.startRing(d, a[0]);\n            let o = a.length > 4 && Ip(a[a.length - 2], a[0], a[1]),\n              u = w ? _p(a[a.length - 2], a[0], a[1], w) : 0;\n            const y = [];\n            let v, b, _;\n            b = a[1].sub(a[0])._perp()._unit();\n            let M = !0;\n            for (let t = 1, i = 0; t < a.length; t++) {\n              let l = a[t - 1],\n                p = a[t];\n              const I = a[t === a.length - 1 ? 1 : t + 1];\n              if (f.appendEdge(d, p, l), Mp(p, l, e)) {\n                w && (b = I.sub(p)._perp()._unit(), M = !M);\n                continue;\n              }\n              const S = p.sub(l)._perp(),\n                P = S.x / (Math.abs(S.x) + Math.abs(S.y)),\n                E = S.y > 0 ? 1 : 0,\n                z = l.dist(p);\n              if (i + z > 32768 && (i = 0), w) {\n                _ = I.sub(p)._perp()._unit();\n                let t = wp(l, p, I, bp(b, _), w);\n                isNaN(t) && (t = 0);\n                const e = p.sub(l)._unit();\n                l = l.add(e.mult(u))._round(), p = p.add(e.mult(-t))._round(), u = t, b = _, m && this.zoom >= 17 && (A(y, l) || y.push(l), A(y, p) || y.push(p));\n              }\n              const k = s.vertexLength,\n                T = a.length > 4 && Ip(l, p, I);\n              let B = Sp(i, o, M);\n              if (lp(this.layoutVertexArray, l.x, l.y, P, E, 0, 0, B), lp(this.layoutVertexArray, l.x, l.y, P, E, 0, 1, B), this.wallMode) {\n                const e = x(t - 1, a),\n                  r = g.joinNormals[t - 1];\n                up(this.wallVertexArray, r, e), up(this.wallVertexArray, r, e);\n              }\n              if (i += z, B = Sp(i, T, !M), o = T, lp(this.layoutVertexArray, p.x, p.y, P, E, 0, 0, B), lp(this.layoutVertexArray, p.x, p.y, P, E, 0, 1, B), this.wallMode) {\n                const e = x(t, a),\n                  r = g.joinNormals[t];\n                up(this.wallVertexArray, r, e), up(this.wallVertexArray, r, e);\n              }\n              if (s.vertexLength += 4, this.indexArray.emplaceBack(k + 0, k + 1, k + 2), this.indexArray.emplaceBack(k + 1, k + 3, k + 2), s.primitiveLength += 2, w) {\n                const n = r + (1 === t ? a.length - 2 : t - 2),\n                  i = 1 === t ? r : n + 1;\n                if (this.indexArray.emplaceBack(k + 1, n, k + 3), this.indexArray.emplaceBack(n, i, k + 3), s.primitiveLength += 2, void 0 === v && (v = k), !Mp(I, a[t], e)) {\n                  const e = t === a.length - 1 ? v : s.vertexLength;\n                  this.indexArray.emplaceBack(k + 2, k + 3, e), this.indexArray.emplaceBack(k + 3, e + 1, e), this.indexArray.emplaceBack(k + 3, i, e + 1), s.primitiveLength += 3;\n                }\n                M = !M;\n              }\n              if (h) {\n                const t = this.layoutVertexExtArray,\n                  e = c.projectTilePoint(l.x, l.y, n),\n                  r = c.projectTilePoint(p.x, p.y, n),\n                  i = c.upVector(n, l.x, l.y),\n                  s = c.upVector(n, p.x, p.y);\n                hp(t, e, i), hp(t, e, i), hp(t, r, s), hp(t, r, s);\n              }\n            }\n            p && (r += a.length - 1), m && w && this.zoom >= 17 && (0 !== y.length && A(y, y[0]) && y.pop(), this.groundEffect.addData(y, e, l, w > 0));\n          }\n          this.footprintSegments.push(o), a.triangleCount = this.indexArray.length - a.triangleArrayOffset, this.polygonSegments.push(a), ++d.footprintSegLen, ++d.polygonSegLen;\n        }\n        if (d.vertexCount = this.layoutVertexArray.length - d.vertexArrayOffset, d.groundVertexCount = this.groundEffect.vertexArray.length - d.groundVertexArrayOffset, 0 !== d.vertexCount) {\n          if (d.centroidXY = f.borders ? ap : this.encodeCentroid(f, d), this.centroidData.push(d), f.borders) {\n            this.featuresOnBorder.push(f);\n            const t = this.featuresOnBorder.length - 1;\n            for (let e = 0; e < f.borders.length; e++) f.borders[e][0] !== Number.MAX_VALUE && this.borderFeatureIndices[e].push(t);\n          }\n          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n, o), this.groundEffect.addPaintPropertiesData(t, r, i, s, n, o), this.maxHeight = Math.max(this.maxHeight, y);\n        }\n      }\n      sortBorders() {\n        for (let t = 0; t < this.borderFeatureIndices.length; t++) this.borderFeatureIndices[t].sort((e, r) => this.featuresOnBorder[e].borders[t][0] - this.featuresOnBorder[r].borders[t][0]);\n      }\n      splitToSubtiles() {\n        const t = [];\n        for (let e = 0; e < this.centroidData.length; e++) {\n          const r = this.centroidData[e],\n            n = +(r.min.y + r.max.y > Kr),\n            i = 2 * n + (+(r.min.x + r.max.x > Kr) ^ n);\n          for (let n = 0; n < r.polygonSegLen; n++) {\n            const s = r.polygonSegIdx + n;\n            t.push({\n              centroidIdx: e,\n              subtile: i,\n              polygonSegmentIdx: s,\n              triangleSegmentIdx: this.polygonSegments[s].triangleSegIdx\n            });\n          }\n        }\n        const e = new ja();\n        t.sort((t, e) => t.triangleSegmentIdx === e.triangleSegmentIdx ? t.subtile - e.subtile : t.triangleSegmentIdx - e.triangleSegmentIdx);\n        let r = 0,\n          n = 0,\n          i = 0;\n        for (const e of t) {\n          if (e.triangleSegmentIdx !== r) break;\n          i++;\n        }\n        const s = t.length;\n        for (; n !== t.length;) {\n          r = t[n].triangleSegmentIdx;\n          let a = 0,\n            o = n,\n            l = n;\n          for (let e = o; e < i && t[e].subtile === a; e++) l++;\n          for (; o !== i;) {\n            const n = t[o];\n            a = n.subtile;\n            const s = this.centroidData[n.centroidIdx].min.clone(),\n              u = this.centroidData[n.centroidIdx].max.clone(),\n              c = {\n                vertexOffset: this.segments.segments[r].vertexOffset,\n                primitiveOffset: e.length,\n                vertexLength: this.segments.segments[r].vertexLength,\n                primitiveLength: 0,\n                sortKey: void 0,\n                vaos: {}\n              };\n            for (let r = o; r < l; r++) {\n              const n = t[r],\n                i = this.polygonSegments[n.polygonSegmentIdx],\n                a = this.centroidData[n.centroidIdx].min,\n                o = this.centroidData[n.centroidIdx].max,\n                l = this.indexArray.uint16;\n              for (let t = i.triangleArrayOffset; t < i.triangleArrayOffset + i.triangleCount; t++) e.emplaceBack(l[3 * t], l[3 * t + 1], l[3 * t + 2]);\n              c.primitiveLength += i.triangleCount, s.x = Math.min(s.x, a.x), s.y = Math.min(s.y, a.y), u.x = Math.max(u.x, o.x), u.y = Math.max(u.y, o.y);\n            }\n            c.primitiveLength > 0 && this.triangleSubSegments.push({\n              segment: c,\n              min: s,\n              max: u\n            }), o = l;\n            for (let e = o; e < i && t[e].subtile === t[o].subtile; e++) l++;\n          }\n          n = i;\n          for (let e = n; e < s && t[e].triangleSegmentIdx === t[n].triangleSegmentIdx; e++) i++;\n        }\n        e._trim(), this.indexArray = e;\n      }\n      getVisibleSegments(t, e, r) {\n        const n = new xo();\n        if (this.wallMode) {\n          for (const t of this.triangleSubSegments) n.segments.push(t.segment);\n          return n;\n        }\n        let i = 0,\n          s = 0;\n        const a = 1 << t.canonical.z;\n        if (e) {\n          const r = e.getMinMaxForTile(t);\n          r && (i = r.min, s = r.max);\n        }\n        s += this.maxHeight;\n        const o = t.toUnwrapped();\n        let l;\n        const u = [o.canonical.x / a + o.wrap, o.canonical.y / a],\n          c = [(o.canonical.x + 1) / a + o.wrap, (o.canonical.y + 1) / a],\n          h = (t, e, r) => [t[0] * (1 - r[0]) + e[0] * r[0], t[1] * (1 - r[1]) + e[1] * r[1]],\n          p = [],\n          f = [];\n        for (const t of this.triangleSubSegments) {\n          p[0] = t.min.x / Kr, p[1] = t.min.y / Kr, f[0] = t.max.x / Kr, f[1] = t.max.y / Kr;\n          const e = h(u, c, p),\n            a = h(u, c, f);\n          if (0 === new Au([e[0], e[1], i], [a[0], a[1], s]).intersectsPrecise(r)) {\n            l && (n.segments.push(l), l = void 0);\n            continue;\n          }\n          const o = t.segment;\n          l && l.vertexOffset !== o.vertexOffset && (n.segments.push(l), l = void 0), l ? (l.vertexLength += o.vertexLength, l.primitiveLength += o.primitiveLength) : l = {\n            vertexOffset: o.vertexOffset,\n            primitiveLength: o.primitiveLength,\n            vertexLength: o.vertexLength,\n            primitiveOffset: o.primitiveOffset,\n            sortKey: void 0,\n            vaos: {}\n          };\n        }\n        return l && n.segments.push(l), n;\n      }\n      encodeCentroid(t, e) {\n        const r = t.centroid(),\n          n = e.span(),\n          i = Math.min(7, Math.round(n.x * this.tileToMeter / 10)),\n          s = Math.min(7, Math.round(n.y * this.tileToMeter / 10));\n        return new q(Q(r.x, 1, Kr - 1) << 3 | i, Q(r.y, 1, Kr - 1) << 3 | s);\n      }\n      encodeBorderCentroid(t) {\n        if (!t.borders) return new q(0, 0);\n        const e = t.borders,\n          r = Number.MAX_VALUE;\n        if (e[0][0] !== r || e[1][0] !== r) {\n          const t = e[0][0] !== r ? 0 : 1;\n          return new q(6 | (e[0][0] !== r ? 0 : 65528), (e[t][0] + e[t][1]) / 2 << 3 | 6);\n        }\n        {\n          const t = e[2][0] !== r ? 2 : 3;\n          return new q((e[t][0] + e[t][1]) / 2 << 3 | 6, 6 | (e[2][0] !== r ? 0 : 65528));\n        }\n      }\n      showCentroid(t) {\n        const e = this.centroidData[t.centroidDataIndex];\n        e.flags &= op, e.centroidXY.x = 0, e.centroidXY.y = 0, this.writeCentroidToBuffer(e);\n      }\n      writeCentroidToBuffer(t) {\n        this.groundEffect.updateHiddenByLandmark(t);\n        const e = t.vertexArrayOffset,\n          r = t.vertexCount + t.vertexArrayOffset,\n          n = t.flags & op ? ap : t.centroidXY,\n          i = this.centroidVertexArray.geta_centroid_pos0(e);\n        if (this.centroidVertexArray.geta_centroid_pos1(e) !== n.y || i !== n.x) {\n          for (let t = e; t < r; ++t) this.centroidVertexArray.emplace(t, n.x, n.y);\n          this.needsCentroidUpdate = !0;\n        }\n      }\n      createCentroidsBuffer() {\n        this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);\n        for (const t of this.centroidData) this.writeCentroidToBuffer(t);\n      }\n      updateReplacement(t, e, r) {\n        if (e.updateTime === this.replacementUpdateTime) return;\n        this.replacementUpdateTime = e.updateTime;\n        const n = e.getReplacementRegionsForTile(t.toUnwrapped());\n        if (Yh(this.activeReplacements, n)) return;\n        if (this.activeReplacements = n, 0 === this.centroidVertexArray.length) this.createCentroidsBuffer();else for (const t of this.centroidData) t.flags &= 2147483647;\n        const i = [];\n        for (const e of this.activeReplacements) {\n          if (e.order < r) continue;\n          const n = Math.max(1, Math.pow(2, e.footprintTileId.canonical.z - t.canonical.z));\n          for (const r of this.centroidData) if (!(r.flags & op || e.min.x > r.max.x || r.min.x > e.max.x || e.min.y > r.max.y || r.min.y > e.max.y)) for (let s = 0; s < r.footprintSegLen; s++) {\n            const a = this.footprintSegments[r.footprintSegIdx + s];\n            if (i.length = 0, zp(this.footprintVertices, a.vertexOffset, a.vertexCount, e.footprintTileId.canonical, t.canonical, i), Zh(e.footprint, i, this.footprintIndices.uint16, a.indexOffset, a.indexCount, -a.vertexOffset, -n)) {\n              r.flags |= op;\n              break;\n            }\n          }\n        }\n        for (const t of this.centroidData) this.writeCentroidToBuffer(t);\n        this.borderDoneWithNeighborZ = [-1, -1, -1, -1];\n      }\n      footprintContainsPoint(t, e, r) {\n        let n = !1;\n        for (let i = 0; i < r.footprintSegLen; i++) {\n          const s = this.footprintSegments[r.footprintSegIdx + i];\n          let a = 0;\n          for (const r of s.ringIndices) {\n            for (let i = a, o = r + a - 1; i < r + a; o = i++) {\n              const r = this.footprintVertices.int16[2 * (i + s.vertexOffset) + 0],\n                a = this.footprintVertices.int16[2 * (i + s.vertexOffset) + 1],\n                l = this.footprintVertices.int16[2 * (o + s.vertexOffset) + 1];\n              a > e != l > e && t < (this.footprintVertices.int16[2 * (o + s.vertexOffset) + 0] - r) * (e - a) / (l - a) + r && (n = !n);\n            }\n            a = r;\n          }\n        }\n        return n;\n      }\n      getHeightAtTileCoord(t, e) {\n        let r = Number.NEGATIVE_INFINITY,\n          n = !0;\n        const i = 4 * (t + Kr) * Kr + (e + Kr);\n        if (this.partLookup.hasOwnProperty(i)) {\n          const t = this.partLookup[i];\n          return t ? {\n            height: t.height,\n            hidden: !!(t.flags & op)\n          } : void 0;\n        }\n        for (const s of this.centroidData) t > s.max.x || s.min.x > t || e > s.max.y || s.min.y > e || this.footprintContainsPoint(t, e, s) && s && s.height > r && (r = s.height, this.partLookup[i] = s, n = !!(s.flags & op));\n        if (r !== Number.NEGATIVE_INFINITY) return {\n          height: r,\n          hidden: n\n        };\n        this.partLookup[i] = void 0;\n      }\n    }\n    function bp(t, e) {\n      const r = t.add(e)._unit();\n      return t.x * r.x + t.y * r.y;\n    }\n    function _p(t, e, r, n) {\n      const i = e.sub(t)._perp()._unit(),\n        s = r.sub(e)._perp()._unit();\n      return wp(t, e, r, bp(i, s), n);\n    }\n    function wp(t, e, r, n, i) {\n      const s = Math.sqrt(1 - n * n);\n      return Math.min(t.dist(e) / 3, e.dist(r) / 3, i * s / n);\n    }\n    function Mp(t, e, r) {\n      return t.x < r[0].x && e.x < r[0].x || t.x > r[1].x && e.x > r[1].x || t.y < r[0].y && e.y < r[0].y || t.y > r[1].y && e.y > r[1].y;\n    }\n    function Ap(t, e) {\n      return t.x < e[0].x || t.x > e[1].x || t.y < e[0].y || t.y > e[1].y;\n    }\n    function Ip(t, e, r) {\n      if (t.x < 0 || t.x >= Kr || e.x < 0 || e.x >= Kr || r.x < 0 || r.x >= Kr) return !1;\n      const n = r.sub(e),\n        i = n.perp(),\n        s = t.sub(e);\n      return (n.x * s.x + n.y * s.y) / Math.sqrt((n.x * n.x + n.y * n.y) * (s.x * s.x + s.y * s.y)) > -.866 && i.x * s.x + i.y * s.y < 0;\n    }\n    function Sp(t, e, r) {\n      const n = e ? 2 | t : -3 & t;\n      return r ? 1 | n : -2 & n;\n    }\n    function Pp() {\n      const t = Math.PI / 32,\n        e = Math.tan(t),\n        r = ol;\n      return r * Math.sqrt(1 + 2 * e * e) - r;\n    }\n    function Ep(t, e, r) {\n      const n = 1 << r.z,\n        i = gl(r.x / n),\n        s = gl((r.x + 1) / n),\n        a = xl(r.y / n),\n        o = xl((r.y + 1) / n);\n      return function (t, e, r, n, i = 0, s) {\n        const a = [];\n        if (!t.length || !r || !n) return a;\n        const o = (t, e) => {\n            for (const r of t) a.push({\n              polygon: r,\n              bounds: e\n            });\n          },\n          l = Math.ceil(Math.log2(r)),\n          u = Math.ceil(Math.log2(n)),\n          c = l - u,\n          h = [];\n        for (let t = 0; t < Math.abs(c); t++) h.push(c > 0 ? 0 : 1);\n        for (let t = 0; t < Math.min(l, u); t++) h.push(0), h.push(1);\n        let p = t;\n        if (p = Fh(p, e[0].y - i, e[1].y + i, 1), p = Fh(p, e[0].x - i, e[1].x + i, 0), !p.length) return a;\n        const f = [];\n        for (h.length ? f.push({\n          polygons: p,\n          bounds: e,\n          depth: 0\n        }) : o(p, e); f.length;) {\n          const t = f.pop(),\n            e = t.depth,\n            r = h[e],\n            n = t.bounds[0],\n            a = t.bounds[1],\n            l = 0 === r ? n.x : n.y,\n            u = 0 === r ? a.x : a.y,\n            c = s ? s(r, l, u) : .5 * (l + u),\n            p = Fh(t.polygons, l - i, c + i, r),\n            d = Fh(t.polygons, c - i, u + i, r);\n          if (p.length) {\n            const t = [n, new q(0 === r ? c : a.x, 1 === r ? c : a.y)];\n            h.length > e + 1 ? f.push({\n              polygons: p,\n              bounds: t,\n              depth: e + 1\n            }) : o(p, t);\n          }\n          if (d.length) {\n            const t = [new q(0 === r ? c : n.x, 1 === r ? c : n.y), a];\n            h.length > e + 1 ? f.push({\n              polygons: d,\n              bounds: t,\n              depth: e + 1\n            }) : o(d, t);\n          }\n        }\n        return a;\n      }(t, e, Math.ceil((s - i) / 11.25), Math.ceil((a - o) / 11.25), 1, (t, e, i) => {\n        if (0 === t) return .5 * (e + i);\n        {\n          const t = xl((r.y + e / Kr) / n);\n          return (ml(.5 * (xl((r.y + i / Kr) / n) + t)) * n - r.y) * Kr;\n        }\n      });\n    }\n    function zp(t, e, r, n, i, s) {\n      const a = Math.pow(2, n.z - i.z);\n      for (let o = 0; o < r; o++) {\n        let r = t.int16[2 * (o + e) + 0],\n          l = t.int16[2 * (o + e) + 1];\n        r = (r + i.x * Kr) * a - n.x * Kr, l = (l + i.y * Kr) * a - n.y * Kr, s.push(new q(r, l));\n      }\n    }\n    let kp, Tp;\n    function Bp(t, e) {\n      return t.x * e.x + t.y * e.y;\n    }\n    function Vp(t, e) {\n      if (1 === t.length) {\n        let r = 0;\n        const n = e[r++];\n        let i;\n        for (; !i || n.equals(i);) if (i = e[r++], !i) return 1 / 0;\n        for (; r < e.length; r++) {\n          const s = e[r],\n            a = t[0],\n            o = i.sub(n),\n            l = s.sub(n),\n            u = a.sub(n),\n            c = Bp(o, o),\n            h = Bp(o, l),\n            p = Bp(l, l),\n            f = Bp(u, o),\n            d = Bp(u, l),\n            m = c * p - h * h,\n            y = (p * f - h * d) / m,\n            g = (c * d - h * f) / m,\n            x = n.z * (1 - y - g) + i.z * y + s.z * g;\n          if (isFinite(x)) return x;\n        }\n        return 1 / 0;\n      }\n      {\n        let t = 1 / 0;\n        for (const r of e) t = Math.min(t, r.z);\n        return t;\n      }\n    }\n    function Cp(t, e, r, n, i, s, a, o) {\n      const l = a * i.getElevationAt(t, e, !0, !0),\n        u = 0 !== s[0],\n        c = u ? 0 === s[1] ? a * (s[0] / 7 - 450) : a * function (t, e, r) {\n          const n = Math.floor(e[0] / 8),\n            i = Math.floor(e[1] / 8),\n            s = 10 * (e[0] - 8 * n),\n            a = 10 * (e[1] - 8 * i),\n            o = t.getElevationAt(n, i, !0, !0),\n            l = t.getMeterToDEM(r),\n            u = Math.floor(.5 * (s * l - 1)),\n            c = Math.floor(.5 * (a * l - 1)),\n            h = t.tileCoordToPixel(n, i),\n            p = 2 * u + 1,\n            f = 2 * c + 1,\n            d = function (t, e, r, n, i) {\n              return [t.getElevationAtPixel(e, r, !0), t.getElevationAtPixel(e + i, r, !0), t.getElevationAtPixel(e, r + i, !0), t.getElevationAtPixel(e + n, r + i, !0)];\n            }(t, h.x - u, h.y - c, p, f),\n            m = Math.abs(d[0] - d[1]),\n            y = Math.abs(d[2] - d[3]),\n            g = Math.abs(d[0] - d[2]) + Math.abs(d[1] - d[3]),\n            x = Math.min(.25, .5 * l * (m + y) / p),\n            v = Math.min(.25, .5 * l * g / f);\n          return o + Math.max(x * s, v * a);\n        }(i, s, o) : l;\n      return {\n        base: l + (0 === r ? -1 : r),\n        top: u ? Math.max(c + n, l + r + 2) : l + n\n      };\n    }\n    us(vp, \"FillExtrusionBucket\", {\n      omit: [\"layers\", \"features\"]\n    }), us(fp, \"PartData\"), us(pp, \"FootprintSegment\"), us(dp, \"BorderCentroidData\"), us(xp, \"GroundEffect\");\n    const Dp = va([{\n        name: \"a_pos_normal\",\n        components: 2,\n        type: \"Int16\"\n      }, {\n        name: \"a_data\",\n        components: 4,\n        type: \"Uint8\"\n      }, {\n        name: \"a_linesofar\",\n        components: 1,\n        type: \"Float32\"\n      }], 4),\n      Rp = va([{\n        name: \"a_z_offset_width\",\n        components: 3,\n        type: \"Float32\"\n      }], 4),\n      {\n        members: Lp\n      } = Dp,\n      Fp = va([{\n        name: \"a_packed\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      {\n        members: Op\n      } = Fp,\n      Np = va([{\n        name: \"a_pattern_data\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      {\n        members: Up\n      } = Np;\n    class jp {\n      constructor(t, e) {\n        this.width = t, this.height = e, this.nextRow = 0, this.image = new hc({\n          width: t,\n          height: e\n        }), this.positions = {}, this.uploaded = !1;\n      }\n      getDash(t, e) {\n        const r = this.getKey(t, e);\n        return this.positions[r];\n      }\n      trim() {\n        const t = this.width,\n          e = this.height = at(this.nextRow);\n        this.image.resize({\n          width: t,\n          height: e\n        });\n      }\n      getKey(t, e) {\n        return t.join(\",\") + e;\n      }\n      getDashRanges(t, e, r) {\n        const n = [];\n        let i = t.length % 2 == 1 ? -t[t.length - 1] * r : 0,\n          s = t[0] * r,\n          a = !0;\n        n.push({\n          left: i,\n          right: s,\n          isDash: a,\n          zeroLength: 0 === t[0]\n        });\n        let o = t[0];\n        for (let e = 1; e < t.length; e++) {\n          a = !a;\n          const l = t[e];\n          i = o * r, o += l, s = o * r, n.push({\n            left: i,\n            right: s,\n            isDash: a,\n            zeroLength: 0 === l\n          });\n        }\n        return n;\n      }\n      addRoundDash(t, e, r) {\n        const n = e / 2;\n        for (let e = -r; e <= r; e++) {\n          const i = this.width * (this.nextRow + r + e);\n          let s = 0,\n            a = t[s];\n          for (let o = 0; o < this.width; o++) {\n            o / a.right > 1 && (a = t[++s]);\n            const l = Math.abs(o - a.left),\n              u = Math.abs(o - a.right),\n              c = Math.min(l, u);\n            let h;\n            const p = e / r * (n + 1);\n            if (a.isDash) {\n              const t = n - Math.abs(p);\n              h = Math.sqrt(c * c + t * t);\n            } else h = n - Math.sqrt(c * c + p * p);\n            this.image.data[i + o] = Math.max(0, Math.min(255, h + 128));\n          }\n        }\n      }\n      addRegularDash(t, e) {\n        for (let e = t.length - 1; e >= 0; --e) {\n          const r = t[e],\n            n = t[e + 1];\n          r.zeroLength ? t.splice(e, 1) : n && n.isDash === r.isDash && (n.left = r.left, t.splice(e, 1));\n        }\n        const r = t[0],\n          n = t[t.length - 1];\n        r.isDash === n.isDash && (r.left = n.left - this.width, n.right = r.right + this.width);\n        const i = this.width * this.nextRow;\n        let s = 0,\n          a = t[s];\n        for (let r = 0; r < this.width; r++) {\n          r / a.right > 1 && (a = t[++s]);\n          const n = Math.abs(r - a.left),\n            o = Math.abs(r - a.right),\n            l = Math.min(n, o);\n          this.image.data[i + r] = Math.max(0, Math.min(255, (a.isDash ? l : -l) + e + 128));\n        }\n      }\n      addDash(t, e) {\n        const r = this.getKey(t, e);\n        if (this.positions[r]) return this.positions[r];\n        const n = \"round\" === e,\n          i = n ? 7 : 0,\n          s = 2 * i + 1;\n        if (this.nextRow + s > this.height) return pt(\"LineAtlas out of space\"), null;\n        0 === t.length && t.push(1);\n        let a = 0;\n        for (let e = 0; e < t.length; e++) t[e] < 0 && (pt(\"Negative value is found in line dasharray, replacing values with 0\"), t[e] = 0), a += t[e];\n        if (0 !== a) {\n          const r = this.width / a,\n            s = this.getDashRanges(t, this.width, r);\n          n ? this.addRoundDash(s, r, i) : this.addRegularDash(s, \"square\" === e ? .5 * r : 0);\n        }\n        const o = this.nextRow + i;\n        this.nextRow += s;\n        const l = {\n          tl: [o, i],\n          br: [a, 0]\n        };\n        return this.positions[r] = l, l;\n      }\n    }\n    us(jp, \"LineAtlas\");\n    const qp = ah.VectorTileFeature.types,\n      $p = Math.cos(Math.PI / 180 * 37.5),\n      Gp = Math.cos(Math.PI / 180 * 5);\n    class Yp {\n      constructor(t) {\n        this.evaluationGlobals = {\n          zoom: 0,\n          lineProgress: void 0\n        }, this.zoom = t.zoom, this.evaluationGlobals.zoom = this.zoom, this.overscaling = t.overscaling, this.pixelRatio = t.pixelRatio, this.layers = t.layers, this.layerIds = this.layers.map(t => t.fqid), this.index = t.index, this.projection = t.projection, this.hasPattern = !1, this.hasZOffset = !1, this.hasCrossSlope = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(t => {\n          this.gradients[t.id] = {};\n        }), this.layoutVertexArray = new Ea(), this.layoutVertexArray2 = new za(), this.patternVertexArray = new za(), this.indexArray = new ja(), this.programConfigurations = new Go(t.layers, {\n          zoom: t.zoom,\n          lut: t.lut\n        }), this.segments = new xo(), this.maxLineLength = 0, this.zOffsetVertexArray = new za(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.tessellationStep = t.tessellationStep ? t.tessellationStep : Kr / 64;\n      }\n      updateFootprints(t, e) {}\n      populate(t, e, r, n) {\n        this.hasPattern = Hc(\"line\", this.layers, this.pixelRatio, e);\n        const i = this.layers[0].layout.get(\"line-sort-key\");\n        this.tileToMeter = Al(r);\n        const s = this.layers[0].layout.get(\"line-z-offset\"),\n          a = s.isConstant() && !s.constantOr(0),\n          o = this.layers[0].layout.get(\"line-elevation-reference\");\n        this.hasZOffset = \"sea\" === o || \"ground\" === o || !a && \"none\" === o, this.hasZOffset && \"none\" === o && pt(`line-elevation-reference: ground is used for the layer ${this.layerIds[0]} because non-zero line-z-offset value was found.`);\n        const l = this.layers[0].layout.get(\"line-cross-slope\");\n        this.hasCrossSlope = this.hasZOffset && void 0 !== l;\n        const u = [];\n        for (const {\n          feature: e,\n          id: s,\n          index: a,\n          sourceLayerIndex: o\n        } of t) {\n          const t = this.layers[0]._featureFilter.needGeometry,\n            l = Cl(e, t);\n          if (!this.layers[0]._featureFilter.filter(new Rs(this.zoom), l, r)) continue;\n          const c = i ? i.evaluate(l, {}, r) : void 0,\n            h = {\n              id: s,\n              properties: e.properties,\n              type: e.type,\n              sourceLayerIndex: o,\n              index: a,\n              geometry: t ? l.geometry : Vl(e, r, n),\n              patterns: {},\n              sortKey: c\n            };\n          u.push(h);\n        }\n        i && u.sort((t, e) => t.sortKey - e.sortKey);\n        const {\n            lineAtlas: c,\n            featureIndex: h\n          } = e,\n          p = this.addConstantDashes(c);\n        for (const n of u) {\n          const {\n            geometry: i,\n            index: s,\n            sourceLayerIndex: a\n          } = n;\n          if (p && this.addFeatureDashes(n, c), this.hasPattern) {\n            const t = Xc(\"line\", this.layers, n, this.zoom, this.pixelRatio, e);\n            this.patternFeatures.push(t);\n          } else this.addFeature(n, i, s, r, c.positions, e.availableImages, e.brightness);\n          h.insert(t[s].feature, i, s, a, this.index);\n        }\n      }\n      addConstantDashes(t) {\n        let e = !1;\n        for (const r of this.layers) {\n          const n = r.paint.get(\"line-dasharray\").value,\n            i = r.layout.get(\"line-cap\").value;\n          if (\"constant\" !== n.kind || \"constant\" !== i.kind) e = !0;else {\n            const e = i.value,\n              r = n.value;\n            if (!r) continue;\n            t.addDash(r, e);\n          }\n        }\n        return e;\n      }\n      addFeatureDashes(t, e) {\n        const r = this.zoom;\n        for (const n of this.layers) {\n          const i = n.paint.get(\"line-dasharray\").value,\n            s = n.layout.get(\"line-cap\").value;\n          if (\"constant\" === i.kind && \"constant\" === s.kind) continue;\n          let a, o;\n          if (\"constant\" === i.kind) {\n            if (a = i.value, !a) continue;\n          } else a = i.evaluate({\n            zoom: r\n          }, t);\n          o = \"constant\" === s.kind ? s.value : s.evaluate({\n            zoom: r\n          }, t), e.addDash(a, o), t.patterns[n.id] = e.getKey(a, o);\n        }\n      }\n      update(t, e, r, n, i, s, a) {\n        this.programConfigurations.updatePaintArrays(t, e, i, r, n, s, a);\n      }\n      addFeatures(t, e, r, n, i, s) {\n        for (const t of this.patternFeatures) this.addFeature(t, t.geometry, t.index, e, r, n, s);\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length;\n      }\n      uploadPending() {\n        return !this.uploaded || this.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, Op)), 0 !== this.patternVertexArray.length && (this.patternVertexBuffer = t.createVertexBuffer(this.patternVertexArray, Up)), !this.zOffsetVertexBuffer && this.zOffsetVertexArray.length > 0 && (this.zOffsetVertexBuffer = t.createVertexBuffer(this.zOffsetVertexArray, Rp.members, !0)), this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Lp), this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t), this.uploaded = !0;\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());\n      }\n      lineFeatureClips(t) {\n        if (t.properties && t.properties.hasOwnProperty(\"mapbox_clip_start\") && t.properties.hasOwnProperty(\"mapbox_clip_end\")) return {\n          start: +t.properties.mapbox_clip_start,\n          end: +t.properties.mapbox_clip_end\n        };\n      }\n      addFeature(t, e, r, n, i, s, a) {\n        const o = this.layers[0].layout,\n          l = o.get(\"line-join\").evaluate(t, {}),\n          u = o.get(\"line-cap\").evaluate(t, {}),\n          c = o.get(\"line-miter-limit\"),\n          h = o.get(\"line-round-limit\");\n        this.lineClips = this.lineFeatureClips(t), this.lineFeature = t, this.zOffsetValue = o.get(\"line-z-offset\").value;\n        const p = this.layers[0].paint.get(\"line-width\").value;\n        \"constant\" !== p.kind && !1 === p.isLineProgressConstant && (this.variableWidthValue = p);\n        for (const r of e) this.addLine(r, t, n, l, u, c, h);\n        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, i, s, n, a);\n      }\n      addLine(t, e, r, n, i, s, a) {\n        this.distance = 0, this.prevDistance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.totalFeatureLength = 0, this.lineSoFar = 0, this.currentVertex = void 0;\n        const o = \"none\" === n;\n        if (this.patternJoinNone = this.hasPattern && o, this.segmentStart = 0, this.segmentStartf32 = 0, this.segmentPoints = [], this.lineClips) {\n          this.lineClipsArray.push(this.lineClips);\n          for (let e = 0; e < t.length - 1; e++) this.totalDistance += t[e].dist(t[e + 1]);\n          this.totalFeatureLength = this.totalDistance / (this.lineClips.end - this.lineClips.start), this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);\n        }\n        const l = \"Polygon\" === qp[e.type];\n        let u = t.length;\n        for (; u >= 2 && t[u - 1].equals(t[u - 2]);) u--;\n        let c = 0;\n        for (; c < u - 1 && t[c].equals(t[c + 1]);) c++;\n        if (u < (l ? 3 : 2)) return;\n        \"bevel\" === n && (s = 1.05);\n        const h = this.segments.prepareSegment(10 * u, this.layoutVertexArray, this.indexArray);\n        let p, f, d, m, y, g;\n        this.e1 = this.e2 = -1, l && (p = t[u - 2], y = t[c].sub(p)._unit()._perp());\n        for (let e = c; e < u; e++) {\n          if (d = e === u - 1 ? l ? t[c + 1] : void 0 : t[e + 1], d && t[e].equals(d)) continue;\n          y && (m = y), p && (f = p), p = t[e], g = this.evaluateLineProgressFeatures(f ? f.dist(p) : 0), y = d ? d.sub(p)._unit()._perp() : m, m = m || y;\n          const r = f && d;\n          let x = r ? n : l || o ? \"butt\" : i;\n          const v = m.x * y.x + m.y * y.y;\n          if (o) {\n            const t = function (t) {\n              if (t.patternJoinNone) {\n                const e = t.segmentPoints.length / 2,\n                  r = t.lineSoFar - t.segmentStart;\n                for (let n = 0; n < e; ++n) {\n                  const e = t.segmentPoints[2 * n + 1],\n                    i = Math.round(t.segmentPoints[2 * n]) + .5 + .25 * e;\n                  t.patternVertexArray.emplaceBack(i, r, t.segmentStart), t.patternVertexArray.emplaceBack(i, r, t.segmentStart);\n                }\n                t.segmentPoints.length = 0;\n              }\n              t.e1 = t.e2 = -1;\n            };\n            if (r && v < Gp) {\n              this.updateDistance(f, p), this.addCurrentVertex(p, m, 1, 1, h, g), t(this), this.addCurrentVertex(p, y, -1, -1, h, g);\n              continue;\n            }\n            if (f) {\n              if (!d) {\n                this.updateDistance(f, p), this.addCurrentVertex(p, m, 1, 1, h, g), t(this);\n                continue;\n              }\n              x = \"miter\";\n            }\n          }\n          let b = m.add(y);\n          0 === b.x && 0 === b.y || b._unit();\n          const _ = b.x * y.x + b.y * y.y,\n            w = 0 !== _ ? 1 / _ : 1 / 0,\n            M = 2 * Math.sqrt(2 - 2 * _),\n            A = _ < $p && f && d,\n            I = m.x * y.y - m.y * y.x > 0,\n            S = this.overscaling <= 16 ? 15 * Kr / (512 * this.overscaling) : 0;\n          if (r && \"round\" === x) if (w < a) x = \"miter\";else if (w <= 2) {\n            const t = Hp(p, -10, Kr + 10);\n            x = this.hasZOffset && (t || this.hasCrossSlope) ? \"miter\" : \"fakeround\";\n          }\n          if (\"miter\" === x && w > s && (x = \"bevel\"), \"bevel\" === x && (w > 2 && (x = \"flipbevel\"), w < s && (x = \"miter\")), f && !(\"miter\" === x && A) && this.updateDistance(f, p), \"miter\" === x) {\n            if (A) {\n              const t = p.dist(f);\n              if (t > 2 * S) {\n                const e = p.sub(p.sub(f)._mult(S / t)._round());\n                this.updateDistance(f, e), this.addCurrentVertex(e, m, 0, 0, h, g), f = e;\n              }\n              this.updateDistance(f, p), b._mult(w), this.addCurrentVertex(p, b, 0, 0, h, g);\n              const e = p.dist(d);\n              if (e > 2 * S) {\n                const t = p.add(d.sub(p)._mult(S / e)._round());\n                this.updateDistance(p, t), this.addCurrentVertex(t, y, 0, 0, h, g), p = t;\n              }\n            } else b._mult(w), this.addCurrentVertex(p, b, 0, 0, h, g);\n          } else if (\"flipbevel\" === x) {\n            if (w > 100) b = y.mult(-1);else {\n              const t = w * m.add(y).mag() / m.sub(y).mag();\n              b._perp()._mult(t * (I ? -1 : 1));\n            }\n            this.addCurrentVertex(p, b, 0, 0, h, g), this.addCurrentVertex(p, b.mult(-1), 0, 0, h, g);\n          } else if (\"bevel\" === x || \"fakeround\" === x) {\n            null != g && f && this.addCurrentVertex(p, m, -1, -1, h, g);\n            const t = p.dist(f) <= 2 * S && \"bevel\" !== x,\n              e = b.mult(I ? 1 : -1);\n            e._mult(w);\n            const r = y.mult(I ? -1 : 1),\n              n = m.mult(I ? -1 : 1),\n              i = this.evaluateLineProgressFeatures(this.distance);\n            if (null == g && (this.addHalfVertex(p, e.x, e.y, !1, !I, 0, h, i), t || this.addHalfVertex(p, e.x + 2 * n.x, e.y + 2 * n.y, !1, I, 0, h, i)), \"fakeround\" === x) {\n              const t = Math.round(180 * M / Math.PI / 20);\n              this.addHalfVertex(p, n.x, n.y, !1, I, 0, h, i);\n              for (let e = 0; e < t; e++) {\n                let s = e / t;\n                if (.5 !== s) {\n                  const t = s - .5;\n                  s += s * t * (s - 1) * ((1.0904 + v * (v * (3.55645 - 1.43519 * v) - 3.2452)) * t * t + (.848013 + v * (.215638 * v - 1.06021)));\n                }\n                const a = r.sub(n)._mult(s)._add(n)._unit();\n                this.addHalfVertex(p, a.x, a.y, !1, I, 0, h, i);\n              }\n              this.addHalfVertex(p, r.x, r.y, !1, I, 0, h, i);\n            }\n            t || null != g || this.addHalfVertex(p, e.x + 2 * r.x, e.y + 2 * r.y, !1, I, 0, h, i), null != g && d && this.addCurrentVertex(p, y, 1, 1, h, g);\n          } else \"butt\" === x ? this.addCurrentVertex(p, b, 0, 0, h, g) : \"square\" === x ? (f || this.addCurrentVertex(p, b, -1, -1, h, g), this.addCurrentVertex(p, b, 0, 0, h, g), f && this.addCurrentVertex(p, b, 1, 1, h, g)) : \"round\" === x && (f && (this.addCurrentVertex(p, m, 0, 0, h, g), this.addCurrentVertex(p, m, 1, 1, h, g, !0)), d && (this.addCurrentVertex(p, y, -1, -1, h, g, !0), this.addCurrentVertex(p, y, 0, 0, h, g)));\n        }\n      }\n      addVerticesTo(t, e, r, n, i, s, a, o, l, u) {\n        const c = (e.w - t.w) / this.tessellationStep | 0;\n        let h = 0;\n        const p = this.scaledDistance;\n        if (c > 1) {\n          this.lineSoFar = t.w;\n          const p = (e.x - t.x) / c,\n            f = (e.y - t.y) / c,\n            d = (e.z - t.z) / c,\n            m = (e.w - t.w) / c;\n          for (let e = 1; e < c; ++e) {\n            t.x += p, t.y += f, t.z += d, this.lineSoFar += m, h += m;\n            const e = this.evaluateLineProgressFeatures(this.prevDistance + h);\n            this.scaledDistance = (this.prevDistance + h) / this.totalDistance, this.addHalfVertex(t, r, n, u, !1, a, l, e), this.addHalfVertex(t, i, s, u, !0, -o, l, e);\n          }\n        }\n        this.lineSoFar = e.w, this.scaledDistance = p;\n        const f = this.evaluateLineProgressFeatures(this.distance);\n        this.addHalfVertex(e, r, n, u, !1, a, l, f), this.addHalfVertex(e, i, s, u, !0, -o, l, f);\n      }\n      evaluateLineProgressFeatures(t) {\n        if (!this.variableWidthValue && !this.hasZOffset) return null;\n        this.evaluationGlobals.lineProgress = 0, this.lineClips ? this.evaluationGlobals.lineProgress = Math.min(1, (this.totalFeatureLength * this.lineClips.start + t) / this.totalFeatureLength) : pt(`line-progress evaluation for ${this.layerIds[0]} requires enabling 'lineMetrics' for the source.`);\n        let e = 0;\n        return this.variableWidthValue && \"constant\" !== this.variableWidthValue.kind && (e = this.variableWidthValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0), this.hasZOffset ? \"constant\" === this.zOffsetValue.kind ? {\n          zOffset: this.zOffsetValue.value,\n          variableWidth: e\n        } : {\n          zOffset: this.zOffsetValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0,\n          variableWidth: e\n        } : {\n          zOffset: 0,\n          variableWidth: e\n        };\n      }\n      addCurrentVertex(t, e, r, n, i, s, a = !1) {\n        const o = e.x + e.y * r,\n          l = e.y - e.x * r,\n          u = e.y * n - e.x,\n          c = -e.y - e.x * n;\n        if (null != s) {\n          const e = this.hasZOffset,\n            h = -10,\n            p = Kr + 10,\n            f = s.zOffset,\n            d = new Lh(t.x, t.y, f, this.lineSoFar),\n            m = !!e && Hp(t, h, p),\n            y = this.lineSoFar,\n            g = this.distance;\n          if (this.currentVertex) {\n            if (m) {\n              const e = this.currentVertexIsOutside,\n                s = this.currentVertex,\n                m = new Lh(t.x, t.y, f, this.lineSoFar);\n              if (Nh(s, m, h, p), !Hp(m, h, p)) {\n                if (e) {\n                  this.e1 = this.e2 = -1, this.distance -= s.dist(d), this.lineSoFar = s.w;\n                  const t = this.evaluateLineProgressFeatures(s.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));\n                  this.addHalfVertex(s, o, l, a, !1, r, i, t), this.addHalfVertex(s, u, c, a, !0, -n, i, t), this.prevDistance = this.distance;\n                }\n                this.distance = this.prevDistance + s.dist(m), this.scaledDistance = this.distance / this.totalDistance, this.addVerticesTo(s, m, o, l, u, c, r, n, i, a), this.distance = g, this.scaledDistance = this.distance / this.totalDistance;\n              }\n            } else {\n              const t = this.currentVertex;\n              if (this.currentVertexIsOutside) {\n                Nh(t, d, h, p), this.e1 = this.e2 = -1, this.distance -= t.dist(d), this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t.w;\n                const e = this.evaluateLineProgressFeatures(t.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));\n                this.addHalfVertex(t, o, l, a, !1, r, i, e), this.addHalfVertex(t, u, c, a, !0, -n, i, e), this.prevDistance = this.distance, this.distance = g, this.scaledDistance = this.distance / this.totalDistance;\n              }\n              this.addVerticesTo(t, d, o, l, u, c, r, n, i, a);\n            }\n          } else m || (this.addHalfVertex(t, o, l, a, !1, r, i, s), this.addHalfVertex(t, u, c, a, !0, -n, i, s));\n          this.currentVertex = d, this.currentVertexIsOutside = m, this.lineSoFar = y;\n        } else this.addHalfVertex(t, o, l, a, !1, r, i, s), this.addHalfVertex(t, u, c, a, !0, -n, i, s);\n      }\n      addHalfVertex({\n        x: t,\n        y: e\n      }, r, n, i, s, a, o, l) {\n        if (this.patternJoinNone && (0 === this.segmentPoints.length && (this.segmentStart = this.lineSoFar, this.segmentStartf32 = Math.fround(this.lineSoFar)), s || this.segmentPoints.push(this.lineSoFar - this.segmentStart, a)), this.layoutVertexArray.emplaceBack((t << 1) + (i ? 1 : 0), (e << 1) + (s ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (0 === a ? 0 : a < 0 ? -1 : 1), 0, this.lineSoFar - this.segmentStartf32), this.lineClips) {\n          const t = Ee(this.lineClips.start, this.lineClips.end, this.scaledDistance);\n          this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, t);\n        }\n        const u = o.vertexLength++;\n        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u), o.primitiveLength++), s ? this.e2 = u : this.e1 = u, null != l && this.zOffsetVertexArray.emplaceBack(l.zOffset, l.variableWidth, l.variableWidth);\n      }\n      updateScaledDistance() {\n        this.lineClips ? (this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = this.totalFeatureLength * this.lineClips.start + this.distance) : this.lineSoFar = this.distance;\n      }\n      updateDistance(t, e) {\n        this.prevDistance = this.distance, this.distance += t.dist(e), this.updateScaledDistance();\n      }\n    }\n    function Hp(t, e, r) {\n      return t.x < e || t.x > r || t.y < e || t.y > r;\n    }\n    let Xp, Zp;\n    function Wp(t, e, r) {\n      return e * (Kr / (t.tileSize * Math.pow(2, r - t.tileID.overscaledZ)));\n    }\n    us(Yp, \"LineBucket\", {\n      omit: [\"layers\", \"patternFeatures\", \"currentVertex\", \"currentVertexIsOutside\"]\n    });\n    const Kp = (t, e, r) => (1 - r) * t + r * e;\n    function Jp(t, e) {\n      return 1 / Wp(t, 1, e.tileZoom);\n    }\n    function Qp(t, e, r, n) {\n      return t.translatePosMatrix(n || e.tileID.projMatrix, e, r.paint.get(\"line-translate\"), r.paint.get(\"line-translate-anchor\"));\n    }\n    const tf = t => {\n      const e = [];\n      ef(t) && e.push(\"RENDER_LINE_DASH\"), t.paint.get(\"line-gradient\") && e.push(\"RENDER_LINE_GRADIENT\");\n      const r = t.paint.get(\"line-trim-offset\");\n      0 === r[0] && 0 === r[1] || e.push(\"RENDER_LINE_TRIM_OFFSET\"), 0 !== t.paint.get(\"line-border-width\").constantOr(1) && e.push(\"RENDER_LINE_BORDER\");\n      const n = \"none\" === t.layout.get(\"line-join\").constantOr(\"miter\"),\n        i = !!t.paint.get(\"line-pattern\").constantOr(1);\n      return n && i && e.push(\"LINE_JOIN_NONE\"), e;\n    };\n    function ef(t) {\n      const e = t.paint.get(\"line-dasharray\").value;\n      return e.value || \"constant\" !== e.kind;\n    }\n    let rf;\n    const nf = () => rf || (rf = {\n      layout: Xp || (Xp = new Xs({\n        \"line-cap\": new Ys(Zs.layout_line[\"line-cap\"]),\n        \"line-join\": new Ys(Zs.layout_line[\"line-join\"]),\n        \"line-miter-limit\": new Gs(Zs.layout_line[\"line-miter-limit\"]),\n        \"line-round-limit\": new Gs(Zs.layout_line[\"line-round-limit\"]),\n        \"line-sort-key\": new Ys(Zs.layout_line[\"line-sort-key\"]),\n        \"line-z-offset\": new Ys(Zs.layout_line[\"line-z-offset\"]),\n        \"line-elevation-reference\": new Gs(Zs.layout_line[\"line-elevation-reference\"]),\n        \"line-cross-slope\": new Gs(Zs.layout_line[\"line-cross-slope\"]),\n        visibility: new Gs(Zs.layout_line.visibility),\n        \"line-width-unit\": new Gs(Zs.layout_line[\"line-width-unit\"])\n      })),\n      paint: Zp || (Zp = new Xs({\n        \"line-opacity\": new Ys(Zs.paint_line[\"line-opacity\"]),\n        \"line-color\": new Ys(Zs.paint_line[\"line-color\"]),\n        \"line-translate\": new Gs(Zs.paint_line[\"line-translate\"]),\n        \"line-translate-anchor\": new Gs(Zs.paint_line[\"line-translate-anchor\"]),\n        \"line-width\": new Ys(Zs.paint_line[\"line-width\"]),\n        \"line-gap-width\": new Ys(Zs.paint_line[\"line-gap-width\"]),\n        \"line-offset\": new Ys(Zs.paint_line[\"line-offset\"]),\n        \"line-blur\": new Ys(Zs.paint_line[\"line-blur\"]),\n        \"line-dasharray\": new Ys(Zs.paint_line[\"line-dasharray\"]),\n        \"line-pattern\": new Ys(Zs.paint_line[\"line-pattern\"]),\n        \"line-gradient\": new Hs(Zs.paint_line[\"line-gradient\"]),\n        \"line-trim-offset\": new Gs(Zs.paint_line[\"line-trim-offset\"]),\n        \"line-trim-fade-range\": new Gs(Zs.paint_line[\"line-trim-fade-range\"]),\n        \"line-trim-color\": new Gs(Zs.paint_line[\"line-trim-color\"]),\n        \"line-emissive-strength\": new Gs(Zs.paint_line[\"line-emissive-strength\"]),\n        \"line-border-width\": new Ys(Zs.paint_line[\"line-border-width\"]),\n        \"line-border-color\": new Ys(Zs.paint_line[\"line-border-color\"]),\n        \"line-occlusion-opacity\": new Gs(Zs.paint_line[\"line-occlusion-opacity\"]),\n        \"line-color-use-theme\": new Ys({\n          type: \"string\",\n          default: \"default\",\n          \"property-type\": \"data-driven\"\n        }),\n        \"line-gradient-use-theme\": new Ys({\n          type: \"string\",\n          default: \"default\",\n          \"property-type\": \"data-driven\"\n        }),\n        \"line-trim-color-use-theme\": new Ys({\n          type: \"string\",\n          default: \"default\",\n          \"property-type\": \"data-driven\"\n        }),\n        \"line-border-color-use-theme\": new Ys({\n          type: \"string\",\n          default: \"default\",\n          \"property-type\": \"data-driven\"\n        })\n      }))\n    }, rf);\n    class sf extends Ys {\n      possiblyEvaluate(t, e) {\n        return e = new Rs(Math.floor(e.zoom), {\n          now: e.now,\n          fadeDuration: e.fadeDuration,\n          transition: e.transition\n        }), super.possiblyEvaluate(t, e);\n      }\n      evaluate(t, e, r, n) {\n        return e = nt({}, e, {\n          zoom: Math.floor(e.zoom)\n        }), super.evaluate(t, e, r, n);\n      }\n    }\n    let af;\n    function of(t, e) {\n      return e > 0 ? e + 2 * t : t;\n    }\n    const lf = va([{\n        name: \"a_pos_offset\",\n        components: 4,\n        type: \"Int16\"\n      }, {\n        name: \"a_tex_size\",\n        components: 4,\n        type: \"Uint16\"\n      }, {\n        name: \"a_pixeloffset\",\n        components: 4,\n        type: \"Int16\"\n      }], 4),\n      uf = va([{\n        name: \"a_globe_anchor\",\n        components: 3,\n        type: \"Int16\"\n      }, {\n        name: \"a_globe_normal\",\n        components: 3,\n        type: \"Float32\"\n      }], 4),\n      cf = va([{\n        name: \"a_projected_pos\",\n        components: 4,\n        type: \"Float32\"\n      }], 4);\n    va([{\n      name: \"a_fade_opacity\",\n      components: 1,\n      type: \"Uint32\"\n    }], 4);\n    const hf = va([{\n        name: \"a_auto_z_offset\",\n        components: 1,\n        type: \"Float32\"\n      }], 4),\n      pf = va([{\n        name: \"a_texb\",\n        components: 2,\n        type: \"Uint16\"\n      }]),\n      ff = va([{\n        name: \"a_placed\",\n        components: 2,\n        type: \"Uint8\"\n      }, {\n        name: \"a_shift\",\n        components: 2,\n        type: \"Float32\"\n      }, {\n        name: \"a_elevation_from_sea\",\n        components: 2,\n        type: \"Float32\"\n      }]),\n      df = va([{\n        name: \"a_size_scale\",\n        components: 1,\n        type: \"Float32\"\n      }, {\n        name: \"a_padding\",\n        components: 2,\n        type: \"Float32\"\n      }, {\n        name: \"a_auto_z_offset\",\n        components: 1,\n        type: \"Float32\"\n      }]);\n    va([{\n      type: \"Int16\",\n      name: \"projectedAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorZ\"\n    }, {\n      type: \"Int16\",\n      name: \"tileAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"tileAnchorY\"\n    }, {\n      type: \"Float32\",\n      name: \"x1\"\n    }, {\n      type: \"Float32\",\n      name: \"y1\"\n    }, {\n      type: \"Float32\",\n      name: \"x2\"\n    }, {\n      type: \"Float32\",\n      name: \"y2\"\n    }, {\n      type: \"Int16\",\n      name: \"padding\"\n    }, {\n      type: \"Uint32\",\n      name: \"featureIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"sourceLayerIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"bucketIndex\"\n    }]);\n    const mf = va([{\n        name: \"a_pos\",\n        components: 3,\n        type: \"Int16\"\n      }, {\n        name: \"a_anchor_pos\",\n        components: 2,\n        type: \"Int16\"\n      }, {\n        name: \"a_extrude\",\n        components: 2,\n        type: \"Int16\"\n      }], 4),\n      yf = va([{\n        name: \"a_pos_2f\",\n        components: 2,\n        type: \"Float32\"\n      }, {\n        name: \"a_radius\",\n        components: 1,\n        type: \"Float32\"\n      }, {\n        name: \"a_flags\",\n        components: 2,\n        type: \"Int16\"\n      }], 4);\n    va([{\n      name: \"triangle\",\n      components: 3,\n      type: \"Uint16\"\n    }]), va([{\n      type: \"Int16\",\n      name: \"projectedAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorZ\"\n    }, {\n      type: \"Float32\",\n      name: \"tileAnchorX\"\n    }, {\n      type: \"Float32\",\n      name: \"tileAnchorY\"\n    }, {\n      type: \"Uint16\",\n      name: \"glyphStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"numGlyphs\"\n    }, {\n      type: \"Uint32\",\n      name: \"vertexStartIndex\"\n    }, {\n      type: \"Uint32\",\n      name: \"lineStartIndex\"\n    }, {\n      type: \"Uint32\",\n      name: \"lineLength\"\n    }, {\n      type: \"Uint16\",\n      name: \"segment\"\n    }, {\n      type: \"Uint16\",\n      name: \"lowerSize\"\n    }, {\n      type: \"Uint16\",\n      name: \"upperSize\"\n    }, {\n      type: \"Float32\",\n      name: \"lineOffsetX\"\n    }, {\n      type: \"Float32\",\n      name: \"lineOffsetY\"\n    }, {\n      type: \"Uint8\",\n      name: \"writingMode\"\n    }, {\n      type: \"Uint8\",\n      name: \"placedOrientation\"\n    }, {\n      type: \"Uint8\",\n      name: \"hidden\"\n    }, {\n      type: \"Uint32\",\n      name: \"crossTileID\"\n    }, {\n      type: \"Int16\",\n      name: \"associatedIconIndex\"\n    }, {\n      type: \"Uint8\",\n      name: \"flipState\"\n    }]), va([{\n      type: \"Float32\",\n      name: \"tileAnchorX\"\n    }, {\n      type: \"Float32\",\n      name: \"tileAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorX\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorY\"\n    }, {\n      type: \"Int16\",\n      name: \"projectedAnchorZ\"\n    }, {\n      type: \"Int16\",\n      name: \"rightJustifiedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"centerJustifiedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"leftJustifiedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"verticalPlacedTextSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"placedIconSymbolIndex\"\n    }, {\n      type: \"Int16\",\n      name: \"verticalPlacedIconSymbolIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"key\"\n    }, {\n      type: \"Uint16\",\n      name: \"textBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"textBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalTextBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalTextBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"iconBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"iconBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalIconBoxStartIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"verticalIconBoxEndIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"featureIndex\"\n    }, {\n      type: \"Uint16\",\n      name: \"numHorizontalGlyphVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"numVerticalGlyphVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"numIconVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"numVerticalIconVertices\"\n    }, {\n      type: \"Uint16\",\n      name: \"useRuntimeCollisionCircles\"\n    }, {\n      type: \"Uint32\",\n      name: \"crossTileID\"\n    }, {\n      type: \"Float32\",\n      components: 2,\n      name: \"textOffset\"\n    }, {\n      type: \"Float32\",\n      name: \"collisionCircleDiameter\"\n    }, {\n      type: \"Float32\",\n      name: \"zOffset\"\n    }, {\n      type: \"Uint8\",\n      name: \"hasIconTextFit\"\n    }, {\n      type: \"Uint16\",\n      name: \"elevationFeatureIndex\"\n    }]), va([{\n      type: \"Float32\",\n      name: \"offsetX\"\n    }]), va([{\n      type: \"Int16\",\n      name: \"x\"\n    }, {\n      type: \"Int16\",\n      name: \"y\"\n    }]);\n    var gf = 24;\n    const xf = 128;\n    function vf(t, e, r, n, i) {\n      if (\"camera\" === t.kind) return t.maxSize;\n      if (\"composite\" === t.kind) {\n        const n = e.possiblyEvaluate(new Rs(t.maxZoom), r).evaluate(i, {}, r),\n          s = e.possiblyEvaluate(new Rs(t.minZoom), r).evaluate(i, {}, r);\n        return Math.max(n, s);\n      }\n      return e.possiblyEvaluate(new Rs(n)).evaluate(i, {}, r);\n    }\n    function bf(t, e) {\n      const {\n        expression: r\n      } = e;\n      if (\"constant\" === r.kind) return {\n        kind: \"constant\",\n        layoutSize: r.evaluate(new Rs(t + 1))\n      };\n      if (\"source\" === r.kind) return {\n        kind: \"source\"\n      };\n      {\n        const {\n          zoomStops: e,\n          interpolationType: n\n        } = r;\n        let i = 0;\n        for (; i < e.length && e[i] <= t;) i++;\n        i = Math.max(0, i - 1);\n        let s = i;\n        for (; s < e.length && e[s] < t + 1;) s++;\n        s = Math.min(e.length - 1, s);\n        const a = e[i],\n          o = e[s];\n        return \"composite\" === r.kind ? {\n          kind: \"composite\",\n          minZoom: a,\n          maxZoom: o,\n          interpolationType: n\n        } : {\n          kind: \"camera\",\n          minZoom: a,\n          maxZoom: o,\n          minSize: r.evaluate(new Rs(a)),\n          maxSize: r.evaluate(new Rs(o)),\n          interpolationType: n\n        };\n      }\n    }\n    function _f(t, {\n      uSize: e,\n      uSizeT: r\n    }, {\n      lowerSize: n,\n      upperSize: i\n    }) {\n      return \"source\" === t.kind ? n / xf : \"composite\" === t.kind ? Ee(n / xf, i / xf, r) : e;\n    }\n    function wf(t, e, r = 1) {\n      let n = 0,\n        i = 0;\n      if (\"constant\" === t.kind) i = t.layoutSize * r;else if (\"source\" !== t.kind) {\n        const {\n            interpolationType: s,\n            minZoom: a,\n            maxZoom: o\n          } = t,\n          l = s ? Q(ai.interpolationFactor(s, e, a, o), 0, 1) : 0;\n        \"camera\" === t.kind ? i = Ee(t.minSize, t.maxSize, l) * r : n = l * r;\n      }\n      return {\n        uSizeT: n,\n        uSize: i\n      };\n    }\n    var Mf = Object.freeze({\n      __proto__: null,\n      SIZE_PACK_FACTOR: xf,\n      evaluateSizeForFeature: _f,\n      evaluateSizeForZoom: wf,\n      getRasterizedIconSize: vf,\n      getSizeData: bf\n    });\n    function Af(t, e, r) {\n      return t.sections.forEach(t => {\n        t.text = function (t, e, r) {\n          const n = e.layout.get(\"text-transform\").evaluate(r, {});\n          return \"uppercase\" === n ? t = t.toLocaleUpperCase() : \"lowercase\" === n && (t = t.toLocaleLowerCase()), Ds.applyArabicShaping && (t = Ds.applyArabicShaping(t)), t;\n        }(t.text, e, r);\n      }), t;\n    }\n    const If = {\n      \"!\": \"ï¸\",\n      \"#\": \"ï¼\",\n      $: \"ï¼\",\n      \"%\": \"ï¼\",\n      \"&\": \"ï¼\",\n      \"(\": \"ï¸µ\",\n      \")\": \"ï¸¶\",\n      \"*\": \"ï¼\",\n      \"+\": \"ï¼\",\n      \",\": \"ï¸\",\n      \"-\": \"ï¸²\",\n      \".\": \"ã»\",\n      \"/\": \"ï¼\",\n      \":\": \"ï¸\",\n      \";\": \"ï¸\",\n      \"<\": \"ï¸¿\",\n      \"=\": \"ï¼\",\n      \">\": \"ï¹\",\n      \"?\": \"ï¸\",\n      \"@\": \"ï¼ \",\n      \"[\": \"ï¹\",\n      \"\\\\\": \"ï¼¼\",\n      \"]\": \"ï¹\",\n      \"^\": \"ï¼¾\",\n      _: \"ï¸³\",\n      \"`\": \"ï½\",\n      \"{\": \"ï¸·\",\n      \"|\": \"â\",\n      \"}\": \"ï¸¸\",\n      \"~\": \"ï½\",\n      \"Â¢\": \"ï¿ \",\n      \"Â£\": \"ï¿¡\",\n      \"Â¥\": \"ï¿¥\",\n      \"Â¦\": \"ï¿¤\",\n      \"Â¬\": \"ï¿¢\",\n      \"Â¯\": \"ï¿£\",\n      \"â\": \"ï¸²\",\n      \"â\": \"ï¸±\",\n      \"â\": \"ï¹\",\n      \"â\": \"ï¹\",\n      \"â\": \"ï¹\",\n      \"â\": \"ï¹\",\n      \"â¦\": \"ï¸\",\n      \"â§\": \"ã»\",\n      \"â©\": \"ï¿¦\",\n      \"ã\": \"ï¸\",\n      \"ã\": \"ï¸\",\n      \"ã\": \"ï¸¿\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¸½\",\n      \"ã\": \"ï¸¾\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¹\",\n      \"ã\": \"ï¸»\",\n      \"ã\": \"ï¸¼\",\n      \"ã\": \"ï¸¹\",\n      \"ã\": \"ï¸º\",\n      \"ã\": \"ï¸\",\n      \"ã\": \"ï¸\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸µ\",\n      \"ï¼\": \"ï¸¶\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸²\",\n      \"ï¼\": \"ã»\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼\": \"ï¸¿\",\n      \"ï¼\": \"ï¹\",\n      \"ï¼\": \"ï¸\",\n      \"ï¼»\": \"ï¹\",\n      \"ï¼½\": \"ï¹\",\n      \"ï¼¿\": \"ï¸³\",\n      \"ï½\": \"ï¸·\",\n      \"ï½\": \"â\",\n      \"ï½\": \"ï¸¸\",\n      \"ï½\": \"ï¸µ\",\n      \"ï½ \": \"ï¸¶\",\n      \"ï½¡\": \"ï¸\",\n      \"ï½¢\": \"ï¹\",\n      \"ï½£\": \"ï¹\",\n      \"â\": \"â\",\n      \"â\": \"â\"\n    };\n    function Sf(t) {\n      return \"ï¸¶\" === t || \"ï¹\" === t || \"ï¸¸\" === t || \"ï¹\" === t || \"ï¹\" === t || \"ï¸¾\" === t || \"ï¸¼\" === t || \"ï¸º\" === t || \"ï¸\" === t || \"ï¹\" === t || \"ï¸\" === t || \"ï¸\" === t || \"ï¸\" === t || \"ï½\" === t || \"ï¿£\" === t || \"ï¸\" === t || \"ï¸\" === t;\n    }\n    function Pf(t) {\n      return \"ï¸µ\" === t || \"ï¹\" === t || \"ï¸·\" === t || \"ï¹\" === t || \"ï¹\" === t || \"ï¸½\" === t || \"ï¸»\" === t || \"ï¸¹\" === t || \"ï¸\" === t || \"ï¸¿\" === t;\n    }\n    var Ef,\n      zf,\n      kf,\n      Tf = {};\n    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n    function Bf() {\n      return Ef || (Ef = 1, Tf.read = function (t, e, r, n, i) {\n        var s,\n          a,\n          o = 8 * i - n - 1,\n          l = (1 << o) - 1,\n          u = l >> 1,\n          c = -7,\n          h = r ? i - 1 : 0,\n          p = r ? -1 : 1,\n          f = t[e + h];\n        for (h += p, s = f & (1 << -c) - 1, f >>= -c, c += o; c > 0; s = 256 * s + t[e + h], h += p, c -= 8);\n        for (a = s & (1 << -c) - 1, s >>= -c, c += n; c > 0; a = 256 * a + t[e + h], h += p, c -= 8);\n        if (0 === s) s = 1 - u;else {\n          if (s === l) return a ? NaN : 1 / 0 * (f ? -1 : 1);\n          a += Math.pow(2, n), s -= u;\n        }\n        return (f ? -1 : 1) * a * Math.pow(2, s - n);\n      }, Tf.write = function (t, e, r, n, i, s) {\n        var a,\n          o,\n          l,\n          u = 8 * s - i - 1,\n          c = (1 << u) - 1,\n          h = c >> 1,\n          p = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,\n          f = n ? 0 : s - 1,\n          d = n ? 1 : -1,\n          m = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;\n        for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, a = c) : (a = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -a)) < 1 && (a--, l *= 2), (e += a + h >= 1 ? p / l : p * Math.pow(2, 1 - h)) * l >= 2 && (a++, l /= 2), a + h >= c ? (o = 0, a = c) : a + h >= 1 ? (o = (e * l - 1) * Math.pow(2, i), a += h) : (o = e * Math.pow(2, h - 1) * Math.pow(2, i), a = 0)); i >= 8; t[r + f] = 255 & o, f += d, o /= 256, i -= 8);\n        for (a = a << i | o, u += i; u > 0; t[r + f] = 255 & a, f += d, a /= 256, u -= 8);\n        t[r + f - d] |= 128 * m;\n      }), Tf;\n    }\n    function Vf() {\n      if (kf) return zf;\n      kf = 1, zf = e;\n      var t = Bf();\n      function e(t) {\n        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t) ? t : new Uint8Array(t || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;\n      }\n      e.Varint = 0, e.Fixed64 = 1, e.Bytes = 2, e.Fixed32 = 5;\n      var r = 4294967296,\n        n = 1 / r,\n        i = \"undefined\" == typeof TextDecoder ? null : new TextDecoder(\"utf8\");\n      function s(t) {\n        return t.type === e.Bytes ? t.readVarint() + t.pos : t.pos + 1;\n      }\n      function a(t, e, r) {\n        return r ? 4294967296 * e + (t >>> 0) : 4294967296 * (e >>> 0) + (t >>> 0);\n      }\n      function o(t, e, r) {\n        var n = e <= 16383 ? 1 : e <= 2097151 ? 2 : e <= 268435455 ? 3 : Math.floor(Math.log(e) / (7 * Math.LN2));\n        r.realloc(n);\n        for (var i = r.pos - 1; i >= t; i--) r.buf[i + n] = r.buf[i];\n      }\n      function l(t, e) {\n        for (var r = 0; r < t.length; r++) e.writeVarint(t[r]);\n      }\n      function u(t, e) {\n        for (var r = 0; r < t.length; r++) e.writeSVarint(t[r]);\n      }\n      function c(t, e) {\n        for (var r = 0; r < t.length; r++) e.writeFloat(t[r]);\n      }\n      function h(t, e) {\n        for (var r = 0; r < t.length; r++) e.writeDouble(t[r]);\n      }\n      function p(t, e) {\n        for (var r = 0; r < t.length; r++) e.writeBoolean(t[r]);\n      }\n      function f(t, e) {\n        for (var r = 0; r < t.length; r++) e.writeFixed32(t[r]);\n      }\n      function d(t, e) {\n        for (var r = 0; r < t.length; r++) e.writeSFixed32(t[r]);\n      }\n      function m(t, e) {\n        for (var r = 0; r < t.length; r++) e.writeFixed64(t[r]);\n      }\n      function y(t, e) {\n        for (var r = 0; r < t.length; r++) e.writeSFixed64(t[r]);\n      }\n      function g(t, e) {\n        return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + 16777216 * t[e + 3];\n      }\n      function x(t, e, r) {\n        t[r] = e, t[r + 1] = e >>> 8, t[r + 2] = e >>> 16, t[r + 3] = e >>> 24;\n      }\n      function v(t, e) {\n        return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) + (t[e + 3] << 24);\n      }\n      return e.prototype = {\n        destroy: function () {\n          this.buf = null;\n        },\n        readFields: function (t, e, r) {\n          for (r = r || this.length; this.pos < r;) {\n            var n = this.readVarint(),\n              i = n >> 3,\n              s = this.pos;\n            this.type = 7 & n, t(i, e, this), this.pos === s && this.skip(n);\n          }\n          return e;\n        },\n        readMessage: function (t, e) {\n          return this.readFields(t, e, this.readVarint() + this.pos);\n        },\n        readFixed32: function () {\n          var t = g(this.buf, this.pos);\n          return this.pos += 4, t;\n        },\n        readSFixed32: function () {\n          var t = v(this.buf, this.pos);\n          return this.pos += 4, t;\n        },\n        readFixed64: function () {\n          var t = g(this.buf, this.pos) + g(this.buf, this.pos + 4) * r;\n          return this.pos += 8, t;\n        },\n        readSFixed64: function () {\n          var t = g(this.buf, this.pos) + v(this.buf, this.pos + 4) * r;\n          return this.pos += 8, t;\n        },\n        readFloat: function () {\n          var e = t.read(this.buf, this.pos, !0, 23, 4);\n          return this.pos += 4, e;\n        },\n        readDouble: function () {\n          var e = t.read(this.buf, this.pos, !0, 52, 8);\n          return this.pos += 8, e;\n        },\n        readVarint: function (t) {\n          var e,\n            r,\n            n = this.buf;\n          return e = 127 & (r = n[this.pos++]), r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 7, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 14, r < 128 ? e : (e |= (127 & (r = n[this.pos++])) << 21, r < 128 ? e : function (t, e, r) {\n            var n,\n              i,\n              s = r.buf;\n            if (n = (112 & (i = s[r.pos++])) >> 4, i < 128) return a(t, n, e);\n            if (n |= (127 & (i = s[r.pos++])) << 3, i < 128) return a(t, n, e);\n            if (n |= (127 & (i = s[r.pos++])) << 10, i < 128) return a(t, n, e);\n            if (n |= (127 & (i = s[r.pos++])) << 17, i < 128) return a(t, n, e);\n            if (n |= (127 & (i = s[r.pos++])) << 24, i < 128) return a(t, n, e);\n            if (n |= (1 & (i = s[r.pos++])) << 31, i < 128) return a(t, n, e);\n            throw new Error(\"Expected varint not more than 10 bytes\");\n          }(e |= (15 & (r = n[this.pos])) << 28, t, this))));\n        },\n        readVarint64: function () {\n          return this.readVarint(!0);\n        },\n        readSVarint: function () {\n          var t = this.readVarint();\n          return t % 2 == 1 ? (t + 1) / -2 : t / 2;\n        },\n        readBoolean: function () {\n          return Boolean(this.readVarint());\n        },\n        readString: function () {\n          var t = this.readVarint() + this.pos,\n            e = this.pos;\n          return this.pos = t, t - e >= 12 && i ? function (t, e, r) {\n            return i.decode(t.subarray(e, r));\n          }(this.buf, e, t) : function (t, e, r) {\n            for (var n = \"\", i = e; i < r;) {\n              var s,\n                a,\n                o,\n                l = t[i],\n                u = null,\n                c = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;\n              if (i + c > r) break;\n              1 === c ? l < 128 && (u = l) : 2 === c ? 128 == (192 & (s = t[i + 1])) && (u = (31 & l) << 6 | 63 & s) <= 127 && (u = null) : 3 === c ? (a = t[i + 2], 128 == (192 & (s = t[i + 1])) && 128 == (192 & a) && ((u = (15 & l) << 12 | (63 & s) << 6 | 63 & a) <= 2047 || u >= 55296 && u <= 57343) && (u = null)) : 4 === c && (a = t[i + 2], o = t[i + 3], 128 == (192 & (s = t[i + 1])) && 128 == (192 & a) && 128 == (192 & o) && ((u = (15 & l) << 18 | (63 & s) << 12 | (63 & a) << 6 | 63 & o) <= 65535 || u >= 1114112) && (u = null)), null === u ? (u = 65533, c = 1) : u > 65535 && (u -= 65536, n += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | 1023 & u), n += String.fromCharCode(u), i += c;\n            }\n            return n;\n          }(this.buf, e, t);\n        },\n        readBytes: function () {\n          var t = this.readVarint() + this.pos,\n            e = this.buf.subarray(this.pos, t);\n          return this.pos = t, e;\n        },\n        readPackedVarint: function (t, r) {\n          if (this.type !== e.Bytes) return t.push(this.readVarint(r));\n          var n = s(this);\n          for (t = t || []; this.pos < n;) t.push(this.readVarint(r));\n          return t;\n        },\n        readPackedSVarint: function (t) {\n          if (this.type !== e.Bytes) return t.push(this.readSVarint());\n          var r = s(this);\n          for (t = t || []; this.pos < r;) t.push(this.readSVarint());\n          return t;\n        },\n        readPackedBoolean: function (t) {\n          if (this.type !== e.Bytes) return t.push(this.readBoolean());\n          var r = s(this);\n          for (t = t || []; this.pos < r;) t.push(this.readBoolean());\n          return t;\n        },\n        readPackedFloat: function (t) {\n          if (this.type !== e.Bytes) return t.push(this.readFloat());\n          var r = s(this);\n          for (t = t || []; this.pos < r;) t.push(this.readFloat());\n          return t;\n        },\n        readPackedDouble: function (t) {\n          if (this.type !== e.Bytes) return t.push(this.readDouble());\n          var r = s(this);\n          for (t = t || []; this.pos < r;) t.push(this.readDouble());\n          return t;\n        },\n        readPackedFixed32: function (t) {\n          if (this.type !== e.Bytes) return t.push(this.readFixed32());\n          var r = s(this);\n          for (t = t || []; this.pos < r;) t.push(this.readFixed32());\n          return t;\n        },\n        readPackedSFixed32: function (t) {\n          if (this.type !== e.Bytes) return t.push(this.readSFixed32());\n          var r = s(this);\n          for (t = t || []; this.pos < r;) t.push(this.readSFixed32());\n          return t;\n        },\n        readPackedFixed64: function (t) {\n          if (this.type !== e.Bytes) return t.push(this.readFixed64());\n          var r = s(this);\n          for (t = t || []; this.pos < r;) t.push(this.readFixed64());\n          return t;\n        },\n        readPackedSFixed64: function (t) {\n          if (this.type !== e.Bytes) return t.push(this.readSFixed64());\n          var r = s(this);\n          for (t = t || []; this.pos < r;) t.push(this.readSFixed64());\n          return t;\n        },\n        skip: function (t) {\n          var r = 7 & t;\n          if (r === e.Varint) for (; this.buf[this.pos++] > 127;);else if (r === e.Bytes) this.pos = this.readVarint() + this.pos;else if (r === e.Fixed32) this.pos += 4;else {\n            if (r !== e.Fixed64) throw new Error(\"Unimplemented type: \" + r);\n            this.pos += 8;\n          }\n        },\n        writeTag: function (t, e) {\n          this.writeVarint(t << 3 | e);\n        },\n        realloc: function (t) {\n          for (var e = this.length || 16; e < this.pos + t;) e *= 2;\n          if (e !== this.length) {\n            var r = new Uint8Array(e);\n            r.set(this.buf), this.buf = r, this.length = e;\n          }\n        },\n        finish: function () {\n          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);\n        },\n        writeFixed32: function (t) {\n          this.realloc(4), x(this.buf, t, this.pos), this.pos += 4;\n        },\n        writeSFixed32: function (t) {\n          this.realloc(4), x(this.buf, t, this.pos), this.pos += 4;\n        },\n        writeFixed64: function (t) {\n          this.realloc(8), x(this.buf, -1 & t, this.pos), x(this.buf, Math.floor(t * n), this.pos + 4), this.pos += 8;\n        },\n        writeSFixed64: function (t) {\n          this.realloc(8), x(this.buf, -1 & t, this.pos), x(this.buf, Math.floor(t * n), this.pos + 4), this.pos += 8;\n        },\n        writeVarint: function (t) {\n          (t = +t || 0) > 268435455 || t < 0 ? function (t, e) {\n            var r, n;\n            if (t >= 0 ? (r = t % 4294967296 | 0, n = t / 4294967296 | 0) : (n = ~(-t / 4294967296), 4294967295 ^ (r = ~(-t % 4294967296)) ? r = r + 1 | 0 : (r = 0, n = n + 1 | 0)), t >= 0x10000000000000000 || t < -0x10000000000000000) throw new Error(\"Given varint doesn't fit into 10 bytes\");\n            e.realloc(10), function (t, e, r) {\n              r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, t >>>= 7, r.buf[r.pos++] = 127 & t | 128, r.buf[r.pos] = 127 & (t >>>= 7);\n            }(r, 0, e), function (t, e) {\n              var r = (7 & t) << 4;\n              e.buf[e.pos++] |= r | ((t >>>= 3) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t | ((t >>>= 7) ? 128 : 0), t && (e.buf[e.pos++] = 127 & t)))));\n            }(n, e);\n          }(t, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = 127 & (t >>>= 7) | (t > 127 ? 128 : 0), t <= 127 || (this.buf[this.pos++] = t >>> 7 & 127))));\n        },\n        writeSVarint: function (t) {\n          this.writeVarint(t < 0 ? 2 * -t - 1 : 2 * t);\n        },\n        writeBoolean: function (t) {\n          this.writeVarint(Boolean(t));\n        },\n        writeString: function (t) {\n          t = String(t), this.realloc(4 * t.length), this.pos++;\n          var e = this.pos;\n          this.pos = function (t, e, r) {\n            for (var n, i, s = 0; s < e.length; s++) {\n              if ((n = e.charCodeAt(s)) > 55295 && n < 57344) {\n                if (!i) {\n                  n > 56319 || s + 1 === e.length ? (t[r++] = 239, t[r++] = 191, t[r++] = 189) : i = n;\n                  continue;\n                }\n                if (n < 56320) {\n                  t[r++] = 239, t[r++] = 191, t[r++] = 189, i = n;\n                  continue;\n                }\n                n = i - 55296 << 10 | n - 56320 | 65536, i = null;\n              } else i && (t[r++] = 239, t[r++] = 191, t[r++] = 189, i = null);\n              n < 128 ? t[r++] = n : (n < 2048 ? t[r++] = n >> 6 | 192 : (n < 65536 ? t[r++] = n >> 12 | 224 : (t[r++] = n >> 18 | 240, t[r++] = n >> 12 & 63 | 128), t[r++] = n >> 6 & 63 | 128), t[r++] = 63 & n | 128);\n            }\n            return r;\n          }(this.buf, t, this.pos);\n          var r = this.pos - e;\n          r >= 128 && o(e, r, this), this.pos = e - 1, this.writeVarint(r), this.pos += r;\n        },\n        writeFloat: function (e) {\n          this.realloc(4), t.write(this.buf, e, this.pos, !0, 23, 4), this.pos += 4;\n        },\n        writeDouble: function (e) {\n          this.realloc(8), t.write(this.buf, e, this.pos, !0, 52, 8), this.pos += 8;\n        },\n        writeBytes: function (t) {\n          var e = t.length;\n          this.writeVarint(e), this.realloc(e);\n          for (var r = 0; r < e; r++) this.buf[this.pos++] = t[r];\n        },\n        writeRawMessage: function (t, e) {\n          this.pos++;\n          var r = this.pos;\n          t(e, this);\n          var n = this.pos - r;\n          n >= 128 && o(r, n, this), this.pos = r - 1, this.writeVarint(n), this.pos += n;\n        },\n        writeMessage: function (t, r, n) {\n          this.writeTag(t, e.Bytes), this.writeRawMessage(r, n);\n        },\n        writePackedVarint: function (t, e) {\n          e.length && this.writeMessage(t, l, e);\n        },\n        writePackedSVarint: function (t, e) {\n          e.length && this.writeMessage(t, u, e);\n        },\n        writePackedBoolean: function (t, e) {\n          e.length && this.writeMessage(t, p, e);\n        },\n        writePackedFloat: function (t, e) {\n          e.length && this.writeMessage(t, c, e);\n        },\n        writePackedDouble: function (t, e) {\n          e.length && this.writeMessage(t, h, e);\n        },\n        writePackedFixed32: function (t, e) {\n          e.length && this.writeMessage(t, f, e);\n        },\n        writePackedSFixed32: function (t, e) {\n          e.length && this.writeMessage(t, d, e);\n        },\n        writePackedFixed64: function (t, e) {\n          e.length && this.writeMessage(t, m, e);\n        },\n        writePackedSFixed64: function (t, e) {\n          e.length && this.writeMessage(t, y, e);\n        },\n        writeBytesField: function (t, r) {\n          this.writeTag(t, e.Bytes), this.writeBytes(r);\n        },\n        writeFixed32Field: function (t, r) {\n          this.writeTag(t, e.Fixed32), this.writeFixed32(r);\n        },\n        writeSFixed32Field: function (t, r) {\n          this.writeTag(t, e.Fixed32), this.writeSFixed32(r);\n        },\n        writeFixed64Field: function (t, r) {\n          this.writeTag(t, e.Fixed64), this.writeFixed64(r);\n        },\n        writeSFixed64Field: function (t, r) {\n          this.writeTag(t, e.Fixed64), this.writeSFixed64(r);\n        },\n        writeVarintField: function (t, r) {\n          this.writeTag(t, e.Varint), this.writeVarint(r);\n        },\n        writeSVarintField: function (t, r) {\n          this.writeTag(t, e.Varint), this.writeSVarint(r);\n        },\n        writeStringField: function (t, r) {\n          this.writeTag(t, e.Bytes), this.writeString(r);\n        },\n        writeFloatField: function (t, r) {\n          this.writeTag(t, e.Fixed32), this.writeFloat(r);\n        },\n        writeDoubleField: function (t, r) {\n          this.writeTag(t, e.Fixed64), this.writeDouble(r);\n        },\n        writeBooleanField: function (t, e) {\n          this.writeVarintField(t, Boolean(e));\n        }\n      }, zf;\n    }\n    var Cf = e(Vf());\n    const Df = 3;\n    function Rf(t, e, r) {\n      e.glyphs = [], 1 === t && r.readMessage(Lf, e);\n    }\n    function Lf(t, e, r) {\n      if (3 === t) {\n        const {\n          id: t,\n          bitmap: n,\n          width: i,\n          height: s,\n          left: a,\n          top: o,\n          advance: l\n        } = r.readMessage(Ff, {});\n        e.glyphs.push({\n          id: t,\n          bitmap: new hc({\n            width: i + 2 * Df,\n            height: s + 2 * Df\n          }, n),\n          metrics: {\n            width: i,\n            height: s,\n            left: a,\n            top: o,\n            advance: l\n          }\n        });\n      } else 4 === t ? e.ascender = r.readSVarint() : 5 === t && (e.descender = r.readSVarint());\n    }\n    function Ff(t, e, r) {\n      1 === t ? e.id = r.readVarint() : 2 === t ? e.bitmap = r.readBytes() : 3 === t ? e.width = r.readVarint() : 4 === t ? e.height = r.readVarint() : 5 === t ? e.left = r.readSVarint() : 6 === t ? e.top = r.readSVarint() : 7 === t && (e.advance = r.readVarint());\n    }\n    const Of = Df,\n      Nf = {\n        horizontal: 1,\n        vertical: 2,\n        horizontalOnly: 3\n      };\n    class Uf {\n      constructor() {\n        this.scale = 1, this.fontStack = \"\", this.image = null;\n      }\n      static forText(t, e) {\n        const r = new Uf();\n        return r.scale = t || 1, r.fontStack = e, r;\n      }\n      static forImage(t) {\n        const e = new Uf();\n        return e.image = t, e;\n      }\n    }\n    class jf {\n      constructor() {\n        this.text = \"\", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;\n      }\n      static fromFeature(t, e, r) {\n        const n = new jf();\n        for (let i = 0; i < t.sections.length; i++) {\n          const s = t.sections[i];\n          s.image ? n.addImageSection(s, r) : n.addTextSection(s, e);\n        }\n        return n;\n      }\n      length() {\n        return this.text.length;\n      }\n      getSection(t) {\n        return this.sections[this.sectionIndex[t]];\n      }\n      getSections() {\n        return this.sections;\n      }\n      getSectionIndex(t) {\n        return this.sectionIndex[t];\n      }\n      getCodePoint(t) {\n        return this.text.codePointAt(t);\n      }\n      verticalizePunctuation(t) {\n        this.text = function (t, e) {\n          let r = \"\";\n          for (let n = 0; n < t.length; n++) {\n            const i = t.charCodeAt(n + 1) || null,\n              s = t.charCodeAt(n - 1) || null;\n            r += !e && (i && vs(i) && !If[t[n + 1]] || s && vs(s) && !If[t[n - 1]]) || !If[t[n]] ? t[n] : If[t[n]];\n          }\n          return r;\n        }(this.text, t);\n      }\n      trim() {\n        let t = 0;\n        for (let e = 0; e < this.text.length && $f[this.text.charCodeAt(e)]; e++) t++;\n        let e = this.text.length;\n        for (let r = this.text.length - 1; r >= 0 && r >= t && $f[this.text.charCodeAt(r)]; r--) e--;\n        this.text = this.text.substring(t, e), this.sectionIndex = this.sectionIndex.slice(t, e);\n      }\n      substring(t, e) {\n        const r = new jf();\n        return r.text = this.text.substring(t, e), r.sectionIndex = this.sectionIndex.slice(t, e), r.sections = this.sections, r;\n      }\n      toString() {\n        return this.text;\n      }\n      getMaxScale() {\n        return this.sectionIndex.reduce((t, e) => Math.max(t, this.sections[e].scale), 0);\n      }\n      addTextSection(t, e) {\n        this.text += t.text, this.sections.push(Uf.forText(t.scale, t.fontStack || e));\n        const r = this.sections.length - 1;\n        for (let e = 0; e < t.text.length; ++e) this.sectionIndex.push(r);\n      }\n      addImageSection(t, e) {\n        const r = t.image ? t.image.getPrimary() : null;\n        if (!r) return void pt(\"Can't add FormattedSection with an empty image.\");\n        r.scaleSelf(e);\n        const n = this.getNextImageSectionCharCode();\n        n ? (this.text += String.fromCodePoint(n), this.sections.push(Uf.forImage(r)), this.sectionIndex.push(this.sections.length - 1)) : pt(\"Reached maximum number of images 6401\");\n      }\n      getNextImageSectionCharCode() {\n        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);\n      }\n    }\n    function qf(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m = 1) {\n      const y = jf.fromFeature(t, i, m);\n      h === Nf.vertical && y.verticalizePunctuation(p);\n      let g = [];\n      const x = function (t, e, r, n, i, s) {\n          if (!t) return [];\n          const a = [],\n            o = function (t, e, r, n, i, s) {\n              let a = 0;\n              for (let r = 0; r < t.length(); r++) {\n                const o = t.getSection(r);\n                a += Yf(t.getCodePoint(r), o, n, i, e, s);\n              }\n              return a / Math.max(1, Math.ceil(a / r));\n            }(t, e, r, n, i, s),\n            l = t.text.indexOf(\"â\") >= 0;\n          let u = 0;\n          for (let r = 0; r < t.length(); r++) {\n            const h = t.getSection(r),\n              p = t.getCodePoint(r);\n            if ($f[p] || (u += Yf(p, h, n, i, e, s)), r < t.length() - 1) {\n              const e = !((c = p) < 11904 || !(ds[\"Bopomofo Extended\"](c) || ds.Bopomofo(c) || ds[\"CJK Compatibility Forms\"](c) || ds[\"CJK Compatibility Ideographs\"](c) || ds[\"CJK Compatibility\"](c) || ds[\"CJK Radicals Supplement\"](c) || ds[\"CJK Strokes\"](c) || ds[\"CJK Symbols and Punctuation\"](c) || ds[\"CJK Unified Ideographs Extension A\"](c) || ds[\"CJK Unified Ideographs\"](c) || ds[\"Enclosed CJK Letters and Months\"](c) || ds[\"Halfwidth and Fullwidth Forms\"](c) || ds.Hiragana(c) || ds[\"Ideographic Description Characters\"](c) || ds[\"Kangxi Radicals\"](c) || ds[\"Katakana Phonetic Extensions\"](c) || ds.Katakana(c) || ds[\"Vertical Forms\"](c) || ds[\"Yi Radicals\"](c) || ds[\"Yi Syllables\"](c)));\n              (Gf[p] || e || h.image) && a.push(Zf(r + 1, u, o, a, Xf(p, t.getCodePoint(r + 1), e && l), !1));\n            }\n          }\n          var c;\n          return Wf(Zf(t.length(), u, o, a, 0, !0));\n        }(y, u, s, e, n, f),\n        {\n          processBidirectionalText: v,\n          processStyledBidirectionalText: b\n        } = Ds;\n      if (v && 1 === y.sections.length) {\n        const t = v(y.toString(), x);\n        for (const e of t) {\n          const t = new jf();\n          t.text = e, t.sections = y.sections;\n          for (let r = 0; r < e.length; r++) t.sectionIndex.push(0);\n          g.push(t);\n        }\n      } else if (b) {\n        const t = b(y.text, y.sectionIndex, x);\n        for (const e of t) {\n          const t = new jf();\n          t.text = e[0], t.sectionIndex = e[1], t.sections = y.sections, g.push(t);\n        }\n      } else g = function (t, e) {\n        const r = [],\n          n = t.text;\n        let i = 0;\n        for (const n of e) r.push(t.substring(i, n)), i = n;\n        return i < n.length && r.push(t.substring(i, n.length)), r;\n      }(y, x);\n      const _ = [],\n        w = {\n          positionedLines: _,\n          text: y.toString(),\n          top: c[1],\n          bottom: c[1],\n          left: c[0],\n          right: c[0],\n          writingMode: h,\n          iconsInText: !1,\n          verticalizable: !1,\n          hasBaseline: !1\n        };\n      if (function (t, e, r, n, i, s, a, o, l, u, c, h) {\n        let p = 0,\n          f = 0,\n          d = 0;\n        const m = \"right\" === o ? 1 : \"left\" === o ? 0 : .5;\n        let y = !1;\n        for (const t of i) {\n          const r = t.getSections();\n          for (const t of r) {\n            if (t.image) continue;\n            const r = e[t.fontStack];\n            if (r && (y = void 0 !== r.ascender && void 0 !== r.descender, !y)) break;\n          }\n          if (!y) break;\n        }\n        let g = 0;\n        for (const a of i) {\n          a.trim();\n          const i = a.getMaxScale(),\n            o = (i - 1) * gf,\n            v = {\n              positionedGlyphs: [],\n              lineOffset: 0\n            };\n          t.positionedLines[g] = v;\n          const b = v.positionedGlyphs;\n          let _ = 0;\n          if (!a.length()) {\n            f += s, ++g;\n            continue;\n          }\n          let w = 0,\n            M = 0;\n          for (let s = 0; s < a.length(); s++) {\n            const o = a.getSection(s),\n              d = a.getSectionIndex(s),\n              m = a.getCodePoint(s);\n            let g = o.scale,\n              v = null,\n              A = null,\n              I = null,\n              S = gf,\n              P = 0;\n            l === Nf.vertical && (12312 === (x = m) || 12313 === x || 12316 === x || 12540 === x || 12448 === x) && (l = Nf.horizontal);\n            const E = !(l === Nf.horizontal || !c && !xs(m) || c && ($f[m] || bs(m)));\n            if (o.image) {\n              const e = n.get(o.image.toString());\n              if (!e) continue;\n              I = o.image, t.iconsInText = t.iconsInText || !0, A = e.paddedRect;\n              const r = e.displaySize;\n              g = g * gf / h, v = {\n                width: r[0],\n                height: r[1],\n                left: 0,\n                top: -Of,\n                advance: E ? r[1] : r[0],\n                localGlyph: !1\n              }, P = y ? -v.height * g : i * gf - 17 - r[1] * g, S = v.advance;\n              const s = (E ? r[0] : r[1]) * g - gf * i;\n              s > 0 && s > _ && (_ = s);\n            } else {\n              const t = r[o.fontStack];\n              if (!t) continue;\n              t[m] && (A = t[m]);\n              const n = e[o.fontStack];\n              if (!n) continue;\n              const s = n.glyphs[m];\n              if (!s) continue;\n              if (v = s.metrics, S = 8203 !== m ? gf : 0, y) {\n                const t = void 0 !== n.ascender ? Math.abs(n.ascender) : 0,\n                  e = void 0 !== n.descender ? Math.abs(n.descender) : 0,\n                  r = (t + e) * g;\n                w < r && (w = r, M = (t - e) / 2 * g), P = -t * g;\n              } else P = (i - g) * gf - 17;\n            }\n            E ? (t.verticalizable = !0, b.push({\n              glyph: m,\n              image: I,\n              x: p,\n              y: f + P,\n              vertical: E,\n              scale: g,\n              localGlyph: v.localGlyph,\n              fontStack: o.fontStack,\n              sectionIndex: d,\n              metrics: v,\n              rect: A\n            }), p += S * g + u) : (b.push({\n              glyph: m,\n              image: I,\n              x: p,\n              y: f + P,\n              vertical: E,\n              scale: g,\n              localGlyph: v.localGlyph,\n              fontStack: o.fontStack,\n              sectionIndex: d,\n              metrics: v,\n              rect: A\n            }), p += v.advance * g + u);\n          }\n          0 !== b.length && (d = Math.max(p - u, d), y ? Jf(b, m, _, M, s * i / 2) : Jf(b, m, _, 0, s / 2)), p = 0;\n          const A = s * i + _;\n          v.lineOffset = Math.max(_, o), f += A, ++g;\n        }\n        var x;\n        const v = f,\n          {\n            horizontalAlign: b,\n            verticalAlign: _\n          } = Kf(a);\n        (function (t, e, r, n, i, s) {\n          const a = (e - r) * i,\n            o = -s * n;\n          for (const e of t) for (const t of e.positionedGlyphs) t.x += a, t.y += o;\n        })(t.positionedLines, m, b, _, d, v), t.top += -_ * v, t.bottom = t.top + v, t.left += -b * d, t.right = t.left + d, t.hasBaseline = y;\n      }(w, e, r, n, g, a, o, l, h, u, p, d), !function (t) {\n        for (const e of t) if (0 !== e.positionedGlyphs.length) return !1;\n        return !0;\n      }(_)) return w;\n    }\n    const $f = {\n        9: !0,\n        10: !0,\n        11: !0,\n        12: !0,\n        13: !0,\n        32: !0\n      },\n      Gf = {\n        10: !0,\n        32: !0,\n        38: !0,\n        40: !0,\n        41: !0,\n        43: !0,\n        45: !0,\n        47: !0,\n        173: !0,\n        183: !0,\n        8203: !0,\n        8208: !0,\n        8211: !0,\n        8231: !0\n      };\n    function Yf(t, e, r, n, i, s) {\n      if (e.image) {\n        const t = n.get(e.image.toString());\n        return t ? t.displaySize[0] * e.scale * gf / s + i : 0;\n      }\n      {\n        const n = r[e.fontStack],\n          s = n && n.glyphs[t];\n        return s ? s.metrics.advance * e.scale + i : 0;\n      }\n    }\n    function Hf(t, e, r, n) {\n      const i = Math.pow(t - e, 2);\n      return n ? t < e ? i / 2 : 2 * i : i + Math.abs(r) * r;\n    }\n    function Xf(t, e, r) {\n      let n = 0;\n      return 10 === t && (n -= 1e4), r && (n += 150), 40 !== t && 65288 !== t || (n += 50), 41 !== e && 65289 !== e || (n += 50), n;\n    }\n    function Zf(t, e, r, n, i, s) {\n      let a = null,\n        o = Hf(e, r, i, s);\n      for (const t of n) {\n        const n = Hf(e - t.x, r, i, s) + t.badness;\n        n <= o && (a = t, o = n);\n      }\n      return {\n        index: t,\n        x: e,\n        priorBreak: a,\n        badness: o\n      };\n    }\n    function Wf(t) {\n      return t ? Wf(t.priorBreak).concat(t.index) : [];\n    }\n    function Kf(t) {\n      let e = .5,\n        r = .5;\n      switch (t) {\n        case \"right\":\n        case \"top-right\":\n        case \"bottom-right\":\n          e = 1;\n          break;\n        case \"left\":\n        case \"top-left\":\n        case \"bottom-left\":\n          e = 0;\n      }\n      switch (t) {\n        case \"bottom\":\n        case \"bottom-right\":\n        case \"bottom-left\":\n          r = 1;\n          break;\n        case \"top\":\n        case \"top-right\":\n        case \"top-left\":\n          r = 0;\n      }\n      return {\n        horizontalAlign: e,\n        verticalAlign: r\n      };\n    }\n    function Jf(t, e, r, n, i) {\n      if (!(e || r || n || i)) return;\n      const s = t.length - 1,\n        a = t[s],\n        o = (a.x + a.metrics.advance * a.scale) * e;\n      for (let e = 0; e <= s; e++) t[e].x -= o, t[e].y += r + n + i;\n    }\n    function Qf(t, e, r, n) {\n      const {\n          horizontalAlign: i,\n          verticalAlign: s\n        } = Kf(n),\n        a = r[0] - t.displaySize[0] * i,\n        o = r[1] - t.displaySize[1] * s;\n      return {\n        imagePrimary: t,\n        imageSecondary: e,\n        top: o,\n        bottom: o + t.displaySize[1],\n        left: a,\n        right: a + t.displaySize[0]\n      };\n    }\n    function td(t, e, r, n, i, s) {\n      const a = t.imagePrimary;\n      let o;\n      if (a.content) {\n        const t = a.content,\n          e = a.pixelRatio || 1;\n        o = [t[0] / e, t[1] / e, a.displaySize[0] - t[2] / e, a.displaySize[1] - t[3] / e];\n      }\n      const l = e.left * s,\n        u = e.right * s;\n      let c, h, p, f;\n      \"width\" === r || \"both\" === r ? (f = i[0] + l - n[3], h = i[0] + u + n[1]) : (f = i[0] + (l + u - a.displaySize[0]) / 2, h = f + a.displaySize[0]);\n      const d = e.top * s,\n        m = e.bottom * s;\n      return \"height\" === r || \"both\" === r ? (c = i[1] + d - n[0], p = i[1] + m + n[2]) : (c = i[1] + (d + m - a.displaySize[1]) / 2, p = c + a.displaySize[1]), {\n        imagePrimary: a,\n        imageSecondary: void 0,\n        top: c,\n        right: h,\n        bottom: p,\n        left: f,\n        collisionPadding: o\n      };\n    }\n    class ed extends q {\n      constructor(t, e, r, n, i) {\n        super(t, e), this.angle = n, this.z = r, void 0 !== i && (this.segment = i);\n      }\n      clone() {\n        return new ed(this.x, this.y, this.z, this.angle, this.segment);\n      }\n    }\n    function rd(t, e, r, n, i) {\n      if (void 0 === e.segment) return !0;\n      let s = e,\n        a = e.segment + 1,\n        o = 0;\n      for (; o > -r / 2;) {\n        if (a--, a < 0) return !1;\n        o -= t[a].dist(s), s = t[a];\n      }\n      o += t[a].dist(t[a + 1]), a++;\n      const l = [];\n      let u = 0;\n      for (; o < r / 2;) {\n        const e = t[a],\n          r = t[a + 1];\n        if (!r) return !1;\n        let s = t[a - 1].angleTo(e) - e.angleTo(r);\n        for (s = Math.abs((s + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l.push({\n          distance: o,\n          angleDelta: s\n        }), u += s; o - l[0].distance > n;) u -= l.shift().angleDelta;\n        if (u > i) return !1;\n        a++, o += e.dist(r);\n      }\n      return !0;\n    }\n    function nd(t) {\n      let e = 0;\n      for (let r = 0; r < t.length - 1; r++) e += t[r].dist(t[r + 1]);\n      return e;\n    }\n    function id(t, e, r) {\n      return t ? .6 * e * r : 0;\n    }\n    function sd(t, e) {\n      return Math.max(t ? t.right - t.left : 0, e ? e.right - e.left : 0);\n    }\n    function ad(t, e, r, n, i, s) {\n      const a = id(r, i, s),\n        o = sd(r, n) * s;\n      let l = 0;\n      const u = nd(t) / 2;\n      for (let r = 0; r < t.length - 1; r++) {\n        const n = t[r],\n          i = t[r + 1],\n          s = n.dist(i);\n        if (l + s > u) {\n          const c = (u - l) / s,\n            h = Ee(n.x, i.x, c),\n            p = Ee(n.y, i.y, c),\n            f = new ed(h, p, 0, i.angleTo(n), r);\n          return !a || rd(t, f, o, a, e) ? f : void 0;\n        }\n        l += s;\n      }\n    }\n    function od(t, e, r, n, i, s, a, o, l) {\n      const u = id(n, s, a),\n        c = sd(n, i),\n        h = c * a,\n        p = 0 === t[0].x || t[0].x === l || 0 === t[0].y || t[0].y === l;\n      return e - h < e / 4 && (e = h + e / 4), ld(t, p ? e / 2 * o % e : (c / 2 + 2 * s) * a * o % e, e, u, r, h, p, !1, l);\n    }\n    function ld(t, e, r, n, i, s, a, o, l) {\n      const u = s / 2,\n        c = nd(t);\n      let h = 0,\n        p = e - r,\n        f = [];\n      for (let e = 0; e < t.length - 1; e++) {\n        const a = t[e],\n          o = t[e + 1],\n          d = a.dist(o),\n          m = o.angleTo(a);\n        for (; p + r < h + d;) {\n          p += r;\n          const y = (p - h) / d,\n            g = Ee(a.x, o.x, y),\n            x = Ee(a.y, o.y, y);\n          if (g >= 0 && g < l && x >= 0 && x < l && p - u >= 0 && p + u <= c) {\n            const r = new ed(g, x, 0, m, e);\n            n && !rd(t, r, s, n, i) || f.push(r);\n          }\n        }\n        h += d;\n      }\n      return o || f.length || a || (f = ld(t, h / 2, r, n, i, s, a, !0, l)), f;\n    }\n    function ud(t, e, r, n, i) {\n      const s = [];\n      for (let a = 0; a < t.length; a++) {\n        const o = t[a];\n        let l;\n        for (let t = 0; t < o.length - 1; t++) {\n          let a = o[t],\n            u = o[t + 1];\n          a.x < e && u.x < e || (a.x < e ? a = new q(e, a.y + (e - a.x) / (u.x - a.x) * (u.y - a.y))._round() : u.x < e && (u = new q(e, a.y + (e - a.x) / (u.x - a.x) * (u.y - a.y))._round()), a.y < r && u.y < r || (a.y < r ? a = new q(a.x + (r - a.y) / (u.y - a.y) * (u.x - a.x), r)._round() : u.y < r && (u = new q(a.x + (r - a.y) / (u.y - a.y) * (u.x - a.x), r)._round()), a.x >= n && u.x >= n || (a.x >= n ? a = new q(n, a.y + (n - a.x) / (u.x - a.x) * (u.y - a.y))._round() : u.x >= n && (u = new q(n, a.y + (n - a.x) / (u.x - a.x) * (u.y - a.y))._round()), a.y >= i && u.y >= i || (a.y >= i ? a = new q(a.x + (i - a.y) / (u.y - a.y) * (u.x - a.x), i)._round() : u.y >= i && (u = new q(a.x + (i - a.y) / (u.y - a.y) * (u.x - a.x), i)._round()), l && a.equals(l[l.length - 1]) || (l = [a], s.push(l)), l.push(u)))));\n        }\n      }\n      return s;\n    }\n    function cd(t) {\n      let e = 0,\n        r = 0;\n      for (const n of t) e += n.w * n.h, r = Math.max(r, n.w);\n      t.sort((t, e) => e.h - t.h);\n      const n = [{\n        x: 0,\n        y: 0,\n        w: Math.max(Math.ceil(Math.sqrt(e / .95)), r),\n        h: 1 / 0\n      }];\n      let i = 0,\n        s = 0;\n      for (const e of t) for (let t = n.length - 1; t >= 0; t--) {\n        const r = n[t];\n        if (!(e.w > r.w || e.h > r.h)) {\n          if (e.x = r.x, e.y = r.y, s = Math.max(s, e.y + e.h), i = Math.max(i, e.x + e.w), e.w === r.w && e.h === r.h) {\n            const e = n.pop();\n            t < n.length && (n[t] = e);\n          } else e.h === r.h ? (r.x += e.w, r.w -= e.w) : e.w === r.w ? (r.y += e.h, r.h -= e.h) : (n.push({\n            x: r.x + e.w,\n            y: r.y,\n            w: r.w - e.w,\n            h: e.h\n          }), r.y += e.h, r.h -= e.h);\n          break;\n        }\n      }\n      return {\n        w: i,\n        h: s,\n        fill: e / (i * s) || 0\n      };\n    }\n    us(ed, \"Anchor\");\n    const hd = 1;\n    class pd {\n      static getImagePositionScale(t, e, r) {\n        if (e && t && t.options && t.options.transform) {\n          const e = t.options.transform;\n          return {\n            x: e.a,\n            y: e.d\n          };\n        }\n        return {\n          x: r,\n          y: r\n        };\n      }\n      constructor(t, e, r, n) {\n        this.paddedRect = t;\n        const {\n          pixelRatio: i,\n          version: s,\n          stretchX: a,\n          stretchY: o,\n          content: l,\n          sdf: u,\n          usvg: c\n        } = e;\n        this.pixelRatio = i, this.stretchX = a, this.stretchY = o, this.content = l, this.version = s, this.padding = r, this.sdf = u, this.scale = pd.getImagePositionScale(n, c, i);\n      }\n      get tl() {\n        return [this.paddedRect.x + this.padding, this.paddedRect.y + this.padding];\n      }\n      get br() {\n        return [this.paddedRect.x + this.paddedRect.w - this.padding, this.paddedRect.y + this.paddedRect.h - this.padding];\n      }\n      get displaySize() {\n        return [(this.paddedRect.w - 2 * this.padding) / this.scale.x, (this.paddedRect.h - 2 * this.padding) / this.scale.y];\n      }\n    }\n    function fd(t, e, r) {\n      const n = tr.parse(t),\n        i = function (t, e, r = [1, 1]) {\n          return {\n            x: 0,\n            y: 0,\n            w: (t.data ? t.data.width : t.width * r[0]) + 2 * e,\n            h: (t.data ? t.data.height : t.height * r[1]) + 2 * e\n          };\n        }(e, r, [n.options.transform.a, n.options.transform.d]);\n      return {\n        bin: i,\n        imagePosition: new pd(i, e, r, n),\n        imageVariant: n\n      };\n    }\n    class dd {\n      constructor(t, e, r) {\n        const n = new Map(),\n          i = new Map();\n        this.haveRenderCallbacks = [];\n        const s = [];\n        this.addImages(t, n, hd, s), this.addImages(e, i, 2, s);\n        const {\n            w: a,\n            h: o\n          } = cd(s),\n          l = new pc({\n            width: a || 1,\n            height: o || 1\n          });\n        for (const [e, i] of t.entries()) {\n          const t = n.get(e).paddedRect;\n          pc.copy(i.data, l, {\n            x: 0,\n            y: 0\n          }, {\n            x: t.x + hd,\n            y: t.y + hd\n          }, i.data, r, i.sdf);\n        }\n        for (const [t, n] of e.entries()) {\n          const e = i.get(t),\n            s = e.paddedRect;\n          let a = e.padding;\n          const o = s.x + a,\n            u = s.y + a,\n            c = n.data.width,\n            h = n.data.height;\n          a = a > 1 ? a - 1 : a, pc.copy(n.data, l, {\n            x: 0,\n            y: 0\n          }, {\n            x: o,\n            y: u\n          }, n.data, r), pc.copy(n.data, l, {\n            x: 0,\n            y: h - a\n          }, {\n            x: o,\n            y: u - a\n          }, {\n            width: c,\n            height: a\n          }, r), pc.copy(n.data, l, {\n            x: 0,\n            y: 0\n          }, {\n            x: o,\n            y: u + h\n          }, {\n            width: c,\n            height: a\n          }, r), pc.copy(n.data, l, {\n            x: c - a,\n            y: 0\n          }, {\n            x: o - a,\n            y: u\n          }, {\n            width: a,\n            height: h\n          }, r), pc.copy(n.data, l, {\n            x: 0,\n            y: 0\n          }, {\n            x: o + c,\n            y: u\n          }, {\n            width: a,\n            height: h\n          }, r), pc.copy(n.data, l, {\n            x: c - a,\n            y: h - a\n          }, {\n            x: o - a,\n            y: u - a\n          }, {\n            width: a,\n            height: a\n          }, r), pc.copy(n.data, l, {\n            x: 0,\n            y: h - a\n          }, {\n            x: o + c,\n            y: u - a\n          }, {\n            width: a,\n            height: a\n          }, r), pc.copy(n.data, l, {\n            x: 0,\n            y: 0\n          }, {\n            x: o + c,\n            y: u + h\n          }, {\n            width: a,\n            height: a\n          }, r), pc.copy(n.data, l, {\n            x: c - a,\n            y: 0\n          }, {\n            x: o - a,\n            y: u + h\n          }, {\n            width: a,\n            height: a\n          }, r);\n        }\n        this.lut = r, this.image = l, this.iconPositions = n, this.patternPositions = i;\n      }\n      addImages(t, e, r, n) {\n        for (const [i, s] of t.entries()) {\n          const {\n            bin: t,\n            imagePosition: a,\n            imageVariant: o\n          } = fd(i, s, r);\n          e.set(i, a), n.push(t), s.hasRenderCallback && this.haveRenderCallbacks.push(o.id);\n        }\n      }\n      patchUpdatedImages(t, e, r) {\n        this.haveRenderCallbacks = this.haveRenderCallbacks.filter(e => t.hasImage(e, r)), t.dispatchRenderCallbacks(this.haveRenderCallbacks, r);\n        for (const n of t.getUpdatedImages(r)) {\n          for (const i of this.iconPositions.keys()) {\n            const s = tr.parse(i);\n            if (we.isEqual(s.id, n)) {\n              const s = t.getImage(n, r);\n              this.patchUpdatedImage(this.iconPositions.get(i), s, e);\n            }\n          }\n          for (const i of this.patternPositions.keys()) {\n            const s = tr.parse(i);\n            if (we.isEqual(s.id, n)) {\n              const s = t.getImage(n, r);\n              this.patchUpdatedImage(this.patternPositions.get(i), s, e);\n            }\n          }\n        }\n      }\n      patchUpdatedImage(t, e, r) {\n        if (!t || !e) return;\n        if (t.version === e.version) return;\n        t.version = e.version;\n        const [n, i] = t.tl,\n          s = t.sdf;\n        if (this.lut || s) {\n          const t = {\n              width: e.data.width,\n              height: e.data.height\n            },\n            a = new pc(t);\n          pc.copy(e.data, a, {\n            x: 0,\n            y: 0\n          }, {\n            x: 0,\n            y: 0\n          }, t, this.lut, s), r.update(a, {\n            position: {\n              x: n,\n              y: i\n            }\n          });\n        } else r.update(e.data, {\n          position: {\n            x: n,\n            y: i\n          }\n        });\n      }\n    }\n    us(pd, \"ImagePosition\"), us(dd, \"ImageAtlas\");\n    const md = 1e20;\n    function yd(t, e, r, n, i, s, a, o, l) {\n      for (let u = e; u < e + n; u++) gd(t, r * s + u, s, i, a, o, l);\n      for (let u = r; u < r + i; u++) gd(t, u * s + e, 1, n, a, o, l);\n    }\n    function gd(t, e, r, n, i, s, a) {\n      s[0] = 0, a[0] = -md, a[1] = md, i[0] = t[e];\n      for (let o = 1, l = 0, u = 0; o < n; o++) {\n        i[o] = t[e + o * r];\n        const n = o * o;\n        do {\n          const t = s[l];\n          u = (i[o] - i[t] + n - t * t) / (o - t) / 2;\n        } while (u <= a[l] && --l > -1);\n        l++, s[l] = o, a[l] = u, a[l + 1] = md;\n      }\n      for (let o = 0, l = 0; o < n; o++) {\n        for (; a[l + 1] < o;) l++;\n        const n = s[l],\n          u = o - n;\n        t[e + o * r] = i[n] + u * u;\n      }\n    }\n    const xd = 2,\n      vd = {\n        none: 0,\n        ideographs: 1,\n        all: 2\n      };\n    class bd {\n      constructor(t, e, r) {\n        this.requestManager = t, this.localGlyphMode = e, this.localFontFamily = r, this.urls = {}, this.entries = {}, this.localGlyphs = {\n          200: {},\n          400: {},\n          500: {},\n          900: {}\n        };\n      }\n      setURL(t, e) {\n        this.urls[e] = t;\n      }\n      getGlyphs(t, e, r) {\n        const n = [],\n          i = this.urls[e] || At.GLYPHS_URL;\n        for (const e in t) for (const r of t[e]) n.push({\n          stack: e,\n          id: r\n        });\n        rt(n, ({\n          stack: t,\n          id: e\n        }, r) => {\n          let n = this.entries[t];\n          n || (n = this.entries[t] = {\n            glyphs: {},\n            requests: {},\n            ranges: {},\n            ascender: void 0,\n            descender: void 0\n          });\n          let s = n.glyphs[e];\n          if (void 0 !== s) return void r(null, {\n            stack: t,\n            id: e,\n            glyph: s\n          });\n          if (s = this._tinySDF(n, t, e), s) return n.glyphs[e] = s, void r(null, {\n            stack: t,\n            id: e,\n            glyph: s\n          });\n          const a = Math.floor(e / 256);\n          if (256 * a > 65535) return pt(\"glyphs > 65535 not supported\"), void r(null, {\n            stack: t,\n            id: e,\n            glyph: s\n          });\n          if (n.ranges[a]) return void r(null, {\n            stack: t,\n            id: e,\n            glyph: s\n          });\n          let o = n.requests[a];\n          o || (o = n.requests[a] = [], bd.loadGlyphRange(t, a, i, this.requestManager, (t, e) => {\n            if (e) {\n              n.ascender = e.ascender, n.descender = e.descender;\n              for (const t in e.glyphs) this._doesCharSupportLocalGlyph(+t) || (n.glyphs[+t] = e.glyphs[+t]);\n              n.ranges[a] = !0;\n            }\n            for (const r of o) r(t, e);\n            delete n.requests[a];\n          })), o.push((n, i) => {\n            n ? r(n) : i && r(null, {\n              stack: t,\n              id: e,\n              glyph: i.glyphs[e] || null\n            });\n          });\n        }, (t, e) => {\n          if (t) r(t);else if (e) {\n            const t = {};\n            for (const {\n              stack: r,\n              id: n,\n              glyph: i\n            } of e) void 0 === t[r] && (t[r] = {}), void 0 === t[r].glyphs && (t[r].glyphs = {}), t[r].glyphs[n] = i && {\n              id: i.id,\n              bitmap: i.bitmap.clone(),\n              metrics: i.metrics\n            }, t[r].ascender = this.entries[r].ascender, t[r].descender = this.entries[r].descender;\n            r(null, t);\n          }\n        });\n      }\n      _doesCharSupportLocalGlyph(t) {\n        return this.localGlyphMode !== vd.none && (this.localGlyphMode === vd.all ? !!this.localFontFamily : !!this.localFontFamily && (ds[\"CJK Unified Ideographs\"](t) || ds[\"Hangul Syllables\"](t) || ds.Hiragana(t) || ds.Katakana(t) || ds[\"CJK Symbols and Punctuation\"](t) || ds[\"CJK Unified Ideographs Extension A\"](t) || ds[\"CJK Unified Ideographs Extension B\"](t) || ds.Osage(t)));\n      }\n      _tinySDF(t, e, r) {\n        const n = this.localFontFamily;\n        if (!n || !this._doesCharSupportLocalGlyph(r)) return;\n        let i = t.tinySDF;\n        if (!i) {\n          let r = \"400\";\n          /bold/i.test(e) ? r = \"900\" : /medium/i.test(e) ? r = \"500\" : /light/i.test(e) && (r = \"200\"), i = t.tinySDF = new bd.TinySDF({\n            fontFamily: n,\n            fontWeight: r,\n            fontSize: 24 * xd,\n            buffer: 3 * xd,\n            radius: 8 * xd\n          }), i.fontWeight = r;\n        }\n        if (this.localGlyphs[i.fontWeight][r]) return this.localGlyphs[i.fontWeight][r];\n        const s = String.fromCodePoint(r),\n          {\n            data: a,\n            width: o,\n            height: l,\n            glyphWidth: u,\n            glyphHeight: c,\n            glyphLeft: h,\n            glyphTop: p,\n            glyphAdvance: f\n          } = i.draw(s);\n        return this.localGlyphs[i.fontWeight][r] = {\n          id: r,\n          bitmap: new hc({\n            width: o,\n            height: l\n          }, a),\n          metrics: {\n            width: u / xd,\n            height: c / xd,\n            left: h / xd,\n            top: p / xd - 27,\n            advance: f / xd,\n            localGlyph: !0\n          }\n        };\n      }\n    }\n    bd.loadGlyphRange = function (t, e, r, n, i) {\n      const s = 256 * e,\n        a = s + 255,\n        o = n.transformRequest(n.normalizeGlyphsURL(r).replace(\"{fontstack}\", t).replace(\"{range}\", `${s}-${a}`), Qt.Glyphs);\n      ne(o, (t, e) => {\n        if (t) i(t);else if (e) {\n          const t = {},\n            r = function (t) {\n              return new Cf(t).readFields(Rf, {});\n            }(e);\n          for (const e of r.glyphs) t[e.id] = e;\n          i(null, {\n            glyphs: t,\n            ascender: r.ascender,\n            descender: r.descender\n          });\n        }\n      });\n    }, bd.TinySDF = class {\n      constructor({\n        fontSize: t = 24,\n        buffer: e = 3,\n        radius: r = 8,\n        cutoff: n = .25,\n        fontFamily: i = \"sans-serif\",\n        fontWeight: s = \"normal\",\n        fontStyle: a = \"normal\"\n      } = {}) {\n        this.buffer = e, this.cutoff = n, this.radius = r;\n        const o = this.size = t + 4 * e,\n          l = this._createCanvas(o),\n          u = this.ctx = l.getContext(\"2d\", {\n            willReadFrequently: !0\n          });\n        u.font = `${a} ${s} ${t}px ${i}`, u.textBaseline = \"alphabetic\", u.textAlign = \"left\", u.fillStyle = \"black\", this.gridOuter = new Float64Array(o * o), this.gridInner = new Float64Array(o * o), this.f = new Float64Array(o), this.z = new Float64Array(o + 1), this.v = new Uint16Array(o);\n      }\n      _createCanvas(t) {\n        const e = document.createElement(\"canvas\");\n        return e.width = e.height = t, e;\n      }\n      draw(t) {\n        const {\n            width: e,\n            actualBoundingBoxAscent: r,\n            actualBoundingBoxDescent: n,\n            actualBoundingBoxLeft: i,\n            actualBoundingBoxRight: s\n          } = this.ctx.measureText(t),\n          a = Math.ceil(r),\n          o = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s - i))),\n          l = Math.min(this.size - this.buffer, a + Math.ceil(n)),\n          u = o + 2 * this.buffer,\n          c = l + 2 * this.buffer,\n          h = Math.max(u * c, 0),\n          p = new Uint8ClampedArray(h),\n          f = {\n            data: p,\n            width: u,\n            height: c,\n            glyphWidth: o,\n            glyphHeight: l,\n            glyphTop: a,\n            glyphLeft: 0,\n            glyphAdvance: e\n          };\n        if (0 === o || 0 === l) return f;\n        const {\n          ctx: d,\n          buffer: m,\n          gridInner: y,\n          gridOuter: g\n        } = this;\n        d.clearRect(m, m, o, l), d.fillText(t, m, m + a);\n        const x = d.getImageData(m, m, o, l);\n        g.fill(md, 0, h), y.fill(0, 0, h);\n        for (let t = 0; t < l; t++) for (let e = 0; e < o; e++) {\n          const r = x.data[4 * (t * o + e) + 3] / 255;\n          if (0 === r) continue;\n          const n = (t + m) * u + e + m;\n          if (1 === r) g[n] = 0, y[n] = md;else {\n            const t = .5 - r;\n            g[n] = t > 0 ? t * t : 0, y[n] = t < 0 ? t * t : 0;\n          }\n        }\n        yd(g, 0, 0, u, c, u, this.f, this.v, this.z), yd(y, m, m, o, l, u, this.f, this.v, this.z);\n        for (let t = 0; t < h; t++) {\n          const e = Math.sqrt(g[t]) - Math.sqrt(y[t]);\n          p[t] = Math.round(255 - 255 * (e / this.radius + this.cutoff));\n        }\n        return f;\n      }\n    };\n    const _d = hd;\n    function wd(t, e) {\n      return t + e[1] - e[0];\n    }\n    function Md(t, e, r, n, i = 1) {\n      const s = [],\n        a = t.imagePrimary,\n        o = a.pixelRatio,\n        l = a.paddedRect.w - 2 * _d,\n        u = a.paddedRect.h - 2 * _d,\n        c = (t.right - t.left) * i,\n        h = (t.bottom - t.top) * i,\n        p = a.stretchX || [[0, l]],\n        f = a.stretchY || [[0, u]],\n        d = p.reduce(wd, 0),\n        m = f.reduce(wd, 0),\n        y = l - d,\n        g = u - m;\n      let x = 0,\n        v = d,\n        b = 0,\n        _ = m,\n        w = 0,\n        M = y,\n        A = 0,\n        I = g;\n      if (a.content && n) {\n        const t = a.content;\n        x = Ad(p, 0, t[0]), b = Ad(f, 0, t[1]), v = Ad(p, t[0], t[2]), _ = Ad(f, t[1], t[3]), w = t[0] - x, A = t[1] - b, M = t[2] - t[0] - v, I = t[3] - t[1] - _;\n      }\n      const S = (n, s, l, u) => {\n        const p = Sd(n.stretch - x, v, c, t.left * i),\n          f = Pd(n.fixed - w, M, n.stretch, d),\n          y = Sd(s.stretch - b, _, h, t.top * i),\n          g = Pd(s.fixed - A, I, s.stretch, m),\n          S = Sd(l.stretch - x, v, c, t.left * i),\n          P = Pd(l.fixed - w, M, l.stretch, d),\n          E = Sd(u.stretch - b, _, h, t.top * i),\n          z = Pd(u.fixed - A, I, u.stretch, m),\n          k = new q(p, y),\n          T = new q(S, y),\n          B = new q(S, E),\n          V = new q(p, E),\n          C = new q(f / o, g / o),\n          D = new q(P / o, z / o),\n          R = e * Math.PI / 180;\n        if (R) {\n          const t = Math.sin(R),\n            e = Math.cos(R),\n            r = [e, -t, t, e];\n          k._matMult(r), T._matMult(r), V._matMult(r), B._matMult(r);\n        }\n        const L = n.stretch + n.fixed,\n          F = l.stretch + l.fixed,\n          O = s.stretch + s.fixed,\n          N = u.stretch + u.fixed,\n          U = t.imageSecondary;\n        return {\n          tl: k,\n          tr: T,\n          bl: V,\n          br: B,\n          texPrimary: {\n            x: a.paddedRect.x + _d + L,\n            y: a.paddedRect.y + _d + O,\n            w: F - L,\n            h: N - O\n          },\n          texSecondary: U ? {\n            x: U.paddedRect.x + _d + L,\n            y: U.paddedRect.y + _d + O,\n            w: F - L,\n            h: N - O\n          } : void 0,\n          writingMode: void 0,\n          glyphOffset: [0, 0],\n          sectionIndex: 0,\n          pixelOffsetTL: C,\n          pixelOffsetBR: D,\n          minFontScaleX: M / o / c,\n          minFontScaleY: I / o / h,\n          isSDF: r\n        };\n      };\n      if (n && (a.stretchX || a.stretchY)) {\n        const t = Id(p, y, d),\n          e = Id(f, g, m);\n        for (let r = 0; r < t.length - 1; r++) {\n          const n = t[r],\n            i = t[r + 1];\n          for (let t = 0; t < e.length - 1; t++) s.push(S(n, e[t], i, e[t + 1]));\n        }\n      } else s.push(S({\n        fixed: 0,\n        stretch: -1\n      }, {\n        fixed: 0,\n        stretch: -1\n      }, {\n        fixed: 0,\n        stretch: l + 1\n      }, {\n        fixed: 0,\n        stretch: u + 1\n      }));\n      return s;\n    }\n    function Ad(t, e, r) {\n      let n = 0;\n      for (const i of t) n += Math.max(e, Math.min(r, i[1])) - Math.max(e, Math.min(r, i[0]));\n      return n;\n    }\n    function Id(t, e, r) {\n      const n = [{\n        fixed: -_d,\n        stretch: 0\n      }];\n      for (const [e, r] of t) {\n        const t = n[n.length - 1];\n        n.push({\n          fixed: e - t.stretch,\n          stretch: t.stretch\n        }), n.push({\n          fixed: e - t.stretch,\n          stretch: t.stretch + (r - e)\n        });\n      }\n      return n.push({\n        fixed: e + _d,\n        stretch: r\n      }), n;\n    }\n    function Sd(t, e, r, n) {\n      return t / e * r + n;\n    }\n    function Pd(t, e, r, n) {\n      return t - e * r / n;\n    }\n    function Ed(t, e, r, n) {\n      const i = e + t.positionedLines[n].lineOffset;\n      return 0 === n ? r + i / 2 : r + (i + (e + t.positionedLines[n - 1].lineOffset)) / 2;\n    }\n    function zd(t, e = 1, r = !1) {\n      let n = 1 / 0,\n        i = 1 / 0,\n        s = -1 / 0,\n        a = -1 / 0;\n      const o = t[0];\n      for (let t = 0; t < o.length; t++) {\n        const e = o[t];\n        (!t || e.x < n) && (n = e.x), (!t || e.y < i) && (i = e.y), (!t || e.x > s) && (s = e.x), (!t || e.y > a) && (a = e.y);\n      }\n      const l = Math.min(s - n, a - i);\n      let u = l / 2;\n      const c = new Wr([], kd);\n      if (0 === l) return new q(n, i);\n      for (let e = n; e < s; e += l) for (let r = i; r < a; r += l) c.push(new Td(e + u, r + u, u, t));\n      let h = function (t) {\n          let e = 0,\n            r = 0,\n            n = 0;\n          const i = t[0];\n          for (let t = 0, s = i.length, a = s - 1; t < s; a = t++) {\n            const s = i[t],\n              o = i[a],\n              l = s.x * o.y - o.x * s.y;\n            r += (s.x + o.x) * l, n += (s.y + o.y) * l, e += 3 * l;\n          }\n          return new Td(r / e, n / e, 0, t);\n        }(t),\n        p = c.length;\n      for (; c.length;) {\n        const n = c.pop();\n        (n.d > h.d || !h.d) && (h = n, r && console.log(\"found best %d after %d probes\", Math.round(1e4 * n.d) / 1e4, p)), n.max - h.d <= e || (u = n.h / 2, c.push(new Td(n.p.x - u, n.p.y - u, u, t)), c.push(new Td(n.p.x + u, n.p.y - u, u, t)), c.push(new Td(n.p.x - u, n.p.y + u, u, t)), c.push(new Td(n.p.x + u, n.p.y + u, u, t)), p += 4);\n      }\n      return r && (console.log(`num probes: ${p}`), console.log(`best distance: ${h.d}`)), h.p;\n    }\n    function kd(t, e) {\n      return e.max - t.max;\n    }\n    class Td {\n      constructor(t, e, r, n) {\n        this.p = new q(t, e), this.h = r, this.d = function (t, e) {\n          let r = !1,\n            n = 1 / 0;\n          for (let i = 0; i < e.length; i++) {\n            const s = e[i];\n            for (let e = 0, i = s.length, a = i - 1; e < i; a = e++) {\n              const i = s[e],\n                o = s[a];\n              i.y > t.y != o.y > t.y && t.x < (o.x - i.x) * (t.y - i.y) / (o.y - i.y) + i.x && (r = !r), n = Math.min(n, Gl(t, i, o));\n            }\n          }\n          return (r ? 1 : -1) * Math.sqrt(n);\n        }(this.p, n), this.max = this.d + this.h * Math.SQRT2;\n      }\n    }\n    const Bd = Number.POSITIVE_INFINITY,\n      Vd = Math.sqrt(2);\n    function Cd(t, [e, r]) {\n      let n = 0,\n        i = 0;\n      if (r === Bd) {\n        e < 0 && (e = 0);\n        const r = e / Vd;\n        switch (t) {\n          case \"top-right\":\n          case \"top-left\":\n            i = r - 7;\n            break;\n          case \"bottom-right\":\n          case \"bottom-left\":\n            i = 7 - r;\n            break;\n          case \"bottom\":\n            i = 7 - e;\n            break;\n          case \"top\":\n            i = e - 7;\n        }\n        switch (t) {\n          case \"top-right\":\n          case \"bottom-right\":\n            n = -r;\n            break;\n          case \"top-left\":\n          case \"bottom-left\":\n            n = r;\n            break;\n          case \"left\":\n            n = e;\n            break;\n          case \"right\":\n            n = -e;\n        }\n      } else {\n        switch (e = Math.abs(e), r = Math.abs(r), t) {\n          case \"top-right\":\n          case \"top-left\":\n          case \"top\":\n            i = r - 7;\n            break;\n          case \"bottom-right\":\n          case \"bottom-left\":\n          case \"bottom\":\n            i = 7 - r;\n        }\n        switch (t) {\n          case \"top-right\":\n          case \"bottom-right\":\n          case \"right\":\n            n = -e;\n            break;\n          case \"top-left\":\n          case \"bottom-left\":\n          case \"left\":\n            n = e;\n        }\n      }\n      return [n, i];\n    }\n    function Dd(t, e, r, n, i, s, a, o) {\n      if (!t) return;\n      const l = vf(e, r, n, i, s);\n      return t.scaleSelf(l * o * a);\n    }\n    function Rd(t, e, r, n, i, s, a, o) {\n      return {\n        iconPrimary: Dd(t.getPrimary(), e, r, n, i, s, a, o),\n        iconSecondary: Dd(t.getSecondary(), e, r, n, i, s, a, o)\n      };\n    }\n    function Ld(t, e, r, n) {\n      if (!t) return;\n      const i = e.get(r.toString());\n      if (t.imagePrimary = i, n) {\n        const r = e.get(n.toString());\n        t.imageSecondary = r;\n      }\n    }\n    function Fd(t, e) {\n      for (const r in t.horizontal) Od(t.horizontal[r], e);\n      Od(t.vertical, e);\n    }\n    function Od(t, e) {\n      if (t) for (const r of t.positionedLines) for (const t of r.positionedGlyphs) if (null !== t.image) {\n        const r = t.image.toString();\n        t.rect = e.get(r).paddedRect;\n      }\n    }\n    function Nd(t) {\n      switch (t) {\n        case \"right\":\n        case \"top-right\":\n        case \"bottom-right\":\n          return \"right\";\n        case \"left\":\n        case \"top-left\":\n        case \"bottom-left\":\n          return \"left\";\n      }\n      return \"center\";\n    }\n    function Ud(t, e, r, n, i, s, a, o, l) {\n      const u = Yd(s.horizontal) || s.vertical,\n        c = r.get(\"icon-text-fit-padding\").evaluate(n, {}, i);\n      let h,\n        p = e;\n      return e && \"none\" !== l && (t.allowVerticalPlacement && s.vertical && (h = td(e, s.vertical, l, c, o, a)), u && (p = td(e, u, l, c, o, a))), {\n        defaultShapedIcon: p,\n        verticallyShapedIcon: h\n      };\n    }\n    function jd(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y, g, x, v) {\n      let b = a.textMaxSize.evaluate(e, {}, p);\n      void 0 === b ? b = o * a.textScaleFactor : b *= a.textScaleFactor;\n      const _ = t.layers[0].layout,\n        w = Yd(r.horizontal) || r.vertical,\n        M = \"globe\" === f.name,\n        A = gf,\n        I = t.tilePixelRatio * b / A,\n        S = (B = t.overscaling, t.zoom > 18 && B > 2 && (B >>= 1), Math.max(Kr / (512 * B), 1) * _.get(\"symbol-spacing\")),\n        P = _.get(\"text-padding\") * t.tilePixelRatio,\n        E = _.get(\"icon-padding\") * t.tilePixelRatio,\n        z = H(_.get(\"text-max-angle\")),\n        k = \"map\" === _.get(\"icon-rotation-alignment\") && \"point\" !== v,\n        T = S / 2;\n      var B;\n      !1 === t.hasAnyIconTextFit && \"none\" !== y && (t.hasAnyIconTextFit = !0);\n      const V = e.properties ? +e.properties[oh] : null,\n        C = V && t.elevationFeatureIdToIndex ? t.elevationFeatureIdToIndex.get(V) : 65535,\n        D = (o, l, v) => {\n          if (l.x < 0 || l.x >= Kr || l.y < 0 || l.y >= Kr) return;\n          let b = null;\n          if (M) {\n            const {\n              x: t,\n              y: e,\n              z: r\n            } = f.projectTilePoint(l.x, l.y, v);\n            b = {\n              anchor: new ed(t, e, r, 0, void 0),\n              up: f.upVector(v, l.x, l.y)\n            };\n          }\n          !function (t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y, g, x, v, b, _, w, M, A, I, S, P, E) {\n            const z = t.addToLineVertexArray(e, n);\n            let k,\n              T,\n              B,\n              V,\n              C,\n              D,\n              R,\n              L = 0,\n              F = 0,\n              O = 0,\n              N = 0,\n              U = -1,\n              j = -1;\n            const q = {};\n            let $ = ye(\"\");\n            const G = r ? r.anchor : e,\n              Y = \"none\" !== P;\n            let H = 0,\n              X = 0;\n            if (void 0 === l._unevaluatedLayout.getValue(\"text-radial-offset\") ? [H, X] = l.layout.get(\"text-offset\").evaluate(b, {}, A).map(t => t * gf) : (H = l.layout.get(\"text-radial-offset\").evaluate(b, {}, A) * gf, X = Bd), t.allowVerticalPlacement && i.vertical) {\n              const t = i.vertical;\n              if (d) D = Xd(t), o && (R = Xd(o));else {\n                const r = l.layout.get(\"text-rotate\").evaluate(b, {}, A) + 90;\n                B = Hd(u, G, e, c, h, p, t, f, r, m), o && (V = Hd(u, G, e, c, h, p, o, g, r));\n              }\n            }\n            if (s) {\n              const n = t.iconSizeData,\n                i = l.layout.get(\"icon-rotate\").evaluate(b, {}, A),\n                a = Md(s, i, w, Y, _.iconScaleFactor),\n                f = o ? Md(o, i, w, Y, _.iconScaleFactor) : void 0;\n              T = Hd(u, G, e, c, h, p, s, g, i, null), L = 4 * a.length;\n              let d = null;\n              \"source\" === n.kind ? (d = [xf * l.layout.get(\"icon-size\").evaluate(b, {}, A) * _.iconScaleFactor], d[0] > $d && pt(`${t.layerIds[0]}: Value for \"icon-size\" is >= ${qd}. Reduce your \"icon-size\".`)) : \"composite\" === n.kind && (d = [xf * _.compositeIconSizes[0].evaluate(b, {}, A) * _.iconScaleFactor, xf * _.compositeIconSizes[1].evaluate(b, {}, A) * _.iconScaleFactor], (d[0] > $d || d[1] > $d) && pt(`${t.layerIds[0]}: Value for \"icon-size\" is >= ${qd}. Reduce your \"icon-size\".`)), t.addSymbols(t.icon, a, d, v, x, b, !1, r, e, z.lineStartIndex, z.lineLength, -1, M, A, I, S), U = t.icon.placedSymbolArray.length - 1, f && (F = 4 * f.length, t.addSymbols(t.icon, f, d, v, x, b, Nf.vertical, r, e, z.lineStartIndex, z.lineLength, -1, M, A, I, S), j = t.icon.placedSymbolArray.length - 1);\n            }\n            for (const n in i.horizontal) {\n              const s = i.horizontal[n];\n              k || ($ = ye(s.text), d ? C = Xd(s) : k = Hd(u, G, e, c, h, p, s, f, l.layout.get(\"text-rotate\").evaluate(b, {}, A), m));\n              const o = 1 === s.positionedLines.length;\n              if (O += Gd(t, r, e, s, a, l, d, b, m, z, i.vertical ? Nf.horizontal : Nf.horizontalOnly, o ? Object.keys(i.horizontal) : [n], q, U, _, M, A, I), o) break;\n            }\n            i.vertical && (N += Gd(t, r, e, i.vertical, a, l, d, b, m, z, Nf.vertical, [\"vertical\"], q, j, _, M, A, I));\n            let Z = -1;\n            const W = (t, e) => t ? Math.max(t, e) : e;\n            Z = W(C, Z), Z = W(D, Z), Z = W(R, Z);\n            const K = Z > -1 ? 1 : 0;\n            t.glyphOffsetArray.length >= 65535 && pt(\"Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907\"), void 0 !== b.sortKey && t.addToSortKeyRanges(t.symbolInstances.length, b.sortKey), t.symbolInstances.emplaceBack(e.x, e.y, G.x, G.y, G.z, q.right >= 0 ? q.right : -1, q.center >= 0 ? q.center : -1, q.left >= 0 ? q.left : -1, q.vertical >= 0 ? q.vertical : -1, U, j, $, void 0 !== k ? k : t.collisionBoxArray.length, void 0 !== k ? k + 1 : t.collisionBoxArray.length, void 0 !== B ? B : t.collisionBoxArray.length, void 0 !== B ? B + 1 : t.collisionBoxArray.length, void 0 !== T ? T : t.collisionBoxArray.length, void 0 !== T ? T + 1 : t.collisionBoxArray.length, V || t.collisionBoxArray.length, V ? V + 1 : t.collisionBoxArray.length, c, O, N, L, F, K, 0, H, X, Z, 0, Y ? 1 : 0, E);\n          }(t, l, b, o, r, n, s, i, t.layers[0], t.collisionBoxArray, e.index, e.sourceLayerIndex, t.index, P, x, u, 0, E, k, g, e, a, c, h, p, d, m, y, C);\n        };\n      if (\"line\" === v) for (const i of ud(e.geometry, 0, 0, Kr, Kr)) {\n        const e = od(i, S, z, r.vertical || w, n, A, I, t.overscaling, Kr);\n        for (const r of e) w && Zd(t, w.text, T, r) || D(i, r, p);\n      } else if (\"line-center\" === v) {\n        for (const t of e.geometry) if (t.length > 1) {\n          const e = ad(t, z, r.vertical || w, n, A, I);\n          e && D(t, e, p);\n        }\n      } else if (\"Polygon\" === e.type) for (const t of $c(e.geometry, 0)) {\n        const e = zd(t, 16);\n        D(t[0], new ed(e.x, e.y, 0, 0, void 0), p);\n      } else if (\"LineString\" === e.type) for (const t of e.geometry) D(t, new ed(t[0].x, t[0].y, 0, 0, void 0), p);else if (\"Point\" === e.type) for (const t of e.geometry) for (const e of t) D([e], new ed(e.x, e.y, 0, 0, void 0), p);\n    }\n    const qd = 255,\n      $d = qd * xf;\n    function Gd(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m, y, g) {\n      const x = function (t, e, r, n, i, s, a, o) {\n          const l = [];\n          if (0 === e.positionedLines.length) return l;\n          const u = n.layout.get(\"text-rotate\").evaluate(s, {}) * Math.PI / 180,\n            c = function (t) {\n              const e = t[0],\n                r = t[1],\n                n = e * r;\n              return n > 0 ? [e, -r] : n < 0 ? [-e, r] : 0 === e ? [r, e] : [r, -e];\n            }(r);\n          let h = Math.abs(e.top - e.bottom);\n          for (const t of e.positionedLines) h -= t.lineOffset;\n          const p = e.positionedLines.length,\n            f = h / p;\n          let d = e.top - r[1];\n          for (let t = 0; t < p; ++t) {\n            const n = e.positionedLines[t];\n            d = Ed(e, f, d, t);\n            for (const t of n.positionedGlyphs) {\n              if (!t.rect) continue;\n              const n = t.rect || {};\n              let s = Of + 1,\n                h = !0,\n                p = 1,\n                f = 0;\n              if (t.image) {\n                const e = a.get(t.image.toString());\n                if (!e) continue;\n                if (e.sdf) {\n                  pt(\"SDF images are not supported in formatted text and will be ignored.\");\n                  continue;\n                }\n                h = !1, p = e.pixelRatio, s = hd / p;\n              }\n              const m = (i || o) && t.vertical,\n                y = t.metrics.advance * t.scale / 2,\n                g = t.metrics,\n                x = t.rect;\n              if (null === x) continue;\n              o && e.verticalizable && (f = t.image ? y - t.metrics.width * t.scale / 2 : 0);\n              const v = i ? [t.x + y, t.y] : [0, 0];\n              let b = [0, 0],\n                _ = [0, 0],\n                w = !1;\n              i || (m ? (_ = [t.x + y + c[0], t.y + c[1] - f], w = !0) : b = [t.x + y + r[0], t.y + r[1] - f]);\n              const M = x.w * t.scale / (p * (t.localGlyph ? xd : 1)),\n                A = x.h * t.scale / (p * (t.localGlyph ? xd : 1));\n              let I, S, P, E;\n              if (m) {\n                const e = t.y - d,\n                  r = new q(-y, y - e),\n                  n = -Math.PI / 2,\n                  i = new q(..._);\n                I = new q(-y + b[0], b[1]), I._rotateAround(n, r)._add(i), I.x += -e + y, I.y -= (g.left - s) * t.scale;\n                const a = t.image ? g.advance * t.scale : gf * t.scale,\n                  o = String.fromCodePoint(t.glyph);\n                Sf(o) ? I.x += (1 - s) * t.scale : Pf(o) ? I.x += a - g.height * t.scale + (-s - 1) * t.scale : I.x += t.image || g.width + 2 * s === x.w && g.height + 2 * s === x.h ? (a - A) / 2 : (a - (g.height + 2 * s) * t.scale) / 2, S = new q(I.x, I.y - M), P = new q(I.x + A, I.y), E = new q(I.x + A, I.y - M);\n              } else {\n                const e = (g.left - s) * t.scale - y + b[0],\n                  r = (-g.top - s) * t.scale + b[1],\n                  n = e + M,\n                  i = r + A;\n                I = new q(e, r), S = new q(n, r), P = new q(e, i), E = new q(n, i);\n              }\n              if (u) {\n                let t;\n                t = i ? new q(0, 0) : w ? new q(c[0], c[1]) : new q(r[0], r[1]), I._rotateAround(u, t), S._rotateAround(u, t), P._rotateAround(u, t), E._rotateAround(u, t);\n              }\n              const z = new q(0, 0),\n                k = new q(0, 0);\n              l.push({\n                tl: I,\n                tr: S,\n                bl: P,\n                br: E,\n                texPrimary: n,\n                texSecondary: void 0,\n                writingMode: e.writingMode,\n                glyphOffset: v,\n                sectionIndex: t.sectionIndex,\n                isSDF: h,\n                pixelOffsetTL: z,\n                pixelOffsetBR: k,\n                minFontScaleX: 0,\n                minFontScaleY: 0\n              });\n            }\n          }\n          return l;\n        }(0, n, l, s, a, o, i, t.allowVerticalPlacement),\n        v = t.textSizeData;\n      let b = null;\n      \"source\" === v.kind ? (b = [xf * s.layout.get(\"text-size\").evaluate(o, {}, y) * d.textScaleFactor], b[0] > $d && pt(`${t.layerIds[0]}: Value for \"text-size\" is >= ${qd}. Reduce your \"text-size\".`)) : \"composite\" === v.kind && (b = [xf * d.compositeTextSizes[0].evaluate(o, {}, y) * d.textScaleFactor, xf * d.compositeTextSizes[1].evaluate(o, {}, y) * d.textScaleFactor], (b[0] > $d || b[1] > $d) && pt(`${t.layerIds[0]}: Value for \"text-size\" is >= ${qd}. Reduce your \"text-size\".`)), t.addSymbols(t.text, x, b, l, a, o, c, e, r, u.lineStartIndex, u.lineLength, f, m, y, g, !1);\n      for (const e of h) p[e] = t.text.placedSymbolArray.length - 1;\n      return 4 * x.length;\n    }\n    function Yd(t) {\n      for (const e in t) return t[e];\n      return null;\n    }\n    function Hd(t, e, r, n, i, s, a, o, l, u) {\n      let c = a.top,\n        h = a.bottom,\n        p = a.left,\n        f = a.right;\n      const d = a.collisionPadding;\n      if (d && (p -= d[0], c -= d[1], f += d[2], h += d[3]), l) {\n        const t = new q(p, c),\n          e = new q(f, c),\n          r = new q(p, h),\n          n = new q(f, h),\n          i = H(l);\n        let s = new q(0, 0);\n        u && (s = new q(u[0], u[1])), t._rotateAround(i, s), e._rotateAround(i, s), r._rotateAround(i, s), n._rotateAround(i, s), p = Math.min(t.x, e.x, r.x, n.x), f = Math.max(t.x, e.x, r.x, n.x), c = Math.min(t.y, e.y, r.y, n.y), h = Math.max(t.y, e.y, r.y, n.y);\n      }\n      return t.emplaceBack(e.x, e.y, e.z, r.x, r.y, p, c, f, h, o, n, i, s), t.length - 1;\n    }\n    function Xd(t) {\n      t.collisionPadding && (t.top -= t.collisionPadding[1], t.bottom += t.collisionPadding[3]);\n      const e = t.bottom - t.top;\n      return e > 0 ? Math.max(10, e) : null;\n    }\n    function Zd(t, e, r, n) {\n      const i = t.compareText;\n      if (e in i) {\n        const t = i[e];\n        for (let e = t.length - 1; e >= 0; e--) if (n.dist(t[e]) < r) return !0;\n      } else i[e] = [];\n      return i[e].push(n), !1;\n    }\n    function Wd(t, e) {\n      const r = t.fovAboveCenter,\n        n = t.elevation ? t.elevation.getMinElevationBelowMSL() * e : 0,\n        i = (t._camera.position[2] * t.worldSize - n) / Math.cos(t._pitch),\n        s = Math.sin(r) * i / Math.sin(Math.max(Math.PI / 2 - t._pitch - r, .01));\n      let a = Math.sin(t._pitch) * s + i;\n      const o = i * (1 / t._horizonShift);\n      if (!t.elevation || 0 === t.elevation.exaggeration()) {\n        let e = Math.max(t.zoom - 17, 0);\n        t.isOrthographic && (e /= 10), a *= 1 + e;\n      }\n      return Math.min(1.01 * a, o);\n    }\n    function Kd(t, e) {\n      if (!e.isReprojectedInTileSpace) return {\n        scale: 1 << t.z,\n        x: t.x,\n        y: t.y,\n        x2: t.x + 1,\n        y2: t.y + 1,\n        projection: e\n      };\n      const r = Math.pow(2, -t.z),\n        n = t.x * r,\n        i = (t.x + 1) * r,\n        s = t.y * r,\n        a = (t.y + 1) * r,\n        o = gl(n),\n        l = gl(i),\n        u = xl(s),\n        c = xl(a),\n        h = e.project(o, u),\n        p = e.project(l, u),\n        f = e.project(l, c),\n        d = e.project(o, c);\n      let m = Math.min(h.x, p.x, f.x, d.x),\n        y = Math.min(h.y, p.y, f.y, d.y),\n        g = Math.max(h.x, p.x, f.x, d.x),\n        x = Math.max(h.y, p.y, f.y, d.y);\n      const v = r / 16;\n      function b(t, r, n, i, s, a) {\n        const o = (n + s) / 2,\n          l = (i + a) / 2,\n          u = e.project(gl(o), xl(l)),\n          c = Math.max(0, m - u.x, y - u.y, u.x - g, u.y - x);\n        m = Math.min(m, u.x), g = Math.max(g, u.x), y = Math.min(y, u.y), x = Math.max(x, u.y), c > v && (b(t, u, n, i, o, l), b(u, r, o, l, s, a));\n      }\n      b(h, p, n, s, i, s), b(p, f, i, s, i, a), b(f, d, i, a, n, a), b(d, h, n, a, n, s), m -= v, y -= v, g += v, x += v;\n      const _ = 1 / Math.max(g - m, x - y);\n      return {\n        scale: _,\n        x: m * _,\n        y: y * _,\n        x2: g * _,\n        y2: x * _,\n        projection: e\n      };\n    }\n    function Jd(t, {\n      x: e,\n      y: r\n    }, n = 0) {\n      return new q(((e - n) * t.scale - t.x) * Kr, (r * t.scale - t.y) * Kr);\n    }\n    const Qd = O.mat4.identity(new Float32Array(16));\n    class tm {\n      constructor(t) {\n        this.spec = t, this.name = t.name, this.wrap = !1, this.requiresDraping = !1, this.supportsWorldCopies = !1, this.supportsTerrain = !1, this.supportsFog = !1, this.supportsFreeCamera = !1, this.zAxisUnit = \"meters\", this.isReprojectedInTileSpace = !0, this.unsupportedLayers = [\"custom\"], this.center = [0, 0], this.range = [3.5, 7];\n      }\n      project(t, e) {\n        return {\n          x: 0,\n          y: 0,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        return new ul(0, 0);\n      }\n      projectTilePoint(t, e, r) {\n        return {\n          x: t,\n          y: e,\n          z: 0\n        };\n      }\n      locationPoint(t, e, r, n = !0) {\n        return t._coordinatePoint(t.locationCoordinate(e, r), n);\n      }\n      pixelsPerMeter(t, e) {\n        return yl(1, t) * e;\n      }\n      pixelSpaceConversion(t, e, r) {\n        return 1;\n      }\n      farthestPixelDistance(t) {\n        return Wd(t, t.pixelsPerMeter);\n      }\n      pointCoordinate(t, e, r, n) {\n        const i = t.horizonLineFromTop(!1),\n          s = new q(e, Math.max(i, r));\n        return t.rayIntersectionCoordinate(t.pointRayIntersection(s, n));\n      }\n      pointCoordinate3D(t, e, r) {\n        const n = new q(e, r);\n        if (t.elevation) return t.elevation.pointCoordinate(n);\n        {\n          const e = this.pointCoordinate(t, n.x, n.y, 0);\n          return [e.x, e.y, e.z];\n        }\n      }\n      isPointAboveHorizon(t, e) {\n        if (t.elevation && t.elevation.visibleDemTiles.length) return !this.pointCoordinate3D(t, e.x, e.y);\n        const r = t.horizonLineFromTop();\n        return e.y < r;\n      }\n      createInversionMatrix(t, e) {\n        return Qd;\n      }\n      createTileMatrix(t, e, r) {\n        let n, i, s;\n        const a = r.canonical,\n          o = O.mat4.identity(new Float64Array(16));\n        if (this.isReprojectedInTileSpace) {\n          const l = Kd(a, this);\n          n = 1, i = l.x + r.wrap * l.scale, s = l.y, O.mat4.scale(o, o, [n / l.scale, n / l.scale, t.pixelsPerMeter / e]);\n        } else n = e / t.zoomScale(a.z), i = (a.x + Math.pow(2, a.z) * r.wrap) * n, s = a.y * n;\n        return O.mat4.translate(o, o, [i, s, 0]), O.mat4.scale(o, o, [n / Kr, n / Kr, 1]), o;\n      }\n      upVector(t, e, r) {\n        return [0, 0, 1];\n      }\n      upVectorScale(t, e, r) {\n        return {\n          metersToTile: 1\n        };\n      }\n    }\n    class em extends tm {\n      constructor(t) {\n        super(t), this.range = [4, 7], this.center = t.center || [-96, 37.5];\n        const [e, r] = this.parallels = t.parallels || [29.5, 45.5],\n          n = Math.sin(H(e));\n        this.n = (n + Math.sin(H(r))) / 2, this.c = 1 + n * (2 * this.n - n), this.r0 = Math.sqrt(this.c) / this.n;\n      }\n      project(t, e) {\n        const {\n            n: r,\n            c: n,\n            r0: i\n          } = this,\n          s = H(t - this.center[0]),\n          a = H(e),\n          o = Math.sqrt(n - 2 * r * Math.sin(a)) / r;\n        return {\n          x: o * Math.sin(s * r),\n          y: o * Math.cos(s * r) - i,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        const {\n            n: r,\n            c: n,\n            r0: i\n          } = this,\n          s = i + e;\n        let a = Math.atan2(t, Math.abs(s)) * Math.sign(s);\n        s * r < 0 && (a -= Math.PI * Math.sign(t) * Math.sign(s));\n        const o = H(this.center[0]) * r;\n        a = et(a, -Math.PI - o, Math.PI - o);\n        const l = Q(X(a / r) + this.center[0], -180, 180),\n          u = Math.asin(Q((n - (t * t + s * s) * r * r) / (2 * r), -1, 1)),\n          c = Q(X(u), -bl, bl);\n        return new ul(l, c);\n      }\n    }\n    const rm = 1.340264,\n      nm = -.081106,\n      im = 893e-6,\n      sm = .003796,\n      am = Math.sqrt(3) / 2;\n    class om extends tm {\n      project(t, e) {\n        e = e / 180 * Math.PI, t = t / 180 * Math.PI;\n        const r = Math.asin(am * Math.sin(e)),\n          n = r * r,\n          i = n * n * n;\n        return {\n          x: .5 * (t * Math.cos(r) / (am * (rm + 3 * nm * n + i * (7 * im + 9 * sm * n))) / Math.PI + .5),\n          y: 1 - .5 * (r * (rm + nm * n + i * (im + sm * n)) / Math.PI + 1),\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        t = (2 * t - .5) * Math.PI;\n        let r = e = (2 * (1 - e) - 1) * Math.PI,\n          n = r * r,\n          i = n * n * n;\n        for (let t, s, a, o = 0; o < 12 && (s = r * (rm + nm * n + i * (im + sm * n)) - e, a = rm + 3 * nm * n + i * (7 * im + 9 * sm * n), t = s / a, r = Q(r - t, -Math.PI / 3, Math.PI / 3), n = r * r, i = n * n * n, !(Math.abs(t) < 1e-12)); ++o);\n        const s = am * t * (rm + 3 * nm * n + i * (7 * im + 9 * sm * n)) / Math.cos(r),\n          a = Math.asin(Math.sin(r) / am),\n          o = Q(180 * s / Math.PI, -180, 180),\n          l = Q(180 * a / Math.PI, -bl, bl);\n        return new ul(o, l);\n      }\n    }\n    class lm extends tm {\n      constructor(t) {\n        super(t), this.wrap = !0, this.supportsWorldCopies = !0;\n      }\n      project(t, e) {\n        return {\n          x: .5 + t / 360,\n          y: .5 - e / 360,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        const r = 360 * (t - .5),\n          n = Q(360 * (.5 - e), -bl, bl);\n        return new ul(r, n);\n      }\n    }\n    const um = Math.PI / 2;\n    function cm(t) {\n      return Math.tan((um + t) / 2);\n    }\n    class hm extends tm {\n      constructor(t) {\n        super(t), this.center = t.center || [0, 30];\n        const [e, r] = this.parallels = t.parallels || [30, 30];\n        let n = H(e),\n          i = H(r);\n        this.southernCenter = n + i < 0, this.southernCenter && (n = -n, i = -i);\n        const s = Math.cos(n),\n          a = cm(n);\n        this.n = n === i ? Math.sin(n) : Math.log(s / Math.cos(i)) / Math.log(cm(i) / a), this.f = s * Math.pow(cm(n), this.n) / this.n;\n      }\n      project(t, e) {\n        e = H(e), this.southernCenter && (e = -e), t = H(t - this.center[0]);\n        const r = 1e-6,\n          {\n            n,\n            f: i\n          } = this;\n        i > 0 ? e < -um + r && (e = -um + r) : e > um - r && (e = um - r);\n        const s = i / Math.pow(cm(e), n);\n        let a = s * Math.sin(n * t),\n          o = i - s * Math.cos(n * t);\n        return a = .5 * (a / Math.PI + .5), o = .5 * (o / Math.PI + .5), {\n          x: a,\n          y: this.southernCenter ? o : 1 - o,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        t = (2 * t - .5) * Math.PI, this.southernCenter && (e = 1 - e), e = (2 * (1 - e) - .5) * Math.PI;\n        const {\n            n: r,\n            f: n\n          } = this,\n          i = n - e,\n          s = Math.sign(i),\n          a = Math.sign(r) * Math.sqrt(t * t + i * i);\n        let o = Math.atan2(t, Math.abs(i)) * s;\n        i * r < 0 && (o -= Math.PI * Math.sign(t) * s);\n        const l = Q(X(o / r) + this.center[0], -180, 180),\n          u = Q(X(2 * Math.atan(Math.pow(n / a, 1 / r)) - um), -bl, bl);\n        return new ul(l, this.southernCenter ? -u : u);\n      }\n    }\n    class pm extends tm {\n      constructor(t) {\n        super(t), this.wrap = !0, this.supportsWorldCopies = !0, this.supportsTerrain = !0, this.supportsFog = !0, this.supportsFreeCamera = !0, this.isReprojectedInTileSpace = !1, this.unsupportedLayers = [], this.range = null;\n      }\n      project(t, e) {\n        return {\n          x: dl(t),\n          y: ml(e),\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        const r = gl(t),\n          n = xl(e);\n        return new ul(r, n);\n      }\n    }\n    const fm = H(bl);\n    class dm extends tm {\n      project(t, e) {\n        const r = (e = H(e)) * e,\n          n = r * r;\n        return {\n          x: .5 * ((t = H(t)) * (.8707 - .131979 * r + n * (n * (.003971 * r - .001529 * n) - .013791)) / Math.PI + .5),\n          y: 1 - .5 * (e * (1.007226 + r * (.015085 + n * (.028874 * r - .044475 - .005916 * n))) / Math.PI + 1),\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        t = (2 * t - .5) * Math.PI;\n        let r = e = (2 * (1 - e) - 1) * Math.PI,\n          n = 25,\n          i = 0,\n          s = r * r;\n        do {\n          s = r * r;\n          const t = s * s;\n          i = (r * (1.007226 + s * (.015085 + t * (.028874 * s - .044475 - .005916 * t))) - e) / (1.007226 + s * (.045255 + t * (.259866 * s - .311325 - .005916 * 11 * t))), r = Q(r - i, -fm, fm);\n        } while (Math.abs(i) > 1e-6 && --n > 0);\n        s = r * r;\n        const a = Q(X(t / (.8707 + s * (s * (s * s * s * (.003971 - .001529 * s) - .013791) - .131979))), -180, 180),\n          o = X(r);\n        return new ul(a, o);\n      }\n    }\n    const mm = H(bl);\n    class ym extends tm {\n      project(t, e) {\n        e = H(e), t = H(t);\n        const r = Math.cos(e),\n          n = 2 / Math.PI,\n          i = Math.acos(r * Math.cos(t / 2)),\n          s = Math.sin(i) / i,\n          a = .5 * (t * n + 2 * r * Math.sin(t / 2) / s) || 0,\n          o = .5 * (e + Math.sin(e) / s) || 0;\n        return {\n          x: .5 * (a / Math.PI + .5),\n          y: 1 - .5 * (o / Math.PI + 1),\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        let r = t = (2 * t - .5) * Math.PI,\n          n = e = (2 * (1 - e) - 1) * Math.PI,\n          i = 25;\n        const s = 1e-6;\n        let a = 0,\n          o = 0;\n        do {\n          const i = Math.cos(n),\n            s = Math.sin(n),\n            l = 2 * s * i,\n            u = s * s,\n            c = i * i,\n            h = Math.cos(r / 2),\n            p = Math.sin(r / 2),\n            f = 2 * h * p,\n            d = p * p,\n            m = 1 - c * h * h,\n            y = m ? 1 / m : 0,\n            g = m ? Math.acos(i * h) * Math.sqrt(1 / m) : 0,\n            x = .5 * (2 * g * i * p + 2 * r / Math.PI) - t,\n            v = .5 * (g * s + n) - e,\n            b = .5 * y * (c * d + g * i * h * u) + 1 / Math.PI,\n            _ = y * (f * l / 4 - g * s * p),\n            w = .125 * y * (l * p - g * s * c * f),\n            M = .5 * y * (u * h + g * d * i) + .5,\n            A = _ * w - M * b;\n          a = (v * _ - x * M) / A, o = (x * w - v * b) / A, r = Q(r - a, -Math.PI, Math.PI), n = Q(n - o, -mm, mm);\n        } while ((Math.abs(a) > s || Math.abs(o) > s) && --i > 0);\n        return new ul(X(r), X(n));\n      }\n    }\n    class gm extends tm {\n      constructor(t) {\n        super(t), this.center = t.center || [0, 0], this.parallels = t.parallels || [0, 0], this.cosPhi = Math.max(.01, Math.cos(H(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = !0, this.supportsWorldCopies = !0;\n      }\n      project(t, e) {\n        const {\n          scale: r,\n          cosPhi: n\n        } = this;\n        return {\n          x: H(t) * n * r + .5,\n          y: -Math.sin(H(e)) / n * r + .5,\n          z: 0\n        };\n      }\n      unproject(t, e) {\n        const {\n            scale: r,\n            cosPhi: n\n          } = this,\n          i = -(e - .5) / r,\n          s = Q(X((t - .5) / r) / n, -180, 180),\n          a = Math.asin(Q(i * n, -1, 1)),\n          o = Q(X(a), -bl, bl);\n        return new ul(s, o);\n      }\n    }\n    class xm extends pm {\n      constructor(t) {\n        super(t), this.requiresDraping = !0, this.supportsWorldCopies = !1, this.supportsFog = !0, this.zAxisUnit = \"pixels\", this.unsupportedLayers = [\"debug\"], this.range = [3, 5];\n      }\n      projectTilePoint(t, e, r) {\n        const n = Ru(t, e, r),\n          i = Ou(ku(r));\n        return O.vec3.transformMat4(n, n, i), {\n          x: n[0],\n          y: n[1],\n          z: n[2]\n        };\n      }\n      locationPoint(t, e, r) {\n        const n = al(e.lat, e.lng),\n          i = O.vec3.normalize([], n),\n          s = r ? t._centerAltitude + r : t.elevation ? t.elevation.getAtPointOrZero(t.locationCoordinate(e), t._centerAltitude) : t._centerAltitude,\n          a = yl(1, 0) * Kr * s;\n        O.vec3.scaleAndAdd(n, n, i, a);\n        const o = O.mat4.identity(new Float64Array(16));\n        return O.mat4.multiply(o, t.pixelMatrix, t.globeMatrix), O.vec3.transformMat4(n, n, o), new q(n[0], n[1]);\n      }\n      pixelsPerMeter(t, e) {\n        return yl(1, 0) * e;\n      }\n      pixelSpaceConversion(t, e, r) {\n        const n = yl(1, t) * e,\n          i = Ee(yl(1, 45) * e, n, r);\n        return this.pixelsPerMeter(t, e) / i;\n      }\n      createTileMatrix(t, e, r) {\n        const n = Nu(ku(r.canonical));\n        return O.mat4.multiply(new Float64Array(16), t.globeMatrix, n);\n      }\n      createInversionMatrix(t, e) {\n        const {\n            center: r\n          } = t,\n          n = Ou(ku(e));\n        return O.mat4.rotateY(n, n, H(r.lng)), O.mat4.rotateX(n, n, H(r.lat)), O.mat4.scale(n, n, [t._pixelsPerMercatorPixel, t._pixelsPerMercatorPixel, 1]), Float32Array.from(n);\n      }\n      pointCoordinate(t, e, r, n) {\n        return Pu(t, e, r, !0) || new Il(0, 0);\n      }\n      pointCoordinate3D(t, e, r) {\n        const n = this.pointCoordinate(t, e, r, 0);\n        return [n.x, n.y, n.z];\n      }\n      isPointAboveHorizon(t, e) {\n        return !Pu(t, e.x, e.y, !1);\n      }\n      farthestPixelDistance(t) {\n        const e = function (t, e) {\n            const r = t.cameraToCenterDistance,\n              n = t._centerAltitude * e,\n              i = t._camera,\n              s = t._camera.forward(),\n              a = O.vec3.add([], O.vec3.scale([], s, -r), [0, 0, n]),\n              o = t.worldSize / (2 * Math.PI),\n              l = [0, 0, -o],\n              u = t.width / t.height,\n              c = Math.tan(t.fovAboveCenter),\n              h = O.vec3.scale([], i.up(), c),\n              p = O.vec3.scale([], i.right(), c * u),\n              f = O.vec3.normalize([], O.vec3.add([], O.vec3.add([], s, h), p)),\n              d = [];\n            let m;\n            if (new gu(a, f).closestPointOnSphere(l, o, d)) {\n              const e = O.vec3.add([], d, l),\n                r = O.vec3.sub([], e, a);\n              m = Math.cos(t.fovAboveCenter) * O.vec3.length(r);\n            } else {\n              const t = O.vec3.sub([], a, l),\n                e = O.vec3.sub([], l, a);\n              O.vec3.normalize(e, e);\n              const r = O.vec3.length(t) - o;\n              m = Math.sqrt(r * (r + 2 * o));\n              const n = Math.acos(m / (o + r)) - Math.acos(O.vec3.dot(s, e));\n              m *= Math.cos(n);\n            }\n            return 1.01 * m;\n          }(t, this.pixelsPerMeter(t.center.lat, t.worldSize)),\n          r = $u(t.zoom);\n        if (r > 0) {\n          const n = Wd(t, yl(1, t.center.lat) * t.worldSize),\n            i = t.worldSize / (2 * Math.PI),\n            s = Math.max(t.width, t.height) / t.worldSize * Math.PI;\n          return Ee(e, n + i * (1 - Math.cos(s)), Math.pow(r, 10));\n        }\n        return e;\n      }\n      upVector(t, e, r) {\n        return Ru(e, r, t, 1);\n      }\n      upVectorScale(t) {\n        return {\n          metersToTile: Iu(Lu(ku(t)))\n        };\n      }\n    }\n    function vm(t) {\n      const e = t.parallels,\n        r = !!e && Math.abs(e[0] + e[1]) < .01;\n      switch (t.name) {\n        case \"mercator\":\n          return new pm(t);\n        case \"equirectangular\":\n          return new lm(t);\n        case \"naturalEarth\":\n          return new dm(t);\n        case \"equalEarth\":\n          return new om(t);\n        case \"winkelTripel\":\n          return new ym(t);\n        case \"albers\":\n          return r ? new gm(t) : new em(t);\n        case \"lambertConformalConic\":\n          return r ? new gm(t) : new hm(t);\n        case \"globe\":\n          return new xm(t);\n      }\n      throw new Error(`Invalid projection name: ${t.name}`);\n    }\n    const bm = ah.VectorTileFeature.types,\n      _m = [{\n        name: \"a_fade_opacity\",\n        components: 1,\n        type: \"Uint8\",\n        offset: 0\n      }];\n    function wm(t, e, r, n, i, s, a, o, l, u, c, h, p) {\n      const f = o ? Math.min($d, Math.round(o[0])) : 0,\n        d = o ? Math.min($d, Math.round(o[1])) : 0;\n      t.emplaceBack(e, r, Math.round(32 * n), Math.round(32 * i), s, a, (f << 1) + (l ? 1 : 0), d, 16 * u, 16 * c, 256 * h, 256 * p);\n    }\n    function Mm(t, e, r) {\n      t.emplaceBack(e, r);\n    }\n    function Am(t, e, r, n, i, s, a) {\n      t.emplaceBack(e, r, n, i, s, a);\n    }\n    function Im(t, e, r, n, i) {\n      t.emplaceBack(e, r, n, i), t.emplaceBack(e, r, n, i), t.emplaceBack(e, r, n, i), t.emplaceBack(e, r, n, i);\n    }\n    function Sm(t) {\n      for (const e of t.sections) if (Ms(e.text)) return !0;\n      return !1;\n    }\n    class Pm {\n      constructor(t) {\n        this.layoutVertexArray = new Va(), this.indexArray = new ja(), this.programConfigurations = t, this.segments = new xo(), this.dynamicLayoutVertexArray = new Da(), this.opacityVertexArray = new Ra(), this.placedSymbolArray = new so(), this.iconTransitioningVertexArray = new La(), this.globeExtVertexArray = new Ca(), this.zOffsetVertexArray = new Aa();\n      }\n      isEmpty() {\n        return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length && 0 === this.iconTransitioningVertexArray.length;\n      }\n      upload(t, e, r, n, i) {\n        this.isEmpty() || (r && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, lf.members), this.indexBuffer = t.createIndexBuffer(this.indexArray, e), this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, cf.members, !0), this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, _m, !0), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = t.createVertexBuffer(this.iconTransitioningVertexArray, pf.members, !0)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, uf.members, !0)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || i) && (this.zOffsetVertexBuffer = t.createVertexBuffer(this.zOffsetVertexArray, hf.members, !0)), this.opacityVertexBuffer.itemSize = 1), (r || n) && this.programConfigurations.upload(t));\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy());\n      }\n    }\n    us(Pm, \"SymbolBuffers\");\n    class Em {\n      constructor(t, e, r) {\n        this.layoutVertexArray = new t(), this.layoutAttributes = e, this.indexArray = new r(), this.segments = new xo(), this.collisionVertexArray = new Ua(), this.collisionVertexArrayExt = new Da();\n      }\n      upload(t) {\n        this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, ff.members, !0), this.collisionVertexBufferExt = t.createVertexBuffer(this.collisionVertexArrayExt, df.members, !0);\n      }\n      destroy() {\n        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());\n      }\n    }\n    us(Em, \"CollisionBuffers\");\n    class zm {\n      constructor(t) {\n        this.collisionBoxArray = t.collisionBoxArray, this.zoom = t.zoom, this.lut = t.lut, this.overscaling = t.overscaling, this.layers = t.layers, this.layerIds = this.layers.map(t => t.fqid), this.index = t.index, this.pixelRatio = t.pixelRatio, this.sourceLayerIndex = t.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.fullyClipped = !1, this.hasAnyIconTextFit = !1, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = O.mat4.identity([]), this.placementViewportMatrix = O.mat4.identity([]);\n        const e = this.layers[0]._unevaluatedLayout._values;\n        this.textSizeData = bf(this.zoom, e[\"text-size\"]), this.iconSizeData = bf(this.zoom, e[\"icon-size\"]);\n        const r = this.layers[0].layout,\n          n = r.get(\"symbol-sort-key\"),\n          i = r.get(\"symbol-z-order\");\n        this.canOverlap = r.get(\"text-allow-overlap\") || r.get(\"icon-allow-overlap\") || r.get(\"text-ignore-placement\") || r.get(\"icon-ignore-placement\"), this.sortFeaturesByKey = \"viewport-y\" !== i && void 0 !== n.constantOr(1), this.sortFeaturesByY = (\"viewport-y\" === i || \"auto\" === i && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r.get(\"text-writing-mode\").map(t => Nf[t]), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.sourceID = t.sourceID, this.projection = t.projection, this.hasAnyZOffset = !1, this.zOffsetSortDirty = !1, this.zOffsetBuffersNeedUpload = !1, this.elevationType = \"none\", this.elevationStateComplete = !1, this.activeReplacements = [], this.replacementUpdateTime = 0;\n      }\n      createArrays() {\n        this.text = new Pm(new Go(this.layers, {\n          zoom: this.zoom,\n          lut: this.lut\n        }, t => t.startsWith(\"text\") || t.startsWith(\"symbol\"))), this.icon = new Pm(new Go(this.layers, {\n          zoom: this.zoom,\n          lut: this.lut\n        }, t => t.startsWith(\"icon\") || t.startsWith(\"symbol\"))), this.glyphOffsetArray = new lo(), this.lineVertexArray = new uo(), this.symbolInstances = new oo();\n      }\n      calculateGlyphDependencies(t, e, r, n, i) {\n        for (const r of t) {\n          const t = r.codePointAt(0);\n          if (void 0 === t) break;\n          if (e[t] = !0, n && i && t <= 65535) {\n            const t = If[r];\n            t && (e[t.charCodeAt(0)] = !0);\n          }\n        }\n      }\n      updateFootprints(t, e) {}\n      updateReplacement(t, e) {\n        if (e.updateTime === this.replacementUpdateTime) return !1;\n        this.replacementUpdateTime = e.updateTime;\n        const r = e.getReplacementRegionsForTile(t.toUnwrapped(), !0);\n        return !Yh(this.activeReplacements, r) && (this.activeReplacements = r, !0);\n      }\n      populate(t, e, r, n) {\n        const i = this.layers[0],\n          s = i.layout,\n          a = \"globe\" === this.projection.name,\n          o = s.get(\"text-font\"),\n          l = s.get(\"text-field\"),\n          u = s.get(\"icon-image\"),\n          [c, h] = s.get(\"icon-size-scale-range\"),\n          p = Q(e.scaleFactor || 1, c, h),\n          f = (\"constant\" !== l.value.kind || l.value.value instanceof Qe && !l.value.value.isEmpty() || l.value.value.toString().length > 0) && (\"constant\" !== o.value.kind || o.value.value.length > 0),\n          d = \"constant\" !== u.value.kind || !!u.value.value || Object.keys(u.parameters).length > 0,\n          m = s.get(\"symbol-sort-key\");\n        if (this.features = [], !f && !d) return;\n        const y = e.iconDependencies,\n          g = e.glyphDependencies,\n          x = e.availableImages,\n          v = new Rs(this.zoom);\n        for (const {\n          feature: e,\n          id: l,\n          index: u,\n          sourceLayerIndex: c\n        } of t) {\n          const t = i._featureFilter.needGeometry,\n            h = Cl(e, t);\n          if (!i._featureFilter.filter(v, h, r)) continue;\n          if (t || (h.geometry = Vl(e, r, n)), a && 1 !== e.type && r.z <= 5) {\n            const t = h.geometry,\n              e = .98078528056,\n              n = (t, n) => {\n                const i = Ru(t.x, t.y, r, 1),\n                  s = Ru(n.x, n.y, r, 1);\n                return O.vec3.dot(i, s) < e;\n              };\n            for (let e = 0; e < t.length; e++) t[e] = zl(t[e], n);\n          }\n          let b, _;\n          if (f) {\n            const t = i.getValueAndResolveTokens(\"text-field\", h, r, x),\n              e = Qe.factory(t);\n            Sm(e) && (this.hasRTLText = !0), (!this.hasRTLText || \"unavailable\" === Vs() || this.hasRTLText && Ds.isParsed()) && (b = Af(e, i, h));\n          }\n          if (d) {\n            const t = i.getValueAndResolveTokens(\"icon-image\", h, r, x);\n            _ = t instanceof er ? t : er.build(t);\n          }\n          if (!b && !_) continue;\n          const w = this.sortFeaturesByKey ? m.evaluate(h, {}, r) : void 0,\n            M = {\n              id: l,\n              text: b,\n              icon: _,\n              index: u,\n              sourceLayerIndex: c,\n              geometry: h.geometry,\n              properties: e.properties,\n              type: bm[e.type],\n              sortKey: w\n            };\n          if (this.features.push(M), _) {\n            const t = this.layers[0]._unevaluatedLayout._values,\n              {\n                iconPrimary: e,\n                iconSecondary: n\n              } = Rd(_, this.iconSizeData, t[\"icon-size\"], r, this.zoom, M, this.pixelRatio, p),\n              i = e.id.toString();\n            if (y.has(i) ? y.get(i).push(e) : y.set(i, [e]), n) {\n              const t = n.id.toString();\n              y.has(t) ? y.get(t).push(n) : y.set(t, [n]);\n            }\n          }\n          if (b) {\n            const t = o.evaluate(h, {}, r).join(\",\"),\n              e = \"map\" === s.get(\"text-rotation-alignment\") && \"point\" !== s.get(\"symbol-placement\");\n            this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(Nf.vertical) >= 0;\n            for (const r of b.sections) if (r.image) {\n              const t = r.image.getPrimary().scaleSelf(this.pixelRatio),\n                e = t.id.toString(),\n                n = y.get(e) || [];\n              n.push(t), y.set(e, n);\n            } else {\n              const n = ms(b.toString()),\n                i = r.fontStack || t,\n                s = g[i] = g[i] || {};\n              this.calculateGlyphDependencies(r.text, s, e, this.allowVerticalPlacement, n);\n            }\n          }\n        }\n        if (\"line\" === s.get(\"symbol-placement\") && (this.features = function (t) {\n          const e = {},\n            r = {},\n            n = [];\n          let i = 0;\n          function s(e) {\n            n.push(t[e]), i++;\n          }\n          function a(t, e, i) {\n            const s = r[t];\n            return delete r[t], r[e] = s, n[s].geometry[0].pop(), n[s].geometry[0] = n[s].geometry[0].concat(i[0]), s;\n          }\n          function o(t, r, i) {\n            const s = e[r];\n            return delete e[r], e[t] = s, n[s].geometry[0].shift(), n[s].geometry[0] = i[0].concat(n[s].geometry[0]), s;\n          }\n          function l(t, e, r) {\n            const n = r ? e[0][e[0].length - 1] : e[0][0];\n            return `${t}:${n.x}:${n.y}`;\n          }\n          for (let u = 0; u < t.length; u++) {\n            const c = t[u],\n              h = c.geometry,\n              p = c.text ? c.text.toString() : null;\n            if (!p) {\n              s(u);\n              continue;\n            }\n            const f = l(p, h),\n              d = l(p, h, !0);\n            if (f in r && d in e && r[f] !== e[d]) {\n              const t = o(f, d, h),\n                i = a(f, d, n[t].geometry);\n              delete e[f], delete r[d], r[l(p, n[i].geometry, !0)] = i, n[t].geometry = null;\n            } else f in r ? a(f, d, h) : d in e ? o(f, d, h) : (s(u), e[f] = i - 1, r[d] = i - 1);\n          }\n          return n.filter(t => t.geometry);\n        }(this.features)), \"hd-road-markup\" === s.get(\"symbol-elevation-reference\")) {\n          if (this.elevationType = \"road\", e.elevationFeatures) {\n            !this.elevationFeatures && e.elevationFeatures.length > 0 && (this.elevationFeatures = [], this.elevationFeatureIdToIndex = new Map());\n            for (const t of e.elevationFeatures) this.elevationFeatureIdToIndex.set(t.id, this.elevationFeatures.length), this.elevationFeatures.push(t);\n          }\n        } else s.get(\"symbol-z-elevate\") && (this.elevationType = \"offset\");\n        \"none\" !== this.elevationType && (this.zOffsetBuffersNeedUpload = !0), this.sortFeaturesByKey && this.features.sort((t, e) => t.sortKey - e.sortKey);\n      }\n      update(t, e, r, n, i, s, a) {\n        this.text.programConfigurations.updatePaintArrays(t, e, i, r, n, s, a), this.icon.programConfigurations.updatePaintArrays(t, e, i, r, n, s, a);\n      }\n      updateRoadElevation() {\n        if (\"road\" !== this.elevationType || !this.elevationFeatures) return;\n        if (this.elevationStateComplete) return;\n        this.elevationStateComplete = !0, this.hasAnyZOffset = !1;\n        let t = !1;\n        for (let e = 0; e < this.symbolInstances.length; e++) {\n          const r = this.symbolInstances.get(e);\n          if (65535 === r.elevationFeatureIndex) continue;\n          const n = this.elevationFeatures[r.elevationFeatureIndex];\n          if (n) {\n            const e = .05 + n.pointElevation(new q(r.tileAnchorX, r.tileAnchorY));\n            r.zOffset !== e && (t = !0, r.zOffset = e);\n          }\n        }\n        t && (this.zOffsetBuffersNeedUpload = !0, this.zOffsetSortDirty = !0);\n      }\n      updateZOffset() {\n        const t = (t, e, n) => {\n            r += e, r > t.length && t.resize(r);\n            for (let i = -e; i < 0; i++) t.emplace(i + r, n);\n          },\n          e = (t, e, r) => {\n            n += e, n > t.length && t.resize(n);\n            for (let i = -e; i < 0; i++) t.emplace(i + n, r);\n          };\n        if (!this.zOffsetBuffersNeedUpload) return;\n        this.zOffsetBuffersNeedUpload = !1;\n        let r = 0,\n          n = 0;\n        for (let r = 0; r < this.symbolInstances.length; r++) {\n          const n = this.symbolInstances.get(r),\n            {\n              numHorizontalGlyphVertices: i,\n              numVerticalGlyphVertices: s,\n              numIconVertices: a\n            } = n,\n            o = n.zOffset,\n            l = a > 0;\n          if ((i > 0 || s > 0) && (t(this.text.zOffsetVertexArray, i, o), t(this.text.zOffsetVertexArray, s, o)), l) {\n            const {\n              placedIconSymbolIndex: t,\n              verticalPlacedIconSymbolIndex: r\n            } = n;\n            t >= 0 && e(this.icon.zOffsetVertexArray, a, o), r >= 0 && e(this.icon.zOffsetVertexArray, n.numVerticalIconVertices, o);\n          }\n        }\n        this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);\n      }\n      isEmpty() {\n        return 0 === this.symbolInstances.length && !this.hasRTLText;\n      }\n      uploadPending() {\n        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;\n      }\n      upload(t) {\n        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = !0;\n      }\n      destroyDebugData() {\n        this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();\n      }\n      getProjection() {\n        return this.projectionInstance || (this.projectionInstance = vm(this.projection)), this.projectionInstance;\n      }\n      destroy() {\n        this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();\n      }\n      addToLineVertexArray(t, e) {\n        const r = this.lineVertexArray.length;\n        if (void 0 !== t.segment) for (const {\n          x: t,\n          y: r\n        } of e) this.lineVertexArray.emplaceBack(t, r);\n        return {\n          lineStartIndex: r,\n          lineLength: this.lineVertexArray.length - r\n        };\n      }\n      addSymbols(t, e, r, n, i, s, a, o, l, u, c, h, p, f, d, m) {\n        const y = t.indexArray,\n          g = t.layoutVertexArray,\n          x = t.globeExtVertexArray,\n          v = t.segments.prepareSegment(4 * e.length, g, y, this.canOverlap ? s.sortKey : void 0),\n          b = this.glyphOffsetArray.length,\n          _ = v.vertexLength,\n          w = this.allowVerticalPlacement && a === Nf.vertical ? Math.PI / 2 : 0,\n          M = s.text && s.text.sections;\n        for (let n = 0; n < e.length; n++) {\n          const {\n              tl: i,\n              tr: a,\n              bl: u,\n              br: c,\n              texPrimary: h,\n              texSecondary: b,\n              pixelOffsetTL: _,\n              pixelOffsetBR: A,\n              minFontScaleX: I,\n              minFontScaleY: S,\n              glyphOffset: P,\n              isSDF: E,\n              sectionIndex: z\n            } = e[n],\n            k = v.vertexLength,\n            T = P[1];\n          if (wm(g, l.x, l.y, i.x, T + i.y, h.x, h.y, r, E, _.x, _.y, I, S), wm(g, l.x, l.y, a.x, T + a.y, h.x + h.w, h.y, r, E, A.x, _.y, I, S), wm(g, l.x, l.y, u.x, T + u.y, h.x, h.y + h.h, r, E, _.x, A.y, I, S), wm(g, l.x, l.y, c.x, T + c.y, h.x + h.w, h.y + h.h, r, E, A.x, A.y, I, S), o) {\n            const {\n                x: e,\n                y: r,\n                z: n\n              } = o.anchor,\n              [i, s, a] = o.up;\n            Am(x, e, r, n, i, s, a), Am(x, e, r, n, i, s, a), Am(x, e, r, n, i, s, a), Am(x, e, r, n, i, s, a), Im(t.dynamicLayoutVertexArray, e, r, n, w);\n          } else Im(t.dynamicLayoutVertexArray, l.x, l.y, l.z, w);\n          if (m) {\n            const e = b || h;\n            Mm(t.iconTransitioningVertexArray, e.x, e.y), Mm(t.iconTransitioningVertexArray, e.x + e.w, e.y), Mm(t.iconTransitioningVertexArray, e.x, e.y + e.h), Mm(t.iconTransitioningVertexArray, e.x + e.w, e.y + e.h);\n          }\n          y.emplaceBack(k, k + 1, k + 2), y.emplaceBack(k + 1, k + 2, k + 3), v.vertexLength += 4, v.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(P[0]), n !== e.length - 1 && z === e[n + 1].sectionIndex || t.programConfigurations.populatePaintArrays(g.length, s, s.index, {}, p, f, d, M && M[z]);\n        }\n        const A = o ? o.anchor : l;\n        t.placedSymbolArray.emplaceBack(A.x, A.y, A.z, l.x, l.y, b, this.glyphOffsetArray.length - b, _, u, c, l.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], a, 0, !1, 0, h, 0);\n      }\n      _commitLayoutVertex(t, e, r, n, i, s, a) {\n        t.emplaceBack(e, r, n, i, s, Math.round(a.x), Math.round(a.y));\n      }\n      _addCollisionDebugVertices(t, e, r, n, i, s, a) {\n        const o = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray),\n          l = o.vertexLength,\n          u = a.tileAnchorX,\n          c = a.tileAnchorY;\n        for (let t = 0; t < 4; t++) r.collisionVertexArray.emplaceBack(0, 0, 0, 0, 0, 0);\n        this._commitDebugCollisionVertexUpdate(r.collisionVertexArrayExt, e, t.padding, a.zOffset), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new q(t.x1, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new q(t.x2, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new q(t.x2, t.y2)), this._commitLayoutVertex(r.layoutVertexArray, n, i, s, u, c, new q(t.x1, t.y2)), o.vertexLength += 4;\n        const h = r.indexArray;\n        h.emplaceBack(l, l + 1), h.emplaceBack(l + 1, l + 2), h.emplaceBack(l + 2, l + 3), h.emplaceBack(l + 3, l), o.primitiveLength += 4;\n      }\n      _addTextDebugCollisionBoxes(t, e, r, n, i, s) {\n        for (let a = n; a < i; a++) {\n          const n = r.get(a),\n            i = this.getSymbolInstanceTextSize(t, s, e, a);\n          this._addCollisionDebugVertices(n, i, this.textCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);\n        }\n      }\n      _addIconDebugCollisionBoxes(t, e, r, n, i, s) {\n        for (let a = n; a < i; a++) {\n          const n = r.get(a),\n            i = this.getSymbolInstanceIconSize(t, e, s.placedIconSymbolIndex);\n          this._addCollisionDebugVertices(n, i, this.iconCollisionBox, n.projectedAnchorX, n.projectedAnchorY, n.projectedAnchorZ, s);\n        }\n      }\n      generateCollisionDebugBuffers(t, e, r) {\n        this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Em(Oa, mf.members, La), this.iconCollisionBox = new Em(Oa, mf.members, La);\n        const n = wf(this.iconSizeData, t),\n          i = wf(this.textSizeData, t, r);\n        for (let r = 0; r < this.symbolInstances.length; r++) {\n          const s = this.symbolInstances.get(r);\n          this._addTextDebugCollisionBoxes(i, t, e, s.textBoxStartIndex, s.textBoxEndIndex, s), this._addTextDebugCollisionBoxes(i, t, e, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._addIconDebugCollisionBoxes(n, t, e, s.iconBoxStartIndex, s.iconBoxEndIndex, s), this._addIconDebugCollisionBoxes(n, t, e, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s);\n        }\n      }\n      getSymbolInstanceTextSize(t, e, r, n) {\n        const i = this.text.placedSymbolArray.get(e.rightJustifiedTextSymbolIndex >= 0 ? e.rightJustifiedTextSymbolIndex : e.centerJustifiedTextSymbolIndex >= 0 ? e.centerJustifiedTextSymbolIndex : e.leftJustifiedTextSymbolIndex >= 0 ? e.leftJustifiedTextSymbolIndex : e.verticalPlacedTextSymbolIndex >= 0 ? e.verticalPlacedTextSymbolIndex : n),\n          s = _f(this.textSizeData, t, i) / gf;\n        return this.tilePixelRatio * s;\n      }\n      getSymbolInstanceIconSize(t, e, r) {\n        const n = this.icon.placedSymbolArray.get(r),\n          i = _f(this.iconSizeData, t, n);\n        return this.tilePixelRatio * i;\n      }\n      _commitDebugCollisionVertexUpdate(t, e, r, n) {\n        t.emplaceBack(e, -r, -r, n), t.emplaceBack(e, r, -r, n), t.emplaceBack(e, r, r, n), t.emplaceBack(e, -r, r, n);\n      }\n      _updateTextDebugCollisionBoxes(t, e, r, n, i, s, a) {\n        for (let a = n; a < i; a++) {\n          const n = r.get(a),\n            i = this.getSymbolInstanceTextSize(t, s, e, a);\n          this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i, n.padding, s.zOffset);\n        }\n      }\n      _updateIconDebugCollisionBoxes(t, e, r, n, i, s, a) {\n        for (let a = n; a < i; a++) {\n          const n = r.get(a),\n            i = this.getSymbolInstanceIconSize(t, e, s.placedIconSymbolIndex);\n          this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i, n.padding, s.zOffset);\n        }\n      }\n      updateCollisionDebugBuffers(t, e, r, n) {\n        if (!this.hasDebugData()) return;\n        this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();\n        const i = wf(this.iconSizeData, t, n),\n          s = wf(this.textSizeData, t, r);\n        for (let a = 0; a < this.symbolInstances.length; a++) {\n          const o = this.symbolInstances.get(a);\n          this._updateTextDebugCollisionBoxes(s, t, e, o.textBoxStartIndex, o.textBoxEndIndex, o, r), this._updateTextDebugCollisionBoxes(s, t, e, o.verticalTextBoxStartIndex, o.verticalTextBoxEndIndex, o, r), this._updateIconDebugCollisionBoxes(i, t, e, o.iconBoxStartIndex, o.iconBoxEndIndex, o, n), this._updateIconDebugCollisionBoxes(i, t, e, o.verticalIconBoxStartIndex, o.verticalIconBoxEndIndex, o, n);\n        }\n        this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);\n      }\n      _deserializeCollisionBoxesForSymbol(t, e, r, n, i, s, a, o, l) {\n        const u = {};\n        if (e < r) {\n          const {\n            x1: r,\n            y1: n,\n            x2: i,\n            y2: s,\n            padding: a,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p,\n            featureIndex: f\n          } = t.get(e);\n          u.textBox = {\n            x1: r,\n            y1: n,\n            x2: i,\n            y2: s,\n            padding: a,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p\n          }, u.textFeatureIndex = f;\n        }\n        if (n < i) {\n          const {\n            x1: e,\n            y1: r,\n            x2: i,\n            y2: s,\n            padding: a,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p,\n            featureIndex: f\n          } = t.get(n);\n          u.verticalTextBox = {\n            x1: e,\n            y1: r,\n            x2: i,\n            y2: s,\n            padding: a,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p\n          }, u.verticalTextFeatureIndex = f;\n        }\n        if (s < a) {\n          const {\n            x1: e,\n            y1: r,\n            x2: n,\n            y2: i,\n            padding: a,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p,\n            featureIndex: f\n          } = t.get(s);\n          u.iconBox = {\n            x1: e,\n            y1: r,\n            x2: n,\n            y2: i,\n            padding: a,\n            projectedAnchorX: o,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p\n          }, u.iconFeatureIndex = f;\n        }\n        if (o < l) {\n          const {\n            x1: e,\n            y1: r,\n            x2: n,\n            y2: i,\n            padding: s,\n            projectedAnchorX: a,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p,\n            featureIndex: f\n          } = t.get(o);\n          u.verticalIconBox = {\n            x1: e,\n            y1: r,\n            x2: n,\n            y2: i,\n            padding: s,\n            projectedAnchorX: a,\n            projectedAnchorY: l,\n            projectedAnchorZ: c,\n            tileAnchorX: h,\n            tileAnchorY: p\n          }, u.verticalIconFeatureIndex = f;\n        }\n        return u;\n      }\n      deserializeCollisionBoxes(t) {\n        this.collisionArrays = [];\n        for (let e = 0; e < this.symbolInstances.length; e++) {\n          const r = this.symbolInstances.get(e);\n          this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));\n        }\n      }\n      hasTextData() {\n        return this.text.segments.get().length > 0;\n      }\n      hasIconData() {\n        return this.icon.segments.get().length > 0;\n      }\n      hasDebugData() {\n        return this.textCollisionBox && this.iconCollisionBox;\n      }\n      hasTextCollisionBoxData() {\n        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;\n      }\n      hasIconCollisionBoxData() {\n        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;\n      }\n      hasIconTextFit() {\n        return this.hasAnyIconTextFit;\n      }\n      addIndicesForPlacedSymbol(t, e) {\n        const r = t.placedSymbolArray.get(e),\n          n = r.vertexStartIndex + 4 * r.numGlyphs;\n        for (let e = r.vertexStartIndex; e < n; e += 4) t.indexArray.emplaceBack(e, e + 1, e + 2), t.indexArray.emplaceBack(e + 1, e + 2, e + 3);\n      }\n      getSortedSymbolIndexes(t) {\n        if (this.sortedAngle === t && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;\n        const e = Math.sin(t),\n          r = Math.cos(t),\n          n = [],\n          i = [],\n          s = [];\n        for (let t = 0; t < this.symbolInstances.length; ++t) {\n          s.push(t);\n          const a = this.symbolInstances.get(t);\n          n.push(0 | Math.round(e * a.tileAnchorX + r * a.tileAnchorY)), i.push(a.featureIndex);\n        }\n        return s.sort((t, e) => n[t] - n[e] || i[e] - i[t]), s;\n      }\n      getSortedIndexesByZOffset() {\n        if (!this.zOffsetSortDirty) return this.symbolInstanceIndexesSortedZOffset;\n        if (!this.symbolInstanceIndexesSortedZOffset) {\n          this.symbolInstanceIndexesSortedZOffset = [];\n          for (let t = 0; t < this.symbolInstances.length; ++t) this.symbolInstanceIndexesSortedZOffset.push(t);\n        }\n        return this.zOffsetSortDirty = !1, this.symbolInstanceIndexesSortedZOffset.sort((t, e) => this.symbolInstances.get(e).zOffset - this.symbolInstances.get(t).zOffset);\n      }\n      addToSortKeyRanges(t, e) {\n        const r = this.sortKeyRanges[this.sortKeyRanges.length - 1];\n        r && r.sortKey === e ? r.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({\n          sortKey: e,\n          symbolInstanceStart: t,\n          symbolInstanceEnd: t + 1\n        });\n      }\n      sortFeatures(t) {\n        if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {\n          this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t), this.sortedAngle = t, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];\n          for (const t of this.symbolInstanceIndexes) {\n            const e = this.symbolInstances.get(t);\n            this.featureSortOrder.push(e.featureIndex);\n            const {\n              rightJustifiedTextSymbolIndex: r,\n              centerJustifiedTextSymbolIndex: n,\n              leftJustifiedTextSymbolIndex: i,\n              verticalPlacedTextSymbolIndex: s,\n              placedIconSymbolIndex: a,\n              verticalPlacedIconSymbolIndex: o\n            } = e;\n            r >= 0 && this.addIndicesForPlacedSymbol(this.text, r), n >= 0 && n !== r && this.addIndicesForPlacedSymbol(this.text, n), i >= 0 && i !== n && i !== r && this.addIndicesForPlacedSymbol(this.text, i), s >= 0 && this.addIndicesForPlacedSymbol(this.text, s), a >= 0 && this.addIndicesForPlacedSymbol(this.icon, a), o >= 0 && this.addIndicesForPlacedSymbol(this.icon, o);\n          }\n          this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);\n        }\n      }\n    }\n    let km, Tm, Bm;\n    us(zm, \"SymbolBucket\", {\n      omit: [\"layers\", \"collisionBoxArray\", \"features\", \"compareText\"]\n    }), zm.addDynamicAttributes = Im;\n    class Vm {\n      constructor(t) {\n        this.type = t.property.overrides ? t.property.overrides.runtimeType : De, this.defaultValue = t;\n      }\n      evaluate(t) {\n        if (t.formattedSection) {\n          const e = this.defaultValue.property.overrides;\n          if (e && e.hasOverride(t.formattedSection)) return e.getOverride(t.formattedSection);\n        }\n        return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;\n      }\n      eachChild(t) {\n        this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);\n      }\n      outputDefined() {\n        return !1;\n      }\n      serialize() {\n        return null;\n      }\n    }\n    us(Vm, \"FormatSectionOverride\", {\n      omit: [\"defaultValue\"]\n    });\n    const Cm = () => Bm || (Bm = {\n      layout: km || (km = new Xs({\n        \"symbol-placement\": new Gs(Zs.layout_symbol[\"symbol-placement\"]),\n        \"symbol-spacing\": new Gs(Zs.layout_symbol[\"symbol-spacing\"]),\n        \"symbol-avoid-edges\": new Gs(Zs.layout_symbol[\"symbol-avoid-edges\"]),\n        \"symbol-sort-key\": new Ys(Zs.layout_symbol[\"symbol-sort-key\"]),\n        \"symbol-z-order\": new Gs(Zs.layout_symbol[\"symbol-z-order\"]),\n        \"symbol-z-elevate\": new Gs(Zs.layout_symbol[\"symbol-z-elevate\"]),\n        \"symbol-elevation-reference\": new Gs(Zs.layout_symbol[\"symbol-elevation-reference\"]),\n        \"icon-allow-overlap\": new Gs(Zs.layout_symbol[\"icon-allow-overlap\"]),\n        \"icon-ignore-placement\": new Gs(Zs.layout_symbol[\"icon-ignore-placement\"]),\n        \"icon-optional\": new Gs(Zs.layout_symbol[\"icon-optional\"]),\n        \"icon-rotation-alignment\": new Gs(Zs.layout_symbol[\"icon-rotation-alignment\"]),\n        \"icon-size\": new Ys(Zs.layout_symbol[\"icon-size\"]),\n        \"icon-size-scale-range\": new Gs(Zs.layout_symbol[\"icon-size-scale-range\"]),\n        \"icon-text-fit\": new Ys(Zs.layout_symbol[\"icon-text-fit\"]),\n        \"icon-text-fit-padding\": new Ys(Zs.layout_symbol[\"icon-text-fit-padding\"]),\n        \"icon-image\": new Ys(Zs.layout_symbol[\"icon-image\"]),\n        \"icon-rotate\": new Ys(Zs.layout_symbol[\"icon-rotate\"]),\n        \"icon-padding\": new Gs(Zs.layout_symbol[\"icon-padding\"]),\n        \"icon-keep-upright\": new Gs(Zs.layout_symbol[\"icon-keep-upright\"]),\n        \"icon-offset\": new Ys(Zs.layout_symbol[\"icon-offset\"]),\n        \"icon-anchor\": new Ys(Zs.layout_symbol[\"icon-anchor\"]),\n        \"icon-pitch-alignment\": new Gs(Zs.layout_symbol[\"icon-pitch-alignment\"]),\n        \"text-pitch-alignment\": new Gs(Zs.layout_symbol[\"text-pitch-alignment\"]),\n        \"text-rotation-alignment\": new Gs(Zs.layout_symbol[\"text-rotation-alignment\"]),\n        \"text-field\": new Ys(Zs.layout_symbol[\"text-field\"]),\n        \"text-font\": new Ys(Zs.layout_symbol[\"text-font\"]),\n        \"text-size\": new Ys(Zs.layout_symbol[\"text-size\"]),\n        \"text-size-scale-range\": new Gs(Zs.layout_symbol[\"text-size-scale-range\"]),\n        \"text-max-width\": new Ys(Zs.layout_symbol[\"text-max-width\"]),\n        \"text-line-height\": new Ys(Zs.layout_symbol[\"text-line-height\"]),\n        \"text-letter-spacing\": new Ys(Zs.layout_symbol[\"text-letter-spacing\"]),\n        \"text-justify\": new Ys(Zs.layout_symbol[\"text-justify\"]),\n        \"text-radial-offset\": new Ys(Zs.layout_symbol[\"text-radial-offset\"]),\n        \"text-variable-anchor\": new Gs(Zs.layout_symbol[\"text-variable-anchor\"]),\n        \"text-anchor\": new Ys(Zs.layout_symbol[\"text-anchor\"]),\n        \"text-max-angle\": new Gs(Zs.layout_symbol[\"text-max-angle\"]),\n        \"text-writing-mode\": new Gs(Zs.layout_symbol[\"text-writing-mode\"]),\n        \"text-rotate\": new Ys(Zs.layout_symbol[\"text-rotate\"]),\n        \"text-padding\": new Gs(Zs.layout_symbol[\"text-padding\"]),\n        \"text-keep-upright\": new Gs(Zs.layout_symbol[\"text-keep-upright\"]),\n        \"text-transform\": new Ys(Zs.layout_symbol[\"text-transform\"]),\n        \"text-offset\": new Ys(Zs.layout_symbol[\"text-offset\"]),\n        \"text-allow-overlap\": new Gs(Zs.layout_symbol[\"text-allow-overlap\"]),\n        \"text-ignore-placement\": new Gs(Zs.layout_symbol[\"text-ignore-placement\"]),\n        \"text-optional\": new Gs(Zs.layout_symbol[\"text-optional\"]),\n        visibility: new Gs(Zs.layout_symbol.visibility)\n      })),\n      paint: Tm || (Tm = new Xs({\n        \"icon-opacity\": new Ys(Zs.paint_symbol[\"icon-opacity\"]),\n        \"icon-occlusion-opacity\": new Ys(Zs.paint_symbol[\"icon-occlusion-opacity\"]),\n        \"icon-emissive-strength\": new Ys(Zs.paint_symbol[\"icon-emissive-strength\"]),\n        \"text-emissive-strength\": new Ys(Zs.paint_symbol[\"text-emissive-strength\"]),\n        \"icon-color\": new Ys(Zs.paint_symbol[\"icon-color\"]),\n        \"icon-halo-color\": new Ys(Zs.paint_symbol[\"icon-halo-color\"]),\n        \"icon-halo-width\": new Ys(Zs.paint_symbol[\"icon-halo-width\"]),\n        \"icon-halo-blur\": new Ys(Zs.paint_symbol[\"icon-halo-blur\"]),\n        \"icon-translate\": new Gs(Zs.paint_symbol[\"icon-translate\"]),\n        \"icon-translate-anchor\": new Gs(Zs.paint_symbol[\"icon-translate-anchor\"]),\n        \"icon-image-cross-fade\": new Ys(Zs.paint_symbol[\"icon-image-cross-fade\"]),\n        \"text-opacity\": new Ys(Zs.paint_symbol[\"text-opacity\"]),\n        \"text-occlusion-opacity\": new Ys(Zs.paint_symbol[\"text-occlusion-opacity\"]),\n        \"text-color\": new Ys(Zs.paint_symbol[\"text-color\"], {\n          runtimeType: Oe,\n          getOverride: t => t.textColor,\n          hasOverride: t => !!t.textColor\n        }),\n        \"text-halo-color\": new Ys(Zs.paint_symbol[\"text-halo-color\"]),\n        \"text-halo-width\": new Ys(Zs.paint_symbol[\"text-halo-width\"]),\n        \"text-halo-blur\": new Ys(Zs.paint_symbol[\"text-halo-blur\"]),\n        \"text-translate\": new Gs(Zs.paint_symbol[\"text-translate\"]),\n        \"text-translate-anchor\": new Gs(Zs.paint_symbol[\"text-translate-anchor\"]),\n        \"icon-color-saturation\": new Gs(Zs.paint_symbol[\"icon-color-saturation\"]),\n        \"icon-color-contrast\": new Gs(Zs.paint_symbol[\"icon-color-contrast\"]),\n        \"icon-color-brightness-min\": new Gs(Zs.paint_symbol[\"icon-color-brightness-min\"]),\n        \"icon-color-brightness-max\": new Gs(Zs.paint_symbol[\"icon-color-brightness-max\"]),\n        \"symbol-z-offset\": new Ys(Zs.paint_symbol[\"symbol-z-offset\"]),\n        \"icon-color-use-theme\": new Ys({\n          type: \"string\",\n          default: \"default\",\n          \"property-type\": \"data-driven\"\n        }),\n        \"icon-halo-color-use-theme\": new Ys({\n          type: \"string\",\n          default: \"default\",\n          \"property-type\": \"data-driven\"\n        }),\n        \"text-color-use-theme\": new Ys({\n          type: \"string\",\n          default: \"default\",\n          \"property-type\": \"data-driven\"\n        }),\n        \"text-halo-color-use-theme\": new Ys({\n          type: \"string\",\n          default: \"default\",\n          \"property-type\": \"data-driven\"\n        })\n      }))\n    }, Bm);\n    class Dm extends ma {\n      constructor(t, e, r, n) {\n        super(t, Cm(), e, r, n), this._colorAdjustmentMatrix = O.mat4.identity([]), this.hasInitialOcclusionOpacityProperties = void 0 !== t.paint && (\"icon-occlusion-opacity\" in t.paint || \"text-occlusion-opacity\" in t.paint);\n      }\n      recalculate(t, e) {\n        super.recalculate(t, e), \"auto\" === this.layout.get(\"icon-rotation-alignment\") && (this.layout._values[\"icon-rotation-alignment\"] = \"point\" !== this.layout.get(\"symbol-placement\") ? \"map\" : \"viewport\"), \"auto\" === this.layout.get(\"text-rotation-alignment\") && (this.layout._values[\"text-rotation-alignment\"] = \"point\" !== this.layout.get(\"symbol-placement\") ? \"map\" : \"viewport\"), \"auto\" === this.layout.get(\"text-pitch-alignment\") && (this.layout._values[\"text-pitch-alignment\"] = this.layout.get(\"text-rotation-alignment\")), \"auto\" === this.layout.get(\"icon-pitch-alignment\") && (this.layout._values[\"icon-pitch-alignment\"] = this.layout.get(\"icon-rotation-alignment\"));\n        const r = this.layout.get(\"text-writing-mode\");\n        if (r) {\n          const t = [];\n          for (const e of r) t.indexOf(e) < 0 && t.push(e);\n          this.layout._values[\"text-writing-mode\"] = t;\n        } else this.layout._values[\"text-writing-mode\"] = \"point\" === this.layout.get(\"symbol-placement\") ? [\"horizontal\"] : [\"horizontal\", \"vertical\"];\n        this._setPaintOverrides();\n      }\n      getColorAdjustmentMatrix(t, e, r, n) {\n        return this._saturation === t && this._contrast === e && this._brightnessMin === r && this._brightnessMax === n || (this._colorAdjustmentMatrix = function (t, e, r, n) {\n          t = Mt(t), e = wt(e);\n          const i = O.mat4.create(),\n            s = t / 3,\n            a = 1 - 2 * s,\n            o = [a, s, s, 0, s, a, s, 0, s, s, a, 0, 0, 0, 0, 1],\n            l = .5 - .5 * e,\n            u = n - r;\n          return O.mat4.multiply(i, [u, 0, 0, 0, 0, u, 0, 0, 0, 0, u, 0, r, r, r, 1], [e, 0, 0, 0, 0, e, 0, 0, 0, 0, e, 0, l, l, l, 1]), O.mat4.multiply(i, i, o), i;\n        }(t, e, r, n), this._saturation = t, this._contrast = e, this._brightnessMin = r, this._brightnessMax = n), this._colorAdjustmentMatrix;\n      }\n      getValueAndResolveTokens(t, e, r, n) {\n        const i = this.layout.get(t).evaluate(e, {}, r, n),\n          s = this._unevaluatedLayout._values[t];\n        return s.isDataDriven() || Ki(s.value) || !i ? i : function (t, e) {\n          return e.replace(/{([^{}]+)}/g, (e, r) => r in t ? String(t[r]) : \"\");\n        }(e.properties, i);\n      }\n      createBucket(t) {\n        return new zm(t);\n      }\n      queryRadius() {\n        return 0;\n      }\n      queryIntersectsFeature() {\n        return !1;\n      }\n      _setPaintOverrides() {\n        for (const t of Cm().paint.overridableProperties) {\n          if (!Dm.hasPaintOverride(this.layout, t)) continue;\n          const e = this.paint.get(t),\n            r = new Vm(e),\n            n = new Wi(r, e.property.specification, this.scope, this.options);\n          let i = null;\n          i = \"constant\" === e.value.kind || \"source\" === e.value.kind ? new Qi(\"source\", n) : new ts(\"composite\", n, e.value.zoomStops, e.value._interpolationType), this.paint._values[t] = new qs(e.property, i, e.parameters);\n        }\n      }\n      _handleOverridablePaintPropertyUpdate(t, e, r) {\n        return !(!this.layout || e.isDataDriven() || r.isDataDriven()) && Dm.hasPaintOverride(this.layout, t);\n      }\n      static hasPaintOverride(t, e) {\n        const r = t.get(\"text-field\"),\n          n = Cm().paint.properties[e];\n        let i = !1;\n        const s = t => {\n          for (const e of t) if (n.overrides && n.overrides.hasOverride(e)) return void (i = !0);\n        };\n        if (\"constant\" === r.value.kind && r.value.value instanceof Qe) s(r.value.value.sections);else if (\"source\" === r.value.kind) {\n          const t = e => {\n              i || (e instanceof ar && ir(e.value) === qe ? s(e.value.sections) : e instanceof cr ? s(e.sections) : e.eachChild(t));\n            },\n            e = r.value;\n          e._styleExpression && t(e._styleExpression.expression);\n        }\n        return i;\n      }\n      getProgramIds() {\n        return [\"symbol\"];\n      }\n      getDefaultProgramParams(t, e, r) {\n        return {\n          config: new $o(this, {\n            zoom: e,\n            lut: r\n          }),\n          overrideFog: !1\n        };\n      }\n    }\n    let Rm, Lm, Fm, Om;\n    var Nm = va([{\n      name: \"a_pos\",\n      type: \"Int16\",\n      components: 2\n    }, {\n      name: \"a_texture_pos\",\n      type: \"Int16\",\n      components: 2\n    }]);\n    function Um(t) {\n      switch (t) {\n        case WebGL2RenderingContext.RGBA8:\n          return WebGL2RenderingContext.RGBA;\n        case WebGL2RenderingContext.DEPTH_COMPONENT16:\n          return WebGL2RenderingContext.DEPTH_COMPONENT;\n        case WebGL2RenderingContext.DEPTH24_STENCIL8:\n          return WebGL2RenderingContext.DEPTH_STENCIL;\n        case WebGL2RenderingContext.R8:\n        case WebGL2RenderingContext.R32F:\n          return WebGL2RenderingContext.RED;\n      }\n    }\n    function jm(t) {\n      switch (t) {\n        case WebGL2RenderingContext.RGBA8:\n          return WebGL2RenderingContext.UNSIGNED_BYTE;\n        case WebGL2RenderingContext.DEPTH_COMPONENT16:\n          return WebGL2RenderingContext.UNSIGNED_SHORT;\n        case WebGL2RenderingContext.DEPTH24_STENCIL8:\n          return WebGL2RenderingContext.UNSIGNED_INT_24_8;\n        case WebGL2RenderingContext.R8:\n          return WebGL2RenderingContext.UNSIGNED_BYTE;\n        case WebGL2RenderingContext.R32F:\n          return WebGL2RenderingContext.FLOAT;\n      }\n    }\n    class qm {\n      constructor(t, e, r, n) {\n        this.context = t, this.format = r, this.useMipmap = n && n.useMipmap, this.texture = t.gl.createTexture(), this.update(e, {\n          premultiply: n && n.premultiply\n        });\n      }\n      update(t, e) {\n        const r = t && t instanceof HTMLVideoElement && 0 === t.width ? t.videoWidth : t.width,\n          n = t && t instanceof HTMLVideoElement && 0 === t.height ? t.videoHeight : t.height,\n          {\n            context: i\n          } = this,\n          {\n            gl: s\n          } = i,\n          {\n            x: a,\n            y: o\n          } = e && e.position ? e.position : {\n            x: 0,\n            y: 0\n          },\n          l = a + r,\n          u = o + n;\n        !this.size || this.size[0] === l && this.size[1] === u || (s.bindTexture(s.TEXTURE_2D, null), s.deleteTexture(this.texture), this.texture = s.createTexture(), this.size = null), s.bindTexture(s.TEXTURE_2D, this.texture), i.pixelStoreUnpackFlipY.set(!1), i.pixelStoreUnpack.set(1), i.pixelStoreUnpackPremultiplyAlpha.set(this.format === s.RGBA8 && (!e || !1 !== e.premultiply));\n        const c = t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof HTMLVideoElement || t instanceof ImageData || ImageBitmap && t instanceof ImageBitmap;\n        if (!this.size && l > 0 && u > 0) {\n          const t = this.useMipmap ? Math.floor(Math.log2(Math.max(l, u))) + 1 : 1;\n          s.texStorage2D(s.TEXTURE_2D, t, this.format, l, u), this.size = [l, u];\n        }\n        if (this.size) if (c) s.texSubImage2D(s.TEXTURE_2D, 0, a, o, Um(this.format), jm(this.format), t);else {\n          const e = t.data;\n          e && s.texSubImage2D(s.TEXTURE_2D, 0, a, o, r, n, Um(this.format), jm(this.format), e);\n        }\n        this.useMipmap && s.generateMipmap(s.TEXTURE_2D);\n      }\n      bind(t, e, r = !1) {\n        const {\n            context: n\n          } = this,\n          {\n            gl: i\n          } = n;\n        i.bindTexture(i.TEXTURE_2D, this.texture), t !== this.minFilter && (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, t), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, this.useMipmap && !r ? t === i.NEAREST ? i.NEAREST_MIPMAP_NEAREST : i.LINEAR_MIPMAP_LINEAR : t), this.minFilter = t), e !== this.wrapS && (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, e), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, e), this.wrapS = e);\n      }\n      bindExtraParam(t, e, r, n) {\n        const {\n            context: i\n          } = this,\n          {\n            gl: s\n          } = i;\n        s.bindTexture(s.TEXTURE_2D, this.texture), e !== this.magFilter && (s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, e), this.magFilter = e), t !== this.minFilter && (s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, this.useMipmap ? t === s.NEAREST ? s.NEAREST_MIPMAP_NEAREST : s.LINEAR_MIPMAP_LINEAR : t), this.minFilter = t), r !== this.wrapS && (s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, r), this.wrapS = r), n !== this.wrapT && (s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, n), this.wrapT = n);\n      }\n      destroy() {\n        const {\n          gl: t\n        } = this.context;\n        t.deleteTexture(this.texture), this.texture = null;\n      }\n    }\n    class $m {\n      constructor(t, e) {\n        this.context = t, this.texture = e;\n      }\n      bind(t, e) {\n        const {\n            context: r\n          } = this,\n          {\n            gl: n\n          } = r;\n        n.bindTexture(n.TEXTURE_2D, this.texture), t !== this.minFilter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, t), this.minFilter = t), e !== this.wrapS && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, e), this.wrapS = e);\n      }\n    }\n    function Gm(t, e, r, n, i, s, a, o) {\n      const l = [t, e, 1, r, n, 1, i, s, 1],\n        u = [a, o, 1],\n        c = O.mat3.adjoint([], l),\n        [h, p, f] = O.vec3.transformMat3(u, u, c);\n      return O.mat3.multiply(l, l, [h, 0, 0, 0, p, 0, 0, 0, f]);\n    }\n    function Ym(t, e, r, n, i, s, a, o) {\n      const l = function (t, e, r, n, i, s, a, o) {\n        const l = Gm(0, 0, 1, 0, 1, 1, 0, 1),\n          u = Gm(t, e, r, n, i, s, a, o),\n          c = O.mat3.adjoint([], l);\n        return O.mat3.multiply(u, u, c);\n      }(t, e, r, n, i, s, a, o);\n      return [l[2] / l[8] / Kr, l[5] / l[8] / Kr];\n    }\n    function Hm(t) {\n      return [t[0], Math.min(Math.max(t[1], -bl), bl)];\n    }\n    class Xm extends _e {\n      constructor(t, e, r, n) {\n        super(), this.id = t, this.dispatcher = r, this.coordinates = e.coordinates, this.type = \"image\", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.onNorthPole = !1, this.onSouthPole = !1, this.setEventedParent(n), this.options = e, this._dirty = !1;\n      }\n      load(t, e) {\n        if (this._loaded = e || !1, this.fire(new ge(\"dataloading\", {\n          dataType: \"source\"\n        })), this.url = this.options.url, !this.url) return t && (this.coordinates = t), this._loaded = !0, void this._finishLoading();\n        this._imageRequest = le(this.map._requestManager.transformRequest(this.url, Qt.Image), (e, r) => {\n          this._imageRequest = null, this._loaded = !0, e ? this.fire(new xe(e)) : r && (this.image = r instanceof HTMLImageElement ? Ct.getImageData(r) : r, this._dirty = !0, this.width = this.image.width, this.height = this.image.height, t && (this.coordinates = t), this._finishLoading());\n        });\n      }\n      loaded() {\n        return this._loaded;\n      }\n      updateImage(t) {\n        return t.url ? (this._imageRequest && t.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = t.url, this.load(t.coordinates, this._loaded), this) : this;\n      }\n      setTexture(t) {\n        if (!(t.handle instanceof WebGLTexture)) throw new Error(\"The provided handle is not a WebGLTexture instance\");\n        return this.texture = new $m(this.map.painter.context, t.handle), this.width = t.dimensions[0], this.height = t.dimensions[1], this._dirty = !1, this._loaded = !0, this._finishLoading(), this;\n      }\n      _finishLoading() {\n        this.map && (this.setCoordinates(this.coordinates), this.fire(new ge(\"data\", {\n          dataType: \"source\",\n          sourceDataType: \"metadata\"\n        })));\n      }\n      onAdd(t) {\n        this.map = t, this.load();\n      }\n      onRemove(t) {\n        this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof $m || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());\n      }\n      setCoordinates(t) {\n        if (this.coordinates = t, this._boundsArray = void 0, this._unsupportedCoords = !1, !t.length) return this;\n        this.onNorthPole = !1, this.onSouthPole = !1;\n        let e = t[0][1],\n          r = t[0][1];\n        for (const n of t) n[1] > r && (r = n[1]), n[1] < e && (e = n[1]);\n        const n = (r + e) / 2;\n        if (n > bl ? this.onNorthPole = !0 : n < -bl && (this.onSouthPole = !0), !this.onNorthPole && !this.onSouthPole) {\n          const e = t.map(Il.fromLngLat);\n          this.tileID = function (t) {\n            let e = 1 / 0,\n              r = 1 / 0,\n              n = -1 / 0,\n              i = -1 / 0;\n            for (const s of t) e = Math.min(e, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y);\n            const s = Math.max(n - e, i - r),\n              a = Math.max(0, Math.floor(-Math.log(s) / Math.LN2)),\n              o = Math.pow(2, a);\n            let l = Math.floor((e + n) / 2 * o);\n            return l > 1 && (l -= 1), new ou(a, l, Math.floor((r + i) / 2 * o));\n          }(e), this.minzoom = this.maxzoom = this.tileID.z;\n        }\n        return this.fire(new ge(\"data\", {\n          dataType: \"source\",\n          sourceDataType: \"content\"\n        })), this;\n      }\n      _clear() {\n        this._boundsArray = void 0, this._unsupportedCoords = !1;\n      }\n      _prepareData(t) {\n        for (const t in this.tiles) {\n          const e = this.tiles[t];\n          \"loaded\" !== e.state && (e.state = \"loaded\", e.texture = this.texture);\n        }\n        if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords) return;\n        const e = Kd(new ou(0, 0, 0), this.map.transform.projection),\n          r = [e.projection.project(this.coordinates[0][0], this.coordinates[0][1]), e.projection.project(this.coordinates[1][0], this.coordinates[1][1]), e.projection.project(this.coordinates[2][0], this.coordinates[2][1]), e.projection.project(this.coordinates[3][0], this.coordinates[3][1])];\n        if (!function (t) {\n          const e = t[1].x - t[0].x,\n            r = t[1].y - t[0].y,\n            n = t[2].x - t[1].x,\n            i = t[2].y - t[1].y,\n            s = t[3].x - t[2].x,\n            a = t[3].y - t[2].y,\n            o = t[0].x - t[3].x,\n            l = t[0].y - t[3].y,\n            u = e * i - n * r,\n            c = n * a - s * i,\n            h = s * l - o * a,\n            p = o * r - e * l;\n          return u > 0 && c > 0 && h > 0 && p > 0 || u < 0 && c < 0 && h < 0 && p < 0;\n        }(r)) return console.warn(\"Image source coordinates are defining non-convex area in the Mercator projection\"), void (this._unsupportedCoords = !0);\n        const n = Kd(this.tileID, this.map.transform.projection),\n          [i, s, a, o] = this.coordinates.map(t => {\n            const e = n.projection.project(t[0], t[1]);\n            return Jd(n, e)._round();\n          });\n        this.perspectiveTransform = Ym(i.x, i.y, s.x, s.y, a.x, a.y, o.x, o.y);\n        const l = this._boundsArray = new Ma();\n        l.emplaceBack(i.x, i.y, 0, 0), l.emplaceBack(s.x, s.y, Kr, 0), l.emplaceBack(o.x, o.y, 0, Kr), l.emplaceBack(a.x, a.y, Kr, Kr), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = t.createVertexBuffer(l, Nm.members), this.boundsSegments = xo.simpleSegment(0, 0, 4, 2);\n        const u = [],\n          c = [Hm((h = this.coordinates)[0]), Hm(h[1]), Hm(h[2]), Hm(h[3])];\n        var h;\n        const [p, f, d, m] = function (t) {\n          let e = t[0][0],\n            r = e,\n            n = t[0][1],\n            i = n;\n          for (let s = 1; s < t.length; s++) t[s][0] < e ? e = t[s][0] : t[s][0] > r && (r = t[s][0]), t[s][1] < n ? n = t[s][1] : t[s][1] > i && (i = t[s][1]);\n          return [e, n, r - e, i - n];\n        }(c);\n        {\n          const n = new Ma(),\n            [i, s, a, o] = function (t) {\n              let e = t[0].x,\n                r = e,\n                n = t[0].y,\n                i = n;\n              for (let s = 1; s < t.length; s++) t[s].x < e ? e = t[s].x : t[s].x > r && (r = t[s].x), t[s].y < n ? n = t[s].y : t[s].y > i && (i = t[s].y);\n              return [e, n, r - e, i - n];\n            }(r),\n            l = t => [(t.x - i) / a, (t.y - s) / o],\n            [c, h, y, g] = r.map(l),\n            x = function (t, e, r, n, i, s, a, o) {\n              const l = Gm(0, 0, 1, 0, 1, 1, 0, 1),\n                u = Gm(t, e, r, n, i, s, a, o),\n                c = O.mat3.adjoint([], u);\n              return O.mat3.multiply(l, l, c);\n            }(c[0], c[1], h[0], h[1], y[0], y[1], g[0], g[1]);\n          this.elevatedGlobePerspectiveTransform = Ym(c[0], c[1], h[0], h[1], y[0], y[1], g[0], g[1]);\n          const v = (t, e) => {\n              u.push(t.lng);\n              const r = Math.round((t.lng - p) / d * Kr),\n                i = Math.round((t.lat - f) / m * Kr),\n                s = l(e),\n                a = O.vec3.transformMat3([], [s[0], s[1], 1], x),\n                o = Math.round(a[0] / a[2] * Kr),\n                c = Math.round(a[1] / a[2] * Kr);\n              n.emplaceBack(r, i, o, c);\n            },\n            b = r[3].x - r[0].x,\n            _ = r[3].y - r[0].y,\n            w = r[2].x - r[1].x,\n            M = r[2].y - r[1].y;\n          for (let t = 0; t < 65; t++) {\n            const n = t / 64,\n              i = [r[0].x + n * b, r[0].y + n * _],\n              s = [r[1].x + n * w, r[1].y + n * M],\n              a = s[0] - i[0],\n              o = s[1] - i[1];\n            for (let t = 0; t < 65; t++) {\n              const r = t / 64,\n                n = {\n                  x: i[0] + a * r,\n                  y: i[1] + o * r,\n                  z: 0\n                };\n              v(e.projection.unproject(n.x, n.y), n);\n            }\n          }\n          this.elevatedGlobeVertexBuffer = t.createVertexBuffer(n, Nm.members);\n        }\n        {\n          this.maxLongitudeTriangleSize = 0;\n          let e = [],\n            r = new ja();\n          const n = (t, n, i) => {\n            r.emplaceBack(t, n, i);\n            const s = u[t],\n              a = u[n],\n              o = u[i],\n              l = Math.min(Math.min(s, a), o),\n              c = Math.max(Math.max(s, a), o) - l;\n            c > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = c), e.push(l + c / 2);\n          };\n          for (let t = 0; t < 64; t++) for (let e = 0; e < 64; e++) {\n            const r = 65 * t + e,\n              i = r + 1,\n              s = r + 65,\n              a = s + 1;\n            n(r, s, i), n(i, s, a);\n          }\n          [e, r] = function (t, e) {\n            const r = Array.from({\n              length: t.length\n            }, (t, e) => e);\n            r.sort((e, r) => t[e] - t[r]);\n            const n = [],\n              i = new ja();\n            for (let s = 0; s < r.length; s++) {\n              const a = r[s];\n              n.push(t[a]);\n              const o = 3 * a,\n                l = o + 1;\n              i.emplaceBack(e.uint16[o], e.uint16[l], e.uint16[l + 1]);\n            }\n            return [n, i];\n          }(e, r), this.elevatedGlobeTrianglesCenterLongitudes = e, this.elevatedGlobeIndexBuffer = t.createIndexBuffer(r);\n        }\n        this.elevatedGlobeSegments = xo.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([0, d / Kr, 0, m / Kr, 0, 0, f, p, 0]);\n      }\n      prepare() {\n        const t = 0 !== Object.keys(this.tiles).length;\n        if (this.tileID && !t) return;\n        const e = this.map.painter.context,\n          r = e.gl;\n        !this._dirty || this.texture instanceof $m || (this.texture ? this.texture.update(this.image) : (this.texture = new qm(e, this.image, r.RGBA8), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE)), this._dirty = !1), t && this._prepareData(e);\n      }\n      loadTile(t, e) {\n        this.tileID && this.tileID.equals(t.tileID.canonical) ? (this.tiles[String(t.tileID.wrap)] = t, t.buckets = {}, e(null)) : (t.state = \"errored\", e(null));\n      }\n      serialize() {\n        return {\n          type: \"image\",\n          url: this.options.url,\n          coordinates: this.coordinates\n        };\n      }\n      hasTransition() {\n        return !1;\n      }\n      getSegmentsForLongitude(t) {\n        const e = this.elevatedGlobeSegments;\n        if (!this.elevatedGlobeTrianglesCenterLongitudes || !e) return null;\n        const r = this.elevatedGlobeTrianglesCenterLongitudes;\n        let n = (i = t + 180) + 360 * Math.round((r[0] - i) / 360);\n        var i;\n        const s = new xo(),\n          a = (t, r) => {\n            s.segments.push({\n              vertexOffset: 0,\n              primitiveOffset: t,\n              vertexLength: e.segments[0].vertexLength,\n              primitiveLength: r,\n              sortKey: void 0,\n              vaos: {}\n            });\n          },\n          o = .51 * this.maxLongitudeTriangleSize;\n        if (Math.abs(r[0] - n) <= o) {\n          const t = _t(r, 0, r.length, n + o);\n          return t === r.length || a(t, bt(r, t + 1, r.length, n + 360 - o) - t), s;\n        }\n        n < r[0] && (n += 360);\n        const l = bt(r, 0, r.length, n - o);\n        if (l === r.length) return a(0, r.length), s;\n        a(0, l - 0);\n        const u = _t(r, l + 1, r.length, n + o);\n        return u !== r.length && a(u, r.length - u), s;\n      }\n    }\n    const Zm = (Math.pow(256, 2) - 1) / 16907520;\n    class Wm extends ma {\n      constructor(t, e, r, n) {\n        super(t, {\n          layout: Fm || (Fm = new Xs({\n            visibility: new Gs(Zs.layout_raster.visibility)\n          })),\n          paint: Om || (Om = new Xs({\n            \"raster-opacity\": new Gs(Zs.paint_raster[\"raster-opacity\"]),\n            \"raster-color\": new Hs(Zs.paint_raster[\"raster-color\"]),\n            \"raster-color-mix\": new Gs(Zs.paint_raster[\"raster-color-mix\"]),\n            \"raster-color-range\": new Gs(Zs.paint_raster[\"raster-color-range\"]),\n            \"raster-hue-rotate\": new Gs(Zs.paint_raster[\"raster-hue-rotate\"]),\n            \"raster-brightness-min\": new Gs(Zs.paint_raster[\"raster-brightness-min\"]),\n            \"raster-brightness-max\": new Gs(Zs.paint_raster[\"raster-brightness-max\"]),\n            \"raster-saturation\": new Gs(Zs.paint_raster[\"raster-saturation\"]),\n            \"raster-contrast\": new Gs(Zs.paint_raster[\"raster-contrast\"]),\n            \"raster-resampling\": new Gs(Zs.paint_raster[\"raster-resampling\"]),\n            \"raster-fade-duration\": new Gs(Zs.paint_raster[\"raster-fade-duration\"]),\n            \"raster-emissive-strength\": new Gs(Zs.paint_raster[\"raster-emissive-strength\"]),\n            \"raster-array-band\": new Gs(Zs.paint_raster[\"raster-array-band\"]),\n            \"raster-elevation\": new Gs(Zs.paint_raster[\"raster-elevation\"]),\n            \"raster-color-use-theme\": new Ys({\n              type: \"string\",\n              default: \"default\",\n              \"property-type\": \"data-driven\"\n            })\n          }))\n        }, e, r, n), this.updateColorRamp(), this._curRampRange = [NaN, NaN];\n      }\n      getProgramIds() {\n        return [\"raster\"];\n      }\n      hasColorMap() {\n        return !!this._transitionablePaint._values[\"raster-color\"].value.value;\n      }\n      tileCoverLift() {\n        return this.paint.get(\"raster-elevation\");\n      }\n      isDraped(t) {\n        return !(t && t._source instanceof Xm && (t._source.onNorthPole || t._source.onSouthPole)) && 0 === this.paint.get(\"raster-elevation\");\n      }\n      _handleSpecialPaintPropertyUpdate(t) {\n        \"raster-color\" !== t && \"raster-color-range\" !== t || (this._curRampRange = [NaN, NaN], this.updateColorRamp());\n      }\n      updateColorRamp(t) {\n        if (!this.hasColorMap()) return;\n        if (!this._curRampRange) return;\n        const e = this._transitionablePaint._values[\"raster-color\"].value.expression,\n          [r, n] = t || this._transitionablePaint._values[\"raster-color-range\"].value.expression.evaluate({\n            zoom: 0\n          }) || [NaN, NaN];\n        isNaN(r) && isNaN(n) || r === this._curRampRange[0] && n === this._curRampRange[1] || (this.colorRamp = dc({\n          expression: e,\n          evaluationKey: \"rasterValue\",\n          image: this.colorRamp,\n          clips: [{\n            start: r,\n            end: n\n          }],\n          resolution: 256\n        }), this.colorRampTexture = null, this._curRampRange = [r, n]);\n      }\n    }\n    let Km, Jm, Qm, ty, ey;\n    class ry extends ma {\n      constructor(t, e, r, n) {\n        super(t, {\n          layout: Km || (Km = new Xs({\n            visibility: new Gs(Zs[\"layout_raster-particle\"].visibility)\n          })),\n          paint: Jm || (Jm = new Xs({\n            \"raster-particle-array-band\": new Gs(Zs[\"paint_raster-particle\"][\"raster-particle-array-band\"]),\n            \"raster-particle-count\": new Gs(Zs[\"paint_raster-particle\"][\"raster-particle-count\"]),\n            \"raster-particle-color\": new Hs(Zs[\"paint_raster-particle\"][\"raster-particle-color\"]),\n            \"raster-particle-max-speed\": new Gs(Zs[\"paint_raster-particle\"][\"raster-particle-max-speed\"]),\n            \"raster-particle-speed-factor\": new Gs(Zs[\"paint_raster-particle\"][\"raster-particle-speed-factor\"]),\n            \"raster-particle-fade-opacity-factor\": new Gs(Zs[\"paint_raster-particle\"][\"raster-particle-fade-opacity-factor\"]),\n            \"raster-particle-reset-rate-factor\": new Gs(Zs[\"paint_raster-particle\"][\"raster-particle-reset-rate-factor\"]),\n            \"raster-particle-elevation\": new Gs(Zs[\"paint_raster-particle\"][\"raster-particle-elevation\"]),\n            \"raster-particle-color-use-theme\": new Ys({\n              type: \"string\",\n              default: \"default\",\n              \"property-type\": \"data-driven\"\n            })\n          }))\n        }, e, r, n), this._updateColorRamp(), this.lastInvalidatedAt = Ct.now();\n      }\n      onRemove(t) {\n        this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy();\n      }\n      hasColorMap() {\n        return !!this._transitionablePaint._values[\"raster-particle-color\"].value.value;\n      }\n      getProgramIds() {\n        return [\"rasterParticle\"];\n      }\n      hasOffscreenPass() {\n        return \"none\" !== this.visibility;\n      }\n      isDraped(t) {\n        return !1;\n      }\n      _handleSpecialPaintPropertyUpdate(t) {\n        \"raster-particle-color\" !== t && \"raster-particle-max-speed\" !== t || (this._updateColorRamp(), this._invalidateAnimationState()), \"raster-particle-count\" === t && this._invalidateAnimationState();\n      }\n      _updateColorRamp() {\n        if (!this.hasColorMap()) return;\n        const t = this._transitionablePaint._values[\"raster-particle-color\"].value.expression,\n          e = this._transitionablePaint._values[\"raster-particle-max-speed\"].value.expression.evaluate({\n            zoom: 0\n          });\n        this.colorRamp = dc({\n          expression: t,\n          evaluationKey: \"rasterParticleSpeed\",\n          image: this.colorRamp,\n          clips: [{\n            start: 0,\n            end: e\n          }],\n          resolution: 256\n        }), this.colorRampTexture = null;\n      }\n      _invalidateAnimationState() {\n        this.lastInvalidatedAt = Ct.now();\n      }\n      tileCoverLift() {\n        return this.paint.get(\"raster-particle-elevation\");\n      }\n    }\n    class ny extends ma {\n      constructor(t, e) {\n        super(t, {}, e, null), this.implementation = t, t.slot && (this.slot = t.slot);\n      }\n      is3D(t) {\n        return \"3d\" === this.implementation.renderingMode;\n      }\n      hasOffscreenPass() {\n        return void 0 !== this.implementation.prerender;\n      }\n      isDraped(t) {\n        return void 0 !== this.implementation.renderToTile;\n      }\n      shouldRedrape() {\n        return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();\n      }\n      recalculate() {}\n      updateTransitions() {}\n      hasTransition() {\n        return !1;\n      }\n      serialize() {}\n      onAdd(t) {\n        this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl);\n      }\n      onRemove(t) {\n        this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl);\n      }\n    }\n    function iy(t, e, r) {\n      const n = [0, 0, 1],\n        i = O.quat.identity([]);\n      return O.quat.rotateY(i, i, r ? -H(t) + Math.PI : H(t)), O.quat.rotateX(i, i, -H(e)), O.vec3.transformQuat(n, n, i), O.vec3.normalize(n, n);\n    }\n    function sy(t, e) {\n      const r = oy(t.projection, t.zoom, t.width, t.height),\n        n = function (t, e, r, n, i) {\n          const s = new ul(r.lng - 180 * ly, r.lat),\n            a = new ul(r.lng + 180 * ly, r.lat),\n            o = t.project(s.lng, s.lat),\n            l = t.project(a.lng, a.lat),\n            u = -Math.atan2(l.y - o.y, l.x - o.x),\n            c = Il.fromLngLat(r);\n          c.y = Q(c.y, -1 + ly, 1 - ly);\n          const h = c.toLngLat(),\n            p = t.project(h.lng, h.lat),\n            f = Il.fromLngLat(h);\n          f.x += ly;\n          const d = f.toLngLat(),\n            m = t.project(d.lng, d.lat),\n            y = cy(m.x - p.x, m.y - p.y, u),\n            g = Il.fromLngLat(h);\n          g.y += ly;\n          const x = g.toLngLat(),\n            v = t.project(x.lng, x.lat),\n            b = cy(v.x - p.x, v.y - p.y, u),\n            _ = Math.abs(y.x) / Math.abs(b.y),\n            w = O.mat4.identity([]);\n          O.mat4.rotateZ(w, w, -u * (1 - (i ? 0 : n)));\n          const M = O.mat4.identity([]);\n          return O.mat4.scale(M, M, [1, 1 - (1 - _) * n, 1]), M[4] = -b.x / b.y * n, O.mat4.rotateZ(M, M, u), O.mat4.multiply(M, w, M), M;\n        }(t.projection, 0, t.center, r, e),\n        i = ay(t);\n      return O.mat4.scale(n, n, [i, i, 1]), n;\n    }\n    function ay(t) {\n      const e = t.projection,\n        r = oy(t.projection, t.zoom, t.width, t.height),\n        n = uy(e, t.center),\n        i = uy(e, ul.convert(e.center));\n      return Math.pow(2, n * r + (1 - r) * i);\n    }\n    function oy(t, e, r, n, i = 1 / 0) {\n      const s = t.range;\n      if (!s) return 0;\n      const a = Math.min(i, Math.max(r, n)),\n        o = Math.log(a / 1024) / Math.LN2;\n      return tt(s[0] + o, s[1] + o, e);\n    }\n    const ly = 1 / 4e4;\n    function uy(t, e) {\n      const r = Q(e.lat, -bl, bl),\n        n = new ul(e.lng - 180 * ly, r),\n        i = new ul(e.lng + 180 * ly, r),\n        s = t.project(n.lng, r),\n        a = t.project(i.lng, r),\n        o = Il.fromLngLat(n),\n        l = Il.fromLngLat(i),\n        u = a.x - s.x,\n        c = a.y - s.y,\n        h = l.x - o.x,\n        p = l.y - o.y,\n        f = Math.sqrt((h * h + p * p) / (u * u + c * c));\n      return Math.log(f) / Math.LN2;\n    }\n    function cy(t, e, r) {\n      const n = Math.cos(r),\n        i = Math.sin(r);\n      return {\n        x: t * n - e * i,\n        y: t * i + e * n\n      };\n    }\n    function hy(t, e, r) {\n      O.mat4.identity(t), O.mat4.rotateZ(t, t, H(e[2])), O.mat4.rotateX(t, t, H(e[0])), O.mat4.rotateY(t, t, H(e[1])), O.mat4.scale(t, t, r), O.mat4.multiply(t, t, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);\n    }\n    function py(t, e, r, n, i, s, a, o) {\n      const l = [r[0] - e[0], r[1] - e[1], 0],\n        u = [n[0] - e[0], n[1] - e[1], 0];\n      if (O.vec3.length(l) < 1e-12 || O.vec3.length(u) < 1e-12) return O.quat.identity(t);\n      const c = O.vec3.cross([], l, u);\n      O.vec3.normalize(c, c), O.vec3.subtract(u, n, e), l[2] = (s - i) * o, u[2] = (a - i) * o;\n      const h = l;\n      return O.vec3.cross(h, l, u), O.vec3.normalize(h, h), O.quat.rotationTo(t, c, h);\n    }\n    function fy(t, e, r = !1) {\n      const n = $u(e.zoom),\n        i = function (t, e, r) {\n          const n = e.worldSize,\n            i = [t[12], t[13], t[14]],\n            s = xl(i[1] / n),\n            a = gl(i[0] / n),\n            o = O.mat4.identity([]),\n            l = yl(1, s) * n,\n            u = yl(1, 0) * n * wl(s, e.zoom),\n            c = 1 / Uu(n);\n          let h = u * c;\n          if (r) {\n            const t = oy(e.projection, e.zoom, e.width, e.height, 1024);\n            h = c * e.projection.pixelSpaceConversion(e.center.lat, n, t);\n          }\n          const p = al(s, a);\n          O.vec3.add(p, p, O.vec3.scale([], O.vec3.normalize([], p), l * h * i[2]));\n          const f = function (t) {\n            const e = [t[0], t[1], t[2]];\n            let r = [0, 1, 0];\n            const n = O.vec3.cross([], r, e);\n            return O.vec3.cross(r, e, n), 0 === O.vec3.squaredLength(r) && (r = [0, 1, 0], O.vec3.cross(n, e, r)), O.vec3.normalize(n, n), O.vec3.normalize(r, r), O.vec3.normalize(e, e), [n[0], n[1], n[2], 0, r[0], r[1], r[2], 0, e[0], e[1], e[2], 0, t[0], t[1], t[2], 1];\n          }(p);\n          O.mat4.scale(o, o, [h, h, h * l]), O.mat4.translate(o, o, [-i[0], -i[1], -i[2]]);\n          const d = O.mat4.multiply([], e.globeMatrix, f);\n          return O.mat4.multiply(d, d, o), O.mat4.multiply(d, d, t), d;\n        }(t, e, r);\n      if (n > 0) {\n        const r = function (t, e) {\n          const r = e.worldSize,\n            n = yl(1, 0) * r * wl(e.center.lat, e.zoom) / Uu(r),\n            i = yl(1, e.center.lat) * r,\n            s = O.mat4.identity([]);\n          return O.mat4.rotateY(s, s, H(e.center.lng)), O.mat4.rotateX(s, s, H(e.center.lat)), O.mat4.translate(s, s, [0, 0, Ko]), O.mat4.scale(s, s, [n, n, n * i]), O.mat4.translate(s, s, [e.point.x - .5 * r, e.point.y - .5 * r, 0]), O.mat4.multiply(s, s, t), O.mat4.multiply(s, e.globeMatrix, s);\n        }(t, e);\n        return function (t, e, r) {\n          const n = (t, e, r) => {\n              const n = O.vec3.length(t),\n                i = O.vec3.length(e),\n                s = Tu(t, e, r);\n              return O.vec3.scale(s, s, 1 / O.vec3.length(s) * Ee(n, i, r));\n            },\n            i = n([t[0], t[1], t[2]], [e[0], e[1], e[2]], r),\n            s = n([t[4], t[5], t[6]], [e[4], e[5], e[6]], r),\n            a = n([t[8], t[9], t[10]], [e[8], e[9], e[10]], r),\n            o = Tu([t[12], t[13], t[14]], [e[12], e[13], e[14]], r);\n          return [i[0], i[1], i[2], 0, s[0], s[1], s[2], 0, a[0], a[1], a[2], 0, o[0], o[1], o[2], 1];\n        }(i, r, n);\n      }\n      return i;\n    }\n    function dy(t, e, r, n) {\n      const i = Au.projectAabbCorners(n, r);\n      let s = Number.MAX_VALUE,\n        a = -1;\n      for (let t = 0; t < i.length; ++t) {\n        const r = i[t];\n        r[0] = (.5 * r[0] + .5) * e.width, r[1] = (.5 - .5 * r[1]) * e.height, r[2] < s && (a = t, s = r[2]);\n      }\n      const o = t => new q(i[t][0], i[t][1]);\n      let l;\n      switch (a) {\n        case 0:\n        case 6:\n          l = [o(1), o(5), o(4), o(7), o(3), o(2), o(1)];\n          break;\n        case 1:\n        case 7:\n          l = [o(0), o(4), o(5), o(6), o(2), o(3), o(0)];\n          break;\n        case 3:\n        case 5:\n          l = [o(1), o(0), o(4), o(7), o(6), o(2), o(1)];\n          break;\n        default:\n          l = [o(1), o(5), o(6), o(7), o(3), o(0), o(1)];\n      }\n      if (Fl(t, l)) return s;\n    }\n    const my = va([{\n        name: \"a_pos_3f\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      yy = va([{\n        name: \"a_color_3f\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      gy = va([{\n        name: \"a_color_4f\",\n        components: 4,\n        type: \"Float32\"\n      }]),\n      xy = va([{\n        name: \"a_uv_2f\",\n        components: 2,\n        type: \"Float32\"\n      }]),\n      vy = va([{\n        name: \"a_normal_3f\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      by = va([{\n        name: \"a_normal_matrix0\",\n        components: 4,\n        type: \"Float32\"\n      }, {\n        name: \"a_normal_matrix1\",\n        components: 4,\n        type: \"Float32\"\n      }, {\n        name: \"a_normal_matrix2\",\n        components: 4,\n        type: \"Float32\"\n      }, {\n        name: \"a_normal_matrix3\",\n        components: 4,\n        type: \"Float32\"\n      }]),\n      _y = va([{\n        name: \"a_pbr\",\n        components: 4,\n        type: \"Uint16\"\n      }, {\n        name: \"a_heightBasedEmissiveStrength\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      wy = {\n        None: 0,\n        Model: 1,\n        Symbol: 2,\n        FillExtrusion: 4,\n        All: 7\n      };\n    class My {\n      constructor(t, e, r, n) {\n        this.message = (t ? `${t}: ` : \"\") + r, n && (this.identifier = n), null != e && e.__line__ && (this.line = e.__line__);\n      }\n    }\n    function Ay(t, e) {\n      const r = -1 === t.indexOf(\"://\");\n      try {\n        return new URL(t, r && e ? \"http://example.com\" : void 0), !0;\n      } catch (t) {\n        return !1;\n      }\n    }\n    class Iy {\n      constructor(t, e) {\n        this.feature = t, this.instancedDataOffset = e, this.instancedDataCount = 0, this.rotation = [0, 0, 0], this.scale = [1, 1, 1], this.translation = [0, 0, 0];\n      }\n    }\n    class Sy {\n      constructor() {\n        this.instancedDataArray = new Ja(), this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};\n      }\n    }\n    class Py {\n      constructor(t) {\n        this.zoom = t.zoom, this.canonical = t.canonical, this.layers = t.layers, this.layerIds = this.layers.map(t => t.fqid), this.projection = t.projection, this.index = t.index, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.hasPattern = !1, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = {\n          id: null,\n          timestamp: 0\n        }, this.modelUris = [], this.modelsRequested = !1, this.activeReplacements = [], this.replacementUpdateTime = 0;\n      }\n      updateFootprints(t, e) {}\n      populate(t, e, r, n) {\n        this.tileToMeter = Al(r);\n        const i = this.layers[0]._featureFilter.needGeometry;\n        this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);\n        for (const {\n          feature: s,\n          id: a,\n          index: o,\n          sourceLayerIndex: l\n        } of t) {\n          const t = null != a ? a : s.properties && s.properties.hasOwnProperty(\"id\") ? s.properties.id : void 0,\n            u = Cl(s, i);\n          if (!this.layers[0]._featureFilter.filter(new Rs(this.zoom), u, r)) continue;\n          const c = {\n              id: t,\n              sourceLayerIndex: l,\n              index: o,\n              geometry: i ? u.geometry : Vl(s, r, n),\n              properties: s.properties,\n              type: s.type,\n              patterns: {}\n            },\n            h = this.addFeature(c, c.geometry, u);\n          h && e.featureIndex.insert(s, c.geometry, o, l, this.index, this.instancesPerModel[h].instancedDataArray.length, Kr / 32);\n        }\n        this.lookup = null;\n      }\n      update(t, e, r, n) {\n        for (const e in this.instancesPerModel) {\n          const r = this.instancesPerModel[e];\n          for (const e in t) r.idToFeaturesIndex.hasOwnProperty(e) && (this.evaluate(r.features[r.idToFeaturesIndex[e]], t[e], r, !0), this.uploaded = !1);\n        }\n        this.maxHeight = 0;\n      }\n      updateZoomBasedPaintProperties() {\n        if (!this.hasZoomDependentProperties) return !1;\n        let t = !1;\n        for (const e in this.instancesPerModel) {\n          const r = this.instancesPerModel[e];\n          for (const e of r.features) {\n            const n = this.layers[0],\n              i = e.feature,\n              s = this.canonical,\n              a = n.paint.get(\"model-rotation\").evaluate(i, {}, s),\n              o = n.paint.get(\"model-scale\").evaluate(i, {}, s),\n              l = n.paint.get(\"model-translation\").evaluate(i, {}, s);\n            O.vec3.exactEquals(e.rotation, a) && O.vec3.exactEquals(e.scale, o) && O.vec3.exactEquals(e.translation, l) || (this.evaluate(e, e.featureStates, r, !0), t = !0);\n          }\n        }\n        return t;\n      }\n      updateReplacement(t, e, r, n) {\n        if (e.updateTime === this.replacementUpdateTime) return !1;\n        this.replacementUpdateTime = e.updateTime;\n        const i = e.getReplacementRegionsForTile(t.toUnwrapped(), !0);\n        if (Yh(this.activeReplacements, i)) return !1;\n        this.activeReplacements = i;\n        let s = !1;\n        for (const e in this.instancesPerModel) {\n          const i = this.instancesPerModel[e],\n            a = i.instancedDataArray;\n          for (const e of i.features) {\n            const i = e.instancedDataOffset,\n              o = e.instancedDataCount;\n            for (let e = 0; e < o; e++) {\n              const o = 16 * (e + i);\n              let l = a.float32[o + 0];\n              const u = l > Kr;\n              l = u ? l - Kr : l;\n              const c = Math.floor(l),\n                h = a.float32[o + 1];\n              let p = !1;\n              for (const e of this.activeReplacements) if (!jh(e, r, wy.Model, n) && !(e.min.x > c || c > e.max.x || e.min.y > h || h > e.max.y) && (p = Jh(Kh(c, h, t.canonical, e.footprintTileId.canonical), e.footprint), p)) break;\n              a.float32[o] = p ? l + Kr : l, s = s || p !== u;\n            }\n          }\n        }\n        return s;\n      }\n      isEmpty() {\n        for (const t in this.instancesPerModel) if (0 !== this.instancesPerModel[t].instancedDataArray.length) return !1;\n        return !0;\n      }\n      uploadPending() {\n        return !this.uploaded;\n      }\n      upload(t) {\n        if (!this.uploaded) for (const e in this.instancesPerModel) {\n          const r = this.instancesPerModel[e];\n          r.instancedDataArray.length < 0 || 0 === r.instancedDataArray.length || (r.instancedDataBuffer ? r.instancedDataBuffer.updateData(r.instancedDataArray) : r.instancedDataBuffer = t.createVertexBuffer(r.instancedDataArray, by.members, !0, void 0, this.instanceCount));\n        }\n        this.uploaded = !0;\n      }\n      destroy() {\n        for (const t in this.instancesPerModel) {\n          const e = this.instancesPerModel[t];\n          0 !== e.instancedDataArray.length && e.instancedDataBuffer && e.instancedDataBuffer.destroy();\n        }\n        const t = this.layers[0].modelManager;\n        if (t && this.modelUris) for (const e of this.modelUris) t.removeModel(e, \"\");\n      }\n      addFeature(t, e, r) {\n        const n = this.layers[0],\n          i = n.layout.get(\"model-id\").evaluate(r, {}, this.canonical);\n        if (!i) return pt(`modelId is not evaluated for layer ${n.id} and it is not going to get rendered.`), i;\n        Ay(i, !1) && (this.modelUris.includes(i) || this.modelUris.push(i)), this.instancesPerModel[i] || (this.instancesPerModel[i] = new Sy());\n        const s = this.instancesPerModel[i],\n          a = s.instancedDataArray,\n          o = new Iy(r, a.length);\n        for (const t of e) for (const e of t) {\n          if (e.x < 0 || e.x >= Kr || e.y < 0 || e.y >= Kr) continue;\n          const t = (this.lookupDim - 1) / Kr,\n            r = this.lookupDim * (e.y * t | 0) + e.x * t | 0;\n          if (this.lookup) {\n            if (0 !== this.lookup[r]) continue;\n            this.lookup[r] = 1;\n          }\n          this.instanceCount++;\n          const n = a.length;\n          a.resize(n + 1), s.instancesEvaluatedElevation.push(0), a.float32[16 * n] = e.x, a.float32[16 * n + 1] = e.y;\n        }\n        return o.instancedDataCount = s.instancedDataArray.length - o.instancedDataOffset, o.instancedDataCount > 0 && (t.id && (s.idToFeaturesIndex[t.id] = s.features.length), s.features.push(o), this.evaluate(o, {}, s, !1)), i;\n      }\n      getModelUris() {\n        return this.modelUris;\n      }\n      evaluate(t, e, r, n) {\n        const i = this.layers[0],\n          s = t.feature,\n          a = this.canonical,\n          o = t.rotation = i.paint.get(\"model-rotation\").evaluate(s, e, a),\n          l = t.scale = i.paint.get(\"model-scale\").evaluate(s, e, a),\n          u = t.translation = i.paint.get(\"model-translation\").evaluate(s, e, a),\n          c = i.paint.get(\"model-color\").evaluate(s, e, a);\n        c.a = i.paint.get(\"model-color-mix-intensity\").evaluate(s, e, a);\n        const h = [];\n        this.maxVerticalOffset < u[2] && (this.maxVerticalOffset = u[2]), this.maxScale = Math.max(Math.max(this.maxScale, l[0]), Math.max(l[1], l[2])), hy(h, o, l);\n        const p = Math.round(100 * c.a) + c.b / 1.05;\n        for (let e = 0; e < t.instancedDataCount; ++e) {\n          const i = t.instancedDataOffset + e,\n            s = 16 * i,\n            o = r.instancedDataArray.float32;\n          let l = 0;\n          n && (l = o[s + 6] - r.instancesEvaluatedElevation[i]);\n          const f = 0 | o[s + 1];\n          o[s] = (0 | o[s]) + c.r / 1.05, o[s + 1] = f + c.g / 1.05, o[s + 2] = p, o[s + 3] = 1 / (a.z > 10 ? this.tileToMeter : Al(a, f)), o[s + 4] = u[0], o[s + 5] = u[1], o[s + 6] = u[2] + l, o[s + 7] = h[0], o[s + 8] = h[1], o[s + 9] = h[2], o[s + 10] = h[4], o[s + 11] = h[5], o[s + 12] = h[6], o[s + 13] = h[8], o[s + 14] = h[9], o[s + 15] = h[10], r.instancesEvaluatedElevation[i] = u[2];\n        }\n      }\n    }\n    let Ey, zy;\n    us(Py, \"ModelBucket\", {\n      omit: [\"layers\"]\n    }), us(Sy, \"PerModelAttributes\"), us(Iy, \"ModelFeature\");\n    const ky = 64,\n      Ty = {\n        CoordinateSpaceTile: 1,\n        CoordinateSpaceYUp: 2,\n        HasMapboxMeshFeatures: 4,\n        HasMeshoptCompression: 8\n      };\n    function By(t, e, r, n, i, s, a, o, l, u = !1) {\n      const c = r.zoom,\n        h = r.project(n),\n        p = wl(n.lat, c),\n        f = 1 / p;\n      O.mat4.identity(t), O.mat4.translate(t, t, [h.x + a[0] * f, h.y + a[1] * f, a[2]]);\n      let d = 1,\n        m = 1;\n      const y = r.worldSize;\n      if (u) {\n        if (\"mercator\" === r.projection.name) {\n          let t = 0;\n          r.elevation && (t = r.elevation.getAtPointOrZero(new Il(h.x / y, h.y / y), 0));\n          const e = O.vec4.transformMat4([], [h.x, h.y, t, 1], r.projMatrix)[3] / r.cameraToCenterDistance;\n          d = e, m = e * wl(r.center.lat, c);\n        } else if (\"globe\" === r.projection.name) {\n          const e = fy(t, r),\n            i = O.mat4.multiply([], r.projMatrix, e),\n            s = [0, 0, 0, 1];\n          O.vec4.transformMat4(s, s, i);\n          const a = s[3] / r.cameraToCenterDistance,\n            o = $u(c),\n            l = r.projection.pixelsPerMeter(n.lat, y) * wl(n.lat, c),\n            u = r.projection.pixelsPerMeter(r.center.lat, y) * wl(r.center.lat, c);\n          d = a / Ee(l, _l(r.center.lat), o), m = a * p / l, d *= u, m *= u;\n        }\n      } else d = f;\n      O.mat4.scale(t, t, [d, d, m]);\n      const g = [...t],\n        x = e.orientation,\n        v = [];\n      if (hy(v, [x[0] + i[0], x[1] + i[1], x[2] + i[2]], s), O.mat4.multiply(t, g, v), o && r.elevation) {\n        let i = 0;\n        const s = [];\n        if (l && r.elevation) {\n          i = function (t, e, r, n, i) {\n            const s = e.elevation;\n            if (!s) return 0;\n            const a = Au.projectAabbCorners(r, n),\n              o = yl(1, i.lat) * e.worldSize,\n              l = function (t, e) {\n                const r = [0, 0, 1],\n                  n = [{\n                    corners: [0, 1, 3, 2],\n                    dotProductWithUp: 0\n                  }, {\n                    corners: [1, 5, 2, 6],\n                    dotProductWithUp: 0\n                  }, {\n                    corners: [0, 4, 1, 5],\n                    dotProductWithUp: 0\n                  }, {\n                    corners: [2, 6, 3, 7],\n                    dotProductWithUp: 0\n                  }, {\n                    corners: [4, 7, 5, 6],\n                    dotProductWithUp: 0\n                  }, {\n                    corners: [0, 3, 4, 7],\n                    dotProductWithUp: 0\n                  }];\n                for (const i of n) {\n                  const n = t[i.corners[0]],\n                    s = t[i.corners[1]],\n                    a = t[i.corners[2]],\n                    o = [s[0] - n[0], s[1] - n[1], e * (s[2] - n[2])],\n                    l = O.vec3.cross(o, o, [a[0] - n[0], a[1] - n[1], e * (a[2] - n[2])]);\n                  O.vec3.normalize(l, l), i.dotProductWithUp = O.vec3.dot(l, r);\n                }\n                return n.sort((t, e) => t.dotProductWithUp - e.dotProductWithUp), n[0].corners;\n              }(a, o),\n              u = a[l[0]],\n              c = a[l[1]],\n              h = a[l[2]],\n              p = a[l[3]],\n              f = s.getAtPointOrZero(new Il(u[0] / e.worldSize, u[1] / e.worldSize), 0),\n              d = s.getAtPointOrZero(new Il(c[0] / e.worldSize, c[1] / e.worldSize), 0),\n              m = s.getAtPointOrZero(new Il(h[0] / e.worldSize, h[1] / e.worldSize), 0),\n              y = s.getAtPointOrZero(new Il(p[0] / e.worldSize, p[1] / e.worldSize), 0),\n              g = (f + y) / 2,\n              x = (d + m) / 2;\n            return g > x ? d < m ? py(t, c, p, u, d, y, f, o) : py(t, h, u, p, m, f, y, o) : f < y ? py(t, u, c, h, f, d, m, o) : py(t, p, h, c, y, m, d, o), Math.max(g, x);\n          }(s, r, e.aabb, t, n);\n          const a = O.mat4.fromQuat([], s),\n            o = O.mat4.multiply([], a, v);\n          O.mat4.multiply(t, g, o);\n        } else i = r.elevation.getAtPointOrZero(new Il(h.x / y, h.y / y), 0);\n        0 !== i && (t[14] += i);\n      }\n    }\n    function Vy(t, e, r = !1) {\n      t.uploaded || (t.gfxTexture = new qm(e, t.image, r ? e.gl.R8 : e.gl.RGBA8, {\n        useMipmap: t.sampler.minFilter >= e.gl.NEAREST_MIPMAP_NEAREST\n      }), t.uploaded = !0, t.image = null);\n    }\n    function Cy(t, e, r) {\n      t.indexBuffer = e.createIndexBuffer(t.indexArray, !1, !0), t.vertexBuffer = e.createVertexBuffer(t.vertexArray, my.members, !1, !0), t.normalArray && (t.normalBuffer = e.createVertexBuffer(t.normalArray, vy.members, !1, !0)), t.texcoordArray && (t.texcoordBuffer = e.createVertexBuffer(t.texcoordArray, xy.members, !1, !0)), t.colorArray && (t.colorBuffer = e.createVertexBuffer(t.colorArray, (12 === t.colorArray.bytesPerElement ? yy : gy).members, !1, !0)), t.featureArray && (t.pbrBuffer = e.createVertexBuffer(t.featureArray, _y.members, !0)), t.segments = xo.simpleSegment(0, 0, t.vertexArray.length, t.indexArray.length);\n      const n = t.material;\n      n.pbrMetallicRoughness.baseColorTexture && Vy(n.pbrMetallicRoughness.baseColorTexture, e), n.pbrMetallicRoughness.metallicRoughnessTexture && Vy(n.pbrMetallicRoughness.metallicRoughnessTexture, e), n.normalTexture && Vy(n.normalTexture, e), n.occlusionTexture && Vy(n.occlusionTexture, e, r), n.emissionTexture && Vy(n.emissionTexture, e);\n    }\n    function Dy(t, e, r) {\n      if (t.meshes) for (const n of t.meshes) Cy(n, e, r);\n      if (t.children) for (const n of t.children) Dy(n, e, r);\n    }\n    function Ry(t) {\n      if (t.meshes) for (const e of t.meshes) e.indexArray.destroy(), e.vertexArray.destroy(), e.colorArray && e.colorArray.destroy(), e.normalArray && e.normalArray.destroy(), e.texcoordArray && e.texcoordArray.destroy(), e.featureArray && e.featureArray.destroy();\n      if (t.children) for (const e of t.children) Ry(e);\n    }\n    function Ly(t) {\n      if (t.meshes) for (const r of t.meshes) r.vertexBuffer && (r.vertexBuffer.destroy(), r.indexBuffer.destroy(), r.normalBuffer && r.normalBuffer.destroy(), r.texcoordBuffer && r.texcoordBuffer.destroy(), r.colorBuffer && r.colorBuffer.destroy(), r.pbrBuffer && r.pbrBuffer.destroy(), r.segments.destroy(), r.material && ((e = r.material).pbrMetallicRoughness.baseColorTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture && e.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e.pbrMetallicRoughness.metallicRoughnessTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e.normalTexture && e.normalTexture.gfxTexture && e.normalTexture.gfxTexture.destroy(), e.emissionTexture && e.emissionTexture.gfxTexture && e.emissionTexture.gfxTexture.destroy(), e.occlusionTexture && e.occlusionTexture.gfxTexture && e.occlusionTexture.gfxTexture.destroy()));\n      var e;\n      if (t.children) for (const e of t.children) Ly(e);\n    }\n    class Fy {\n      constructor(t, e, r) {\n        this._demTile = t, this._dem = this._demTile.dem, this._scale = e, this._offset = r;\n      }\n      static create(t, e, r) {\n        const n = r || t.findDEMTileFor(e);\n        if (!n || !n.dem) return;\n        const i = n.dem,\n          s = n.tileID,\n          a = 1 << e.canonical.z - s.canonical.z;\n        return new Fy(n, i.dim / Kr / a, [(e.canonical.x / a - s.canonical.x) * i.dim, (e.canonical.y / a - s.canonical.y) * i.dim]);\n      }\n      tileCoordToPixel(t, e) {\n        const r = e * this._scale + this._offset[1],\n          n = Math.floor(t * this._scale + this._offset[0]),\n          i = Math.floor(r);\n        return new q(n, i);\n      }\n      getElevationAt(t, e, r, n) {\n        const i = t * this._scale + this._offset[0],\n          s = e * this._scale + this._offset[1],\n          a = Math.floor(i),\n          o = Math.floor(s),\n          l = this._dem;\n        return n = !!n, r ? Ee(Ee(l.get(a, o, n), l.get(a, o + 1, n), s - o), Ee(l.get(a + 1, o, n), l.get(a + 1, o + 1, n), s - o), i - a) : l.get(a, o, n);\n      }\n      getElevationAtPixel(t, e, r) {\n        return this._dem.get(t, e, !!r);\n      }\n      getMeterToDEM(t) {\n        return (1 << this._demTile.tileID.canonical.z) * yl(1, t) * this._dem.stride;\n      }\n    }\n    const Oy = new Float32Array(262144),\n      Ny = new Uint8Array(262144);\n    function Uy(t) {\n      let e = 0;\n      if (t.meshes) for (const r of t.meshes) e = Math.max(e, r.aabb.max[2]);\n      if (t.children) for (const r of t.children) e = Math.max(e, Uy(r));\n      return e;\n    }\n    function jy(t, e, r) {\n      if (t.meshes) for (const n of t.meshes) {\n        if (n.aabb.min[0] === 1 / 0) continue;\n        const i = Au.applyTransform(n.aabb, t.matrix);\n        r.insert(e, i.min[0], i.min[1], i.max[0], i.max[1]);\n      }\n      if (t.children) for (const n of t.children) jy(n, e, r);\n    }\n    const qy = [\"\", \"wall\", \"door\", \"roof\", \"window\", \"lamp\", \"logo\"];\n    class $y {\n      constructor(t) {\n        this.node = t, this.evaluatedRMEA = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [.4, 1, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]], this.hiddenByReplacement = !1, this.evaluatedScale = [1, 1, 1], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.cameraCollisionOpacity = 1, this.feature = {\n          type: \"Point\",\n          id: t.id,\n          geometry: [],\n          properties: {\n            height: Uy(t)\n          }\n        }, this.aabb = this._getLocalBounds(), this.state = null;\n      }\n      _getLocalBounds() {\n        if (!this.node.meshes) return new Au([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);\n        if (!this.aabb) {\n          let t = 0;\n          const e = new Au([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);\n          for (const r of this.node.meshes) this.node.lightMeshIndex !== t && (r.transformedAabb = Au.applyTransformFast(r.aabb, this.node.matrix), e.encapsulate(r.transformedAabb)), t++;\n          this.aabb = e;\n        }\n        return this.aabb;\n      }\n    }\n    class Gy {\n      constructor(t, e, r, n, i, s, a) {\n        this.id = r, this.layers = t, this.layerIds = this.layers.map(t => t.fqid), this.stateDependentLayerIds = this.layers.filter(t => t.isStateDependent()).map(t => t.id), this.modelTraits |= Ty.CoordinateSpaceTile, this.uploaded = !1, this.hasPattern = !1, n && (this.modelTraits |= Ty.HasMapboxMeshFeatures), i && (this.modelTraits |= Ty.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = {\n          name: \"mercator\"\n        }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = s, this.dirty = !0, this.needsUpload = !1, this.filter = null, this.nodesInfo = [];\n        for (const t of e) this.nodesInfo.push(new $y(t)), jy(t, a.featureIndexArray.length, a.grid), a.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, a.bucketLayerIDs.length - 1, 0);\n        this.states = {};\n      }\n      updateFootprints(t, e) {\n        for (const r of this.getNodesInfo()) {\n          const n = r.node;\n          n.footprint && e.push({\n            footprint: n.footprint,\n            id: t\n          });\n        }\n      }\n      update(t) {\n        const e = 0 !== Object.keys(t).length;\n        if (e && !this.stateDependentLayers.length) return;\n        const r = e ? this.stateDependentLayers : this.layers;\n        if (!$(t, this.states)) for (const e of r) this.evaluate(e, t);\n        this.states = structuredClone(t);\n      }\n      populate() {\n        console.log(\"populate 3D model bucket\");\n      }\n      uploadPending() {\n        return !this.uploaded || this.needsUpload;\n      }\n      upload(t) {\n        if (!this.needsUpload) return;\n        const e = this.getNodesInfo();\n        for (const r of e) {\n          const e = r.node;\n          this.uploaded ? this.updatePbrBuffer(e) : Dy(e, t, !0);\n        }\n        for (const t of e) Ry(t.node);\n        this.uploaded = !0, this.needsUpload = !1;\n      }\n      updatePbrBuffer(t) {\n        let e = !1;\n        if (!t.meshes) return e;\n        for (const r of t.meshes) r.pbrBuffer && (r.pbrBuffer.updateData(r.featureArray), e = !0);\n        return e;\n      }\n      needsReEvaluation(t, e, r) {\n        const n = t.transform.projectionOptions,\n          i = t.style.getBrightness(),\n          s = this.brightness !== i;\n        if (!this.uploaded || this.dirty || n.name !== this.projection.name || Yy(r.paint.get(\"model-color\").value, s) || Yy(r.paint.get(\"model-color-mix-intensity\").value, s) || Yy(r.paint.get(\"model-roughness\").value, s) || Yy(r.paint.get(\"model-emissive-strength\").value, s) || Yy(r.paint.get(\"model-height-based-emissive-strength-multiplier\").value, s)) {\n          this.projection = n, this.brightness = i;\n          const t = this.getNodesInfo();\n          for (const e of t) e.state = null;\n          return !0;\n        }\n        return !1;\n      }\n      evaluateScale(t, e) {\n        if (t.transform.zoom === this.zoom) return;\n        this.zoom = t.transform.zoom;\n        const r = this.getNodesInfo(),\n          n = this.id.canonical;\n        for (const t of r) {\n          const r = t.feature;\n          t.evaluatedScale = e.paint.get(\"model-scale\").evaluate(r, {}, n);\n        }\n      }\n      evaluate(t, e) {\n        const r = this.getNodesInfo();\n        for (const n of r) {\n          if (!n.node.meshes) continue;\n          const r = n.feature,\n            i = e && e[r.id];\n          if ($(i, n.state)) continue;\n          n.state = structuredClone(i);\n          const s = n.node.meshes && n.node.meshes[0].featureData,\n            a = n.evaluatedColor[2],\n            o = n.evaluatedRMEA[2],\n            l = this.id.canonical;\n          if (n.hasTranslucentParts = !1, s) {\n            for (let e = 0; e < qy.length; e++) {\n              const s = qy[e];\n              s.length && (r.properties.part = s);\n              const a = t.paint.get(\"model-color\").evaluate(r, i, l).toRenderColor(null),\n                o = t.paint.get(\"model-color-mix-intensity\").evaluate(r, i, l);\n              n.evaluatedColor[e] = [a.r, a.g, a.b, o], n.evaluatedRMEA[e][0] = t.paint.get(\"model-roughness\").evaluate(r, i, l), n.evaluatedRMEA[e][2] = t.paint.get(\"model-emissive-strength\").evaluate(r, i, l), n.evaluatedRMEA[e][3] = a.a, n.emissionHeightBasedParams[e] = t.paint.get(\"model-height-based-emissive-strength-multiplier\").evaluate(r, i, l), !n.hasTranslucentParts && a.a < 1 && (n.hasTranslucentParts = !0);\n            }\n            delete r.properties.part, Xy(n, a !== n.evaluatedColor[2] || o !== n.evaluatedRMEA[2], this.modelTraits);\n          } else n.evaluatedRMEA[0][2] = t.paint.get(\"model-emissive-strength\").evaluate(r, i, l);\n          n.evaluatedScale = t.paint.get(\"model-scale\").evaluate(r, i, l), this.updatePbrBuffer(n.node) || (this.needsUpload = !0);\n        }\n        this.dirty = !1;\n      }\n      elevationUpdate(t, e, r, n) {\n        const i = t.findDEMTileFor(r);\n        if (i && (i.tileID.canonical !== this.terrainTile || e !== this.terrainExaggeration)) {\n          if (i.dem && i.tileID.overscaledZ !== this.elevationReadFromZ) {\n            this.elevationReadFromZ = i.tileID.overscaledZ;\n            const e = Fy.create(t, r, i);\n            if (!e) return;\n            this.modelTraits & Ty.HasMapboxMeshFeatures && this.updateDEM(t, e, r, n);\n            for (const t of this.getNodesInfo()) {\n              const r = t.node;\n              if (!r.footprint || !r.footprint.vertices || !r.footprint.vertices.length) continue;\n              const n = r.footprint.vertices;\n              let i = e.getElevationAt(n[0].x, n[0].y, !0, !0);\n              for (let t = 1; t < n.length; t++) i = Math.min(i, e.getElevationAt(n[t].x, n[t].y, !0, !0));\n              r.elevation = i;\n            }\n          }\n          this.terrainTile = i.tileID.canonical, this.terrainExaggeration = e;\n        }\n      }\n      updateDEM(t, e, r, n) {\n        let i = e._dem._modifiedForSources[n];\n        if (void 0 === i && (e._dem._modifiedForSources[n] = [], i = e._dem._modifiedForSources[n]), i.includes(r.canonical)) return;\n        const s = e._dem.dim;\n        i.push(r.canonical);\n        let a = !1;\n        for (const t of this.getNodesInfo()) {\n          const r = t.node;\n          if (!r.footprint || !r.footprint.grid) continue;\n          const n = r.footprint.grid,\n            i = e.tileCoordToPixel(n.min.x, n.min.y),\n            o = e.tileCoordToPixel(n.max.x, n.max.y),\n            l = Math.min(Math.min(s - o.y, i.x), Math.min(i.y, s - o.x));\n          if (l < 0) continue;\n          const u = Q(l, 2, 5);\n          let c = Math.max(0, i.x - u),\n            h = Math.max(0, i.y - u),\n            p = Math.min(o.x + u, s - 1),\n            f = Math.min(o.y + u, s - 1);\n          for (let t = h; t <= f; ++t) for (let e = c; e <= p; ++e) Ny[t * s + e] = 255;\n          let d = 0,\n            m = 0;\n          for (let t = 0; t < n.cellsY; ++t) for (let r = 0; r < n.cellsX; ++r) {\n            if (!n.cells[t * n.cellsX + r]) continue;\n            const i = e.tileCoordToPixel(n.min.x + r / n.xScale, n.min.y + t / n.yScale),\n              a = e.tileCoordToPixel(n.min.x + (r + 1) / n.xScale, n.min.y + (t + 1) / n.yScale);\n            for (let t = i.y; t <= Math.min(a.y + 1, s - 1); ++t) for (let r = i.x; r <= Math.min(a.x + 1, s - 1); ++r) 255 === Ny[t * s + r] && (Ny[t * s + r] = 0, d += e.getElevationAtPixel(r, t), m++);\n          }\n          const y = d / m;\n          c = Math.max(1, i.x - u), h = Math.max(1, i.y - u), p = Math.min(o.x + u, s - 2), f = Math.min(o.y + u, s - 2), a = !0;\n          for (let t = h; t <= f; ++t) for (let r = c; r <= p; ++r) 0 === Ny[t * s + r] && (Oy[t * s + r] = e._dem.set(r, t, y));\n          for (let t = 1; t < u; ++t) {\n            c = Math.max(1, i.x - t), h = Math.max(1, i.y - t), p = Math.min(o.x + t, s - 2), f = Math.min(o.y + t, s - 2);\n            for (let r = h; r <= f; ++r) for (let n = c; n <= p; ++n) {\n              const i = r * s + n;\n              if (255 === Ny[i]) {\n                let a = 0,\n                  o = 0,\n                  l = -1,\n                  c = -1;\n                for (let e = -1; e <= 1; ++e) for (let i = -1; i <= 1; ++i) {\n                  const u = (r + e) * s + n + i;\n                  if (Ny[u] >= t) continue;\n                  const h = Oy[u],\n                    p = Math.abs(h);\n                  p > o && (a = h, o = p, l = i, c = e);\n                }\n                if (o > .1) {\n                  const s = 1 - (t + .5 * Math.abs(l * c)) / u;\n                  let o = e._dem.get(n, r) + a * s;\n                  const h = e._dem.get(n + l, r + c),\n                    p = e._dem.get(n - l, r - c, !0);\n                  (o - h) * (o - p) > 0 && (o = (h + p) / 2), Oy[i] = e._dem.set(n, r, o), Ny[i] = t;\n                }\n              }\n            }\n          }\n        }\n        a && (e._demTile.needsDEMTextureUpload = !0, e._dem._timestamp = Ct.now());\n      }\n      setFilter(t) {\n        this.filter = t ? Qs(t) : null;\n      }\n      getNodesInfo() {\n        return this.filter ? this.nodesInfo.filter(t => this.filter.filter(new Rs(this.id.overscaledZ), t.feature, this.id.canonical)) : this.nodesInfo;\n      }\n      destroy() {\n        const t = this.getNodesInfo();\n        for (const e of t) Ry(e.node), Ly(e.node);\n      }\n      isEmpty() {\n        return !this.nodesInfo.length;\n      }\n      updateReplacement(t, e) {\n        if (e.updateTime === this.replacementUpdateTime) return;\n        this.replacementUpdateTime = e.updateTime;\n        const r = e.getReplacementRegionsForTile(t.toUnwrapped()),\n          n = this.getNodesInfo();\n        for (let t = 0; t < this.nodesInfo.length; t++) {\n          const e = n[t].node;\n          n[t].hiddenByReplacement = !!e.footprint && !r.find(t => t.footprint === e.footprint);\n        }\n      }\n      getHeightAtTileCoord(t, e) {\n        const r = this.getNodesInfo(),\n          n = [],\n          i = [0, 0, 0],\n          s = O.mat4.identity([]);\n        for (let a = 0; a < this.nodesInfo.length; a++) {\n          const o = r[a],\n            l = o.node.meshes[0],\n            u = l.transformedAabb;\n          if (t < u.min[0] || e < u.min[1] || t > u.max[0] || e > u.max[1]) continue;\n          if (!0 === o.node.hidden) return {\n            height: 1 / 0,\n            maxHeight: o.feature.properties.height,\n            hidden: !1,\n            verticalScale: o.evaluatedScale[2]\n          };\n          O.mat4.invert(s, o.node.matrix), i[0] = t, i[1] = e, O.vec3.transformMat4(i, i, s);\n          const c = (i[0] - l.aabb.min[0]) / (l.aabb.max[0] - l.aabb.min[0]) * ky | 0,\n            h = Math.min(63, (i[1] - l.aabb.min[1]) / (l.aabb.max[1] - l.aabb.min[1]) * ky | 0) * ky + Math.min(63, c),\n            p = l.heightmap[h];\n          if (!(p < 0 && o.node.footprint)) {\n            if (o.hiddenByReplacement) return;\n            return {\n              height: p,\n              maxHeight: o.feature.properties.height,\n              hidden: !1,\n              verticalScale: o.evaluatedScale[2]\n            };\n          }\n          if (o.node.footprint.grid.query(new q(t, e), new q(t, e), n), n.length > 0) return {\n            height: void 0,\n            maxHeight: o.feature.properties.height,\n            hidden: o.hiddenByReplacement,\n            verticalScale: o.evaluatedScale[2]\n          };\n        }\n      }\n    }\n    function Yy(t, e) {\n      return !t.isLightConstant && e;\n    }\n    function Hy(t, e, r, n, i, s, a, o) {\n      let l = (61440 & e | (61440 & e) >> 4) >> 8,\n        u = (3840 & e | (3840 & e) >> 4) >> 4,\n        c = 240 & e | (240 & e) >> 4;\n      r[3] > 0 && (l = Ee(l, 255 * r[0], r[3]), u = Ee(u, 255 * r[1], r[3]), c = Ee(c, 255 * r[2], r[3]));\n      const h = l << 8 | u,\n        p = c << 8 | Math.floor(255 * n[3]),\n        f = function (t) {\n          const e = Q(t, 0, 2);\n          return Math.min(Math.round(.5 * e * 255), 255);\n        }(n[2]) << 8 | 15 * n[0] << 4 | 15 * n[1],\n        d = Q(i[0], 0, 1),\n        m = Q(i[1], 0, 1),\n        y = Q(i[2], 0, 1),\n        g = Q(i[3], 0, 1);\n      let x, v, b, _;\n      if (d !== m && a !== s && m !== d) {\n        const t = a - s;\n        v = 1 / (t * (m - d)), b = -(s + t * d) / (t * (m - d));\n        const e = Q(i[4], -1, 1);\n        _ = Math.pow(10, e), x = 255 * y << 8 | 255 * g;\n      } else x = 65535, v = 0, b = 1, _ = 1;\n      if (t.emplaceBack(h, p, f, x, v, b, _), o) {\n        const t = o.length;\n        o.clear();\n        for (let e = 0; e < t; e++) o.emplaceBack(h, p, f, x, v, b, _);\n      }\n    }\n    function Xy(t, e, r) {\n      const n = t.node;\n      let i = 0;\n      const s = r & Ty.HasMeshoptCompression;\n      for (const r of n.meshes) {\n        if (n.lights && n.lightMeshIndex === i) continue;\n        if (!r.featureData) continue;\n        r.featureArray = new Qa(), r.featureArray.reserve(r.featureData.length);\n        let a = e;\n        for (const e of r.featureData) {\n          const i = s ? 65535 & e : e >> 16 & 65535,\n            o = s ? e >> 16 & 65535 : 65535 & e,\n            l = (15 & o) < 8 ? 15 & o : 0,\n            u = t.evaluatedRMEA[l],\n            c = t.evaluatedColor[l],\n            h = t.emissionHeightBasedParams[l];\n          let p;\n          if (a && 2 === l && n.lights && (p = new Qa(), p.resize(10 * n.lights.length)), Hy(r.featureArray, i, c, u, h, r.aabb.min[2], r.aabb.max[2], p), p && a) {\n            a = !1;\n            const t = n.meshes[n.lightMeshIndex];\n            t.featureArray = p, t.featureArray._trim();\n          }\n        }\n        r.featureArray._trim(), i++;\n      }\n    }\n    function Zy(t, e, r, n) {\n      const i = 1 << t.z;\n      e.lat = xl((n / Kr + t.y) / i), e.lng = gl((r / Kr + t.x) / i);\n    }\n    us(Gy, \"Tiled3dModelBucket\", {\n      omit: [\"layers\"]\n    }), us($y, \"Tiled3dModelFeature\");\n    const Wy = {\n      circle: class extends ma {\n        constructor(t, e, r, n) {\n          super(t, {\n            layout: ru || (ru = new Xs({\n              \"circle-sort-key\": new Ys(Zs.layout_circle[\"circle-sort-key\"]),\n              \"circle-elevation-reference\": new Gs(Zs.layout_circle[\"circle-elevation-reference\"]),\n              visibility: new Gs(Zs.layout_circle.visibility)\n            })),\n            paint: nu || (nu = new Xs({\n              \"circle-radius\": new Ys(Zs.paint_circle[\"circle-radius\"]),\n              \"circle-color\": new Ys(Zs.paint_circle[\"circle-color\"]),\n              \"circle-blur\": new Ys(Zs.paint_circle[\"circle-blur\"]),\n              \"circle-opacity\": new Ys(Zs.paint_circle[\"circle-opacity\"]),\n              \"circle-translate\": new Gs(Zs.paint_circle[\"circle-translate\"]),\n              \"circle-translate-anchor\": new Gs(Zs.paint_circle[\"circle-translate-anchor\"]),\n              \"circle-pitch-scale\": new Gs(Zs.paint_circle[\"circle-pitch-scale\"]),\n              \"circle-pitch-alignment\": new Gs(Zs.paint_circle[\"circle-pitch-alignment\"]),\n              \"circle-stroke-width\": new Ys(Zs.paint_circle[\"circle-stroke-width\"]),\n              \"circle-stroke-color\": new Ys(Zs.paint_circle[\"circle-stroke-color\"]),\n              \"circle-stroke-opacity\": new Ys(Zs.paint_circle[\"circle-stroke-opacity\"]),\n              \"circle-emissive-strength\": new Gs(Zs.paint_circle[\"circle-emissive-strength\"]),\n              \"circle-color-use-theme\": new Ys({\n                type: \"string\",\n                default: \"default\",\n                \"property-type\": \"data-driven\"\n              }),\n              \"circle-stroke-color-use-theme\": new Ys({\n                type: \"string\",\n                default: \"default\",\n                \"property-type\": \"data-driven\"\n              })\n            }))\n          }, e, r, n);\n        }\n        createBucket(t) {\n          return new Ll(t);\n        }\n        queryRadius(t) {\n          const e = t;\n          return Jl(\"circle-radius\", this, e) + Jl(\"circle-stroke-width\", this, e) + Ql(this.paint.get(\"circle-translate\"));\n        }\n        queryIntersectsFeature(t, e, r, n, i, s, a, o) {\n          const l = eu(this.paint.get(\"circle-translate\"), this.paint.get(\"circle-translate-anchor\"), s.angle, t.pixelToTileUnitsFactor),\n            u = this.paint.get(\"circle-radius\").evaluate(e, r) + this.paint.get(\"circle-stroke-width\").evaluate(e, r);\n          return Ju(t, n, s, a, o, \"map\" === this.paint.get(\"circle-pitch-alignment\"), \"map\" === this.paint.get(\"circle-pitch-scale\"), l, u);\n        }\n        getProgramIds() {\n          return [\"circle\"];\n        }\n        getDefaultProgramParams(t, e, r) {\n          const n = Ku(this);\n          return {\n            config: new $o(this, {\n              zoom: e,\n              lut: r\n            }),\n            defines: n,\n            overrideFog: !1\n          };\n        }\n      },\n      heatmap: class extends ma {\n        createBucket(t) {\n          return new nc(t);\n        }\n        constructor(t, e, r, n) {\n          super(t, {\n            layout: ic || (ic = new Xs({\n              visibility: new Gs(Zs.layout_heatmap.visibility)\n            })),\n            paint: sc || (sc = new Xs({\n              \"heatmap-radius\": new Ys(Zs.paint_heatmap[\"heatmap-radius\"]),\n              \"heatmap-weight\": new Ys(Zs.paint_heatmap[\"heatmap-weight\"]),\n              \"heatmap-intensity\": new Gs(Zs.paint_heatmap[\"heatmap-intensity\"]),\n              \"heatmap-color\": new Hs(Zs.paint_heatmap[\"heatmap-color\"]),\n              \"heatmap-opacity\": new Gs(Zs.paint_heatmap[\"heatmap-opacity\"]),\n              \"heatmap-color-use-theme\": new Ys({\n                type: \"string\",\n                default: \"default\",\n                \"property-type\": \"data-driven\"\n              })\n            }))\n          }, e, r, n), this._updateColorRamp();\n        }\n        _handleSpecialPaintPropertyUpdate(t) {\n          \"heatmap-color\" === t && this._updateColorRamp();\n        }\n        _updateColorRamp() {\n          this.colorRamp = dc({\n            expression: this._transitionablePaint._values[\"heatmap-color\"].value.expression,\n            evaluationKey: \"heatmapDensity\",\n            image: this.colorRamp\n          }), this.colorRampTexture = null;\n        }\n        resize() {\n          this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);\n        }\n        queryRadius(t) {\n          return Jl(\"heatmap-radius\", this, t);\n        }\n        queryIntersectsFeature(t, e, r, n, i, s, a, o) {\n          const l = this.paint.get(\"heatmap-radius\").evaluate(e, r);\n          return Ju(t, n, s, a, o, !0, !0, new q(0, 0), l);\n        }\n        hasOffscreenPass() {\n          return 0 !== this.paint.get(\"heatmap-opacity\") && \"none\" !== this.visibility;\n        }\n        getProgramIds() {\n          return [\"heatmap\", \"heatmapTexture\"];\n        }\n        getDefaultProgramParams(t, e, r) {\n          return \"heatmap\" === t ? {\n            config: new $o(this, {\n              zoom: e,\n              lut: r\n            }),\n            overrideFog: !1\n          } : {};\n        }\n      },\n      hillshade: class extends ma {\n        constructor(t, e, r, n) {\n          super(t, {\n            layout: ac || (ac = new Xs({\n              visibility: new Gs(Zs.layout_hillshade.visibility)\n            })),\n            paint: oc || (oc = new Xs({\n              \"hillshade-illumination-direction\": new Gs(Zs.paint_hillshade[\"hillshade-illumination-direction\"]),\n              \"hillshade-illumination-anchor\": new Gs(Zs.paint_hillshade[\"hillshade-illumination-anchor\"]),\n              \"hillshade-exaggeration\": new Gs(Zs.paint_hillshade[\"hillshade-exaggeration\"]),\n              \"hillshade-shadow-color\": new Gs(Zs.paint_hillshade[\"hillshade-shadow-color\"]),\n              \"hillshade-highlight-color\": new Gs(Zs.paint_hillshade[\"hillshade-highlight-color\"]),\n              \"hillshade-accent-color\": new Gs(Zs.paint_hillshade[\"hillshade-accent-color\"]),\n              \"hillshade-emissive-strength\": new Gs(Zs.paint_hillshade[\"hillshade-emissive-strength\"]),\n              \"hillshade-shadow-color-use-theme\": new Ys({\n                type: \"string\",\n                default: \"default\",\n                \"property-type\": \"data-driven\"\n              }),\n              \"hillshade-highlight-color-use-theme\": new Ys({\n                type: \"string\",\n                default: \"default\",\n                \"property-type\": \"data-driven\"\n              }),\n              \"hillshade-accent-color-use-theme\": new Ys({\n                type: \"string\",\n                default: \"default\",\n                \"property-type\": \"data-driven\"\n              })\n            }))\n          }, e, r, n);\n        }\n        shouldRedrape() {\n          return this.hasOffscreenPass() && \"viewport\" === this.paint.get(\"hillshade-illumination-anchor\");\n        }\n        hasOffscreenPass() {\n          return 0 !== this.paint.get(\"hillshade-exaggeration\") && \"none\" !== this.visibility;\n        }\n        getProgramIds() {\n          return [\"hillshade\", \"hillshadePrepare\"];\n        }\n        getDefaultProgramParams(t, e, r) {\n          return {\n            overrideFog: !1\n          };\n        }\n      },\n      fill: class extends ma {\n        constructor(t, e, r, n) {\n          super(t, {\n            layout: wh || (wh = new Xs({\n              \"fill-sort-key\": new Ys(Zs.layout_fill[\"fill-sort-key\"]),\n              visibility: new Gs(Zs.layout_fill.visibility),\n              \"fill-elevation-reference\": new Gs(Zs.layout_fill[\"fill-elevation-reference\"]),\n              \"fill-construct-bridge-guard-rail\": new Ys(Zs.layout_fill[\"fill-construct-bridge-guard-rail\"])\n            })),\n            paint: Mh || (Mh = new Xs({\n              \"fill-antialias\": new Gs(Zs.paint_fill[\"fill-antialias\"]),\n              \"fill-opacity\": new Ys(Zs.paint_fill[\"fill-opacity\"]),\n              \"fill-color\": new Ys(Zs.paint_fill[\"fill-color\"]),\n              \"fill-outline-color\": new Ys(Zs.paint_fill[\"fill-outline-color\"]),\n              \"fill-translate\": new Gs(Zs.paint_fill[\"fill-translate\"]),\n              \"fill-translate-anchor\": new Gs(Zs.paint_fill[\"fill-translate-anchor\"]),\n              \"fill-pattern\": new Ys(Zs.paint_fill[\"fill-pattern\"]),\n              \"fill-emissive-strength\": new Gs(Zs.paint_fill[\"fill-emissive-strength\"]),\n              \"fill-z-offset\": new Ys(Zs.paint_fill[\"fill-z-offset\"]),\n              \"fill-bridge-guard-rail-color\": new Ys(Zs.paint_fill[\"fill-bridge-guard-rail-color\"]),\n              \"fill-tunnel-structure-color\": new Ys(Zs.paint_fill[\"fill-tunnel-structure-color\"]),\n              \"fill-color-use-theme\": new Ys({\n                type: \"string\",\n                default: \"default\",\n                \"property-type\": \"data-driven\"\n              }),\n              \"fill-outline-color-use-theme\": new Ys({\n                type: \"string\",\n                default: \"default\",\n                \"property-type\": \"data-driven\"\n              }),\n              \"fill-bridge-guard-rail-color-use-theme\": new Ys({\n                type: \"string\",\n                default: \"default\",\n                \"property-type\": \"data-driven\"\n              }),\n              \"fill-tunnel-structure-color-use-theme\": new Ys({\n                type: \"string\",\n                default: \"default\",\n                \"property-type\": \"data-driven\"\n              })\n            }))\n          }, e, r, n);\n        }\n        getProgramIds() {\n          const t = this.paint.get(\"fill-pattern\"),\n            e = t && t.constantOr(1),\n            r = [e ? \"fillPattern\" : \"fill\"];\n          return this.paint.get(\"fill-antialias\") && r.push(e && !this.getPaintProperty(\"fill-outline-color\") ? \"fillOutlinePattern\" : \"fillOutline\"), r;\n        }\n        getDefaultProgramParams(t, e, r) {\n          return {\n            config: new $o(this, {\n              zoom: e,\n              lut: r\n            }),\n            overrideFog: !1\n          };\n        }\n        recalculate(t, e) {\n          super.recalculate(t, e);\n          const r = this.paint._values[\"fill-outline-color\"];\n          \"constant\" === r.value.kind && void 0 === r.value.value && (this.paint._values[\"fill-outline-color\"] = this.paint._values[\"fill-color\"]);\n        }\n        createBucket(t) {\n          return new _h(t);\n        }\n        queryRadius() {\n          return Ql(this.paint.get(\"fill-translate\"));\n        }\n        queryIntersectsFeature(t, e, r, n, i, s) {\n          return !t.queryGeometry.isAboveHorizon && Nl(tu(t.tilespaceGeometry, this.paint.get(\"fill-translate\"), this.paint.get(\"fill-translate-anchor\"), s.angle, t.pixelToTileUnitsFactor), n);\n        }\n        isTileClipped() {\n          return 0 === this.paint.get(\"fill-z-offset\").constantOr(1);\n        }\n        is3D(t) {\n          if (0 !== this.paint.get(\"fill-z-offset\").constantOr(1)) return !0;\n          const e = this.layout && \"none\" !== this.layout.get(\"fill-elevation-reference\");\n          return null != t ? e && !t : e;\n        }\n      },\n      \"fill-extrusion\": class extends ma {\n        constructor(t, e, r, n) {\n          super(t, {\n            layout: kp || (kp = new Xs({\n              visibility: new Gs(Zs[\"layout_fill-extrusion\"].visibility),\n              \"fill-extrusion-edge-radius\": new Gs(Zs[\"layout_fill-extrusion\"][\"fill-extrusion-edge-radius\"])\n            })),\n            paint: Tp || (Tp = new Xs({\n              \"fill-extrusion-opacity\": new Gs(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-opacity\"]),\n              \"fill-extrusion-color\": new Ys(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-color\"]),\n              \"fill-extrusion-translate\": new Gs(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-translate\"]),\n              \"fill-extrusion-translate-anchor\": new Gs(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-translate-anchor\"]),\n              \"fill-extrusion-pattern\": new Ys(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-pattern\"]),\n              \"fill-extrusion-height\": new Ys(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-height\"]),\n              \"fill-extrusion-base\": new Ys(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-base\"]),\n              \"fill-extrusion-height-alignment\": new Gs(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-height-alignment\"]),\n              \"fill-extrusion-base-alignment\": new Gs(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-base-alignment\"]),\n              \"fill-extrusion-vertical-gradient\": new Gs(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-vertical-gradient\"]),\n              \"fill-extrusion-ambient-occlusion-intensity\": new Gs(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-ambient-occlusion-intensity\"]),\n              \"fill-extrusion-ambient-occlusion-radius\": new Gs(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-ambient-occlusion-radius\"]),\n              \"fill-extrusion-ambient-occlusion-wall-radius\": new Gs(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-ambient-occlusion-wall-radius\"]),\n              \"fill-extrusion-ambient-occlusion-ground-radius\": new Gs(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-ambient-occlusion-ground-radius\"]),\n              \"fill-extrusion-ambient-occlusion-ground-attenuation\": new Gs(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-ambient-occlusion-ground-attenuation\"]),\n              \"fill-extrusion-flood-light-color\": new Gs(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-flood-light-color\"]),\n              \"fill-extrusion-flood-light-intensity\": new Gs(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-flood-light-intensity\"]),\n              \"fill-extrusion-flood-light-wall-radius\": new Ys(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-flood-light-wall-radius\"]),\n              \"fill-extrusion-flood-light-ground-radius\": new Ys(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-flood-light-ground-radius\"]),\n              \"fill-extrusion-flood-light-ground-attenuation\": new Gs(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-flood-light-ground-attenuation\"]),\n              \"fill-extrusion-vertical-scale\": new Gs(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-vertical-scale\"]),\n              \"fill-extrusion-rounded-roof\": new Gs(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-rounded-roof\"]),\n              \"fill-extrusion-cutoff-fade-range\": new Gs(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-cutoff-fade-range\"]),\n              \"fill-extrusion-emissive-strength\": new Ys(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-emissive-strength\"]),\n              \"fill-extrusion-line-width\": new Ys(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-line-width\"]),\n              \"fill-extrusion-cast-shadows\": new Gs(Zs[\"paint_fill-extrusion\"][\"fill-extrusion-cast-shadows\"]),\n              \"fill-extrusion-color-use-theme\": new Ys({\n                type: \"string\",\n                default: \"default\",\n                \"property-type\": \"data-driven\"\n              }),\n              \"fill-extrusion-flood-light-color-use-theme\": new Ys({\n                type: \"string\",\n                default: \"default\",\n                \"property-type\": \"data-driven\"\n              })\n            }))\n          }, e, r, n), this._stats = {\n            numRenderedVerticesInShadowPass: 0,\n            numRenderedVerticesInTransparentPass: 0\n          };\n        }\n        createBucket(t) {\n          return new vp(t);\n        }\n        queryRadius() {\n          return Ql(this.paint.get(\"fill-extrusion-translate\"));\n        }\n        is3D(t) {\n          return !0;\n        }\n        hasShadowPass() {\n          return this.paint.get(\"fill-extrusion-cast-shadows\");\n        }\n        cutoffRange() {\n          return this.paint.get(\"fill-extrusion-cutoff-fade-range\");\n        }\n        canCastShadows() {\n          return !0;\n        }\n        getProgramIds() {\n          return [this.paint.get(\"fill-extrusion-pattern\").constantOr(1) ? \"fillExtrusionPattern\" : \"fillExtrusion\"];\n        }\n        queryIntersectsFeature(t, e, r, n, i, s, a, o, l) {\n          const u = eu(this.paint.get(\"fill-extrusion-translate\"), this.paint.get(\"fill-extrusion-translate-anchor\"), s.angle, t.pixelToTileUnitsFactor),\n            c = this.paint.get(\"fill-extrusion-height\").evaluate(e, r),\n            h = this.paint.get(\"fill-extrusion-base\").evaluate(e, r),\n            p = [0, 0],\n            f = o && s.elevation,\n            d = s.elevation ? s.elevation.exaggeration() : 1,\n            m = t.tile.getBucket(this);\n          if (f && m instanceof vp) {\n            const t = m.centroidVertexArray,\n              e = l + 1;\n            e < t.length && (p[0] = t.geta_centroid_pos0(e), p[1] = t.geta_centroid_pos1(e));\n          }\n          if (0 === p[0] && 1 === p[1]) return !1;\n          \"globe\" === s.projection.name && (n = Ep([n], [new q(0, 0), new q(Kr, Kr)], t.tileID.canonical).map(t => t.polygon).flat());\n          const y = f ? o : null,\n            [g, x] = function (t, e, r, n, i, s, a, o, l, u, c) {\n              return \"globe\" === t.projection.name ? function (t, e, r, n, i, s, a, o, l, u, c) {\n                const h = [],\n                  p = [],\n                  f = t.projection.upVectorScale(c, t.center.lat, t.worldSize).metersToTile,\n                  d = [0, 0, 0, 1],\n                  m = [0, 0, 0, 1],\n                  y = (t, e, r, n) => {\n                    t[0] = e, t[1] = r, t[2] = n, t[3] = 1;\n                  },\n                  g = Pp();\n                r > 0 && (r += g), n += g;\n                for (const g of e) {\n                  const e = [],\n                    x = [];\n                  for (const h of g) {\n                    const p = h.x + i.x,\n                      g = h.y + i.y,\n                      v = t.projection.projectTilePoint(p, g, c),\n                      b = t.projection.upVector(c, h.x, h.y);\n                    let _ = r,\n                      w = n;\n                    if (a) {\n                      const t = Cp(p, g, r, n, a, o, l, u);\n                      _ += t.base, w += t.top;\n                    }\n                    0 !== r ? y(d, v.x + b[0] * f * _, v.y + b[1] * f * _, v.z + b[2] * f * _) : y(d, v.x, v.y, v.z), y(m, v.x + b[0] * f * w, v.y + b[1] * f * w, v.z + b[2] * f * w), O.vec3.transformMat4(d, d, s), O.vec3.transformMat4(m, m, s), e.push(new Rh(d[0], d[1], d[2])), x.push(new Rh(m[0], m[1], m[2]));\n                  }\n                  h.push(e), p.push(x);\n                }\n                return [h, p];\n              }(t, e, r, n, i, s, a, o, l, u, c) : a ? function (t, e, r, n, i, s, a, o, l) {\n                const u = [],\n                  c = [],\n                  h = [0, 0, 0, 1];\n                for (const p of t) {\n                  const t = [],\n                    f = [];\n                  for (const u of p) {\n                    const c = u.x + n.x,\n                      p = u.y + n.y,\n                      d = Cp(c, p, e, r, s, a, o, l);\n                    h[0] = c, h[1] = p, h[2] = d.base, h[3] = 1, O.vec4.transformMat4(h, h, i), h[3] = Math.max(h[3], 1e-5);\n                    const m = new Rh(h[0] / h[3], h[1] / h[3], h[2] / h[3]);\n                    h[0] = c, h[1] = p, h[2] = d.top, h[3] = 1, O.vec4.transformMat4(h, h, i), h[3] = Math.max(h[3], 1e-5);\n                    const y = new Rh(h[0] / h[3], h[1] / h[3], h[2] / h[3]);\n                    t.push(m), f.push(y);\n                  }\n                  u.push(t), c.push(f);\n                }\n                return [u, c];\n              }(e, r, n, i, s, a, o, l, u) : function (t, e, r, n, i) {\n                const s = [],\n                  a = [],\n                  o = i[8] * e,\n                  l = i[9] * e,\n                  u = i[10] * e,\n                  c = i[11] * e,\n                  h = i[8] * r,\n                  p = i[9] * r,\n                  f = i[10] * r,\n                  d = i[11] * r;\n                for (const e of t) {\n                  const t = [],\n                    r = [];\n                  for (const s of e) {\n                    const e = s.x + n.x,\n                      a = s.y + n.y,\n                      m = i[0] * e + i[4] * a + i[12],\n                      y = i[1] * e + i[5] * a + i[13],\n                      g = i[2] * e + i[6] * a + i[14],\n                      x = i[3] * e + i[7] * a + i[15],\n                      v = m + o,\n                      b = y + l,\n                      _ = g + u,\n                      w = Math.max(x + c, 1e-5),\n                      M = m + h,\n                      A = y + p,\n                      I = g + f,\n                      S = Math.max(x + d, 1e-5);\n                    t.push(new Rh(v / w, b / w, _ / w)), r.push(new Rh(M / S, A / S, I / S));\n                  }\n                  s.push(t), a.push(r);\n                }\n                return [s, a];\n              }(e, r, n, i, s);\n            }(s, n, h, c, u, a, y, p, d, s.center.lat, t.tileID.canonical),\n            v = t.queryGeometry;\n          return function (t, e, r) {\n            let n = 1 / 0;\n            Nl(r, e) && (n = Vp(r, e[0]));\n            for (let i = 0; i < e.length; i++) {\n              const s = e[i],\n                a = t[i];\n              for (let t = 0; t < s.length - 1; t++) {\n                const e = s[t],\n                  i = [e, s[t + 1], a[t + 1], a[t], e];\n                Fl(r, i) && (n = Math.min(n, Vp(r, i)));\n              }\n            }\n            return n !== 1 / 0 && n;\n          }(g, x, v.isPointQuery() ? v.screenBounds : v.screenGeometry);\n        }\n      },\n      line: class extends ma {\n        constructor(t, e, r, n) {\n          const i = nf();\n          super(t, i, e, r, n), i.layout && (this.layout = new $s(i.layout)), this.gradientVersion = 0, this.hasElevatedBuckets = !1, this.hasNonElevatedBuckets = !1;\n        }\n        _handleSpecialPaintPropertyUpdate(t) {\n          if (\"line-gradient\" === t) {\n            const t = this._transitionablePaint._values[\"line-gradient\"].value.expression;\n            this.stepInterpolant = t._styleExpression && t._styleExpression.expression instanceof Un, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;\n          }\n        }\n        gradientExpression() {\n          return this._transitionablePaint._values[\"line-gradient\"].value.expression;\n        }\n        widthExpression() {\n          return this._transitionablePaint._values[\"line-width\"].value.expression;\n        }\n        recalculate(t, e) {\n          super.recalculate(t, e), this.paint._values[\"line-floorwidth\"] = (() => {\n            if (af) return af;\n            const t = nf();\n            return af = new sf(t.paint.properties[\"line-width\"].specification), af.useIntegerZoom = !0, af;\n          })().possiblyEvaluate(this._transitioningPaint._values[\"line-width\"].value, t);\n        }\n        createBucket(t) {\n          return new Yp(t);\n        }\n        getProgramIds() {\n          return [this.paint.get(\"line-pattern\").constantOr(1) ? \"linePattern\" : \"line\"];\n        }\n        getDefaultProgramParams(t, e, r) {\n          const n = tf(this);\n          return {\n            config: new $o(this, {\n              zoom: e,\n              lut: r\n            }),\n            defines: n,\n            overrideFog: !1\n          };\n        }\n        queryRadius(t) {\n          const e = t,\n            r = of(Jl(\"line-width\", this, e), Jl(\"line-gap-width\", this, e)),\n            n = Jl(\"line-offset\", this, e);\n          return r / 2 + Math.abs(n) + Ql(this.paint.get(\"line-translate\"));\n        }\n        queryIntersectsFeature(t, e, r, n, i, s) {\n          if (t.queryGeometry.isAboveHorizon) return !1;\n          const a = tu(t.tilespaceGeometry, this.paint.get(\"line-translate\"), this.paint.get(\"line-translate-anchor\"), s.angle, t.pixelToTileUnitsFactor),\n            o = t.pixelToTileUnitsFactor / 2 * of(this.paint.get(\"line-width\").evaluate(e, r), this.paint.get(\"line-gap-width\").evaluate(e, r)),\n            l = this.paint.get(\"line-offset\").evaluate(e, r);\n          return l && (n = function (t, e) {\n            const r = [],\n              n = new q(0, 0);\n            for (let i = 0; i < t.length; i++) {\n              const s = t[i],\n                a = [];\n              for (let t = 0; t < s.length; t++) {\n                const r = s[t],\n                  i = s[t + 1],\n                  o = 0 === t ? n : r.sub(s[t - 1])._unit()._perp(),\n                  l = t === s.length - 1 ? n : i.sub(r)._unit()._perp(),\n                  u = o._add(l)._unit();\n                u._mult(1 / (u.x * l.x + u.y * l.y)), a.push(u._mult(e)._add(r));\n              }\n              r.push(a);\n            }\n            return r;\n          }(n, l * t.pixelToTileUnitsFactor)), function (t, e, r) {\n            for (let n = 0; n < e.length; n++) {\n              const i = e[n];\n              if (t.length >= 3) for (let e = 0; e < i.length; e++) if (Hl(t, i[e])) return !0;\n              if (Ul(t, i, r)) return !0;\n            }\n            return !1;\n          }(a, n, o);\n        }\n        isTileClipped() {\n          return this.hasNonElevatedBuckets;\n        }\n        isDraped(t) {\n          return !this.hasElevatedBuckets;\n        }\n      },\n      symbol: Dm,\n      background: class extends ma {\n        constructor(t, e, r, n) {\n          super(t, {\n            layout: Rm || (Rm = new Xs({\n              visibility: new Gs(Zs.layout_background.visibility)\n            })),\n            paint: Lm || (Lm = new Xs({\n              \"background-pitch-alignment\": new Gs(Zs.paint_background[\"background-pitch-alignment\"]),\n              \"background-color\": new Gs(Zs.paint_background[\"background-color\"]),\n              \"background-pattern\": new Gs(Zs.paint_background[\"background-pattern\"]),\n              \"background-opacity\": new Gs(Zs.paint_background[\"background-opacity\"]),\n              \"background-emissive-strength\": new Gs(Zs.paint_background[\"background-emissive-strength\"]),\n              \"background-color-use-theme\": new Ys({\n                type: \"string\",\n                default: \"default\",\n                \"property-type\": \"data-driven\"\n              })\n            }))\n          }, e, r, n);\n        }\n        getProgramIds() {\n          return [this.paint.get(\"background-pattern\") ? \"backgroundPattern\" : \"background\"];\n        }\n        getDefaultProgramParams(t, e, r) {\n          return {\n            overrideFog: !1\n          };\n        }\n        is3D(t) {\n          return \"viewport\" === this.paint.get(\"background-pitch-alignment\");\n        }\n      },\n      raster: Wm,\n      \"raster-particle\": ry,\n      sky: class extends ma {\n        constructor(t, e, r, n) {\n          super(t, {\n            layout: Qm || (Qm = new Xs({\n              visibility: new Gs(Zs.layout_sky.visibility)\n            })),\n            paint: ty || (ty = new Xs({\n              \"sky-type\": new Gs(Zs.paint_sky[\"sky-type\"]),\n              \"sky-atmosphere-sun\": new Gs(Zs.paint_sky[\"sky-atmosphere-sun\"]),\n              \"sky-atmosphere-sun-intensity\": new Gs(Zs.paint_sky[\"sky-atmosphere-sun-intensity\"]),\n              \"sky-gradient-center\": new Gs(Zs.paint_sky[\"sky-gradient-center\"]),\n              \"sky-gradient-radius\": new Gs(Zs.paint_sky[\"sky-gradient-radius\"]),\n              \"sky-gradient\": new Hs(Zs.paint_sky[\"sky-gradient\"]),\n              \"sky-atmosphere-halo-color\": new Gs(Zs.paint_sky[\"sky-atmosphere-halo-color\"]),\n              \"sky-atmosphere-color\": new Gs(Zs.paint_sky[\"sky-atmosphere-color\"]),\n              \"sky-opacity\": new Gs(Zs.paint_sky[\"sky-opacity\"]),\n              \"sky-gradient-use-theme\": new Ys({\n                type: \"string\",\n                default: \"default\",\n                \"property-type\": \"data-driven\"\n              }),\n              \"sky-atmosphere-halo-color-use-theme\": new Ys({\n                type: \"string\",\n                default: \"default\",\n                \"property-type\": \"data-driven\"\n              }),\n              \"sky-atmosphere-color-use-theme\": new Ys({\n                type: \"string\",\n                default: \"default\",\n                \"property-type\": \"data-driven\"\n              })\n            }))\n          }, e, r, n), this._updateColorRamp();\n        }\n        _handleSpecialPaintPropertyUpdate(t) {\n          \"sky-gradient\" === t ? this._updateColorRamp() : \"sky-atmosphere-sun\" !== t && \"sky-atmosphere-halo-color\" !== t && \"sky-atmosphere-color\" !== t && \"sky-atmosphere-sun-intensity\" !== t || (this._skyboxInvalidated = !0);\n        }\n        _updateColorRamp() {\n          this.colorRamp = dc({\n            expression: this._transitionablePaint._values[\"sky-gradient\"].value.expression,\n            evaluationKey: \"skyRadialProgress\"\n          }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);\n        }\n        needsSkyboxCapture(t) {\n          if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;\n          if (!this.paint.get(\"sky-atmosphere-sun\")) {\n            const e = t.style.light.properties.get(\"position\");\n            return this._lightPosition.azimuthal !== e.azimuthal || this._lightPosition.polar !== e.polar;\n          }\n          return !1;\n        }\n        getCenter(t, e) {\n          if (\"atmosphere\" === this.paint.get(\"sky-type\")) {\n            const r = this.paint.get(\"sky-atmosphere-sun\"),\n              n = !r,\n              i = t.style.light,\n              s = i.properties.get(\"position\");\n            return n && \"viewport\" === i.properties.get(\"anchor\") && pt(\"The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly.\"), n ? iy(s.azimuthal, 90 - s.polar, e) : iy(r[0], 90 - r[1], e);\n          }\n          const r = this.paint.get(\"sky-gradient-center\");\n          return iy(r[0], 90 - r[1], e);\n        }\n        isSky() {\n          return !0;\n        }\n        markSkyboxValid(t) {\n          this._skyboxInvalidated = !1, this._lightPosition = t.style.light.properties.get(\"position\");\n        }\n        hasOffscreenPass() {\n          return !0;\n        }\n        getProgramIds() {\n          const t = this.paint.get(\"sky-type\");\n          return \"atmosphere\" === t ? [\"skyboxCapture\", \"skybox\"] : \"gradient\" === t ? [\"skyboxGradient\"] : null;\n        }\n      },\n      slot: class extends ma {\n        constructor(t, e, r, n) {\n          super(t, {\n            paint: ey || (ey = new Xs({}))\n          }, e, null);\n        }\n      },\n      model: class extends ma {\n        constructor(t, e, r, n) {\n          super(t, {\n            layout: Ey || (Ey = new Xs({\n              visibility: new Gs(Zs.layout_model.visibility),\n              \"model-id\": new Ys(Zs.layout_model[\"model-id\"])\n            })),\n            paint: zy || (zy = new Xs({\n              \"model-opacity\": new Ys(Zs.paint_model[\"model-opacity\"]),\n              \"model-rotation\": new Ys(Zs.paint_model[\"model-rotation\"]),\n              \"model-scale\": new Ys(Zs.paint_model[\"model-scale\"]),\n              \"model-translation\": new Ys(Zs.paint_model[\"model-translation\"]),\n              \"model-color\": new Ys(Zs.paint_model[\"model-color\"]),\n              \"model-color-mix-intensity\": new Ys(Zs.paint_model[\"model-color-mix-intensity\"]),\n              \"model-type\": new Gs(Zs.paint_model[\"model-type\"]),\n              \"model-cast-shadows\": new Gs(Zs.paint_model[\"model-cast-shadows\"]),\n              \"model-receive-shadows\": new Gs(Zs.paint_model[\"model-receive-shadows\"]),\n              \"model-ambient-occlusion-intensity\": new Gs(Zs.paint_model[\"model-ambient-occlusion-intensity\"]),\n              \"model-emissive-strength\": new Ys(Zs.paint_model[\"model-emissive-strength\"]),\n              \"model-roughness\": new Ys(Zs.paint_model[\"model-roughness\"]),\n              \"model-height-based-emissive-strength-multiplier\": new Ys(Zs.paint_model[\"model-height-based-emissive-strength-multiplier\"]),\n              \"model-cutoff-fade-range\": new Gs(Zs.paint_model[\"model-cutoff-fade-range\"]),\n              \"model-front-cutoff\": new Gs(Zs.paint_model[\"model-front-cutoff\"]),\n              \"model-color-use-theme\": new Ys({\n                type: \"string\",\n                default: \"default\",\n                \"property-type\": \"data-driven\"\n              })\n            }))\n          }, e, r, n), this._stats = {\n            numRenderedVerticesInShadowPass: 0,\n            numRenderedVerticesInTransparentPass: 0\n          };\n        }\n        createBucket(t) {\n          return new Py(t);\n        }\n        getProgramIds() {\n          return [\"model\"];\n        }\n        is3D(t) {\n          return !0;\n        }\n        hasShadowPass() {\n          return !0;\n        }\n        canCastShadows() {\n          return !0;\n        }\n        hasLightBeamPass() {\n          return !0;\n        }\n        cutoffRange() {\n          return this.paint.get(\"model-cutoff-fade-range\");\n        }\n        queryRadius(t) {\n          return t instanceof Gy ? Kr - 1 : 0;\n        }\n        queryIntersectsFeature(t, e, r, n, i, s) {\n          if (!this.modelManager) return !1;\n          const a = this.modelManager,\n            o = t.tile.getBucket(this);\n          if (!(o && o instanceof Py)) return !1;\n          for (const r in o.instancesPerModel) {\n            const n = o.instancesPerModel[r],\n              i = void 0 !== e.id ? e.id : e.properties && e.properties.hasOwnProperty(\"id\") ? e.properties.id : void 0;\n            if (n.idToFeaturesIndex.hasOwnProperty(i)) {\n              const e = n.features[n.idToFeaturesIndex[i]],\n                l = a.getModel(r, this.scope);\n              if (!l) return !1;\n              let u = O.mat4.create();\n              const c = new ul(0, 0),\n                h = o.canonical;\n              let p = Number.MAX_VALUE;\n              for (let r = 0; r < e.instancedDataCount; ++r) {\n                const i = 16 * (e.instancedDataOffset + r),\n                  a = n.instancedDataArray.float32,\n                  o = [a[i + 4], a[i + 5], a[i + 6]];\n                Zy(h, c, a[i], 0 | a[i + 1]), By(u, l, s, c, e.rotation, e.scale, o, !1, !1, !1), \"globe\" === s.projection.name && (u = fy(u, s));\n                const f = O.mat4.multiply([], s.projMatrix, u),\n                  d = t.queryGeometry,\n                  m = dy(d.isPointQuery() ? d.screenBounds : d.screenGeometry, s, f, l.aabb);\n                null != m && (p = Math.min(m, p));\n              }\n              return p !== Number.MAX_VALUE && p;\n            }\n          }\n          return !1;\n        }\n        _handleOverridablePaintPropertyUpdate(t, e, r) {\n          return !(!this.layout || e.isDataDriven() || r.isDataDriven() || \"model-color\" !== t && \"model-color-mix-intensity\" !== t && \"model-rotation\" !== t && \"model-scale\" !== t && \"model-translation\" !== t && \"model-emissive-strength\" !== t);\n        }\n        _isPropertyZoomDependent(t) {\n          const e = this._transitionablePaint._values[t];\n          return null != e && null != e.value && null != e.value.expression && e.value.expression instanceof ts;\n        }\n        isZoomDependent() {\n          return this._isPropertyZoomDependent(\"model-scale\") || this._isPropertyZoomDependent(\"model-rotation\") || this._isPropertyZoomDependent(\"model-translation\");\n        }\n      },\n      clip: class extends ma {\n        constructor(t, e, r, n) {\n          super(t, {\n            layout: Ah || (Ah = new Xs({\n              \"clip-layer-types\": new Gs(Zs.layout_clip[\"clip-layer-types\"]),\n              \"clip-layer-scope\": new Gs(Zs.layout_clip[\"clip-layer-scope\"])\n            })),\n            paint: Ih || (Ih = new Xs({}))\n          }, e, r, n);\n        }\n        recalculate(t, e) {\n          super.recalculate(t, e);\n        }\n        createBucket(t) {\n          return new Eh(t);\n        }\n        is3D(t) {\n          return !0;\n        }\n      }\n    };\n    class Ky {\n      constructor(t) {\n        this._callback = t, this._triggered = !1, \"undefined\" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {\n          this._triggered = !1, this._callback();\n        });\n      }\n      trigger() {\n        this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {\n          this._triggered = !1, this._callback();\n        }, 0));\n      }\n      remove() {\n        this._channel = void 0, this._callback = () => {};\n      }\n    }\n    class Jy {\n      constructor() {\n        this.tasks = {}, this.taskQueue = [], ot([\"process\"], this), this.invoker = new Ky(this.process), this.nextId = 0;\n      }\n      add(t, e) {\n        const r = this.nextId++,\n          n = function ({\n            type: t,\n            isSymbolTile: e,\n            zoom: r\n          }) {\n            return r = r || 0, \"message\" === t ? 0 : \"maybePrepare\" !== t || e ? \"parseTile\" !== t || e ? \"parseTile\" === t && e ? 300 - r : \"maybePrepare\" === t && e ? 400 - r : 500 : 200 - r : 100 - r;\n          }(e);\n        if (0 === n) {\n          try {\n            t();\n          } finally {}\n          return null;\n        }\n        return this.tasks[r] = {\n          fn: t,\n          metadata: e,\n          priority: n,\n          id: r\n        }, this.taskQueue.push(r), this.invoker.trigger(), {\n          cancel: () => {\n            delete this.tasks[r];\n          }\n        };\n      }\n      process() {\n        try {\n          if (this.taskQueue = this.taskQueue.filter(t => !!this.tasks[t]), !this.taskQueue.length) return;\n          const t = this.pick();\n          if (null === t) return;\n          const e = this.tasks[t];\n          if (delete this.tasks[t], this.taskQueue.length && this.invoker.trigger(), !e) return;\n          e.fn();\n        } finally {}\n      }\n      pick() {\n        let t = null,\n          e = 1 / 0;\n        for (let r = 0; r < this.taskQueue.length; r++) {\n          const n = this.tasks[this.taskQueue[r]];\n          n.priority < e && (e = n.priority, t = r);\n        }\n        if (null === t) return null;\n        const r = this.taskQueue[t];\n        return this.taskQueue.splice(t, 1), r;\n      }\n      remove() {\n        this.invoker.remove();\n      }\n    }\n    class Qy {\n      constructor(t, e, r) {\n        this.target = t, this.parent = e, this.mapId = r, this.callbacks = {}, this.cancelCallbacks = {}, ot([\"receive\"], this), this.target.addEventListener(\"message\", this.receive, !1), this.scheduler = new Jy();\n      }\n      send(t, e, r, n, i = !1, s) {\n        const a = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);\n        r && (r.metadata = s, this.callbacks[a] = r);\n        const o = new Set();\n        return this.target.postMessage({\n          id: a,\n          type: t,\n          hasCallback: !!r,\n          targetMapId: n,\n          mustQueue: i,\n          sourceMapId: this.mapId,\n          data: ps(e, o)\n        }, o), {\n          cancel: () => {\n            r && delete this.callbacks[a], this.target.postMessage({\n              id: a,\n              type: \"<cancel>\",\n              targetMapId: n,\n              sourceMapId: this.mapId\n            });\n          }\n        };\n      }\n      receive(t) {\n        const e = t.data;\n        if (!e) return;\n        const r = e.id;\n        if (r && (!e.targetMapId || this.mapId === e.targetMapId)) if (\"<cancel>\" === e.type) {\n          const t = this.cancelCallbacks[r];\n          delete this.cancelCallbacks[r], t && t.cancel();\n        } else if (e.mustQueue || yt()) {\n          const t = this.callbacks[r],\n            n = this.scheduler.add(() => this.processTask(r, e), t && t.metadata || {\n              type: \"message\"\n            });\n          n && (this.cancelCallbacks[r] = n);\n        } else this.processTask(r, e);\n      }\n      processTask(t, e) {\n        if (delete this.cancelCallbacks[t], \"<response>\" === e.type) {\n          const r = this.callbacks[t];\n          delete this.callbacks[t], r && (e.error ? r(fs(e.error)) : r(null, fs(e.data)));\n        } else {\n          const r = new Set(),\n            n = e.hasCallback ? (e, n) => {\n              this.target.postMessage({\n                id: t,\n                type: \"<response>\",\n                sourceMapId: this.mapId,\n                error: e ? ps(e) : null,\n                data: ps(n, r)\n              }, r);\n            } : () => {},\n            i = fs(e.data);\n          if (this.parent[e.type]) this.parent[e.type](e.sourceMapId, i, n);else if (this.parent.getWorkerSource) {\n            const t = e.type.split(\".\");\n            this.parent.getWorkerSource(e.sourceMapId, t[0], i.source, i.scope)[t[1]](i, n);\n          } else n(new Error(`Could not find function ${e.type}`));\n        }\n      }\n      remove() {\n        this.scheduler.remove(), this.target.removeEventListener(\"message\", this.receive, !1);\n      }\n    }\n    var tg = {\n      workerUrl: \"\",\n      workerClass: null,\n      workerParams: void 0\n    };\n    const eg = \"mapboxgl_preloaded_worker_pool\";\n    class rg {\n      constructor() {\n        this.active = {};\n      }\n      acquire(t, e = rg.workerCount) {\n        if (!this.workers) for (this.workers = []; this.workers.length < e;) this.workers.push(null != tg.workerClass ? new tg.workerClass() : new self.Worker(tg.workerUrl, tg.workerParams));\n        return this.active[t] = !0, this.workers.slice();\n      }\n      release(t) {\n        delete this.active[t], this.workers && 0 === this.numActive() && (this.workers.forEach(t => {\n          t.terminate();\n        }), this.workers = null);\n      }\n      isPreloaded() {\n        return !!this.active[eg];\n      }\n      numActive() {\n        return Object.keys(this.active).length;\n      }\n    }\n    rg.workerCount = 2;\n    class ng {\n      constructor(t, e, r = \"Worker\", n = rg.workerCount) {\n        this.workerPool = t, this.actors = [], this.currentActor = 0, this.id = st();\n        const i = this.workerPool.acquire(this.id, n);\n        for (let t = 0; t < i.length; t++) {\n          const n = new ng.Actor(i[t], e, this.id);\n          n.name = `${r} ${t}`, this.actors.push(n);\n        }\n        this.ready = !1, this.broadcast(\"checkIfReady\", null, () => {\n          this.ready = !0;\n        });\n      }\n      broadcast(t, e, r) {\n        rt(this.actors, (r, n) => {\n          r.send(t, e, n);\n        }, r = r || function () {});\n      }\n      getActor() {\n        return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];\n      }\n      remove() {\n        this.actors.forEach(t => {\n          t.remove();\n        }), this.actors = [], this.workerPool.release(this.id);\n      }\n    }\n    let ig, sg;\n    function ag() {\n      return ig || (ig = new rg()), ig;\n    }\n    ng.Actor = Qy;\n    const og = new Se(0, 0, 0);\n    var lg = (t => (t[t.PATH_RULE_UNSPECIFIED = 0] = \"PATH_RULE_UNSPECIFIED\", t[t.PATH_RULE_NON_ZERO = 1] = \"PATH_RULE_NON_ZERO\", t[t.PATH_RULE_EVEN_ODD = 2] = \"PATH_RULE_EVEN_ODD\", t))(lg || {}),\n      ug = (t => (t[t.LINE_CAP_UNSPECIFIED = 0] = \"LINE_CAP_UNSPECIFIED\", t[t.LINE_CAP_BUTT = 1] = \"LINE_CAP_BUTT\", t[t.LINE_CAP_ROUND = 2] = \"LINE_CAP_ROUND\", t[t.LINE_CAP_SQUARE = 3] = \"LINE_CAP_SQUARE\", t))(ug || {}),\n      cg = (t => (t[t.LINE_JOIN_UNSPECIFIED = 0] = \"LINE_JOIN_UNSPECIFIED\", t[t.LINE_JOIN_MITER = 1] = \"LINE_JOIN_MITER\", t[t.LINE_JOIN_MITER_CLIP = 2] = \"LINE_JOIN_MITER_CLIP\", t[t.LINE_JOIN_ROUND = 3] = \"LINE_JOIN_ROUND\", t[t.LINE_JOIN_BEVEL = 4] = \"LINE_JOIN_BEVEL\", t))(cg || {}),\n      hg = (t => (t[t.PAINT_ORDER_UNSPECIFIED = 0] = \"PAINT_ORDER_UNSPECIFIED\", t[t.PAINT_ORDER_FILL_AND_STROKE = 1] = \"PAINT_ORDER_FILL_AND_STROKE\", t[t.PAINT_ORDER_STROKE_AND_FILL = 2] = \"PAINT_ORDER_STROKE_AND_FILL\", t))(hg || {}),\n      pg = (t => (t[t.PATH_COMMAND_UNSPECIFIED = 0] = \"PATH_COMMAND_UNSPECIFIED\", t[t.PATH_COMMAND_MOVE = 1] = \"PATH_COMMAND_MOVE\", t[t.PATH_COMMAND_LINE = 2] = \"PATH_COMMAND_LINE\", t[t.PATH_COMMAND_QUAD = 3] = \"PATH_COMMAND_QUAD\", t[t.PATH_COMMAND_CUBIC = 4] = \"PATH_COMMAND_CUBIC\", t[t.PATH_COMMAND_CLOSE = 5] = \"PATH_COMMAND_CLOSE\", t))(pg || {}),\n      fg = (t => (t[t.MASK_TYPE_UNSPECIFIED = 0] = \"MASK_TYPE_UNSPECIFIED\", t[t.MASK_TYPE_LUMINANCE = 1] = \"MASK_TYPE_LUMINANCE\", t[t.MASK_TYPE_ALPHA = 2] = \"MASK_TYPE_ALPHA\", t))(fg || {});\n    function dg(t, e, r) {\n      1 === t && e.icons.push(function (t, e) {\n        return function (t) {\n          if (t.usvg_tree.height || (t.usvg_tree.height = t.usvg_tree.width), !t.metadata) return t;\n          const {\n            metadata: e\n          } = t;\n          if (e.content_area) {\n            const {\n              content_area: r\n            } = e;\n            null == r.top && (r.top = r.left), null == r.width && (r.width = t.usvg_tree.width), null == r.height && (r.height = r.width);\n          }\n          return e.stretch_x && e.stretch_x.length && mg(e, \"x\"), e.stretch_y && e.stretch_y.length && mg(e, \"y\"), t;\n        }(t.readFields(yg, {\n          name: void 0\n        }, e));\n      }(r, r.readVarint() + r.pos));\n    }\n    function mg(t, e) {\n      const r = [],\n        n = t[`stretch_${e}`];\n      let i = null;\n      for (let t = 0; t < n.length; t++) null === i ? i = 0 === r.length ? n[0] : r[r.length - 1][1] + n[t] : (r.push([i, i + n[t]]), i = null);\n      t[`stretch_${e}_areas`] = r;\n    }\n    function yg(t, e, r) {\n      1 === t ? e.name = r.readString() : 2 === t ? e.metadata = function (t, e) {\n        return t.readFields(gg, {\n          stretch_x: null,\n          stretch_y: null,\n          stretch_x_areas: null,\n          stretch_y_areas: null,\n          variables: []\n        }, e);\n      }(r, r.readVarint() + r.pos) : 3 === t && (e.usvg_tree = function (t, e) {\n        return t.readFields(bg, {\n          width: 20,\n          children: [],\n          linear_gradients: [],\n          radial_gradients: [],\n          clip_paths: [],\n          masks: []\n        }, e);\n      }(r, r.readVarint() + r.pos), e.data = \"usvg_tree\");\n    }\n    function gg(t, e, r) {\n      1 === t ? e.stretch_x = r.readPackedVarint() : 2 === t ? e.stretch_y = r.readPackedVarint() : 3 === t ? e.content_area = function (t, e) {\n        return t.readFields(xg, {\n          left: 0\n        }, e);\n      }(r, r.readVarint() + r.pos) : 4 === t && e.variables.push(function (t, e) {\n        return t.readFields(vg, {\n          name: void 0\n        }, e);\n      }(r, r.readVarint() + r.pos));\n    }\n    function xg(t, e, r) {\n      1 === t ? e.left = r.readVarint() : 2 === t ? e.width = r.readVarint() : 3 === t ? e.top = r.readVarint() : 4 === t && (e.height = r.readVarint());\n    }\n    function vg(t, e, r) {\n      1 === t ? e.name = r.readString() : 2 === t && (e.rgb_color = Eg(r.readVarint()), e.value = \"rgb_color\");\n    }\n    function bg(t, e, r) {\n      1 === t ? e.width = e.height = r.readVarint() : 2 === t ? e.height = r.readVarint() : 3 === t ? e.children.push(_g(r, r.readVarint() + r.pos)) : 4 === t ? e.linear_gradients.push(function (t, e) {\n        return t.readFields(kg, {\n          spread_method: 1,\n          stops: [],\n          x1: 0,\n          y1: 0,\n          x2: 1,\n          y2: 0\n        }, e);\n      }(r, r.readVarint() + r.pos)) : 5 === t ? e.radial_gradients.push(function (t, e) {\n        return t.readFields(Vg, {\n          spread_method: 1,\n          stops: [],\n          cx: .5,\n          cy: .5,\n          r: .5,\n          fx: .5,\n          fy: .5,\n          fr: 0\n        }, e);\n      }(r, r.readVarint() + r.pos)) : 7 === t ? e.clip_paths.push(function (t, e) {\n        return t.readFields(Cg, {\n          children: []\n        }, e);\n      }(r, r.readVarint() + r.pos)) : 8 === t && e.masks.push(function (t, e) {\n        const r = t.readFields(Dg, {\n          left: 0,\n          width: 20,\n          mask_type: 1,\n          children: []\n        }, e);\n        return null == r.height && (r.height = r.width), null == r.top && (r.top = r.left), r;\n      }(r, r.readVarint() + r.pos));\n    }\n    function _g(t, e) {\n      return t.readFields(wg, {}, e);\n    }\n    function wg(t, e, r) {\n      1 === t ? (e.group = function (t, e) {\n        return t.readFields(Mg, {\n          opacity: 255,\n          children: []\n        }, e);\n      }(r, r.readVarint() + r.pos), e.node = \"group\") : 2 === t && (e.path = function (t, e) {\n        return t.readFields(Sg, {\n          paint_order: 1,\n          commands: [],\n          step: 1,\n          diffs: [],\n          rule: 1\n        }, e);\n      }(r, r.readVarint() + r.pos), e.node = \"path\");\n    }\n    function Mg(t, e, r) {\n      1 === t ? e.transform = Ag(r, r.readVarint() + r.pos) : 2 === t ? e.opacity = r.readVarint() : 5 === t ? e.clip_path_idx = r.readVarint() : 6 === t ? e.mask_idx = r.readVarint() : 7 === t && e.children.push(_g(r, r.readVarint() + r.pos));\n    }\n    function Ag(t, e) {\n      return t.readFields(Ig, {\n        sx: 1,\n        ky: 0,\n        kx: 0,\n        sy: 1,\n        tx: 0,\n        ty: 0\n      }, e);\n    }\n    function Ig(t, e, r) {\n      1 === t ? e.sx = r.readFloat() : 2 === t ? e.ky = r.readFloat() : 3 === t ? e.kx = r.readFloat() : 4 === t ? e.sy = r.readFloat() : 5 === t ? e.tx = r.readFloat() : 6 === t && (e.ty = r.readFloat());\n    }\n    function Sg(t, e, r) {\n      1 === t ? e.fill = function (t, e) {\n        return t.readFields(Pg, {\n          rgb_color: og,\n          paint: \"rgb_color\",\n          opacity: 255\n        }, e);\n      }(r, r.readVarint() + r.pos) : 2 === t ? e.stroke = function (t, e) {\n        return t.readFields(zg, {\n          rgb_color: og,\n          paint: \"rgb_color\",\n          dasharray: [],\n          dashoffset: 0,\n          miterlimit: 4,\n          opacity: 255,\n          width: 1,\n          linecap: 1,\n          linejoin: 1\n        }, e);\n      }(r, r.readVarint() + r.pos) : 3 === t ? e.paint_order = r.readVarint() : 5 === t ? r.readPackedVarint(e.commands) : 6 === t ? e.step = r.readFloat() : 7 === t ? r.readPackedSVarint(e.diffs) : 8 === t && (e.rule = r.readVarint());\n    }\n    function Pg(t, e, r) {\n      1 === t ? (e.rgb_color = Eg(r.readVarint()), e.paint = \"rgb_color\") : 2 === t ? (e.linear_gradient_idx = r.readVarint(), e.paint = \"linear_gradient_idx\") : 3 === t ? (e.radial_gradient_idx = r.readVarint(), e.paint = \"radial_gradient_idx\") : 5 === t && (e.opacity = r.readVarint());\n    }\n    function Eg(t) {\n      return new Se((t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255, 1);\n    }\n    function zg(t, e, r) {\n      1 === t ? (e.rgb_color = Eg(r.readVarint()), e.paint = \"rgb_color\") : 2 === t ? (e.linear_gradient_idx = r.readVarint(), e.paint = \"linear_gradient_idx\") : 3 === t ? (e.radial_gradient_idx = r.readVarint(), e.paint = \"radial_gradient_idx\") : 5 === t ? r.readPackedFloat(e.dasharray) : 6 === t ? e.dashoffset = r.readFloat() : 7 === t ? e.miterlimit = r.readFloat() : 8 === t ? e.opacity = r.readVarint() : 9 === t ? e.width = r.readFloat() : 10 === t ? e.linecap = r.readVarint() : 11 === t && (e.linejoin = r.readVarint());\n    }\n    function kg(t, e, r) {\n      1 === t ? e.transform = Ag(r, r.readVarint() + r.pos) : 2 === t ? e.spread_method = r.readVarint() : 3 === t ? e.stops.push(Tg(r, r.readVarint() + r.pos)) : 4 === t ? e.x1 = r.readFloat() : 5 === t ? e.y1 = r.readFloat() : 6 === t ? e.x2 = r.readFloat() : 7 === t && (e.y2 = r.readFloat());\n    }\n    function Tg(t, e) {\n      return t.readFields(Bg, {\n        offset: 0,\n        opacity: 255,\n        rgb_color: og\n      }, e);\n    }\n    function Bg(t, e, r) {\n      1 === t ? e.offset = r.readFloat() : 2 === t ? e.opacity = r.readVarint() : 3 === t && (e.rgb_color = Eg(r.readVarint()));\n    }\n    function Vg(t, e, r) {\n      1 === t ? e.transform = Ag(r, r.readVarint() + r.pos) : 2 === t ? e.spread_method = r.readVarint() : 3 === t ? e.stops.push(Tg(r, r.readVarint() + r.pos)) : 4 === t ? e.cx = r.readFloat() : 5 === t ? e.cy = r.readFloat() : 6 === t ? e.r = r.readFloat() : 7 === t ? e.fx = r.readFloat() : 8 === t ? e.fy = r.readFloat() : 9 === t && (e.fr = r.readFloat());\n    }\n    function Cg(t, e, r) {\n      1 === t ? e.transform = Ag(r, r.readVarint() + r.pos) : 2 === t ? e.clip_path_idx = r.readVarint() : 3 === t && e.children.push(_g(r, r.readVarint() + r.pos));\n    }\n    function Dg(t, e, r) {\n      1 === t ? e.left = e.top = r.readFloat() : 2 === t ? e.width = e.height = r.readFloat() : 3 === t ? e.top = r.readFloat() : 4 === t ? e.height = r.readFloat() : 5 === t ? e.mask_type = r.readVarint() : 6 === t ? e.mask_idx = r.readVarint() : 7 === t && e.children.push(_g(r, r.readVarint() + r.pos));\n    }\n    class Rg {\n      static calculate(t = {}, e = []) {\n        const r = new Map(),\n          n = new Map();\n        if (0 === Object.keys(t).length) return r;\n        e.forEach(t => {\n          n.set(t.name, t.rgb_color || new Se(0, 0, 0));\n        });\n        for (const [e, i] of Object.entries(t)) n.has(e) ? r.set(n.get(e).toStringPremultipliedAlpha(), i) : console.warn(`Ignoring unknown image variable \"${e}\"`);\n        return r;\n      }\n    }\n    function Lg(t, e = 255, r) {\n      const n = e / 255,\n        i = t.toStringPremultipliedAlpha(),\n        s = r.has(i) ? r.get(i).clone() : t.clone();\n      return s.a *= n, s.toString();\n    }\n    function Fg(t, e) {\n      if (!Vt()) {\n        const r = document.createElement(\"canvas\");\n        return r.width = t, r.height = e, r;\n      }\n      return new OffscreenCanvas(t, e);\n    }\n    function Og(t, e) {\n      const r = Rg.calculate(e.params, t.metadata ? t.metadata.variables : []),\n        n = t.usvg_tree,\n        i = n.width,\n        s = n.height,\n        a = e.transform ? e.transform : new DOMMatrix(),\n        o = Math.max(1, Math.round(i * a.a)),\n        l = Math.max(1, Math.round(s * a.d)),\n        u = new DOMMatrix([o / i, 0, 0, l / s, 0, 0]),\n        c = Fg(o, l).getContext(\"2d\");\n      return Ng(c, u, n, n, r), c.getImageData(0, 0, o, l);\n    }\n    function Ng(t, e, r, n, i) {\n      for (const s of n.children) Ug(t, e, r, s, i);\n    }\n    function Ug(t, e, r, n, i) {\n      n.group ? (t.save(), function (t, e, r, n, i) {\n        const s = null != n.mask_idx ? r.masks[n.mask_idx] : null,\n          a = null != n.clip_path_idx ? r.clip_paths[n.clip_path_idx] : null;\n        if (n.transform && (e = Wg(n.transform).preMultiplySelf(e)), !function (t, e, r) {\n          return 255 !== t.opacity || e || r;\n        }(n, null != a, null != s)) return void Ng(t, e, r, n, i);\n        const o = Fg(t.canvas.width, t.canvas.height),\n          l = o.getContext(\"2d\");\n        Ng(l, e, r, n, i), a && Xg(l, e, r, a), s && Zg(l, e, r, s, i), t.globalAlpha = n.opacity / 255, t.drawImage(o, 0, 0);\n      }(t, e, r, n.group, i), t.restore()) : n.path && (t.save(), function (t, e, r, n, i) {\n        const s = Kg(n);\n        t.setTransform(e), n.paint_order === hg.PAINT_ORDER_FILL_AND_STROKE ? (jg(t, r, n, s, i), $g(t, r, n, s, i)) : ($g(t, r, n, s, i), jg(t, r, n, s, i));\n      }(t, e, r, n.path, i), t.restore());\n    }\n    function jg(t, e, r, n, i) {\n      const s = r.fill;\n      if (!s) return;\n      const a = s.opacity / 255;\n      switch (s.paint) {\n        case \"rgb_color\":\n          t.fillStyle = Lg(s.rgb_color, s.opacity, i);\n          break;\n        case \"linear_gradient_idx\":\n          t.fillStyle = Gg(t, e.linear_gradients[s.linear_gradient_idx], a, i);\n          break;\n        case \"radial_gradient_idx\":\n          t.fillStyle = Yg(t, e.radial_gradients[s.radial_gradient_idx], a, i);\n      }\n      t.fill(n, qg(r));\n    }\n    function qg(t) {\n      return t.rule === lg.PATH_RULE_NON_ZERO ? \"nonzero\" : t.rule === lg.PATH_RULE_EVEN_ODD ? \"evenodd\" : void 0;\n    }\n    function $g(t, e, r, n, i) {\n      const s = r.stroke;\n      if (!s) return;\n      t.lineWidth = s.width, t.miterLimit = s.miterlimit, t.setLineDash(s.dasharray), t.lineDashOffset = s.dashoffset;\n      const a = s.opacity / 255;\n      switch (s.paint) {\n        case \"rgb_color\":\n          t.strokeStyle = Lg(s.rgb_color, s.opacity, i);\n          break;\n        case \"linear_gradient_idx\":\n          t.strokeStyle = Gg(t, e.linear_gradients[s.linear_gradient_idx], a, i);\n          break;\n        case \"radial_gradient_idx\":\n          t.strokeStyle = Yg(t, e.radial_gradients[s.radial_gradient_idx], a, i);\n      }\n      switch (s.linejoin) {\n        case cg.LINE_JOIN_MITER_CLIP:\n        case cg.LINE_JOIN_MITER:\n          t.lineJoin = \"miter\";\n          break;\n        case cg.LINE_JOIN_ROUND:\n          t.lineJoin = \"round\";\n          break;\n        case cg.LINE_JOIN_BEVEL:\n          t.lineJoin = \"bevel\";\n      }\n      switch (s.linecap) {\n        case ug.LINE_CAP_BUTT:\n          t.lineCap = \"butt\";\n          break;\n        case ug.LINE_CAP_ROUND:\n          t.lineCap = \"round\";\n          break;\n        case ug.LINE_CAP_SQUARE:\n          t.lineCap = \"square\";\n      }\n      t.stroke(n);\n    }\n    function Gg(t, e, r, n) {\n      if (1 === e.stops.length) {\n        const t = e.stops[0];\n        return Lg(t.rgb_color, t.opacity * r, n);\n      }\n      const i = Wg(e.transform),\n        {\n          x1: s,\n          y1: a,\n          x2: o,\n          y2: l\n        } = e,\n        u = i.transformPoint(new DOMPoint(s, a)),\n        c = i.transformPoint(new DOMPoint(o, l)),\n        h = t.createLinearGradient(u.x, u.y, c.x, c.y);\n      for (const t of e.stops) h.addColorStop(t.offset, Lg(t.rgb_color, t.opacity * r, n));\n      return h;\n    }\n    function Yg(t, e, r, n) {\n      if (1 === e.stops.length) {\n        const t = e.stops[0];\n        return Lg(t.rgb_color, t.opacity * r, n);\n      }\n      const i = Wg(e.transform),\n        {\n          fx: s,\n          fy: a,\n          cx: o,\n          cy: l\n        } = e,\n        u = i.transformPoint(new DOMPoint(s, a)),\n        c = i.transformPoint(new DOMPoint(o, l)),\n        h = t.createRadialGradient(u.x, u.y, 0, c.x, c.y, e.r * ((i.a + i.d) / 2));\n      for (const t of e.stops) h.addColorStop(t.offset, Lg(t.rgb_color, t.opacity * r, n));\n      return h;\n    }\n    function Hg(t, e, r, n) {\n      const i = n.transform ? Wg(n.transform).preMultiplySelf(e) : e,\n        s = Fg(t.canvas.width, t.canvas.height),\n        a = s.getContext(\"2d\");\n      for (const t of n.children) if (t.group) Hg(a, i, r, t.group);else if (t.path) {\n        const e = t.path,\n          r = new Path2D();\n        r.addPath(Kg(e), i), a.fill(r, qg(e));\n      }\n      const o = null != n.clip_path_idx ? r.clip_paths[n.clip_path_idx] : null;\n      o && Xg(a, i, r, o), t.globalCompositeOperation = \"source-over\", t.drawImage(s, 0, 0);\n    }\n    function Xg(t, e, r, n) {\n      const i = Fg(t.canvas.width, t.canvas.height);\n      Hg(i.getContext(\"2d\"), e, r, n), t.globalCompositeOperation = \"destination-in\", t.drawImage(i, 0, 0);\n    }\n    function Zg(t, e, r, n, i) {\n      if (0 === n.children.length) return;\n      const s = null != n.mask_idx ? r.masks[n.mask_idx] : null;\n      s && Zg(t, e, r, s, i);\n      const a = t.canvas.width,\n        o = t.canvas.height,\n        l = Fg(a, o),\n        u = l.getContext(\"2d\"),\n        c = n.width,\n        h = n.height,\n        p = n.left,\n        f = n.top,\n        d = new Path2D(),\n        m = new Path2D();\n      m.rect(p, f, c, h), d.addPath(m, e), u.clip(d);\n      for (const t of n.children) Ug(u, e, r, t, i);\n      const y = u.getImageData(0, 0, a, o),\n        g = y.data;\n      if (n.mask_type === fg.MASK_TYPE_LUMINANCE) for (let t = 0; t < g.length; t += 4) g[t + 3] = g[t + 3] / 255 * (.2126 * g[t] + .7152 * g[t + 1] + .0722 * g[t + 2]);\n      u.putImageData(y, 0, 0), t.globalCompositeOperation = \"destination-in\", t.drawImage(l, 0, 0);\n    }\n    function Wg(t) {\n      return t ? new DOMMatrix([t.sx, t.ky, t.kx, t.sy, t.tx, t.ty]) : new DOMMatrix();\n    }\n    function Kg(t) {\n      const e = new Path2D(),\n        r = t.step;\n      let n = t.diffs[0] * r,\n        i = t.diffs[1] * r;\n      e.moveTo(n, i);\n      for (let s = 0, a = 2; s < t.commands.length; s++) switch (t.commands[s]) {\n        case pg.PATH_COMMAND_MOVE:\n          n += t.diffs[a++] * r, i += t.diffs[a++] * r, e.moveTo(n, i);\n          break;\n        case pg.PATH_COMMAND_LINE:\n          n += t.diffs[a++] * r, i += t.diffs[a++] * r, e.lineTo(n, i);\n          break;\n        case pg.PATH_COMMAND_QUAD:\n          {\n            const s = n + t.diffs[a++] * r,\n              o = i + t.diffs[a++] * r;\n            n = s + t.diffs[a++] * r, i = o + t.diffs[a++] * r, e.quadraticCurveTo(s, o, n, i);\n            break;\n          }\n        case pg.PATH_COMMAND_CUBIC:\n          {\n            const s = n + t.diffs[a++] * r,\n              o = i + t.diffs[a++] * r,\n              l = s + t.diffs[a++] * r,\n              u = o + t.diffs[a++] * r;\n            n = l + t.diffs[a++] * r, i = u + t.diffs[a++] * r, e.bezierCurveTo(s, o, l, u, n, i);\n            break;\n          }\n        case pg.PATH_COMMAND_CLOSE:\n          e.closePath();\n      }\n      return e;\n    }\n    class Jg {\n      constructor(t) {\n        this.capacity = t, this.cache = new Map();\n      }\n      get(t) {\n        if (!this.cache.has(t)) return;\n        const e = this.cache.get(t);\n        return this.cache.delete(t), this.cache.set(t, e), e;\n      }\n      put(t, e) {\n        this.cache.has(t) ? this.cache.delete(t) : this.cache.size === this.capacity && this.cache.delete(this.cache.keys().next().value), this.cache.set(t, e);\n      }\n      delete(t) {\n        this.cache.delete(t);\n      }\n    }\n    us(Jg, \"LRUCache\");\n    class Qg {\n      constructor() {\n        this.cacheMap = new Map(), this.cacheDependenciesMap = new Map();\n      }\n      static _getImage(t) {\n        return new pc(t, t.data);\n      }\n      getFromCache(t, e, r) {\n        return this.cacheMap.has(r) || this.cacheMap.set(r, new Jg(150)), this.cacheMap.get(r).get(pa(t.toString(), e));\n      }\n      setInCache(t, e, r, n) {\n        this.cacheDependenciesMap.has(n) || this.cacheDependenciesMap.set(n, new Map()), this.cacheMap.has(n) || this.cacheMap.set(n, new Jg(150));\n        const i = this.cacheDependenciesMap.get(n),\n          s = pa(t.id.toString(), r);\n        i.get(s) || i.set(s, new Set());\n        const a = this.cacheMap.get(n),\n          o = t.toString();\n        i.get(s).add(o), a.put(pa(t.toString(), r), e);\n      }\n      removeImagesFromCacheByIds(t, e, r = 0) {\n        if (!this.cacheMap.has(r) || !this.cacheDependenciesMap.has(r)) return;\n        const n = this.cacheMap.get(r),\n          i = this.cacheDependenciesMap.get(r);\n        for (const r of t) {\n          const t = pa(r.toString(), e);\n          if (i.has(t)) {\n            for (const e of i.get(t)) n.delete(e);\n            i.delete(t);\n          }\n        }\n      }\n      rasterize(t, e, r, n, i = Og) {\n        const s = this.getFromCache(t, r, n);\n        if (s) return s.clone();\n        const a = i(e.icon, t.options),\n          o = Qg._getImage(a);\n        return this.setInCache(t, o, r, n), o.clone();\n      }\n    }\n    class tx {\n      constructor(t) {\n        this.size = t, this.minimums = [], this.maximums = [], this.leaves = [];\n      }\n      getElevation(t, e) {\n        const r = this.toIdx(t, e);\n        return {\n          min: this.minimums[r],\n          max: this.maximums[r]\n        };\n      }\n      isLeaf(t, e) {\n        return this.leaves[this.toIdx(t, e)];\n      }\n      toIdx(t, e) {\n        return e * this.size + t;\n      }\n    }\n    function ex(t, e, r, n) {\n      let i = 0,\n        s = Number.MAX_VALUE;\n      for (let a = 0; a < 3; a++) if (Math.abs(n[a]) < 1e-15) {\n        if (r[a] < t[a] || r[a] > e[a]) return null;\n      } else {\n        const o = 1 / n[a];\n        let l = (t[a] - r[a]) * o,\n          u = (e[a] - r[a]) * o;\n        if (l > u) {\n          const t = l;\n          l = u, u = t;\n        }\n        if (l > i && (i = l), u < s && (s = u), i > s) return null;\n      }\n      return i;\n    }\n    function rx(t, e, r, n, i, s, a, o, l, u, c) {\n      const h = n - t,\n        p = i - e,\n        f = s - r,\n        d = a - t,\n        m = o - e,\n        y = l - r,\n        g = c[1] * y - c[2] * m,\n        x = c[2] * d - c[0] * y,\n        v = c[0] * m - c[1] * d,\n        b = h * g + p * x + f * v;\n      if (Math.abs(b) < 1e-15) return null;\n      const _ = 1 / b,\n        w = u[0] - t,\n        M = u[1] - e,\n        A = u[2] - r,\n        I = (w * g + M * x + A * v) * _;\n      if (I < 0 || I > 1) return null;\n      const S = M * f - A * p,\n        P = A * h - w * f,\n        E = w * p - M * h,\n        z = (c[0] * S + c[1] * P + c[2] * E) * _;\n      return z < 0 || I + z > 1 ? null : (d * S + m * P + y * E) * _;\n    }\n    function nx(t, e, r) {\n      return (t - e) / (r - e);\n    }\n    function ix(t, e, r, n, i, s, a, o, l) {\n      const u = 1 << r,\n        c = s - n,\n        h = a - i,\n        p = (t + 1) / u * c + n,\n        f = (e + 0) / u * h + i,\n        d = (e + 1) / u * h + i;\n      o[0] = (t + 0) / u * c + n, o[1] = f, l[0] = p, l[1] = d;\n    }\n    class sx {\n      constructor(t) {\n        if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return;\n        const e = function (t) {\n            const e = Math.ceil(Math.log2(t.dim / 8)),\n              r = [];\n            let n = Math.ceil(Math.pow(2, e));\n            const i = 1 / n,\n              s = (t, e, r, n, i) => {\n                const s = n ? 1 : 0,\n                  a = (t + 1) * r - s,\n                  o = e * r,\n                  l = (e + 1) * r - s;\n                i[0] = t * r, i[1] = o, i[2] = a, i[3] = l;\n              };\n            let a = new tx(n);\n            const o = [];\n            for (let e = 0; e < n * n; e++) {\n              s(e % n, Math.floor(e / n), i, !1, o);\n              const r = ox(o[0], o[1], t),\n                l = ox(o[2], o[1], t),\n                u = ox(o[2], o[3], t),\n                c = ox(o[0], o[3], t);\n              a.minimums.push(Math.min(r, l, u, c)), a.maximums.push(Math.max(r, l, u, c)), a.leaves.push(1);\n            }\n            for (r.push(a), n /= 2; n >= 1; n /= 2) {\n              const t = r[r.length - 1];\n              a = new tx(n);\n              for (let e = 0; e < n * n; e++) {\n                s(e % n, Math.floor(e / n), 2, !0, o);\n                const r = t.getElevation(o[0], o[1]),\n                  i = t.getElevation(o[2], o[1]),\n                  l = t.getElevation(o[2], o[3]),\n                  u = t.getElevation(o[0], o[3]),\n                  c = t.isLeaf(o[0], o[1]),\n                  h = t.isLeaf(o[2], o[1]),\n                  p = t.isLeaf(o[2], o[3]),\n                  f = t.isLeaf(o[0], o[3]),\n                  d = Math.min(r.min, i.min, l.min, u.min),\n                  m = Math.max(r.max, i.max, l.max, u.max),\n                  y = c && h && p && f;\n                a.maximums.push(m), a.minimums.push(d), a.leaves.push(m - d <= 5 && y ? 1 : 0);\n              }\n              r.push(a);\n            }\n            return r;\n          }(this.dem),\n          r = e.length - 1,\n          n = e[r];\n        this._addNode(n.minimums[0], n.maximums[0], n.leaves[0]), this._construct(e, 0, 0, r, 0);\n      }\n      raycastRoot(t, e, r, n, i, s, a = 1) {\n        return ex([t, e, -100], [r, n, this.maximums[0] * a], i, s);\n      }\n      raycast(t, e, r, n, i, s, a = 1) {\n        if (!this.nodeCount) return null;\n        const o = this.raycastRoot(t, e, r, n, i, s, a);\n        if (null == o) return null;\n        const l = [],\n          u = [],\n          c = [],\n          h = [],\n          p = [{\n            idx: 0,\n            t: o,\n            nodex: 0,\n            nodey: 0,\n            depth: 0\n          }];\n        for (; p.length > 0;) {\n          const {\n            idx: o,\n            t: f,\n            nodex: d,\n            nodey: m,\n            depth: y\n          } = p.pop();\n          if (this.leaves[o]) {\n            ix(d, m, y, t, e, r, n, c, h);\n            const o = 1 << y,\n              l = (d + 0) / o,\n              u = (d + 1) / o,\n              p = (m + 0) / o,\n              g = (m + 1) / o,\n              x = ox(l, p, this.dem) * a,\n              v = ox(u, p, this.dem) * a,\n              b = ox(u, g, this.dem) * a,\n              _ = ox(l, g, this.dem) * a,\n              w = rx(c[0], c[1], x, h[0], c[1], v, h[0], h[1], b, i, s),\n              M = rx(h[0], h[1], b, c[0], h[1], _, c[0], c[1], x, i, s),\n              A = Math.min(null !== w ? w : Number.MAX_VALUE, null !== M ? M : Number.MAX_VALUE);\n            if (A !== Number.MAX_VALUE) return A;\n            {\n              const t = O.vec3.scaleAndAdd([], i, s, f);\n              if (ax(x, v, _, b, nx(t[0], c[0], h[0]), nx(t[1], c[1], h[1])) >= t[2]) return f;\n            }\n            continue;\n          }\n          let g = 0;\n          for (let p = 0; p < this._siblingOffset.length; p++) {\n            ix((d << 1) + this._siblingOffset[p][0], (m << 1) + this._siblingOffset[p][1], y + 1, t, e, r, n, c, h), c[2] = -100, h[2] = this.maximums[this.childOffsets[o] + p] * a;\n            const f = ex(c, h, i, s);\n            if (null != f) {\n              const t = f;\n              l[p] = t;\n              let e = !1;\n              for (let r = 0; r < g && !e; r++) t >= l[u[r]] && (u.splice(r, 0, p), e = !0);\n              e || (u[g] = p), g++;\n            }\n          }\n          for (let t = 0; t < g; t++) {\n            const e = u[t];\n            p.push({\n              idx: this.childOffsets[o] + e,\n              t: l[e],\n              nodex: (d << 1) + this._siblingOffset[e][0],\n              nodey: (m << 1) + this._siblingOffset[e][1],\n              depth: y + 1\n            });\n          }\n        }\n        return null;\n      }\n      _addNode(t, e, r) {\n        return this.minimums.push(t), this.maximums.push(e), this.leaves.push(r), this.childOffsets.push(0), this.nodeCount++;\n      }\n      _construct(t, e, r, n, i) {\n        if (1 === t[n].isLeaf(e, r)) return;\n        this.childOffsets[i] || (this.childOffsets[i] = this.nodeCount);\n        const s = n - 1,\n          a = t[s];\n        let o = 0,\n          l = 0;\n        for (let t = 0; t < this._siblingOffset.length; t++) {\n          const n = 2 * e + this._siblingOffset[t][0],\n            i = 2 * r + this._siblingOffset[t][1],\n            s = a.getElevation(n, i),\n            u = a.isLeaf(n, i),\n            c = this._addNode(s.min, s.max, u);\n          u && (o |= 1 << t), l || (l = c);\n        }\n        for (let n = 0; n < this._siblingOffset.length; n++) o & 1 << n || this._construct(t, 2 * e + this._siblingOffset[n][0], 2 * r + this._siblingOffset[n][1], s, l + n);\n      }\n    }\n    function ax(t, e, r, n, i, s) {\n      return Ee(Ee(t, r, s), Ee(e, n, s), i);\n    }\n    function ox(t, e, r) {\n      const n = r.dim,\n        i = Q(t * n - .5, 0, n - 1),\n        s = Q(e * n - .5, 0, n - 1),\n        a = Math.floor(i),\n        o = Math.floor(s),\n        l = Math.min(a + 1, n - 1),\n        u = Math.min(o + 1, n - 1);\n      return ax(r.get(a, o), r.get(l, o), r.get(a, u), r.get(l, u), i - a, s - o);\n    }\n    const lx = {\n      mapbox: [6553.6, 25.6, .1, 1e4],\n      terrarium: [256, 1, 1 / 256, 32768]\n    };\n    function ux(t, e, r) {\n      return (256 * t * 256 + 256 * e + r) / 10 - 1e4;\n    }\n    function cx(t, e, r) {\n      return 256 * t + e + r / 256 - 32768;\n    }\n    class hx {\n      get tree() {\n        return this._tree || this._buildQuadTree(), this._tree;\n      }\n      constructor(t, e, r, n = !1) {\n        if (this.uid = t, e.height !== e.width) throw new RangeError(\"DEM tiles must be square\");\n        if (r && \"mapbox\" !== r && \"terrarium\" !== r) return void pt(`\"${r}\" is not a valid encoding type. Valid types include \"mapbox\" and \"terrarium\".`);\n        this.stride = e.height;\n        const i = this.dim = e.height - 2,\n          s = new Uint32Array(e.data.buffer);\n        if (this.pixels = new Uint8Array(e.data.buffer), this.floatView = new Float32Array(e.data.buffer), this.borderReady = n, this._modifiedForSources = {}, !n) {\n          for (let t = 0; t < i; t++) s[this._idx(-1, t)] = s[this._idx(0, t)], s[this._idx(i, t)] = s[this._idx(i - 1, t)], s[this._idx(t, -1)] = s[this._idx(t, 0)], s[this._idx(t, i)] = s[this._idx(t, i - 1)];\n          s[this._idx(-1, -1)] = s[this._idx(0, 0)], s[this._idx(i, -1)] = s[this._idx(i - 1, 0)], s[this._idx(-1, i)] = s[this._idx(0, i - 1)], s[this._idx(i, i)] = s[this._idx(i - 1, i - 1)];\n        }\n        const a = \"terrarium\" === r ? cx : ux;\n        for (let t = 0; t < s.length; ++t) {\n          const e = 4 * t;\n          this.floatView[t] = a(this.pixels[e], this.pixels[e + 1], this.pixels[e + 2]);\n        }\n        this._timestamp = Ct.now();\n      }\n      _buildQuadTree() {\n        this._tree = new sx(this);\n      }\n      get(t, e, r = !1) {\n        r && (t = Q(t, -1, this.dim), e = Q(e, -1, this.dim));\n        const n = this._idx(t, e);\n        return this.floatView[n];\n      }\n      set(t, e, r) {\n        const n = this._idx(t, e),\n          i = this.floatView[n];\n        return this.floatView[n] = r, r - i;\n      }\n      static getUnpackVector(t) {\n        return lx[t];\n      }\n      _idx(t, e) {\n        if (t < -1 || t >= this.dim + 1 || e < -1 || e >= this.dim + 1) throw new RangeError(\"out of range source coordinates for DEM data\");\n        return (e + 1) * this.stride + (t + 1);\n      }\n      static pack(t, e) {\n        const r = [0, 0, 0, 0],\n          n = hx.getUnpackVector(e);\n        let i = Math.floor((t + n[3]) / n[2]);\n        return r[2] = i % 256, i = Math.floor(i / 256), r[1] = i % 256, i = Math.floor(i / 256), r[0] = i, r;\n      }\n      getPixels() {\n        return new fc({\n          width: this.stride,\n          height: this.stride\n        }, this.pixels);\n      }\n      backfillBorder(t, e, r) {\n        if (this.dim !== t.dim) throw new Error(\"dem dimension mismatch\");\n        let n = e * this.dim,\n          i = e * this.dim + this.dim,\n          s = r * this.dim,\n          a = r * this.dim + this.dim;\n        switch (e) {\n          case -1:\n            n = i - 1;\n            break;\n          case 1:\n            i = n + 1;\n        }\n        switch (r) {\n          case -1:\n            s = a - 1;\n            break;\n          case 1:\n            a = s + 1;\n        }\n        const o = -e * this.dim,\n          l = -r * this.dim;\n        for (let e = s; e < a; e++) for (let r = n; r < i; r++) {\n          const n = 4 * this._idx(r, e),\n            i = 4 * this._idx(r + o, e + l);\n          this.pixels[n + 0] = t.pixels[i + 0], this.pixels[n + 1] = t.pixels[i + 1], this.pixels[n + 2] = t.pixels[i + 2], this.pixels[n + 3] = t.pixels[i + 3];\n        }\n      }\n      onDeserialize() {\n        this._tree && (this._tree.dem = this);\n      }\n    }\n    function px(t, e, r) {\n      1 === t ? e.headerLength = r.readFixed32() : 2 === t ? e.x = r.readVarint() : 3 === t ? e.y = r.readVarint() : 4 === t ? e.z = r.readVarint() : 5 === t && e.layers.push(function (t, e) {\n        return t.readFields(gx, {\n          version: 0,\n          name: \"\",\n          units: \"\",\n          tileSize: 0,\n          buffer: 0,\n          pixelFormat: 0,\n          dataIndex: []\n        }, e);\n      }(r, r.readVarint() + r.pos));\n    }\n    function fx(t, e, r) {\n      1 === t ? (e.delta_filter = function (t, e) {\n        return t.readFields(dx, {\n          blockSize: 0\n        }, e);\n      }(r, r.readVarint() + r.pos), e.filter = \"delta_filter\") : 2 === t ? (r.readVarint(), e.filter = \"zigzag_filter\") : 3 === t ? (r.readVarint(), e.filter = \"bitshuffle_filter\") : 4 === t && (r.readVarint(), e.filter = \"byteshuffle_filter\");\n    }\n    function dx(t, e, r) {\n      1 === t && (e.blockSize = r.readVarint());\n    }\n    function mx(t, e, r) {\n      1 === t ? (r.readVarint(), e.codec = \"gzip_data\") : 2 === t ? (r.readVarint(), e.codec = \"jpeg_image\") : 3 === t ? (r.readVarint(), e.codec = \"webp_image\") : 4 === t && (r.readVarint(), e.codec = \"png_image\");\n    }\n    function yx(t, e, r) {\n      let n = 0,\n        i = 0;\n      1 === t ? e.firstByte = r.readFixed64() : 2 === t ? e.lastByte = r.readFixed64() : 3 === t ? e.filters.push(function (t, e) {\n        return t.readFields(fx, {}, e);\n      }(r, r.readVarint() + r.pos)) : 4 === t ? e.codec = function (t, e) {\n        return t.readFields(mx, {}, e);\n      }(r, r.readVarint() + r.pos) : 5 === t ? i = r.readFloat() : 6 === t ? n = r.readFloat() : 7 === t ? e.bands.push(r.readString()) : 8 === t ? e.offset = r.readDouble() : 9 === t && (e.scale = r.readDouble()), 0 === e.offset && (e.offset = i), 0 === e.scale && (e.scale = n);\n    }\n    function gx(t, e, r) {\n      1 === t ? e.version = r.readVarint() : 2 === t ? e.name = r.readString() : 3 === t ? e.units = r.readString() : 4 === t ? e.tileSize = r.readVarint() : 5 === t ? e.buffer = r.readVarint() : 6 === t ? e.pixelFormat = r.readVarint() : 7 === t && e.dataIndex.push(function (t, e) {\n        return t.readFields(yx, {\n          firstByte: 0,\n          lastByte: 0,\n          filters: [],\n          codec: null,\n          offset: 0,\n          scale: 0,\n          bands: []\n        }, e);\n      }(r, r.readVarint() + r.pos));\n    }\n    function xx(t, e, r) {\n      if (2 === t) !function (t, e, r) {\n        t.readFields(vx, r, e);\n      }(r, r.readVarint() + r.pos, e);else if (3 === t) throw new Error(\"Not implemented\");\n    }\n    function vx(t, e, r) {\n      if (1 === t) {\n        let t = 0;\n        const n = r.readVarint() + r.pos;\n        for (; r.pos < n;) e[t++] = r.readVarint();\n      }\n    }\n    function bx(t, e) {\n      if (4 !== e.length) throw new Error(`Expected data of dimension 4 but got ${e.length}.`);\n      let r = e[3];\n      for (let n = 2; n >= 1; n--) {\n        const i = 1 === n ? 1 : 0,\n          s = 2 === n ? 1 : 0;\n        for (let n = 0; n < e[0]; n++) {\n          const a = e[1] * n;\n          for (let n = i; n < e[1]; n++) {\n            const i = e[2] * (n + a);\n            for (let n = s; n < e[2]; n++) {\n              const s = e[3] * (n + i);\n              for (let n = 0; n < e[3]; n++) {\n                const e = s + n;\n                t[e] += t[e - r];\n              }\n            }\n          }\n        }\n        r *= e[n];\n      }\n      return t;\n    }\n    function _x(t) {\n      for (let e = 0, r = t.length; e < r; e++) t[e] = t[e] >>> 1 ^ -(1 & t[e]);\n      return t;\n    }\n    function wx(t, e) {\n      switch (e) {\n        case \"uint32\":\n          return t;\n        case \"uint16\":\n          for (let e = 0; e < t.length; e += 2) {\n            const r = t[e],\n              n = t[e + 1];\n            t[e] = (240 & r) >> 4 | (61440 & r) >> 8 | (240 & n) << 4 | 61440 & n, t[e + 1] = 15 & r | (3840 & r) >> 4 | (15 & n) << 8 | (3840 & n) << 4;\n          }\n          return t;\n        case \"uint8\":\n          for (let e = 0; e < t.length; e += 4) {\n            const r = t[e],\n              n = t[e + 1],\n              i = t[e + 2],\n              s = t[e + 3];\n            t[e + 0] = (192 & r) >> 6 | (192 & n) >> 4 | (192 & i) >> 2 | 192 & s, t[e + 1] = (48 & r) >> 4 | (48 & n) >> 2 | 48 & i | (48 & s) << 2, t[e + 2] = (12 & r) >> 2 | 12 & n | (12 & i) << 2 | (12 & s) << 4, t[e + 3] = 3 & r | (3 & n) << 2 | (3 & i) << 4 | (3 & s) << 6;\n          }\n          return t;\n        default:\n          throw new Error(`Invalid pixel format, \"${e}\"`);\n      }\n    }\n    us(hx, \"DEMData\"), us(sx, \"DemMinMaxQuadTree\", {\n      omit: [\"dem\"]\n    });\n    var Mx = Uint8Array,\n      Ax = Uint16Array,\n      Ix = Int32Array,\n      Sx = new Mx([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),\n      Px = new Mx([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),\n      Ex = new Mx([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),\n      zx = function (t, e) {\n        for (var r = new Ax(31), n = 0; n < 31; ++n) r[n] = e += 1 << t[n - 1];\n        var i = new Ix(r[30]);\n        for (n = 1; n < 30; ++n) for (var s = r[n]; s < r[n + 1]; ++s) i[s] = s - r[n] << 5 | n;\n        return {\n          b: r,\n          r: i\n        };\n      },\n      kx = zx(Sx, 2),\n      Tx = kx.b,\n      Bx = kx.r;\n    Tx[28] = 258, Bx[258] = 28;\n    for (var Vx = zx(Px, 0).b, Cx = new Ax(32768), Dx = 0; Dx < 32768; ++Dx) {\n      var Rx = (43690 & Dx) >> 1 | (21845 & Dx) << 1;\n      Cx[Dx] = ((65280 & (Rx = (61680 & (Rx = (52428 & Rx) >> 2 | (13107 & Rx) << 2)) >> 4 | (3855 & Rx) << 4)) >> 8 | (255 & Rx) << 8) >> 1;\n    }\n    var Lx = function (t, e, r) {\n        for (var n = t.length, i = 0, s = new Ax(e); i < n; ++i) t[i] && ++s[t[i] - 1];\n        var a,\n          o = new Ax(e);\n        for (i = 1; i < e; ++i) o[i] = o[i - 1] + s[i - 1] << 1;\n        a = new Ax(1 << e);\n        var l = 15 - e;\n        for (i = 0; i < n; ++i) if (t[i]) for (var u = i << 4 | t[i], c = e - t[i], h = o[t[i] - 1]++ << c, p = h | (1 << c) - 1; h <= p; ++h) a[Cx[h] >> l] = u;\n        return a;\n      },\n      Fx = new Mx(288);\n    for (Dx = 0; Dx < 144; ++Dx) Fx[Dx] = 8;\n    for (Dx = 144; Dx < 256; ++Dx) Fx[Dx] = 9;\n    for (Dx = 256; Dx < 280; ++Dx) Fx[Dx] = 7;\n    for (Dx = 280; Dx < 288; ++Dx) Fx[Dx] = 8;\n    var Ox = new Mx(32);\n    for (Dx = 0; Dx < 32; ++Dx) Ox[Dx] = 5;\n    var Nx = Lx(Fx, 9),\n      Ux = Lx(Ox, 5),\n      jx = function (t) {\n        for (var e = t[0], r = 1; r < t.length; ++r) t[r] > e && (e = t[r]);\n        return e;\n      },\n      qx = function (t, e, r) {\n        var n = e / 8 | 0;\n        return (t[n] | t[n + 1] << 8) >> (7 & e) & r;\n      },\n      $x = function (t, e) {\n        var r = e / 8 | 0;\n        return (t[r] | t[r + 1] << 8 | t[r + 2] << 16) >> (7 & e);\n      },\n      Gx = [\"unexpected EOF\", \"invalid block type\", \"invalid length/literal\", \"invalid distance\", \"stream finished\", \"no stream handler\",, \"no callback\", \"invalid UTF-8 data\", \"extra field too long\", \"date not in range 1980-2099\", \"filename too long\", \"stream finishing\", \"invalid zip data\"],\n      Yx = function (t, e, r) {\n        var n = new Error(e || Gx[t]);\n        if (n.code = t, Error.captureStackTrace && Error.captureStackTrace(n, Yx), !r) throw n;\n        return n;\n      },\n      Hx = new Mx(0),\n      Xx = \"undefined\" != typeof TextDecoder && new TextDecoder();\n    try {\n      Xx.decode(Hx, {\n        stream: !0\n      });\n    } catch (t) {}\n    const Zx = {\n      gzip_data: \"gzip\"\n    };\n    class Wx extends Error {\n      constructor(t) {\n        super(t), this.name = \"MRTError\";\n      }\n    }\n    const Kx = {\n        0: \"uint32\",\n        1: \"uint32\",\n        2: \"uint16\",\n        3: \"uint8\"\n      },\n      Jx = {\n        uint32: 1,\n        uint16: 2,\n        uint8: 4\n      },\n      Qx = {\n        uint32: Uint32Array,\n        uint16: Uint16Array,\n        uint8: Uint8Array\n      };\n    let tv;\n    class ev {\n      constructor(t = 5) {\n        this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = t;\n      }\n      getLayer(t) {\n        const e = this.layers[t];\n        if (!e) throw new Wx(`Layer '${t}' not found`);\n        return e;\n      }\n      getHeaderLength(t) {\n        const e = new Uint8Array(t),\n          r = new DataView(t);\n        if (13 !== e[0]) throw new Wx(\"File is not a valid MRT.\");\n        return r.getUint32(1, !0);\n      }\n      parseHeader(t) {\n        const e = new Uint8Array(t),\n          r = this.getHeaderLength(t);\n        if (e.length < r) throw new Wx(`Expected header with length >= ${r} but got buffer of length ${e.length}`);\n        const n = function (t, e) {\n          return t.readFields(px, {\n            headerLength: 0,\n            x: 0,\n            y: 0,\n            z: 0,\n            layers: []\n          }, void 0);\n        }(new tv(e.subarray(0, r)));\n        if (!isNaN(this.x) && (this.x !== n.x || this.y !== n.y || this.z !== n.z)) throw new Wx(`Invalid attempt to parse header ${n.z}/${n.x}/${n.y} for tile ${this.z}/${this.x}/${this.y}`);\n        this.x = n.x, this.y = n.y, this.z = n.z;\n        for (const t of n.layers) this.layers[t.name] = new rv(t, {\n          cacheSize: this._cacheSize\n        });\n        return this;\n      }\n      createDecodingTask(t) {\n        const e = [],\n          r = this.getLayer(t.layerName);\n        for (let n of t.blockIndices) {\n          const i = r.dataIndex[n],\n            s = i.firstByte - t.firstByte,\n            a = i.lastByte - t.firstByte;\n          if (r._blocksInProgress.has(n)) continue;\n          const o = {\n            layerName: r.name,\n            firstByte: s,\n            lastByte: a,\n            pixelFormat: r.pixelFormat,\n            blockIndex: n,\n            blockShape: [i.bands.length].concat(r.bandShape),\n            buffer: r.buffer,\n            codec: i.codec.codec,\n            filters: i.filters.map(t => t.filter)\n          };\n          r._blocksInProgress.add(n), e.push(o);\n        }\n        return new nv(e, () => {\n          e.forEach(t => r._blocksInProgress.delete(t.blockIndex));\n        }, (t, n) => {\n          if (e.forEach(t => r._blocksInProgress.delete(t.blockIndex)), t) throw t;\n          n.forEach(t => {\n            this.getLayer(t.layerName).processDecodedData(t);\n          });\n        });\n      }\n    }\n    class rv {\n      constructor({\n        version: t,\n        name: e,\n        units: r,\n        tileSize: n,\n        pixelFormat: i,\n        buffer: s,\n        dataIndex: a\n      }, o) {\n        if (this.version = t, 1 !== this.version) throw new Wx(`Cannot parse raster layer encoded with MRT version ${t}`);\n        this.name = e, this.units = r, this.tileSize = n, this.buffer = s, this.pixelFormat = Kx[i], this.dataIndex = a, this.bandShape = [n + 2 * s, n + 2 * s, Jx[this.pixelFormat]], this._decodedBlocks = new Jg(o ? o.cacheSize : 5), this._blocksInProgress = new Set();\n      }\n      get dimension() {\n        return Jx[this.pixelFormat];\n      }\n      get cacheSize() {\n        return this._decodedBlocks.capacity;\n      }\n      getBandList() {\n        return this.dataIndex.map(({\n          bands: t\n        }) => t).flat();\n      }\n      processDecodedData(t) {\n        const e = t.blockIndex.toString();\n        this._decodedBlocks.get(e) || this._decodedBlocks.put(e, t.data);\n      }\n      getBlockForBand(t) {\n        let e = 0;\n        switch (typeof t) {\n          case \"string\":\n            for (const [r, n] of this.dataIndex.entries()) {\n              for (const [i, s] of n.bands.entries()) if (s === t) return {\n                bandIndex: e + i,\n                blockIndex: r,\n                blockBandIndex: i\n              };\n              e += n.bands.length;\n            }\n            break;\n          case \"number\":\n            for (const [r, n] of this.dataIndex.entries()) {\n              if (t >= e && t < e + n.bands.length) return {\n                bandIndex: t,\n                blockIndex: r,\n                blockBandIndex: t - e\n              };\n              e += n.bands.length;\n            }\n            break;\n          default:\n            throw new Wx(`Invalid band \\`${JSON.stringify(t)}\\`. Expected string or integer.`);\n        }\n        throw new Wx(`Band not found: ${JSON.stringify(t)}`);\n      }\n      getDataRange(t) {\n        let e = 1 / 0,\n          r = -1 / 0;\n        const n = [],\n          i = new Set();\n        for (const s of t) {\n          const {\n            blockIndex: t\n          } = this.getBlockForBand(s);\n          if (t < 0) throw new Wx(`Invalid band: ${JSON.stringify(s)}`);\n          const a = this.dataIndex[t];\n          n.includes(t) || n.push(t), i.add(t), e = Math.min(e, a.firstByte), r = Math.max(r, a.lastByte);\n        }\n        if (i.size > this.cacheSize) throw new Wx(`Number of blocks to decode (${i.size}) exceeds cache size (${this.cacheSize}).`);\n        return {\n          layerName: this.name,\n          firstByte: e,\n          lastByte: r,\n          blockIndices: n\n        };\n      }\n      hasBand(t) {\n        const {\n          blockIndex: e\n        } = this.getBlockForBand(t);\n        return e >= 0;\n      }\n      hasDataForBand(t) {\n        const {\n          blockIndex: e\n        } = this.getBlockForBand(t);\n        return e >= 0 && !!this._decodedBlocks.get(e.toString());\n      }\n      getBandView(t) {\n        const {\n            blockIndex: e,\n            blockBandIndex: r\n          } = this.getBlockForBand(t),\n          n = this._decodedBlocks.get(e.toString());\n        if (!n) throw new Wx(`Data for band ${JSON.stringify(t)} of layer \"${this.name}\" not decoded.`);\n        const i = this.dataIndex[e],\n          s = this.bandShape.reduce((t, e) => t * e, 1),\n          a = r * s,\n          o = n.subarray(a, a + s);\n        return {\n          data: o,\n          bytes: new Uint8Array(o.buffer).subarray(o.byteOffset, o.byteOffset + o.byteLength),\n          tileSize: this.tileSize,\n          buffer: this.buffer,\n          pixelFormat: this.pixelFormat,\n          dimension: this.dimension,\n          offset: i.offset,\n          scale: i.scale\n        };\n      }\n    }\n    ev.setPbf = function (t) {\n      tv = t;\n    };\n    class nv {\n      constructor(t, e, r) {\n        this.tasks = t, this._onCancel = e, this._onComplete = r, this._finalized = !1;\n      }\n      cancel() {\n        this._finalized || (this._onCancel(), this._finalized = !0);\n      }\n      complete(t, e) {\n        this._finalized || (this._onComplete(t, e), this._finalized = !0);\n      }\n    }\n    ev.performDecoding = function (t, e) {\n      const r = new Uint8Array(t);\n      return Promise.all(e.tasks.map(t => {\n        const {\n            layerName: e,\n            firstByte: n,\n            lastByte: i,\n            pixelFormat: s,\n            blockShape: a,\n            blockIndex: o,\n            filters: l,\n            codec: u\n          } = t,\n          c = r.subarray(n, i + 1),\n          h = new Uint32Array(a[0] * a[1] * a[2]);\n        let p;\n        if (\"gzip_data\" !== u) throw new Wx(`Unhandled codec: ${u}`);\n        return p = function (t, e) {\n          if (!globalThis.DecompressionStream && \"gzip_data\" === e) return Promise.resolve(((s = function (t) {\n            31 == t[0] && 139 == t[1] && 8 == t[2] || Yx(6, \"invalid gzip data\");\n            var e = t[3],\n              r = 10;\n            4 & e && (r += 2 + (t[10] | t[11] << 8));\n            for (var n = (e >> 3 & 1) + (e >> 4 & 1); n > 0; n -= !t[r++]);\n            return r + (2 & e);\n          }(i = t)) + 8 > i.length && Yx(6, \"invalid gzip data\"), function (t, e, r, n) {\n            var i = t.length;\n            if (!i || e.f && !e.l) return r || new Mx(0);\n            var s = !r,\n              a = s || 2 != e.i,\n              o = e.i;\n            s && (r = new Mx(3 * i));\n            var l,\n              u,\n              c = function (t) {\n                var e = r.length;\n                if (t > e) {\n                  var n = new Mx(Math.max(2 * e, t));\n                  n.set(r), r = n;\n                }\n              },\n              h = e.f || 0,\n              p = e.p || 0,\n              f = e.b || 0,\n              d = e.l,\n              m = e.d,\n              y = e.m,\n              g = e.n,\n              x = 8 * i;\n            do {\n              if (!d) {\n                h = qx(t, p, 1);\n                var v = qx(t, p + 1, 3);\n                if (p += 3, !v) {\n                  var b = t[(T = 4 + ((p + 7) / 8 | 0)) - 4] | t[T - 3] << 8,\n                    _ = T + b;\n                  if (_ > i) {\n                    o && Yx(0);\n                    break;\n                  }\n                  a && c(f + b), r.set(t.subarray(T, _), f), e.b = f += b, e.p = p = 8 * _, e.f = h;\n                  continue;\n                }\n                if (1 == v) d = Nx, m = Ux, y = 9, g = 5;else if (2 == v) {\n                  var w = qx(t, p, 31) + 257,\n                    M = qx(t, p + 10, 15) + 4,\n                    A = w + qx(t, p + 5, 31) + 1;\n                  p += 14;\n                  for (var I = new Mx(A), S = new Mx(19), P = 0; P < M; ++P) S[Ex[P]] = qx(t, p + 3 * P, 7);\n                  p += 3 * M;\n                  var E = jx(S),\n                    z = (1 << E) - 1,\n                    k = Lx(S, E);\n                  for (P = 0; P < A;) {\n                    var T,\n                      B = k[qx(t, p, z)];\n                    if (p += 15 & B, (T = B >> 4) < 16) I[P++] = T;else {\n                      var V = 0,\n                        C = 0;\n                      for (16 == T ? (C = 3 + qx(t, p, 3), p += 2, V = I[P - 1]) : 17 == T ? (C = 3 + qx(t, p, 7), p += 3) : 18 == T && (C = 11 + qx(t, p, 127), p += 7); C--;) I[P++] = V;\n                    }\n                  }\n                  var D = I.subarray(0, w),\n                    R = I.subarray(w);\n                  y = jx(D), g = jx(R), d = Lx(D, y), m = Lx(R, g);\n                } else Yx(1);\n                if (p > x) {\n                  o && Yx(0);\n                  break;\n                }\n              }\n              a && c(f + 131072);\n              for (var L = (1 << y) - 1, F = (1 << g) - 1, O = p;; O = p) {\n                var N = (V = d[$x(t, p) & L]) >> 4;\n                if ((p += 15 & V) > x) {\n                  o && Yx(0);\n                  break;\n                }\n                if (V || Yx(2), N < 256) r[f++] = N;else {\n                  if (256 == N) {\n                    O = p, d = null;\n                    break;\n                  }\n                  var U = N - 254;\n                  N > 264 && (U = qx(t, p, (1 << ($ = Sx[P = N - 257])) - 1) + Tx[P], p += $);\n                  var j = m[$x(t, p) & F],\n                    q = j >> 4;\n                  if (j || Yx(3), p += 15 & j, R = Vx[q], q > 3) {\n                    var $ = Px[q];\n                    R += $x(t, p) & (1 << $) - 1, p += $;\n                  }\n                  if (p > x) {\n                    o && Yx(0);\n                    break;\n                  }\n                  a && c(f + 131072);\n                  var G = f + U;\n                  if (f < R) {\n                    var Y = 0 - R,\n                      H = Math.min(R, G);\n                    for (Y + f < 0 && Yx(3); f < H; ++f) r[f] = (void 0)[Y + f];\n                  }\n                  for (; f < G; ++f) r[f] = r[f - R];\n                }\n              }\n              e.l = d, e.p = O, e.b = f, e.f = h, d && (h = 1, e.m = y, e.d = m, e.n = g);\n            } while (!h);\n            return f != r.length && s ? (l = r, (null == (u = f) || u > l.length) && (u = l.length), new Mx(l.subarray(0, u))) : r.subarray(0, f);\n          }(i.subarray(s, -8), {\n            i: 2\n          }, new Mx(((r = i)[(n = r.length) - 4] | r[n - 3] << 8 | r[n - 2] << 16 | r[n - 1] << 24) >>> 0))));\n          var r, n, i, s;\n          const a = Zx[e];\n          if (!a) throw new Error(`Unhandled codec: ${e}`);\n          const o = new globalThis.DecompressionStream(a);\n          return new Response(new Blob([t]).stream().pipeThrough(o)).arrayBuffer().then(t => new Uint8Array(t));\n        }(c, u).then(t => (function (t, e) {\n          t.readFields(xx, e);\n        }(new tv(t), h), new (0, Qx[s])(h.buffer))), p.then(t => {\n          for (let e = l.length - 1; e >= 0; e--) switch (l[e]) {\n            case \"delta_filter\":\n              bx(t, a);\n              break;\n            case \"zigzag_filter\":\n              _x(t);\n              break;\n            case \"bitshuffle_filter\":\n              wx(t, s);\n              break;\n            default:\n              throw new Wx(`Unhandled filter \"${l[e]}\"`);\n          }\n          return {\n            layerName: e,\n            blockIndex: o,\n            data: t\n          };\n        }).catch(t => {\n          throw t;\n        });\n      }));\n    }, us(nv, \"MRTDecodingBatch\", {\n      omit: [\"_onCancel\", \"_onComplete\"]\n    }), us(ev, \"MapboxRasterTile\"), us(rv, \"MapboxRasterLayer\", {\n      omit: [\"_blocksInProgress\"]\n    });\n    let iv,\n      sv,\n      av,\n      ov,\n      lv,\n      uv = null;\n    function cv() {\n      return yt() && self.worker && self.worker.dracoUrl ? self.worker.dracoUrl : sv || At.DRACO_URL;\n    }\n    function hv() {\n      if (yt() && self.worker && self.worker.meshoptUrl) return self.worker.meshoptUrl;\n      if (ov) return ov;\n      const t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);\n      if (\"object\" != typeof WebAssembly) throw new Error(\"WebAssembly not supported, cannot instantiate meshoptimizer\");\n      return ov = WebAssembly.validate(t) ? At.MESHOPT_SIMD_URL : At.MESHOPT_URL, ov;\n    }\n    const pv = {\n        5120: Int8Array,\n        5121: Uint8Array,\n        5122: Int16Array,\n        5123: Uint16Array,\n        5125: Uint32Array,\n        5126: Float32Array\n      },\n      fv = {\n        5120: \"DT_INT8\",\n        5121: \"DT_UINT8\",\n        5122: \"DT_INT16\",\n        5123: \"DT_UINT16\",\n        5125: \"DT_UINT32\",\n        5126: \"DT_FLOAT32\"\n      },\n      dv = {\n        SCALAR: 1,\n        VEC2: 2,\n        VEC3: 3,\n        VEC4: 4,\n        MAT2: 4,\n        MAT3: 9,\n        MAT4: 16\n      };\n    function mv(t, e, r) {\n      const n = r.json.bufferViews.length,\n        i = r.buffers.length;\n      e.bufferView = n, r.json.bufferViews[n] = {\n        buffer: i,\n        byteLength: t.byteLength\n      }, r.buffers[i] = t;\n    }\n    const yv = \"KHR_draco_mesh_compression\";\n    function gv(t, e) {\n      const r = t.extensions && t.extensions[yv];\n      if (!r) return;\n      const n = new av.Decoder(),\n        i = Av(e, r.bufferView),\n        s = new av.Mesh();\n      if (!n.DecodeArrayToMesh(i, i.byteLength, s)) throw new Error(\"Failed to decode Draco mesh\");\n      const a = e.json.accessors[t.indices],\n        o = pv[a.componentType],\n        l = a.count * o.BYTES_PER_ELEMENT,\n        u = av._malloc(l);\n      o === Uint16Array ? n.GetTrianglesUInt16Array(s, l, u) : n.GetTrianglesUInt32Array(s, l, u), mv(av.memory.buffer.slice(u, u + l), a, e), av._free(u);\n      for (const i of Object.keys(r.attributes)) {\n        const a = n.GetAttributeByUniqueId(s, r.attributes[i]),\n          o = e.json.accessors[t.attributes[i]],\n          l = fv[o.componentType],\n          u = o.count * dv[o.type] * pv[o.componentType].BYTES_PER_ELEMENT,\n          c = av._malloc(u);\n        n.GetAttributeDataArrayForAllPoints(s, a, av[l], u, c), mv(av.memory.buffer.slice(c, c + u), o, e), av._free(c);\n      }\n      n.destroy(), s.destroy(), delete t.extensions[yv];\n    }\n    const xv = \"EXT_meshopt_compression\";\n    function vv(t, e) {\n      if (!t.extensions || !t.extensions[xv]) return;\n      const r = t.extensions[xv],\n        n = new Uint8Array(e.buffers[r.buffer], r.byteOffset || 0, r.byteLength || 0),\n        i = new Uint8Array(r.count * r.byteStride);\n      lv.decodeGltfBuffer(i, r.count, r.byteStride, n, r.mode, r.filter), t.buffer = e.buffers.length, t.byteOffset = 0, e.buffers[t.buffer] = i.buffer, delete t.extensions[xv];\n    }\n    const bv = 1179937895,\n      _v = new TextDecoder(\"utf8\");\n    function wv(t, e) {\n      return new URL(t, e).href;\n    }\n    function Mv(t, e, r, n) {\n      return fetch(wv(t.uri, n)).then(t => t.arrayBuffer()).then(t => {\n        e.buffers[r] = t;\n      });\n    }\n    function Av(t, e) {\n      const r = t.json.bufferViews[e];\n      return new Uint8Array(t.buffers[r.buffer], r.byteOffset || 0, r.byteLength);\n    }\n    function Iv(t, e, r, n) {\n      if (t.uri) {\n        const i = wv(t.uri, n);\n        return fetch(i).then(t => t.blob()).then(t => createImageBitmap(t)).then(t => {\n          e.images[r] = t;\n        });\n      }\n      if (void 0 !== t.bufferView) {\n        const n = Av(e, t.bufferView),\n          i = new Blob([n], {\n            type: t.mimeType\n          });\n        return createImageBitmap(i).then(t => {\n          e.images[r] = t;\n        });\n      }\n    }\n    function Sv(t, e = 0, r) {\n      const n = {\n        json: null,\n        images: [],\n        buffers: []\n      };\n      if (new Uint32Array(t, e, 1)[0] === bv) {\n        const r = new Uint32Array(t, e);\n        let i = 2;\n        const s = (r[i++] >> 2) - 3,\n          a = r[i++] >> 2;\n        if (i++, n.json = JSON.parse(_v.decode(r.subarray(i, i + a))), i += a, i < s) {\n          const s = r[i++];\n          i++;\n          const a = e + (i << 2);\n          n.buffers[0] = t.slice(a, a + s);\n        }\n      } else n.json = JSON.parse(_v.decode(new Uint8Array(t, e)));\n      const {\n        buffers: i,\n        images: s,\n        meshes: a,\n        extensionsUsed: o,\n        bufferViews: l\n      } = n.json;\n      let u = Promise.resolve();\n      if (i) {\n        const t = [];\n        for (let e = 0; e < i.length; e++) {\n          const s = i[e];\n          s.uri ? t.push(Mv(s, n, e, r)) : n.buffers[e] || (n.buffers[e] = null);\n        }\n        u = Promise.all(t);\n      }\n      return u.then(() => {\n        const t = [],\n          e = o && o.includes(yv),\n          i = o && o.includes(xv);\n        if (e && t.push(function () {\n          if (!av) return null != iv ? iv : (iv = function (t) {\n            let e,\n              r = null;\n            function n() {\n              e = new Uint8Array(r.buffer);\n            }\n            function i() {\n              throw new Error(\"Unexpected Draco error.\");\n            }\n            const s = {\n              a: {\n                a: i,\n                d: function (t, r, n) {\n                  return e.copyWithin(t, r, r + n);\n                },\n                c: function (t) {\n                  const i = e.length,\n                    s = Math.max(t >>> 0, Math.ceil(1.2 * i)),\n                    a = Math.ceil((s - i) / 65536);\n                  try {\n                    return r.grow(a), n(), !0;\n                  } catch (t) {\n                    return !1;\n                  }\n                },\n                b: i\n              }\n            };\n            return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t, s) : t.then(t => t.arrayBuffer()).then(t => WebAssembly.instantiate(t, s))).then(t => {\n              const {\n                Rb: i,\n                Qb: s,\n                P: a,\n                T: o,\n                X: l,\n                Ja: u,\n                La: c,\n                Qa: h,\n                Va: p,\n                Wa: f,\n                eb: d,\n                jb: m,\n                f: y,\n                e: g,\n                yb: x,\n                zb: v,\n                Ab: b,\n                Bb: _,\n                Db: w,\n                Gb: M\n              } = t.instance.exports;\n              r = g;\n              const A = (() => {\n                let t = 0,\n                  r = 0,\n                  n = 0,\n                  a = 0;\n                return o => {\n                  n && (i(a), i(t), r += n, n = t = 0), t || (r += 128, t = s(r));\n                  const l = o.length + 7 & -8;\n                  let u = t;\n                  l >= r && (n = l, u = a = s(l));\n                  for (let t = 0; t < o.length; t++) e[u + t] = o[t];\n                  return u;\n                };\n              })();\n              return n(), y(), {\n                memory: g,\n                _free: i,\n                _malloc: s,\n                Mesh: class {\n                  constructor() {\n                    this.ptr = a();\n                  }\n                  destroy() {\n                    o(this.ptr);\n                  }\n                },\n                Decoder: class {\n                  constructor() {\n                    this.ptr = u();\n                  }\n                  destroy() {\n                    m(this.ptr);\n                  }\n                  DecodeArrayToMesh(t, e, r) {\n                    const n = A(t),\n                      i = c(this.ptr, n, e, r.ptr);\n                    return !!l(i);\n                  }\n                  GetAttributeByUniqueId(t, e) {\n                    return {\n                      ptr: h(this.ptr, t.ptr, e)\n                    };\n                  }\n                  GetTrianglesUInt16Array(t, e, r) {\n                    p(this.ptr, t.ptr, e, r);\n                  }\n                  GetTrianglesUInt32Array(t, e, r) {\n                    f(this.ptr, t.ptr, e, r);\n                  }\n                  GetAttributeDataArrayForAllPoints(t, e, r, n, i) {\n                    d(this.ptr, t.ptr, e.ptr, r, n, i);\n                  }\n                },\n                DT_INT8: x(),\n                DT_UINT8: v(),\n                DT_INT16: b(),\n                DT_UINT16: _(),\n                DT_UINT32: w(),\n                DT_FLOAT32: M()\n              };\n            });\n          }(fetch(cv())), iv.then(t => {\n            av = t, iv = void 0;\n          }));\n        }()), i && t.push(function () {\n          if (lv) return;\n          const t = function (t) {\n            let e;\n            const r = WebAssembly.instantiateStreaming(t, {}).then(t => {\n                e = t.instance, e.exports.__wasm_call_ctors();\n              }),\n              n = {\n                NONE: \"\",\n                OCTAHEDRAL: \"meshopt_decodeFilterOct\",\n                QUATERNION: \"meshopt_decodeFilterQuat\",\n                EXPONENTIAL: \"meshopt_decodeFilterExp\"\n              },\n              i = {\n                ATTRIBUTES: \"meshopt_decodeVertexBuffer\",\n                TRIANGLES: \"meshopt_decodeIndexBuffer\",\n                INDICES: \"meshopt_decodeIndexSequence\"\n              };\n            return {\n              ready: r,\n              supported: !0,\n              decodeGltfBuffer(t, r, s, a, o, l) {\n                !function (t, e, r, n, i, s, a) {\n                  const o = t.exports.sbrk,\n                    l = n + 3 & -4,\n                    u = o(l * i),\n                    c = o(s.length),\n                    h = new Uint8Array(t.exports.memory.buffer);\n                  h.set(s, c);\n                  const p = e(u, n, i, c, s.length);\n                  if (0 === p && a && a(u, l, i), r.set(h.subarray(u, u + n * i)), o(u - o(0)), 0 !== p) throw new Error(`Malformed buffer data: ${p}`);\n                }(e, e.exports[i[o]], t, r, s, a, e.exports[n[l]]);\n              }\n            };\n          }(fetch(hv()));\n          return t.ready.then(() => {\n            lv = t;\n          });\n        }()), s) for (let e = 0; e < s.length; e++) t.push(Iv(s[e], n, e, r));\n        return (t.length ? Promise.all(t) : Promise.resolve()).then(() => {\n          if (e && a) for (const {\n            primitives: t\n          } of a) for (const e of t) gv(e, n);\n          if (i && a && l) for (const t of l) vv(t, n);\n          return n;\n        });\n      });\n    }\n    function Pv(t, e) {\n      const r = t.json.bufferViews[e.bufferView],\n        n = pv[e.componentType];\n      return new n(t.buffers[r.buffer], (e.byteOffset || 0) + (r.byteOffset || 0), e.count * (r.byteStride && r.byteStride !== dv[e.type] * n.BYTES_PER_ELEMENT ? r.byteStride / n.BYTES_PER_ELEMENT : dv[e.type]));\n    }\n    function Ev(t, e, r, n) {\n      const i = pv[e.componentType],\n        s = function (t) {\n          switch (t) {\n            case Int8Array:\n              return 1 / 127;\n            case Uint8Array:\n              return 1 / 255;\n            case Int16Array:\n              return 1 / 32767;\n            case Uint16Array:\n              return 1 / 65535;\n            default:\n              return 1;\n          }\n        }(i),\n        a = t.json.bufferViews[e.bufferView],\n        o = a.byteStride ? a.byteStride / i.BYTES_PER_ELEMENT : dv[e.type],\n        l = r.float32,\n        u = l.length / r.capacity;\n      for (let t = 0, r = 0; t < e.count * o; t += o, r += u) for (let e = 0; e < u; e++) l[r + e] = n[t + e] * s;\n      r._trim();\n    }\n    function zv(t, e, r) {\n      const n = t.indices,\n        i = t.attributes,\n        s = {};\n      s.indexArray = new ja();\n      const a = e.json.accessors[n],\n        o = a.count / 3;\n      s.indexArray.reserve(o);\n      const l = Pv(e, a);\n      for (let t = 0; t < o; t++) s.indexArray.emplaceBack(l[3 * t], l[3 * t + 1], l[3 * t + 2]);\n      s.indexArray._trim(), s.vertexArray = new za();\n      const u = e.json.accessors[i.POSITION];\n      s.vertexArray.reserve(u.count);\n      const c = Pv(e, u);\n      for (let t = 0; t < u.count; t++) s.vertexArray.emplaceBack(c[3 * t], c[3 * t + 1], c[3 * t + 2]);\n      if (s.vertexArray._trim(), s.aabb = new Au(u.min, u.max), s.centroid = function (t, e) {\n        const r = [0, 0, 0],\n          n = t.length;\n        if (n > 0) {\n          for (let i = 0; i < n; i++) {\n            const n = 3 * t[i];\n            r[0] += e[n], r[1] += e[n + 1], r[2] += e[n + 2];\n          }\n          r[0] /= n, r[1] /= n, r[2] /= n;\n        }\n        return r;\n      }(l, c), void 0 !== i.COLOR_0) {\n        const t = e.json.accessors[i.COLOR_0],\n          r = dv[t.type],\n          n = Pv(e, t);\n        s.colorArray = 3 === r ? new za() : new Da(), s.colorArray.resize(t.count), Ev(e, t, s.colorArray, n);\n      }\n      if (void 0 !== i.NORMAL) {\n        s.normalArray = new za();\n        const t = e.json.accessors[i.NORMAL];\n        s.normalArray.resize(t.count);\n        const r = Pv(e, t);\n        Ev(e, t, s.normalArray, r);\n      }\n      if (void 0 !== i.TEXCOORD_0 && r.length > 0) {\n        s.texcoordArray = new Za();\n        const t = e.json.accessors[i.TEXCOORD_0];\n        s.texcoordArray.resize(t.count);\n        const r = Pv(e, t);\n        Ev(e, t, s.texcoordArray, r);\n      }\n      if (void 0 !== i._FEATURE_ID_RGBA4444) {\n        const t = e.json.accessors[i._FEATURE_ID_RGBA4444];\n        e.json.extensionsUsed && e.json.extensionsUsed.includes(\"EXT_meshopt_compression\") && (s.featureData = Pv(e, t));\n      }\n      void 0 !== i._FEATURE_RGBA4444 && (s.featureData = new Uint32Array(Pv(e, e.json.accessors[i._FEATURE_RGBA4444]).buffer));\n      const h = t.material;\n      return s.material = function (t, e) {\n        const {\n            emissiveFactor: r = [0, 0, 0],\n            alphaMode: n = \"OPAQUE\",\n            alphaCutoff: i = .5,\n            normalTexture: s,\n            occlusionTexture: a,\n            emissiveTexture: o,\n            doubleSided: l\n          } = t,\n          {\n            baseColorFactor: u = [1, 1, 1, 1],\n            metallicFactor: c = 1,\n            roughnessFactor: h = 1,\n            baseColorTexture: p,\n            metallicRoughnessTexture: f\n          } = t.pbrMetallicRoughness || {},\n          d = a ? e[a.index] : void 0;\n        if (a && a.extensions && a.extensions.KHR_texture_transform && d) {\n          const t = a.extensions.KHR_texture_transform;\n          d.offsetScale = [t.offset[0], t.offset[1], t.scale[0], t.scale[1]];\n        }\n        return {\n          pbrMetallicRoughness: {\n            baseColorFactor: new Se(...u),\n            metallicFactor: c,\n            roughnessFactor: h,\n            baseColorTexture: p ? e[p.index] : void 0,\n            metallicRoughnessTexture: f ? e[f.index] : void 0\n          },\n          doubleSided: l,\n          emissiveFactor: r,\n          alphaMode: n,\n          alphaCutoff: i,\n          normalTexture: s ? e[s.index] : void 0,\n          occlusionTexture: d,\n          emissionTexture: o ? e[o.index] : void 0,\n          defined: void 0 === t.defined\n        };\n      }(void 0 !== h ? e.json.materials[h] : {\n        defined: !1\n      }, r), s;\n    }\n    function kv(t, e, r) {\n      const {\n          matrix: n,\n          rotation: i,\n          translation: s,\n          scale: a,\n          mesh: o,\n          extras: l,\n          children: u\n        } = t,\n        c = {};\n      if (c.matrix = n || O.mat4.fromRotationTranslationScale([], i || [0, 0, 0, 1], s || [0, 0, 0], a || [1, 1, 1]), void 0 !== o) {\n        c.meshes = r[o];\n        const t = c.anchor = [0, 0];\n        for (const e of c.meshes) {\n          const {\n            min: r,\n            max: n\n          } = e.aabb;\n          t[0] += r[0] + n[0], t[1] += r[1] + n[1];\n        }\n        t[0] = Math.floor(t[0] / c.meshes.length / 2), t[1] = Math.floor(t[1] / c.meshes.length / 2);\n      }\n      if (l && (l.id && (c.id = l.id), l.lights && (c.lights = function (t) {\n        if (!t.length) return [];\n        const e = function (t) {\n            const e = atob(t),\n              r = new Uint8Array(e.length);\n            for (let t = 0; t < e.length; t++) r[t] = e.codePointAt(t);\n            return r;\n          }(t),\n          r = [],\n          n = e.length / 24,\n          i = new Uint16Array(e.buffer),\n          s = new Float32Array(e.buffer);\n        for (let t = 0; t < n; t++) {\n          const e = i[2 * t * 6] / 30,\n            n = i[2 * t * 6 + 1] / 30,\n            a = i[2 * t * 6 + 10] / 100,\n            o = s[6 * t + 1],\n            l = s[6 * t + 2],\n            u = s[6 * t + 3],\n            c = s[6 * t + 4],\n            h = u - o,\n            p = c - l,\n            f = Math.hypot(h, p);\n          r.push({\n            pos: [o + .5 * h, l + .5 * p, n],\n            normal: [p / f, -h / f, 0],\n            width: f,\n            height: e,\n            depth: a,\n            points: [o, l, u, c]\n          });\n        }\n        return r;\n      }(l.lights))), u) {\n        const t = [];\n        for (const n of u) t.push(kv(e.json.nodes[n], e, r));\n        c.children = t;\n      }\n      return c;\n    }\n    function Tv(t) {\n      if (0 === t.vertices.length || 0 === t.indices.length) return null;\n      const e = new Sh(t.vertices, t.indices, 8, 256),\n        [r, n] = [e.min.clone(), e.max.clone()];\n      return {\n        vertices: t.vertices,\n        indices: t.indices,\n        grid: e,\n        min: r,\n        max: n\n      };\n    }\n    function Bv(t) {\n      if (!t.extras || !t.extras.ground) return null;\n      const e = t.extras.ground;\n      if (!e || !Array.isArray(e) || 0 === e.length) return null;\n      const r = e[0];\n      if (!r || !Array.isArray(r) || 0 === r.length) return null;\n      const n = [];\n      for (const t of r) {\n        if (!Array.isArray(t) || 2 !== t.length) continue;\n        const e = t[0],\n          r = t[1];\n        \"number\" == typeof e && \"number\" == typeof r && n.push(new q(e, r));\n      }\n      if (n.length < 3) return null;\n      n.length > 1 && n[n.length - 1].equals(n[0]) && n.pop();\n      let i = 0;\n      for (let t = 0; t < n.length; t++) {\n        const e = n[t],\n          r = n[(t + 1) % n.length],\n          s = n[(t + 2) % n.length];\n        i += (e.x - r.x) * (s.y - r.y) - (s.x - r.x) * (e.y - r.y);\n      }\n      i > 0 && n.reverse();\n      const s = vc(n.flatMap(t => [t.x, t.y]), []);\n      return 0 === s.length ? null : {\n        vertices: n,\n        indices: s\n      };\n    }\n    function Vv(t, e) {\n      const r = [],\n        n = [];\n      let i = 0;\n      const s = [];\n      for (const a of t) {\n        i = r.length;\n        const t = a.vertexArray.float32,\n          o = a.indexArray.uint16;\n        for (let n = 0; n < a.vertexArray.length; n++) s[0] = t[3 * n + 0], s[1] = t[3 * n + 1], s[2] = t[3 * n + 2], O.vec3.transformMat4(s, s, e), r.push(new q(s[0], s[1]));\n        for (let t = 0; t < 3 * a.indexArray.length; t++) n.push(o[t] + i);\n      }\n      if (n.length % 3 != 0) return null;\n      for (let t = 0; t < n.length; t += 3) {\n        const e = r[n[t + 0]],\n          i = r[n[t + 1]],\n          s = r[n[t + 2]];\n        (e.x - i.x) * (s.y - i.y) - (s.x - i.x) * (e.y - i.y) > 0 && ([n[t + 1], n[t + 2]] = [n[t + 2], n[t + 1]]);\n      }\n      return {\n        vertices: r,\n        indices: n\n      };\n    }\n    function Cv(t) {\n      const e = function (t, e) {\n          const r = [],\n            n = WebGL2RenderingContext;\n          if (t.json.textures) for (const i of t.json.textures) {\n            const s = {\n              magFilter: n.LINEAR,\n              minFilter: n.NEAREST,\n              wrapS: n.REPEAT,\n              wrapT: n.REPEAT\n            };\n            void 0 !== i.sampler && Object.assign(s, t.json.samplers[i.sampler]), r.push({\n              image: e[i.source],\n              sampler: s,\n              uploaded: !1\n            });\n          }\n          return r;\n        }(t, t.images),\n        r = function (t, e) {\n          const r = [];\n          for (const n of t.json.meshes) {\n            const i = [];\n            for (const r of n.primitives) i.push(zv(r, t, e));\n            r.push(i);\n          }\n          return r;\n        }(t, e),\n        {\n          scenes: n,\n          scene: i,\n          nodes: s\n        } = t.json,\n        a = n ? n[i || 0].nodes : s,\n        o = [];\n      for (const e of a) o.push(kv(s[e], t, r));\n      return function (t, e, r) {\n        const n = {},\n          i = new Set();\n        for (let s = 0; s < t.length; s++) {\n          const t = r[e[s]];\n          if (!t.extras) continue;\n          const a = t.extras[\"mapbox:footprint:version\"],\n            o = t.extras[\"mapbox:footprint:id\"];\n          (a || o) && i.add(s), \"1.0.0\" === a && o && (n[o] = s);\n        }\n        for (let s = 0; s < t.length; s++) {\n          if (i.has(s)) continue;\n          const a = t[s],\n            o = r[e[s]];\n          if (!o.extras) continue;\n          let l = null;\n          a.id in n && (l = Vv(t[n[a.id]].meshes, a.matrix)), l || (l = Bv(o)), l && (a.footprint = Tv(l));\n        }\n        if (i.size > 0) {\n          const e = Array.from(i.values()).sort((t, e) => t - e);\n          for (let r = e.length - 1; r >= 0; r--) t.splice(e[r], 1);\n        }\n      }(o, a, t.json.nodes), o;\n    }\n    function Dv(t) {\n      t.heightmap = new Float32Array(4096), t.heightmap.fill(-1);\n      const e = t.vertexArray.float32,\n        r = t.aabb.min[0] - 1,\n        n = t.aabb.min[1] - 1,\n        i = ky / (t.aabb.max[0] - r + 2),\n        s = ky / (t.aabb.max[1] - n + 2);\n      for (let a = 0; a < e.length; a += 3) {\n        const o = e[a + 2],\n          l = (e[a + 0] - r) * i | 0,\n          u = (e[a + 1] - n) * s | 0;\n        o > t.heightmap[u * ky + l] && (t.heightmap[u * ky + l] = o);\n      }\n    }\n    function Rv(t, e) {\n      const r = {};\n      r.indexArray = new ja(), r.indexArray.reserve(4 * t.length), r.vertexArray = new za(), r.vertexArray.reserve(10 * t.length), r.colorArray = new Da(), r.vertexArray.reserve(10 * t.length);\n      let n = 0;\n      for (const i of t) {\n        const t = Math.min(10, Math.max(4, 1.3 * i.height)) * e,\n          s = [-i.normal[1], i.normal[0], 0],\n          a = Math.min(.29, .1 * i.width / i.depth),\n          o = i.width - 2 * i.depth * e * (a + .01),\n          l = O.vec3.scaleAndAdd([], i.pos, s, o / 2),\n          u = O.vec3.scaleAndAdd([], i.pos, s, -o / 2),\n          c = [l[0], l[1], l[2] + i.height],\n          h = [u[0], u[1], u[2] + i.height],\n          p = O.vec3.scaleAndAdd([], i.normal, s, a);\n        O.vec3.scale(p, p, t);\n        const f = O.vec3.scaleAndAdd([], i.normal, s, -a);\n        O.vec3.scale(f, f, t), O.vec3.add(p, l, p), O.vec3.add(f, u, f), l[2] += .1, u[2] += .1, r.vertexArray.emplaceBack(p[0], p[1], p[2]), r.vertexArray.emplaceBack(f[0], f[1], f[2]), r.vertexArray.emplaceBack(l[0], l[1], l[2]), r.vertexArray.emplaceBack(u[0], u[1], u[2]), r.vertexArray.emplaceBack(c[0], c[1], c[2]), r.vertexArray.emplaceBack(h[0], h[1], h[2]), r.vertexArray.emplaceBack(l[0], l[1], l[2]), r.vertexArray.emplaceBack(u[0], u[1], u[2]), r.vertexArray.emplaceBack(p[0], p[1], p[2]), r.vertexArray.emplaceBack(f[0], f[1], f[2]);\n        const d = o / t / 2;\n        r.colorArray.emplaceBack(-d - a, -1, d, .8), r.colorArray.emplaceBack(d + a, -1, d, .8), r.colorArray.emplaceBack(-d, 0, d, 1.3), r.colorArray.emplaceBack(d, 0, d, 1.3), r.colorArray.emplaceBack(d + a, -.8, d, .7), r.colorArray.emplaceBack(d + a, -.8, d, .7), r.colorArray.emplaceBack(0, 0, d, 1.3), r.colorArray.emplaceBack(0, 0, d, 1.3), r.colorArray.emplaceBack(d + a, -1.2, d, .8), r.colorArray.emplaceBack(d + a, -1.2, d, .8), r.indexArray.emplaceBack(6 + n, 4 + n, 8 + n), r.indexArray.emplaceBack(7 + n, 9 + n, 5 + n), r.indexArray.emplaceBack(0 + n, 1 + n, 2 + n), r.indexArray.emplaceBack(1 + n, 3 + n, 2 + n), n += 10;\n      }\n      const i = {\n          defined: !0,\n          emissiveFactor: [0, 0, 0]\n        },\n        s = {};\n      return s.baseColorFactor = Se.white, i.pbrMetallicRoughness = s, r.material = i, r.aabb = new Au([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), r;\n    }\n    class Lv {\n      constructor(t) {\n        this._stringToNumber = {}, this._numberToString = [];\n        for (let e = 0; e < t.length; e++) {\n          const r = t[e];\n          this._stringToNumber[r] = e, this._numberToString[e] = r;\n        }\n      }\n      encode(t) {\n        return this._stringToNumber[t];\n      }\n      decode(t) {\n        return this._numberToString[t];\n      }\n    }\n    const Fv = [\"id\", \"tile\", \"layer\", \"source\", \"sourceLayer\", \"state\"];\n    class Ov {\n      constructor(t, e, r, n, i) {\n        this.type = \"Feature\", this._vectorTileFeature = t, this._z = e, this._x = r, this._y = n, this.properties = t.properties, this.id = i;\n      }\n      clone() {\n        const t = new Ov(this._vectorTileFeature, this._z, this._x, this._y, this.id);\n        return this.state && (t.state = Object.assign({}, this.state)), this.layer && (t.layer = Object.assign({}, this.layer)), this.source && (t.source = this.source), this.sourceLayer && (t.sourceLayer = this.sourceLayer), t;\n      }\n      get geometry() {\n        return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;\n      }\n      set geometry(t) {\n        this._geometry = t;\n      }\n      toJSON() {\n        const t = {\n          type: \"Feature\",\n          state: void 0,\n          geometry: this.geometry,\n          properties: this.properties\n        };\n        for (const e of Fv) void 0 !== this[e] && (t[e] = this[e]);\n        return t;\n      }\n    }\n    class Nv {\n      constructor(t, e) {\n        this.tileID = t, this.x = t.canonical.x, this.y = t.canonical.y, this.z = t.canonical.z, this.grid = new os(Kr, 16, 0), this.featureIndexArray = new ho(), this.promoteId = e, this.is3DTile = !1, this.serializedLayersCache = new Map();\n      }\n      insert(t, e, r, n, i, s = 0, a = 0) {\n        const o = this.featureIndexArray.length;\n        this.featureIndexArray.emplaceBack(r, n, i, s);\n        const l = this.grid;\n        for (let t = 0; t < e.length; t++) {\n          const r = e[t],\n            n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];\n          for (let t = 0; t < r.length; t++) {\n            const e = r[t];\n            n[0] = Math.min(n[0], e.x), n[1] = Math.min(n[1], e.y), n[2] = Math.max(n[2], e.x), n[3] = Math.max(n[3], e.y);\n          }\n          0 !== a && (n[0] -= a, n[1] -= a, n[2] += a, n[3] += a), n[0] < Kr && n[1] < Kr && n[2] >= 0 && n[3] >= 0 && l.insert(o, n[0], n[1], n[2], n[3]);\n        }\n      }\n      loadVTLayers() {\n        if (!this.vtLayers) {\n          this.vtLayers = new ah.VectorTile(new Cf(this.rawTileData)).layers, this.sourceLayerCoder = new Lv(this.vtLayers ? Object.keys(this.vtLayers).sort() : [\"_geojsonTileLayer\"]), this.vtFeatures = {};\n          for (const t in this.vtLayers) this.vtFeatures[t] = [];\n        }\n        return this.vtLayers;\n      }\n      query(t, e) {\n        const {\n          tilespaceGeometry: r,\n          transform: n,\n          tileTransform: i,\n          pixelPosMatrix: s,\n          availableImages: a\n        } = e;\n        this.loadVTLayers(), this.serializedLayersCache.clear();\n        const o = r.bufferedTilespaceBounds,\n          l = this.grid.query(o.min.x, o.min.y, o.max.x, o.max.y, (t, e, n, i) => Xl(r.bufferedTilespaceGeometry, t, e, n, i));\n        l.sort(jv);\n        let u = null;\n        n.elevation && l.length > 0 && (u = Fy.create(n.elevation, this.tileID));\n        const c = {};\n        let h;\n        for (let e = 0; e < l.length; e++) {\n          const o = l[e];\n          if (o === h) continue;\n          h = o;\n          const p = this.featureIndexArray.get(o);\n          let f = null;\n          this.is3DTile ? this.loadMatchingModelFeature(c, p, t, r, n) : this.loadMatchingFeature(c, p, t, a, (t, e, a, o = 0) => (f || (f = Vl(t, this.tileID.canonical, i)), e.queryIntersectsFeature(r, t, a, f, this.z, n, s, u, o)));\n        }\n        return c;\n      }\n      loadMatchingFeature(t, e, r, n, i) {\n        const {\n            featureIndex: s,\n            bucketIndex: a,\n            sourceLayerIndex: o,\n            layoutVertexArrayOffset: l\n          } = e,\n          u = this.bucketLayerIDs[a],\n          c = r.layers,\n          h = Object.keys(c);\n        if (h.length && !function (t, e) {\n          for (let r = 0; r < t.length; r++) if (e.indexOf(t[r]) >= 0) return !0;\n          return !1;\n        }(h, u)) return;\n        const p = r.sourceCache,\n          f = this.sourceLayerCoder.decode(o),\n          d = this.vtLayers[f].feature(s),\n          m = this.getId(d, f);\n        for (let e = 0; e < u.length; e++) {\n          const r = u[e];\n          if (!c[r]) continue;\n          const {\n            styleLayer: a,\n            targets: o\n          } = c[r];\n          let h = {};\n          void 0 !== m && (h = p.getFeatureState(a.sourceLayer, m));\n          const f = !i || i(d, a, h, l);\n          if (!f) continue;\n          const y = new Ov(d, this.z, this.x, this.y, m);\n          y.tile = this.tileID.canonical, y.state = h;\n          let g = this.serializedLayersCache.get(r);\n          g || (g = a.serialize(), g.id = r, this.serializedLayersCache.set(r, g)), y.source = g.source, y.sourceLayer = g[\"source-layer\"], y.layer = nt({}, g), y.layer.paint = Uv(g.paint, a.paint, d, h, n), y.layer.layout = Uv(g.layout, a.layout, d, h, n);\n          let x = !1;\n          for (const t of o) {\n            this.updateFeatureProperties(y, t);\n            const {\n              filter: e\n            } = t;\n            if (e) if (d.properties = y.properties, e.needGeometry) {\n              const t = Cl(d, !0);\n              if (!e.filter(new Rs(this.tileID.overscaledZ), t, this.tileID.canonical)) continue;\n            } else if (!e.filter(new Rs(this.tileID.overscaledZ), d)) continue;\n            x = !0, t.targetId && this.addFeatureVariant(y, t);\n          }\n          x && this.appendToResult(t, r, s, y, f);\n        }\n      }\n      loadMatchingModelFeature(t, e, r, n, i) {\n        const s = this.bucketLayerIDs[0][0],\n          a = r.layers;\n        if (!a[s]) return;\n        const {\n          styleLayer: o,\n          targets: l\n        } = a[s];\n        if (\"model\" !== o.type) return;\n        const u = n.tile,\n          c = e.featureIndex,\n          h = u.getBucket(o);\n        if (!(h && h instanceof Gy)) return;\n        const p = function (t, e, r, n) {\n          const i = t.getNodesInfo()[e];\n          if (i.hiddenByReplacement || !i.node.meshes) return;\n          let s = Number.MAX_VALUE;\n          const a = i.node,\n            o = r.tile,\n            l = n.calculatePosMatrix(o.tileID.toUnwrapped(), n.worldSize),\n            u = i.evaluatedScale;\n          let c = 0;\n          n.elevation && a.elevation && (c = a.elevation * n.elevation.exaggeration()), O.mat4.translate(l, l, [(a.anchor ? a.anchor[0] : 0) * (u[0] - 1), (a.anchor ? a.anchor[1] : 0) * (u[1] - 1), c]), O.mat4.scale(l, l, u);\n          const h = r.queryGeometry,\n            p = h.isPointQuery() ? h.screenBounds : h.screenGeometry,\n            f = function (t) {\n              const e = O.mat4.multiply([], l, t.matrix);\n              O.mat4.multiply(e, n.expandedFarZProjMatrix, e);\n              for (let r = 0; r < t.meshes.length; ++r) {\n                const i = t.meshes[r];\n                if (r === t.lightMeshIndex) continue;\n                const a = dy(p, n, e, i.aabb);\n                null != a && (s = Math.min(a, s));\n              }\n              if (t.children) for (const e of t.children) f(e);\n            };\n          if (f(a), s === Number.MAX_VALUE) return;\n          const d = new ul(0, 0);\n          return Zy(o.tileID.canonical, d, i.node.anchor[0], i.node.anchor[1]), {\n            intersectionZ: s,\n            position: d,\n            feature: i.feature\n          };\n        }(h, c, n, i);\n        if (!p) return;\n        const {\n            z: f,\n            x: d,\n            y: m\n          } = u.tileID.canonical,\n          {\n            feature: y,\n            intersectionZ: g,\n            position: x\n          } = p;\n        let v = {};\n        void 0 !== y.id && (v = r.sourceCache.getFeatureState(o.sourceLayer, y.id));\n        const b = new Ov({}, f, d, m, y.id);\n        b.tile = this.tileID.canonical, b.state = v, b.properties = y.properties, b.geometry = {\n          type: \"Point\",\n          coordinates: [x.lng, x.lat]\n        };\n        let _ = this.serializedLayersCache.get(s);\n        _ || (_ = o.serialize(), _.id = s, this.serializedLayersCache.set(s, _)), b.source = _.source, b.sourceLayer = _[\"source-layer\"], b.layer = nt({}, _);\n        let w = !1;\n        for (const t of l) {\n          this.updateFeatureProperties(b, t);\n          const {\n            filter: e\n          } = t;\n          if (e) if (y.properties = b.properties, e.needGeometry) {\n            if (!e.filter(new Rs(this.tileID.overscaledZ), y, this.tileID.canonical)) continue;\n          } else if (!e.filter(new Rs(this.tileID.overscaledZ), y)) continue;\n          w = !0, t.targetId && this.addFeatureVariant(b, t);\n        }\n        w && this.appendToResult(t, s, c, b, g);\n      }\n      updateFeatureProperties(t, e, r) {\n        if (e.properties) {\n          const n = {};\n          for (const i in e.properties) {\n            const s = e.properties[i].evaluate({\n              zoom: this.z\n            }, t._vectorTileFeature, t.state, t.tile, r);\n            null != s && (n[i] = s);\n          }\n          t.properties = n;\n        }\n      }\n      addFeatureVariant(t, e, r) {\n        const n = {\n          target: e.target,\n          namespace: e.namespace,\n          uniqueFeatureID: e.uniqueFeatureID\n        };\n        e.properties && (n.properties = t.properties), t.variants = t.variants || {}, t.variants[e.targetId] = t.variants[e.targetId] || [], t.variants[e.targetId].push(n);\n      }\n      appendToResult(t, e, r, n, i) {\n        let s = t[e];\n        void 0 === s && (s = t[e] = []), s.push({\n          featureIndex: r,\n          feature: n,\n          intersectionZ: i\n        });\n      }\n      lookupSymbolFeatures(t, e, r, n, i) {\n        const s = {};\n        this.loadVTLayers();\n        for (const a of t) this.loadMatchingFeature(s, {\n          bucketIndex: e,\n          sourceLayerIndex: r,\n          featureIndex: a,\n          layoutVertexArrayOffset: 0\n        }, n, i);\n        return s;\n      }\n      loadFeature(t) {\n        const {\n          featureIndex: e,\n          sourceLayerIndex: r\n        } = t;\n        this.loadVTLayers();\n        const n = this.sourceLayerCoder.decode(r),\n          i = this.vtFeatures[n];\n        if (i[e]) return i[e];\n        const s = this.vtLayers[n].feature(e);\n        return i[e] = s, s;\n      }\n      hasLayer(t) {\n        for (const e of this.bucketLayerIDs) for (const r of e) if (t === r) return !0;\n        return !1;\n      }\n      getId(t, e) {\n        let r = t.id;\n        if (this.promoteId) {\n          const n = Array.isArray(this.promoteId) || \"object\" != typeof this.promoteId ? this.promoteId : this.promoteId[e];\n          if (null != n) if (Array.isArray(n)) {\n            if (!this.promoteIdExpression) {\n              const t = Ji(n);\n              if (\"success\" !== t.result) {\n                const e = t.value.map(t => `${t.key}: ${t.message}`).join(\", \");\n                return void pt(`Failed to create expression for promoteId: ${e}`);\n              }\n              this.promoteIdExpression = t.value;\n            }\n            this.promoteIdExpression._evaluator || (this.promoteIdExpression._evaluator = new yr()), r = this.promoteIdExpression.evaluate({\n              zoom: 0\n            }, t);\n          } else r = t.properties[n];\n          \"boolean\" == typeof r && (r = Number(r));\n        }\n        return r;\n      }\n    }\n    function Uv(t, e, r, n, i) {\n      return lt(t, (t, s) => {\n        const a = e instanceof $s ? e.get(s) : null;\n        return a && a.evaluate ? a.evaluate(r, n, i) : a;\n      });\n    }\n    function jv(t, e) {\n      return e - t;\n    }\n    us(Nv, \"FeatureIndex\", {\n      omit: [\"rawTileData\", \"sourceLayerCoder\"]\n    });\n    const qv = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\n    class $v {\n      static from(t) {\n        if (!(t instanceof ArrayBuffer)) throw new Error(\"Data must be an instance of ArrayBuffer.\");\n        const [e, r] = new Uint8Array(t, 0, 2);\n        if (219 !== e) throw new Error(\"Data does not appear to be in a KDBush format.\");\n        const n = r >> 4;\n        if (1 !== n) throw new Error(`Got v${n} data when expected v1.`);\n        const i = qv[15 & r];\n        if (!i) throw new Error(\"Unrecognized array type.\");\n        const [s] = new Uint16Array(t, 2, 1),\n          [a] = new Uint32Array(t, 4, 1);\n        return new $v(a, s, i, t);\n      }\n      constructor(t, e = 64, r = Float64Array, n) {\n        if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);\n        this.numItems = +t, this.nodeSize = Math.min(Math.max(+e, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;\n        const i = qv.indexOf(this.ArrayType),\n          s = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,\n          a = t * this.IndexArrayType.BYTES_PER_ELEMENT,\n          o = (8 - a % 8) % 8;\n        if (i < 0) throw new Error(`Unexpected typed array class: ${r}.`);\n        n && n instanceof ArrayBuffer ? (this.data = n, this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + a + o, 2 * t), this._pos = 2 * t, this._finished = !0) : (this.data = new ArrayBuffer(8 + s + a + o), this.ids = new this.IndexArrayType(this.data, 8, t), this.coords = new this.ArrayType(this.data, 8 + a + o, 2 * t), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + i]), new Uint16Array(this.data, 2, 1)[0] = e, new Uint32Array(this.data, 4, 1)[0] = t);\n      }\n      add(t, e) {\n        const r = this._pos >> 1;\n        return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = e, r;\n      }\n      finish() {\n        const t = this._pos >> 1;\n        if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);\n        return Gv(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;\n      }\n      range(t, e, r, n) {\n        if (!this._finished) throw new Error(\"Data not yet indexed - call index.finish().\");\n        const {\n            ids: i,\n            coords: s,\n            nodeSize: a\n          } = this,\n          o = [0, i.length - 1, 0],\n          l = [];\n        for (; o.length;) {\n          const u = o.pop() || 0,\n            c = o.pop() || 0,\n            h = o.pop() || 0;\n          if (c - h <= a) {\n            for (let a = h; a <= c; a++) {\n              const o = s[2 * a],\n                u = s[2 * a + 1];\n              o >= t && o <= r && u >= e && u <= n && l.push(i[a]);\n            }\n            continue;\n          }\n          const p = h + c >> 1,\n            f = s[2 * p],\n            d = s[2 * p + 1];\n          f >= t && f <= r && d >= e && d <= n && l.push(i[p]), (0 === u ? t <= f : e <= d) && (o.push(h), o.push(p - 1), o.push(1 - u)), (0 === u ? r >= f : n >= d) && (o.push(p + 1), o.push(c), o.push(1 - u));\n        }\n        return l;\n      }\n      within(t, e, r) {\n        if (!this._finished) throw new Error(\"Data not yet indexed - call index.finish().\");\n        const {\n            ids: n,\n            coords: i,\n            nodeSize: s\n          } = this,\n          a = [0, n.length - 1, 0],\n          o = [],\n          l = r * r;\n        for (; a.length;) {\n          const u = a.pop() || 0,\n            c = a.pop() || 0,\n            h = a.pop() || 0;\n          if (c - h <= s) {\n            for (let r = h; r <= c; r++) Zv(i[2 * r], i[2 * r + 1], t, e) <= l && o.push(n[r]);\n            continue;\n          }\n          const p = h + c >> 1,\n            f = i[2 * p],\n            d = i[2 * p + 1];\n          Zv(f, d, t, e) <= l && o.push(n[p]), (0 === u ? t - r <= f : e - r <= d) && (a.push(h), a.push(p - 1), a.push(1 - u)), (0 === u ? t + r >= f : e + r >= d) && (a.push(p + 1), a.push(c), a.push(1 - u));\n        }\n        return o;\n      }\n    }\n    function Gv(t, e, r, n, i, s) {\n      if (i - n <= r) return;\n      const a = n + i >> 1;\n      Yv(t, e, a, n, i, s), Gv(t, e, r, n, a - 1, 1 - s), Gv(t, e, r, a + 1, i, 1 - s);\n    }\n    function Yv(t, e, r, n, i, s) {\n      for (; i > n;) {\n        if (i - n > 600) {\n          const a = i - n + 1,\n            o = r - n + 1,\n            l = Math.log(a),\n            u = .5 * Math.exp(2 * l / 3),\n            c = .5 * Math.sqrt(l * u * (a - u) / a) * (o - a / 2 < 0 ? -1 : 1);\n          Yv(t, e, r, Math.max(n, Math.floor(r - o * u / a + c)), Math.min(i, Math.floor(r + (a - o) * u / a + c)), s);\n        }\n        const a = e[2 * r + s];\n        let o = n,\n          l = i;\n        for (Hv(t, e, n, r), e[2 * i + s] > a && Hv(t, e, n, i); o < l;) {\n          for (Hv(t, e, o, l), o++, l--; e[2 * o + s] < a;) o++;\n          for (; e[2 * l + s] > a;) l--;\n        }\n        e[2 * n + s] === a ? Hv(t, e, n, l) : (l++, Hv(t, e, l, i)), l <= r && (n = l + 1), r <= l && (i = l - 1);\n      }\n    }\n    function Hv(t, e, r, n) {\n      Xv(t, r, n), Xv(e, 2 * r, 2 * n), Xv(e, 2 * r + 1, 2 * n + 1);\n    }\n    function Xv(t, e, r) {\n      const n = t[e];\n      t[e] = t[r], t[r] = n;\n    }\n    function Zv(t, e, r, n) {\n      const i = t - r,\n        s = e - n;\n      return i * i + s * s;\n    }\n    t.$ = gr, t.A = ge, t.B = tr, t.C = pa, t.D = ng, t.E = _e, t.F = 2, t.G = pd, t.H = cd, t.I = we, t.J = class extends My {}, t.K = pr, t.L = Be, t.M = Ws, t.N = Ui, t.O = Fi, t.P = q, t.Q = Ni, t.R = Qt, t.S = Ki, t.T = qm, t.U = Ks, t.V = My, t.W = es, t.X = Ji, t.Y = Vn, t.Z = Dn, t._ = Bn, t.a = function (t) {\n      return At.API_CDN_URL_REGEX.test(t);\n    }, t.a$ = Cl, t.a0 = Ie, t.a1 = Js, t.a2 = ji, t.a3 = Oi, t.a4 = function (t) {\n      const e = t.value;\n      let r = [];\n      if (!e) return r;\n      const n = pr(e);\n      return \"string\" !== n ? (r = r.concat([new My(t.key, e, `string expected, \"${n}\" found`)]), r) : (Ay(e, !0) || (r = r.concat([new My(t.key, e, `invalid url \"${e}\"`)])), r);\n    }, t.a5 = Zs, t.a6 = Os, t.a7 = Xs, t.a8 = Gs, t.a9 = class {\n      constructor(t) {\n        this.specification = t;\n      }\n      possiblyEvaluate(t, e) {\n        return mt(t.expression.evaluate(e));\n      }\n      interpolate(t, e, r) {\n        return {\n          x: Ee(t.x, e.x, r),\n          y: Ee(t.y, e.y, r),\n          z: Ee(t.z, e.z, r),\n          azimuthal: Ee(t.azimuthal, e.azimuthal, r),\n          polar: Ee(t.polar, e.polar, r)\n        };\n      }\n    }, t.aA = function (t, e) {\n      const r = {};\n      for (let n = 0; n < e.length; n++) {\n        const i = e[n];\n        i in t && (r[i] = t[i]);\n      }\n      return r;\n    }, t.aB = cl, t.aC = ml, t.aD = class {\n      constructor(t) {\n        this.entries = {}, this.scheduler = t;\n      }\n      request(t, e, r, n) {\n        const i = this.entries[t] = this.entries[t] || {\n          callbacks: []\n        };\n        if (i.result) {\n          const [t, r] = i.result;\n          return this.scheduler ? this.scheduler.add(() => {\n            n(t, r);\n          }, e) : n(t, r), () => {};\n        }\n        return i.callbacks.push(n), i.cancel || (i.cancel = r((r, n) => {\n          i.result = [r, n];\n          for (const t of i.callbacks) this.scheduler ? this.scheduler.add(() => {\n            t(r, n);\n          }, e) : t(r, n);\n          setTimeout(() => delete this.entries[t], 3e3);\n        })), () => {\n          i.result || (i.callbacks = i.callbacks.filter(t => t !== n), i.callbacks.length || (i.cancel(), delete this.entries[t]));\n        };\n      }\n    }, t.aE = function (t, e, r) {\n      const n = JSON.stringify(t.request);\n      return t.data && (this.deduped.entries[n] = {\n        result: [null, t.data]\n      }), this.deduped.request(n, {\n        type: \"parseTile\",\n        isSymbolTile: t.isSymbolTile,\n        zoom: t.tileZoom\n      }, e => {\n        const n = ne(t.request, (t, n, i, s) => {\n          t ? e(t) : n && e(null, {\n            vectorTile: r ? void 0 : new ah.VectorTile(new Cf(n)),\n            rawData: n,\n            cacheControl: i,\n            expires: s\n          });\n        });\n        return () => {\n          n.cancel(), e();\n        };\n      }, e);\n    }, t.aF = function (t) {\n      Gt++, Gt > Ot && (t.getActor().send(\"enforceCacheSizeLimit\", Ft), Gt = 0);\n    }, t.aG = function (t) {\n      return t <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t) / Math.LN2));\n    }, t.aH = uu, t.aI = Wm, t.aJ = ry, t.aK = Xm, t.aL = function (t, e) {\n      const r = document.createElement(\"video\");\n      r.muted = !0, r.onloadstart = function () {\n        e(null, r);\n      };\n      for (let e = 0; e < t.length; e++) {\n        const n = document.createElement(\"source\");\n        ie(t[e]) || (r.crossOrigin = \"Anonymous\"), n.src = t[e], r.appendChild(n);\n      }\n      return {\n        cancel: () => {}\n      };\n    }, t.aM = $m, t.aN = function (t) {\n      return fetch(t).then(t => t.arrayBuffer()).then(e => Sv(e, 0, t));\n    }, t.aO = Cv, t.aP = class {\n      constructor(t, e, r, n) {\n        this.id = t, this.position = null != e ? new ul(e[0], e[1]) : new ul(0, 0), this.orientation = null != r ? r : [0, 0, 0], this.nodes = n, this.uploaded = !1, this.aabb = new Au([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), this.matrix = [];\n      }\n      _applyTransformations(t, e) {\n        if (O.mat4.multiply(t.matrix, e, t.matrix), t.meshes) for (const e of t.meshes) {\n          const r = Au.applyTransformFast(e.aabb, t.matrix);\n          this.aabb.encapsulate(r);\n        }\n        if (t.children) for (const e of t.children) this._applyTransformations(e, t.matrix);\n      }\n      computeBoundsAndApplyParent() {\n        const t = O.mat4.identity([]);\n        for (const e of this.nodes) this._applyTransformations(e, t);\n      }\n      computeModelMatrix(t, e, r, n, i, s, a = !1) {\n        By(this.matrix, this, t.transform, this.position, e, r, n, i, s, a);\n      }\n      upload(t) {\n        if (!this.uploaded) {\n          for (const e of this.nodes) Dy(e, t);\n          for (const t of this.nodes) Ry(t);\n          this.uploaded = !0;\n        }\n      }\n      destroy() {\n        for (const t of this.nodes) Ly(t);\n      }\n    }, t.aQ = ot, t.aR = Kd, t.aS = gl, t.aT = xl, t.aU = Ma, t.aV = ja, t.aW = st, t.aX = no, t.aY = zm, t.aZ = function () {\n      Ds.isLoading() || Ds.isLoaded() || \"deferred\" !== Vs() || Cs();\n    }, t.a_ = Qs, t.aa = Rs, t.ab = ts, t.ac = Il, t.ad = O, t.ae = tt, t.af = $s, t.ag = $u, t.ah = Ee, t.ai = Kr, t.aj = ze, t.ak = H, t.al = Se, t.am = class {\n      constructor(t) {\n        this.specification = t;\n      }\n      possiblyEvaluate(t, e) {\n        return function ([t, e]) {\n          const r = mt([1, t, e]);\n          return {\n            x: r.x,\n            y: r.y,\n            z: r.z\n          };\n        }(t.expression.evaluate(e));\n      }\n      interpolate(t, e, r) {\n        return {\n          x: Ee(t.x, e.x, r),\n          y: Ee(t.y, e.y, r),\n          z: Ee(t.z, e.z, r)\n        };\n      }\n    }, t.an = function (t, e, r = 0, n = !0) {\n      const i = new q(r, r),\n        s = t.sub(i),\n        a = e.add(i),\n        o = [s, new q(a.x, s.y), a, new q(s.x, a.y)];\n      return n && o.push(s.clone()), o;\n    }, t.ao = function (t, e) {\n      const r = [];\n      for (let n = 0; n < t.length; n++) {\n        const i = et(n - 1, -1, t.length - 1),\n          s = et(n + 1, -1, t.length - 1),\n          a = t[n],\n          o = t[s],\n          l = t[i].sub(a).unit(),\n          u = o.sub(a).unit(),\n          c = u.angleWithSep(l.x, l.y),\n          h = l.add(u).unit().mult(-1 * e / Math.sin(c / 2));\n        r.push(a.add(h));\n      }\n      return r;\n    }, t.ap = Jd, t.aq = Xl, t.ar = function (t, e, r = 0) {\n      return O.vec3.fromValues(((e.x - r) * t.scale - t.x) * Kr, (e.y * t.scale - t.y) * Kr, vl(e.z, e.y));\n    }, t.as = gu, t.at = Wp, t.au = function (t) {\n      let e = 1 / 0,\n        r = 1 / 0,\n        n = -1 / 0,\n        i = -1 / 0;\n      for (const s of t) e = Math.min(e, s.x), r = Math.min(r, s.y), n = Math.max(n, s.x), i = Math.max(i, s.y);\n      return {\n        min: new q(e, r),\n        max: new q(n, i)\n      };\n    }, t.av = dl, t.aw = Hl, t.ax = Pl, t.ay = Q, t.az = Ko, t.b = function (t) {\n      return At.API_FONTS_REGEX.test(t);\n    }, t.b$ = oy, t.b0 = Ov, t.b1 = gt, t.b2 = Yp, t.b3 = _h, t.b4 = Vl, t.b5 = _a, t.b6 = Ka, t.b7 = mu, t.b8 = xo, t.b9 = vc, t.bA = Jh, t.bB = Nd, t.bC = Cd, t.bD = Kf, t.bE = $v, t.bF = et, t.bG = vt, t.bH = yl, t.bI = function (t, e, r) {\n      t[4 * e + 0] = r[0], t[4 * e + 1] = r[1], t[4 * e + 2] = r[2], t[4 * e + 3] = r[3];\n    }, t.bJ = Co, t.bK = zo, t.bL = ko, t.bM = Eo, t.bN = Po, t.bO = ul, t.bP = vm, t.bQ = lu, t.bR = Mu, t.bS = ay, t.bT = ou, t.bU = Vu, t.bV = function (t, e, r, n, i, s, a, o, l) {\n      if (\"globe\" === l.name) return Vu(t, e, new ou(r, n, i), !1);\n      const u = Kd({\n        z: r,\n        x: n,\n        y: i\n      }, l);\n      return new Au([(s + u.x / u.scale) * e, e * (u.y / u.scale), a], [(s + u.x2 / u.scale) * e, e * (u.y2 / u.scale), o]);\n    }, t.bW = function (t, e, r) {\n      let n = 0;\n      for (let r = 0; r < 2; ++r) {\n        const i = 0;\n        t[r] > i && (n += (t[r] - i) * (t[r] - i)), e[r] < i && (n += (i - e[r]) * (i - e[r]));\n      }\n      return n;\n    }, t.bX = bl, t.bY = Qo, t.bZ = function (t) {\n      const e = O.mat4.identity(new Float64Array(16));\n      O.mat4.multiply(e, t.pixelMatrix, t.globeMatrix);\n      const r = [0, nl, 0],\n        n = [0, il, 0];\n      return O.vec3.transformMat4(r, r, e), O.vec3.transformMat4(n, n, e), [r[0] > 0 && r[0] <= t.width && r[1] > 0 && r[1] <= t.height && !Yu(t, new ul(t.center.lat, 90)), n[0] > 0 && n[0] <= t.width && n[1] > 0 && n[1] <= t.height && !Yu(t, new ul(t.center.lat, -90))];\n    }, t.b_ = function (t, e) {\n      const {\n          scale: r\n        } = t.tileTransform,\n        n = r * Kr / (t.tileSize * Math.pow(2, e.zoom - t.tileID.overscaledZ + t.tileID.canonical.z));\n      return O.mat2.scale(new Float32Array(4), e.inverseAdjustmentMatrix, [n, n]);\n    }, t.ba = Nm, t.bb = function (t, e) {\n      const r = $u(e.zoom);\n      if (0 === r) return ku(t);\n      const n = Cu(t),\n        i = Du(n),\n        s = dl(n.getWest()) * e.worldSize,\n        a = dl(n.getEast()) * e.worldSize,\n        o = ml(n.getNorth()) * e.worldSize,\n        l = ml(n.getSouth()) * e.worldSize,\n        u = [s, o, 0],\n        c = [a, o, 0],\n        h = [s, l, 0],\n        p = [a, l, 0],\n        f = O.mat4.invert([], e.globeMatrix);\n      return O.vec3.transformMat4(u, u, f), O.vec3.transformMat4(c, c, f), O.vec3.transformMat4(h, h, f), O.vec3.transformMat4(p, p, f), i[0] = Tu(i[0], h, r), i[1] = Tu(i[1], p, r), i[2] = Tu(i[2], c, r), i[3] = Tu(i[3], u, r), Au.fromPoints(i);\n    }, t.bc = Ou, t.bd = Ru, t.be = Tu, t.bf = wa, t.bg = du, t.bh = ev, t.bi = Cf, t.bj = ne, t.bk = function (t, e) {\n      const r = [];\n      for (const n in t) n in e || r.push(n);\n      return r;\n    }, t.bl = rt, t.bm = [\"type\", \"source\", \"source-layer\", \"minzoom\", \"maxzoom\", \"filter\", \"layout\"], t.bn = $, t.bo = function (t, e) {\n      const {\n          x: r,\n          y: n\n        } = t.point,\n        i = qu(r, n, t.worldSize / t._pixelsPerMercatorPixel, 0, 0);\n      return O.mat4.multiply(i, i, Nu(ku(e)));\n    }, t.bp = wf, t.bq = Nf, t.br = _f, t.bs = function (t, e, r, n, i) {\n      const s = 5 * e + 2;\n      t.float32[s + 0] = r, t.float32[s + 1] = n, t.float32[s + 2] = i;\n    }, t.bt = Im, t.bu = ud, t.bv = Fl, t.bw = gf, t.bx = jh, t.by = wy, t.bz = Kh, t.c = St, t.c$ = tf, t.c0 = sy, t.c1 = function (t) {\n      const e = sy(t, !0);\n      return O.mat2.invert([], [e[0], e[1], e[4], e[5]]);\n    }, t.c2 = xu, t.c3 = function (t) {\n      const {\n          x: e,\n          y: r\n        } = t.point,\n        {\n          lng: n,\n          lat: i\n        } = t._center;\n      return qu(e, r, t.worldSize, n, i);\n    }, t.c4 = X, t.c5 = cu, t.c6 = Jo, t.c7 = function (t) {\n      const e = Math.round((t + 45 + 360) % 360 / 90) % 4;\n      return Z[e];\n    }, t.c8 = 45, t.c9 = ke, t.cA = Bo, t.cB = class extends So {\n      constructor(t) {\n        super(t), this.current = Do;\n      }\n      set(t, e, r) {\n        if (this.fetchUniformLocation(t, e)) for (let t = 0; t < 9; t++) if (r[t] !== this.current[t]) {\n          this.current = r, this.gl.uniformMatrix3fv(this.location, !1, r);\n          break;\n        }\n      }\n    }, t.cC = W, t.cD = function (t, e, r) {\n      const n = $u(r.zoom),\n        i = t.style.map._antialias,\n        s = t.terrain && t.terrain.exaggeration() > 0;\n      return 0 === n && !i && !s;\n    }, t.cE = function (t) {\n      const e = t.pixelsPerMeter,\n        r = e / yl(1, t.center.lat),\n        n = O.mat4.identity(new Float64Array(16));\n      return O.mat4.translate(n, n, [t.point.x, t.point.y, 0]), O.mat4.scale(n, n, [r, r, e]), Float32Array.from(n);\n    }, t.cF = Cu, t.cG = function (t) {\n      const e = bl - 5;\n      t = Q(t, -e, e) / e * 90;\n      const r = Math.pow(Math.abs(Math.sin(H(t))), 3);\n      return Math.round(r * (rl.length - 1));\n    }, t.cH = function (t, e, r, n) {\n      const i = e.getNorth(),\n        s = e.getSouth(),\n        a = e.getWest(),\n        o = e.getEast(),\n        l = 1 << t.z,\n        u = o - a,\n        c = i - s,\n        h = u / el,\n        p = -c / rl[r],\n        f = [0, h, 0, p, 0, 0, i, a, 0];\n      if (t.z > 0) {\n        const t = 180 / n;\n        O.mat3.multiply(f, f, [t / u + 1, 0, 0, 0, t / c + 1, 0, -.5 * t / h, .5 * t / p, 1]);\n      }\n      return f[2] = l, f[5] = t.x, f[8] = t.y, f;\n    }, t.cI = ku, t.cJ = function (t, e, r) {\n      const n = O.mat4.identity(new Float64Array(16)),\n        i = (e / (1 << t) - .5) * Math.PI * 2;\n      return O.mat4.rotateY(n, r.globeMatrix, i), Float32Array.from(n);\n    }, t.cK = class {\n      isDataAvailableAtPoint(t) {\n        const e = this._source();\n        if (this.isUsingMockSource() || !e || t.y < 0 || t.y > 1) return !1;\n        const r = e.getSource().maxzoom,\n          n = 1 << r,\n          i = Math.floor(t.x),\n          s = Math.floor((t.x - i) * n),\n          a = Math.floor(t.y * n),\n          o = this.findDEMTileFor(new uu(r, i, r, s, a));\n        return !(!o || !o.dem);\n      }\n      getAtPointOrZero(t, e = 0) {\n        return this.getAtPoint(t, e) || 0;\n      }\n      getAtPoint(t, e, r = !0) {\n        if (this.isUsingMockSource()) return null;\n        null == e && (e = null);\n        const n = this._source();\n        if (!n) return e;\n        if (t.y < 0 || t.y > 1) return e;\n        const i = n.getSource().maxzoom,\n          s = 1 << i,\n          a = Math.floor(t.x),\n          o = t.x - a,\n          l = new uu(i, a, i, Math.floor(o * s), Math.floor(t.y * s)),\n          u = this.findDEMTileFor(l);\n        if (!u || !u.dem) return e;\n        const c = u.dem,\n          h = 1 << u.tileID.canonical.z,\n          p = (o * h - u.tileID.canonical.x) * c.dim,\n          f = (t.y * h - u.tileID.canonical.y) * c.dim,\n          d = Math.floor(p),\n          m = Math.floor(f);\n        return (r ? this.exaggeration() : 1) * Ee(Ee(c.get(d, m), c.get(d, m + 1), f - m), Ee(c.get(d + 1, m), c.get(d + 1, m + 1), f - m), p - d);\n      }\n      getAtTileOffset(t, e, r) {\n        const n = 1 << t.canonical.z;\n        return this.getAtPointOrZero(new Il(t.wrap + (t.canonical.x + e / Kr) / n, (t.canonical.y + r / Kr) / n));\n      }\n      getAtTileOffsetFunc(t, e, r, n) {\n        return i => {\n          const s = this.getAtTileOffset(t, i.x, i.y),\n            a = n.upVector(t.canonical, i.x, i.y),\n            o = n.upVectorScale(t.canonical, e, r).metersToTile;\n          return O.vec3.scale(a, a, s * o), a;\n        };\n      }\n      getForTilePoints(t, e, r, n) {\n        if (this.isUsingMockSource()) return !1;\n        const i = Fy.create(this, t, n);\n        return !!i && (e.forEach(t => {\n          t[2] = this.exaggeration() * i.getElevationAt(t[0], t[1], r);\n        }), !0);\n      }\n      getMinMaxForTile(t) {\n        if (this.isUsingMockSource()) return null;\n        const e = this.findDEMTileFor(t);\n        if (!e || !e.dem) return null;\n        const r = e.dem.tree,\n          n = e.tileID,\n          i = 1 << t.canonical.z - n.canonical.z;\n        let s = t.canonical.x / i - n.canonical.x,\n          a = t.canonical.y / i - n.canonical.y,\n          o = 0;\n        for (let e = 0; e < t.canonical.z - n.canonical.z && !r.leaves[o]; e++) {\n          s *= 2, a *= 2;\n          const t = 2 * Math.floor(a) + Math.floor(s);\n          o = r.childOffsets[o] + t, s %= 1, a %= 1;\n        }\n        return {\n          min: this.exaggeration() * r.minimums[o],\n          max: this.exaggeration() * r.maximums[o]\n        };\n      }\n      getMinElevationBelowMSL() {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      raycast(t, e, r) {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      pointCoordinate(t) {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      _source() {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      isUsingMockSource() {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      exaggeration() {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      findDEMTileFor(t) {\n        throw new Error(\"Pure virtual method called.\");\n      }\n      get visibleDemTiles() {\n        throw new Error(\"Getter must be implemented in subclass.\");\n      }\n      getMinMaxForVisibleTiles() {\n        const t = this.visibleDemTiles;\n        if (0 === t.length) return null;\n        let e = !1,\n          r = Number.MAX_VALUE,\n          n = Number.MIN_VALUE;\n        for (const i of t) {\n          const t = this.getMinMaxForTile(i.tileID);\n          t && (r = Math.min(r, t.min), n = Math.max(n, t.max), e = !0);\n        }\n        return e ? {\n          min: r,\n          max: n\n        } : null;\n      }\n    }, t.cL = fc, t.cM = Iu, t.cN = function (t, e) {\n      return [Math.pow(t[0], 2.2) * e, Math.pow(t[1], 2.2) * e, Math.pow(t[2], 2.2) * e];\n    }, t.cO = ju, t.cP = Mt, t.cQ = wt, t.cR = 256, t.cS = function (t, e) {\n      const r = [0, 0, 0],\n        n = Ou(ku(e.canonical));\n      return O.vec3.transformMat4(r, r, n), O.vec3.transformMat4(r, r, t), r;\n    }, t.cT = t => ({\n      u_camera_to_center_distance: new Eo(t),\n      u_extrude_scale: new Lo(t),\n      u_device_pixel_ratio: new Eo(t),\n      u_matrix: new Co(t),\n      u_inv_rot_matrix: new Co(t),\n      u_merc_center: new zo(t),\n      u_tile_id: new ko(t),\n      u_zoom_transition: new Eo(t),\n      u_up_dir: new ko(t),\n      u_emissive_strength: new Eo(t)\n    }), t.cU = t => ({\n      u_matrix: new Co(t),\n      u_pixels_to_tile_units: new Lo(t),\n      u_device_pixel_ratio: new Eo(t),\n      u_width_scale: new Eo(t),\n      u_floor_width_scale: new Eo(t),\n      u_units_to_pixels: new zo(t),\n      u_dash_image: new Po(t),\n      u_gradient_image: new Po(t),\n      u_image_height: new Eo(t),\n      u_texsize: new zo(t),\n      u_tile_units_to_pixels: new Eo(t),\n      u_alpha_discard_threshold: new Eo(t),\n      u_trim_offset: new zo(t),\n      u_trim_fade_range: new zo(t),\n      u_trim_color: new To(t),\n      u_emissive_strength: new Eo(t),\n      u_zbias_factor: new Eo(t),\n      u_tile_to_meter: new Eo(t)\n    }), t.cV = t => ({\n      u_matrix: new Co(t),\n      u_texsize: new zo(t),\n      u_pixels_to_tile_units: new Lo(t),\n      u_device_pixel_ratio: new Eo(t),\n      u_width_scale: new Eo(t),\n      u_floor_width_scale: new Eo(t),\n      u_image: new Po(t),\n      u_units_to_pixels: new zo(t),\n      u_tile_units_to_pixels: new Eo(t),\n      u_alpha_discard_threshold: new Eo(t),\n      u_trim_offset: new zo(t),\n      u_trim_fade_range: new zo(t),\n      u_trim_color: new To(t),\n      u_emissive_strength: new Eo(t),\n      u_zbias_factor: new Eo(t),\n      u_tile_to_meter: new Eo(t)\n    }), t.cW = Na, t.cX = yf, t.cY = Mf, t.cZ = Ku, t.c_ = (t, e, r, n, i, s) => {\n      const a = t.transform,\n        o = \"globe\" === a.projection.name;\n      let l;\n      if (\"map\" === s.paint.get(\"circle-pitch-alignment\")) {\n        if (o) {\n          const t = ju(a.zoom, e.canonical) * a._pixelsPerMercatorPixel;\n          l = Float32Array.from([t, 0, 0, t]);\n        } else l = a.calculatePixelsToTileUnitsMatrix(r);\n      } else l = new Float32Array([a.pixelsToGLUnits[0], 0, 0, a.pixelsToGLUnits[1]]);\n      const u = {\n        u_camera_to_center_distance: t.transform.getCameraToCenterDistance(a.projection),\n        u_matrix: t.translatePosMatrix(e.projMatrix, r, s.paint.get(\"circle-translate\"), s.paint.get(\"circle-translate-anchor\")),\n        u_device_pixel_ratio: Ct.devicePixelRatio,\n        u_extrude_scale: l,\n        u_inv_rot_matrix: Wu,\n        u_merc_center: [0, 0],\n        u_tile_id: [0, 0, 0],\n        u_zoom_transition: 0,\n        u_up_dir: [0, 0, 0],\n        u_emissive_strength: s.paint.get(\"circle-emissive-strength\")\n      };\n      if (o) {\n        u.u_inv_rot_matrix = n, u.u_merc_center = i, u.u_tile_id = [e.canonical.x, e.canonical.y, 1 << e.canonical.z], u.u_zoom_transition = $u(a.zoom);\n        const t = i[0] * Kr,\n          r = i[1] * Kr;\n        u.u_up_dir = a.projection.upVector(new ou(0, 0, 0), t, r);\n      }\n      return u;\n    }, t.ca = fl, t.cb = To, t.cc = function (t, e, r) {\n      const n = Math.sqrt(t * t + e * e + r * r),\n        i = n > 0 ? Math.acos(r / n) * Y : 0;\n      let s = 0 !== t || 0 !== e ? Math.atan2(-e, -t) * Y + 90 : 0;\n      return s < 0 && (s += 360), [n, s, i];\n    }, t.cd = Al, t.ce = Au, t.cf = mt, t.cg = function (t) {\n      return [Math.pow(t[0], 1 / 2.2), Math.pow(t[1], 1 / 2.2), Math.pow(t[2], 1 / 2.2)];\n    }, t.ch = function (t, e) {\n      return t.readFields(dg, {\n        icons: []\n      }, e);\n    }, t.ci = function (t) {\n      return t({\n        pluginStatus: Es,\n        pluginURL: zs\n      }), Bs.on(\"pluginStateChange\", t), t;\n    }, t.cj = ag, t.ck = bd, t.cl = vd, t.cm = ee, t.cn = ks, t.co = Rt, t.cp = ye, t.cq = ct, t.cr = function (t) {\n      const e = t.indexOf(ha);\n      return e >= 0 ? t.slice(0, e) : t;\n    }, t.cs = function (t) {\n      return t.indexOf(ha) >= 0;\n    }, t.ct = function (t) {\n      const e = t.indexOf(ha);\n      return e >= 0 ? t.slice(e + 1) : \"\";\n    }, t.cu = function (t) {\n      const e = [],\n        r = t.id;\n      return void 0 === r && e.push({\n        message: `layers.${r}: missing required property \"id\"`\n      }), void 0 === t.render && e.push({\n        message: `layers.${r}: missing required method \"render\"`\n      }), t.renderingMode && \"2d\" !== t.renderingMode && \"3d\" !== t.renderingMode && e.push({\n        message: `layers.${r}: property \"renderingMode\" must be either \"2d\" or \"3d\"`\n      }), e;\n    }, t.cv = function (t, e, r, n) {\n      return \"custom\" === t.type ? new ny(t, e) : new Wy[t.type](t, e, r, n);\n    }, t.cw = ut, t.cx = class extends Ov {\n      constructor(t, e) {\n        super(t._vectorTileFeature, t._z, t._x, t._y, t.id), t.state && (this.state = Object.assign({}, t.state)), this.target = e.target, this.namespace = e.namespace, e.properties && (this.properties = e.properties), this.target && (\"featuresetId\" in this.target && !this.target.importId || \"layerId\" in this.target) && (this.source = t.source, this.sourceLayer = t.sourceLayer, this.layer = t.layer);\n      }\n      toJSON() {\n        const t = super.toJSON();\n        return t.target = this.target, t.namespace = this.namespace, t;\n      }\n    }, t.cy = Bs, t.cz = re, t.d = function (t) {\n      return At.API_TILEJSON_REGEX.test(t);\n    }, t.d$ = Lv, t.d0 = er, t.d1 = (t, e, r, n, i, s, a, o) => {\n      const l = t.transform,\n        u = l.pitch < 15 ? Kp(.07, .7, Q((14 - l.zoom) / 5, 0, 1)) : .07,\n        c = \"none\" === r.paint.get(\"line-trim-color-use-theme\").constantOr(\"default\");\n      return {\n        u_matrix: Qp(t, e, r, n),\n        u_texsize: e.imageAtlasTexture ? e.imageAtlasTexture.size : [0, 0],\n        u_pixels_to_tile_units: l.calculatePixelsToTileUnitsMatrix(e),\n        u_device_pixel_ratio: i,\n        u_width_scale: s,\n        u_floor_width_scale: a,\n        u_image: 0,\n        u_tile_units_to_pixels: Jp(e, l),\n        u_units_to_pixels: [1 / l.pixelsToGLUnits[0], 1 / l.pixelsToGLUnits[1]],\n        u_alpha_discard_threshold: 0,\n        u_trim_offset: o,\n        u_trim_fade_range: r.paint.get(\"line-trim-fade-range\"),\n        u_trim_color: r.paint.get(\"line-trim-color\").toRenderColor(c ? null : r.lut).toArray01(),\n        u_emissive_strength: r.paint.get(\"line-emissive-strength\"),\n        u_zbias_factor: u,\n        u_tile_to_meter: Al(e.tileID.canonical, 0)\n      };\n    }, t.d2 = (t, e, r, n, i, s, a, o, l) => {\n      const u = t.transform,\n        c = u.calculatePixelsToTileUnitsMatrix(e),\n        h = \"none\" === r.paint.get(\"line-trim-color-use-theme\").constantOr(\"default\"),\n        p = u.pitch < 15 ? Kp(.07, .7, Q((14 - u.zoom) / 5, 0, 1)) : .07;\n      return {\n        u_matrix: Qp(t, e, r, n),\n        u_pixels_to_tile_units: c,\n        u_device_pixel_ratio: s,\n        u_width_scale: a,\n        u_floor_width_scale: o,\n        u_units_to_pixels: [1 / u.pixelsToGLUnits[0], 1 / u.pixelsToGLUnits[1]],\n        u_dash_image: 0,\n        u_gradient_image: 1,\n        u_image_height: i,\n        u_texsize: ef(r) && e.lineAtlasTexture ? e.lineAtlasTexture.size : [0, 0],\n        u_tile_units_to_pixels: Jp(e, t.transform),\n        u_alpha_discard_threshold: 0,\n        u_trim_offset: l,\n        u_trim_fade_range: r.paint.get(\"line-trim-fade-range\"),\n        u_trim_color: r.paint.get(\"line-trim-color\").toRenderColor(h ? null : r.lut).toArray01(),\n        u_emissive_strength: r.paint.get(\"line-emissive-strength\"),\n        u_zbias_factor: p,\n        u_tile_to_meter: Al(e.tileID.canonical, 0)\n      };\n    }, t.d3 = at, t.d4 = dc, t.d5 = vl, t.d6 = Pp, t.d7 = hu, t.d8 = vp, t.d9 = op, t.dA = Uh, t.dB = K, t.dC = function () {\n      return !!document.fullscreenElement || !!document.webkitFullscreenElement;\n    }, t.dD = J, t.dE = Ml, t.dF = al, t.dG = function ([t, e, r]) {\n      const n = Math.hypot(t, e, r),\n        i = Math.atan2(t, r),\n        s = .5 * Math.PI - Math.acos(-e / n);\n      return new ul(X(i), X(s));\n    }, t.dH = uy, t.dI = function (t) {\n      const e = t.navigator ? t.navigator.userAgent : null;\n      return !!function (t) {\n        if (null == xt) {\n          const e = t.navigator ? t.navigator.userAgent : null;\n          xt = !!t.safari || !(!e || !(/\\b(iPad|iPhone|iPod)\\b/.test(e) || e.match(\"Safari\") && !e.match(\"Chrome\")));\n        }\n        return xt;\n      }(t) && e && (e.match(\"Version/15.4\") || e.match(\"Version/15.5\") || e.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/));\n    }, t.dJ = function (t, e) {\n      Ft = t, Ot = e;\n    }, t.dK = Yu, t.dL = Gu, t.dM = function (t) {\n      const e = [0, 0, 0],\n        r = O.mat4.identity(new Float64Array(16));\n      return O.mat4.multiply(r, t.pixelMatrix, t.globeMatrix), O.vec3.transformMat4(e, e, r), new q(e[0], e[1]);\n    }, t.dN = function (t, e, r = !1) {\n      if (Es === As || Es === Is || Es === Ss) throw new Error(\"setRTLTextPlugin cannot be called multiple times.\");\n      zs = Ct.resolveURL(t), Es = As, Ps = e, Ts(), r || Cs();\n    }, t.dO = Vs, t.dP = function () {\n      ag().acquire(eg);\n    }, t.dQ = function () {\n      const t = ig;\n      t && (t.isPreloaded() && 1 === t.numActive() ? (t.release(eg), ig = null) : console.warn(\"Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()\"));\n    }, t.dR = rg, t.dS = function (t) {\n      const e = qt();\n      if (!e) return;\n      const r = e.delete(Lt);\n      t && r.catch(t).then(() => t());\n    }, t.dT = tg, t.dU = cv, t.dV = function (t) {\n      sv = Ct.resolveURL(t), uv || (uv = new ng(ag(), new _e())), uv.broadcast(\"setDracoUrl\", sv);\n    }, t.dW = hv, t.dX = function (t) {\n      ov = Ct.resolveURL(t), uv || (uv = new ng(ag(), new _e())), uv.broadcast(\"setMeshoptUrl\", ov);\n    }, t.dY = us, t.dZ = hc, t.d_ = xd, t.da = 450, t.db = 7, t.dc = Zm, t.dd = va, t.de = to, t.df = 256, t.dg = Nu, t.dh = za, t.di = Ga, t.dj = Ya, t.dk = function (t, e, r, n, i) {\n      return Q((t - e) / (r - e) * (i - n) + n, n, i);\n    }, t.dl = Ei, t.dm = wl, t.dn = class {\n      constructor(t, e, r, n) {\n        this.context = t, this.format = n, this.size = r, this.texture = t.gl.createTexture();\n        const [i, s, a] = this.size,\n          {\n            gl: o\n          } = t;\n        o.bindTexture(o.TEXTURE_3D, this.texture), t.pixelStoreUnpackFlipY.set(!1), t.pixelStoreUnpack.set(1), t.pixelStoreUnpackPremultiplyAlpha.set(!1), o.texImage3D(o.TEXTURE_3D, 0, this.format, i, s, a, 0, Um(this.format), jm(this.format), e.data);\n      }\n      bind(t, e) {\n        const {\n            context: r\n          } = this,\n          {\n            gl: n\n          } = r;\n        n.bindTexture(n.TEXTURE_3D, this.texture), t !== this.minFilter && (n.texParameteri(n.TEXTURE_3D, n.TEXTURE_MAG_FILTER, t), n.texParameteri(n.TEXTURE_3D, n.TEXTURE_MIN_FILTER, t), this.minFilter = t), e !== this.wrapS && (n.texParameteri(n.TEXTURE_3D, n.TEXTURE_WRAP_S, e), n.texParameteri(n.TEXTURE_3D, n.TEXTURE_WRAP_T, e), this.wrapS = e);\n      }\n      destroy() {\n        const {\n          gl: t\n        } = this.context;\n        t.deleteTexture(this.texture), this.texture = null;\n      }\n    }, t.dp = fy, t.dq = [1, 1, 1], t.dr = Fy, t.ds = Ty, t.dt = La, t.du = Za, t.dv = ol, t.dw = Xa, t.dx = Ha, t.dy = class {\n      constructor() {\n        this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [], this._globalClipBounds = {\n          min: new q(1 / 0, 1 / 0),\n          max: new q(-1 / 0, -1 / 0)\n        };\n      }\n      clear() {\n        this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];\n      }\n      get updateTime() {\n        return this._updateTime;\n      }\n      getReplacementRegionsForTile(t, e = !1) {\n        const r = Hh(new q(0, 0), new q(Kr, Kr), t),\n          n = [];\n        if (e && !Gh(r, this._globalClipBounds)) return n;\n        for (const e of this._activeRegions) {\n          if (e.hiddenByOverlap) continue;\n          if (!Gh(r, e)) continue;\n          const i = Xh(e.min, e.max, t);\n          n.push({\n            min: i.min,\n            max: i.max,\n            sourceId: this._sourceIds[e.priority],\n            footprint: e.footprint,\n            footprintTileId: e.tileId,\n            order: e.order,\n            clipMask: e.clipMask,\n            clipScope: e.clipScope\n          });\n        }\n        return n;\n      }\n      setSources(t) {\n        this._setSources(t.map(t => ({\n          getSourceId: () => t.cache.id,\n          getFootprints: () => {\n            const e = [];\n            for (const r of t.cache.getVisibleCoordinates()) {\n              const n = t.cache.getTile(r).buckets[t.layer];\n              n && n.updateFootprints(r.toUnwrapped(), e);\n            }\n            return e;\n          },\n          getOrder: () => t.order,\n          getClipMask: () => t.clipMask,\n          getClipScope: () => t.clipScope\n        })));\n      }\n      _addSource(t) {\n        const e = t.getFootprints();\n        if (0 === e.length) return;\n        const r = t.getOrder(),\n          n = t.getClipMask(),\n          i = t.getClipScope();\n        for (const t of e) {\n          if (!t.footprint) continue;\n          const e = Hh(t.footprint.min, t.footprint.max, t.id);\n          this._activeRegions.push({\n            min: e.min,\n            max: e.max,\n            hiddenByOverlap: !1,\n            priority: this._sourceIds.length,\n            tileId: t.id,\n            footprint: t.footprint,\n            order: r,\n            clipMask: n,\n            clipScope: i\n          });\n        }\n        this._sourceIds.push(t.getSourceId());\n      }\n      _computeReplacement() {\n        this._activeRegions.sort((t, e) => t.priority - e.priority || qh(t.min, e.min) || qh(t.max, e.max) || t.order - e.order || t.clipMask - e.clipMask || function (t, e) {\n          const r = (t, e) => t + e;\n          return t.length - e.length || t.reduce(r, \"\").localeCompare(e.reduce(r, \"\"));\n        }(t.clipScope, e.clipScope));\n        let t = this._activeRegions.length !== this._prevRegions.length;\n        if (!t) {\n          let e = 0;\n          for (; !t && e !== this._activeRegions.length;) {\n            const r = this._activeRegions[e],\n              n = this._prevRegions[e];\n            t = r.priority !== n.priority || !$h(r, n) || r.order !== n.order || r.clipMask !== n.clipMask || !$(r.clipScope, n.clipScope), ++e;\n          }\n        }\n        if (t) {\n          ++this._updateTime;\n          for (const t of this._activeRegions) t.order !== Uh && (this._globalClipBounds.min.x = Math.min(this._globalClipBounds.min.x, t.min.x), this._globalClipBounds.min.y = Math.min(this._globalClipBounds.min.y, t.min.y), this._globalClipBounds.max.x = Math.max(this._globalClipBounds.max.x, t.max.x), this._globalClipBounds.max.y = Math.max(this._globalClipBounds.max.y, t.max.y));\n          const t = t => {\n            const e = this._activeRegions;\n            if (t >= e.length) return t;\n            const r = e[t].priority;\n            for (; t < e.length && e[t].priority === r;) ++t;\n            return t;\n          };\n          if (this._sourceIds.length > 1) {\n            let e = 0,\n              r = t(e);\n            for (; e !== r;) {\n              let n = e;\n              const i = e;\n              for (; n !== r;) {\n                const t = this._activeRegions[n];\n                t.hiddenByOverlap = !1;\n                for (let e = 0; e < i; e++) {\n                  const r = this._activeRegions[e];\n                  if (!r.hiddenByOverlap && t.order === Uh && Gh(t, r) && (t.hiddenByOverlap = Wh(t.footprint, t.tileId, r.footprint, r.tileId), t.hiddenByOverlap)) break;\n                }\n                ++n;\n              }\n              e = r, r = t(e);\n            }\n          }\n        }\n      }\n      _setSources(t) {\n        [this._prevRegions, this._activeRegions] = [this._activeRegions, []], this._sourceIds = [];\n        for (let e = t.length - 1; e >= 0; e--) this._addSource(t[e]);\n        this._computeReplacement();\n      }\n    }, t.dz = class {\n      constructor(t) {\n        this._createGrid(t), this._createPoles(t);\n      }\n      destroy() {\n        this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();\n        for (const t of this._poleSegments) t.destroy();\n        for (const t of this._gridSegments) t.withSkirts.destroy(), t.withoutSkirts.destroy();\n      }\n      _fillGridMeshWithLods(t, e) {\n        const r = new _a(),\n          n = new ja(),\n          i = [],\n          s = t + 1 + 2,\n          a = e[0] + 1,\n          o = e[0] + 1 + (1 + e.length),\n          l = (t, e, r) => {\n            let n = t === s - 1 ? t - 2 : 0 === t ? t : t - 1;\n            return n += r ? 24575 : 0, [n, e];\n          };\n        for (let t = 0; t < s; ++t) r.emplaceBack(...l(t, 0, !0));\n        for (let t = 0; t < a; ++t) for (let e = 0; e < s; ++e) r.emplaceBack(...l(e, t, (0 === e || e === s - 1) && !0));\n        for (let t = 0; t < e.length; ++t) {\n          const n = e[t];\n          for (let t = 0; t < s; ++t) r.emplaceBack(...l(t, n, !0));\n        }\n        for (let t = 0; t < e.length; ++t) {\n          const a = n.length,\n            l = e[t] + 1 + 2,\n            u = new ja();\n          for (let r = 0; r < l - 1; r++) {\n            const i = r === l - 2,\n              a = i ? s * (o - e.length + t - r) : s;\n            for (let t = 0; t < s - 1; t++) {\n              const e = r * s + t;\n              0 === r || i || 0 === t || t === s - 2 ? (u.emplaceBack(e + 1, e, e + a), u.emplaceBack(e + a, e + a + 1, e + 1)) : (n.emplaceBack(e + 1, e, e + a), n.emplaceBack(e + a, e + a + 1, e + 1));\n            }\n          }\n          const c = xo.simpleSegment(0, a, r.length, n.length - a);\n          for (let t = 0; t < u.uint16.length; t += 3) n.emplaceBack(u.uint16[t], u.uint16[t + 1], u.uint16[t + 2]);\n          const h = xo.simpleSegment(0, a, r.length, n.length - a);\n          i.push({\n            withoutSkirts: c,\n            withSkirts: h\n          });\n        }\n        return {\n          vertices: r,\n          indices: n,\n          segments: i\n        };\n      }\n      _createGrid(t) {\n        const e = this._fillGridMeshWithLods(el, rl);\n        this._gridSegments = e.segments, this._gridBuffer = t.createVertexBuffer(e.vertices, mu.members), this._gridIndexBuffer = t.createIndexBuffer(e.indices, !0);\n      }\n      _createPoles(t) {\n        const e = new ja();\n        for (let t = 0; t <= el; t++) e.emplaceBack(0, t + 1, t + 2);\n        this._poleIndexBuffer = t.createIndexBuffer(e, !0);\n        const r = new Ga(),\n          n = new Ga(),\n          i = new Ga(),\n          s = new Ga();\n        this._poleSegments = [];\n        for (let t = 0, e = 0; t < Jo; t++) {\n          const a = 360 / (1 << t);\n          r.emplaceBack(0, -Ko, 0, .5, 0), n.emplaceBack(0, -Ko, 0, .5, 1), i.emplaceBack(0, -Ko, 0, .5, .5), s.emplaceBack(0, -Ko, 0, .5, .5);\n          for (let t = 0; t <= el; t++) {\n            let e = t / el,\n              o = 0;\n            const l = Ee(0, a, e),\n              [u, c, h] = sl(Xu, Zu, l, Ko);\n            r.emplaceBack(u, c, h, e, o), n.emplaceBack(u, c, h, e, 1 - o);\n            const p = H(l);\n            e = .5 + .5 * Math.sin(p), o = .5 + .5 * Math.cos(p), i.emplaceBack(u, c, h, e, o), s.emplaceBack(u, c, h, e, 1 - o);\n          }\n          this._poleSegments.push(xo.simpleSegment(e, 0, 66, 64)), e += 66;\n        }\n        this._poleNorthVertexBuffer = t.createVertexBuffer(r, fu, !1), this._poleSouthVertexBuffer = t.createVertexBuffer(n, fu, !1), this._texturedPoleNorthVertexBuffer = t.createVertexBuffer(i, fu, !1), this._texturedPoleSouthVertexBuffer = t.createVertexBuffer(s, fu, !1);\n      }\n      getGridBuffers(t, e) {\n        return [this._gridBuffer, this._gridIndexBuffer, e ? this._gridSegments[t].withSkirts : this._gridSegments[t].withoutSkirts];\n      }\n      getPoleBuffers(t, e) {\n        return [e ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, e ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t]];\n      }\n    }, t.e = At, t.e0 = Nv, t.e1 = jp, t.e2 = oh, t.e3 = \"hd_road_elevation\", t.e4 = class {\n      static parseFrom(t, e) {\n        const r = fh.parse(t);\n        if (!r) return [];\n        let {\n          vertices: n,\n          features: i\n        } = r;\n        const s = 1 / Al(e);\n        i.sort((t, e) => t.id - e.id), n.sort((t, e) => t.id - e.id || t.idx - e.idx), n = n.filter((t, e, r) => e === r.findIndex(e => e.id === t.id && e.idx === t.idx));\n        const a = new Array();\n        let o = 0;\n        const l = n.length;\n        for (const t of i) {\n          if (t.constantHeight) {\n            a.push(new dh(t.id, t.bounds, t.constantHeight));\n            continue;\n          }\n          for (; o !== l && n[o].id < t.id;) o++;\n          if (o === l || n[o].id !== t.id) continue;\n          const e = new Array(),\n            r = new Array(),\n            i = o;\n          for (; o !== l && n[o].id === t.id;) {\n            const t = n[o];\n            if (e.push({\n              position: t.position,\n              height: t.height,\n              extent: t.extent\n            }), o !== i && n[o - 1].idx === t.idx - 1) {\n              const t = o - i;\n              r.push({\n                a: t - 1,\n                b: t\n              });\n            }\n            o++;\n          }\n          a.push(new dh(t.id, t.bounds, void 0, e, r, s));\n        }\n        return a;\n      }\n    }, t.e5 = lt, t.e6 = gh, t.e7 = fd, t.e8 = hd, t.e9 = function (t, e, r, n, i, s, a, o = 1, l) {\n      t.createArrays(), t.tilePixelRatio = Kr / (512 * t.overscaling), t.compareText = {}, t.iconsNeedLinear = !1;\n      const u = t.layers[0].layout,\n        c = t.layers[0]._unevaluatedLayout._values,\n        h = {};\n      h.scaleFactor = o, h.textSizeScaleRange = u.get(\"text-size-scale-range\"), h.iconSizeScaleRange = u.get(\"icon-size-scale-range\");\n      const [p, f] = h.textSizeScaleRange,\n        [d, m] = h.iconSizeScaleRange;\n      h.textScaleFactor = Q(h.scaleFactor, p, f), h.iconScaleFactor = Q(h.scaleFactor, d, m);\n      const y = c[\"text-size\"],\n        g = c[\"icon-size\"];\n      if (\"composite\" === t.textSizeData.kind) {\n        const {\n          minZoom: e,\n          maxZoom: r\n        } = t.textSizeData;\n        h.compositeTextSizes = [y.possiblyEvaluate(new Rs(e), s), y.possiblyEvaluate(new Rs(r), s)];\n      }\n      if (\"composite\" === t.iconSizeData.kind) {\n        const {\n          minZoom: e,\n          maxZoom: r\n        } = t.iconSizeData;\n        h.compositeIconSizes = [g.possiblyEvaluate(new Rs(e), s), g.possiblyEvaluate(new Rs(r), s)];\n      }\n      h.layoutTextSize = y.possiblyEvaluate(new Rs(a + 1), s), h.layoutIconSize = g.possiblyEvaluate(new Rs(a + 1), s), h.textMaxSize = y.possiblyEvaluate(new Rs(18), s);\n      const x = u.get(\"symbol-placement\"),\n        v = \"map\" === u.get(\"text-rotation-alignment\") && \"point\" !== x,\n        b = u.get(\"text-size\");\n      let _ = !1;\n      const w = [];\n      for (const a of t.features) {\n        const o = u.get(\"text-font\").evaluate(a, {}, s).join(\",\"),\n          p = b.evaluate(a, {}, s) * h.textScaleFactor,\n          f = h.layoutTextSize.evaluate(a, {}, s) * h.textScaleFactor,\n          d = h.layoutIconSize.evaluate(a, {}, s) * h.iconScaleFactor,\n          m = {\n            horizontal: {},\n            vertical: void 0\n          },\n          y = a.text;\n        let g,\n          M = [0, 0];\n        if (y) {\n          const n = y.toString(),\n            c = u.get(\"text-letter-spacing\").evaluate(a, {}, s) * gf,\n            h = u.get(\"text-line-height\").evaluate(a, {}, s) * gf,\n            d = ys(n) ? c : 0,\n            g = u.get(\"text-anchor\").evaluate(a, {}, s),\n            b = u.get(\"text-variable-anchor\");\n          if (!b) {\n            const t = u.get(\"text-radial-offset\").evaluate(a, {}, s);\n            M = t ? Cd(g, [t * gf, Bd]) : u.get(\"text-offset\").evaluate(a, {}, s).map(t => t * gf);\n          }\n          let _ = v ? \"center\" : u.get(\"text-justify\").evaluate(a, {}, s);\n          const w = \"point\" === x,\n            A = w ? u.get(\"text-max-width\").evaluate(a, {}, s) * gf : 1 / 0,\n            I = s => {\n              t.allowVerticalPlacement && ms(n) && (m.vertical = qf(y, e, r, i, o, A, h, g, s, d, M, Nf.vertical, !0, f, p, l));\n            };\n          if (!v && b) {\n            const t = \"auto\" === _ ? b.map(t => Nd(t)) : [_];\n            let n = !1;\n            for (let s = 0; s < t.length; s++) {\n              const a = t[s];\n              if (!m.horizontal[a]) if (n) m.horizontal[a] = m.horizontal[0];else {\n                const t = qf(y, e, r, i, o, A, h, \"center\", a, d, M, Nf.horizontal, !1, f, p, l);\n                t && (m.horizontal[a] = t, n = 1 === t.positionedLines.length);\n              }\n            }\n            I(\"left\");\n          } else {\n            if (\"auto\" === _ && (_ = Nd(g)), w || u.get(\"text-writing-mode\").indexOf(\"horizontal\") >= 0 || !ms(n)) {\n              const t = qf(y, e, r, i, o, A, h, g, _, d, M, Nf.horizontal, !1, f, p, l);\n              t && (m.horizontal[_] = t);\n            }\n            I(w ? \"left\" : _);\n          }\n        }\n        let A,\n          I,\n          S,\n          P,\n          E,\n          z = !1;\n        if (a.icon && a.icon.hasPrimary()) {\n          const e = Rd(a.icon, t.iconSizeData, c[\"icon-size\"], s, t.zoom, a, l, h.iconScaleFactor);\n          A = e.iconPrimary, I = e.iconSecondary;\n          const r = A.toString(),\n            o = n.get(r);\n          o && (S = u.get(\"icon-offset\").evaluate(a, {}, s), P = u.get(\"icon-anchor\").evaluate(a, {}, s), E = u.get(\"icon-text-fit\").evaluate(a, {}, s), g = Qf(i.get(r), I ? i.get(I.toString()) : void 0, S, P), z = o.sdf, void 0 === t.sdfIcons ? t.sdfIcons = o.sdf : t.sdfIcons !== o.sdf && pt(\"Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer\"), (o.pixelRatio !== t.pixelRatio || 0 !== u.get(\"icon-rotate\").constantOr(1)) && (t.iconsNeedLinear = !0));\n        }\n        _ = _ || !(!a.icon || !a.icon.hasSecondary());\n        const k = Yd(m.horizontal) || m.vertical;\n        t.iconsInText || (t.iconsInText = !!k && k.iconsInText);\n        const T = f * h.textScaleFactor / gf,\n          {\n            defaultShapedIcon: B,\n            verticallyShapedIcon: V\n          } = Ud(t, g, u, a, s, m, T, S, E);\n        g = B, w.push({\n          feature: a,\n          shapedTextOrientations: m,\n          shapedText: k,\n          shapedIcon: g,\n          iconPrimary: A,\n          iconSecondary: I,\n          iconOffset: S,\n          iconAnchor: P,\n          verticallyShapedIcon: V,\n          layoutTextSize: f,\n          layoutIconSize: d,\n          textOffset: M,\n          isSDFIcon: z,\n          iconTextFit: E\n        });\n      }\n      return {\n        featureData: w,\n        sizes: h,\n        hasAnySecondaryIcon: _,\n        textAlongLine: v,\n        symbolPlacement: x\n      };\n    }, t.ea = dd, t.eb = function (t, e, r, n, i, s, a, o, l, u) {\n      const {\n        featureData: c,\n        hasAnySecondaryIcon: h,\n        sizes: p,\n        textAlongLine: f,\n        symbolPlacement: d\n      } = e;\n      for (const e of c) {\n        const {\n          shapedIcon: r,\n          verticallyShapedIcon: s,\n          feature: c,\n          shapedTextOrientations: m,\n          shapedText: y,\n          layoutTextSize: g,\n          textOffset: x,\n          isSDFIcon: v,\n          iconPrimary: b,\n          iconSecondary: _,\n          iconTextFit: w,\n          iconOffset: M\n        } = e;\n        Ld(r, u.iconPositions, b, _), Ld(s, u.iconPositions, b, _), Fd(m, u.iconPositions), (y || r) && jd(t, c, m, r, s, l, p, g, 0, x, v, n, i, a, o, h, w, M, f, d);\n      }\n      r && t.generateCollisionDebugBuffers(s, t.collisionBoxArray, p.textScaleFactor);\n    }, t.ec = ah, t.ed = hx, t.ee = j, t.ef = sh, t.eg = Vf, t.eh = e, t.ei = function (t) {\n      let e = 0;\n      if (new Uint32Array(t, 0, 1)[0] !== bv) {\n        const r = new Uint32Array(t, 0, 7),\n          [,, n, i, s, a] = r;\n        e = r.byteLength + i + s + a + s, (n !== t.byteLength || e >= t.byteLength) && pt(\"Invalid b3dm header information.\");\n      }\n      return Sv(t, e);\n    }, t.ej = function (t, e) {\n      const r = Cv(t);\n      for (const t of r) {\n        for (const e of t.meshes) Dv(e);\n        t.lights && (t.lightMeshIndex = t.meshes.length, t.meshes.push(Rv(t.lights, e)));\n      }\n      return r;\n    }, t.ek = Gy, t.el = Qy, t.em = Ds, t.en = function (t) {\n      $t(), null != Ut && Ut.then(e => {\n        e.keys().then(r => {\n          for (let n = 0; n < r.length - t; n++) e.delete(r[n]);\n        });\n      });\n    }, t.f = function (t) {\n      return 0 === t.indexOf(\"mapbox:\");\n    }, t.g = function (t, e) {\n      return re(nt(t, {\n        method: \"GET\"\n      }), e);\n    }, t.h = It, t.i = function (t) {\n      return At.API_STYLE_REGEX.test(t) && !St(t);\n    }, t.j = function (t) {\n      return decodeURIComponent(atob(t).split(\"\").map(t => \"%\" + (\"00\" + t.charCodeAt(0).toString(16)).slice(-2)).join(\"\"));\n    }, t.k = function (t) {\n      return btoa(encodeURIComponent(t).replace(/%([0-9A-F]{2})/g, (t, e) => String.fromCharCode(Number(\"0x\" + e))));\n    }, t.l = nt, t.m = Yt, t.n = function (t, e) {\n      return re(nt(t, {\n        type: \"json\"\n      }), e);\n    }, t.o = le, t.p = function (t, e) {\n      return re(nt(t, {\n        method: \"POST\"\n      }), e);\n    }, t.q = Ct, t.r = pc, t.s = function (t) {\n      try {\n        const e = self[t];\n        return e.setItem(\"_mapbox_test_\", 1), e.removeItem(\"_mapbox_test_\"), !0;\n      } catch (t) {\n        return !1;\n      }\n    }, t.t = Vt, t.u = function () {\n      return function t(e) {\n        return e ? (e ^ Math.random() * (16 >> e / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t);\n      }();\n    }, t.v = function (t) {\n      return !!t && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t);\n    }, t.w = pt, t.x = function () {\n      return sg || (sg = new rg()), sg;\n    }, t.y = Qg, t.z = xe;\n  });\n  define([\"./shared\"], function (e) {\n    function t(e) {\n      const t = e ? e.url.toString() : void 0;\n      return t ? performance.getEntriesByName(t) : [];\n    }\n    function s(e) {\n      if (\"number\" == typeof e || \"boolean\" == typeof e || \"string\" == typeof e || null == e) return JSON.stringify(e);\n      if (Array.isArray(e)) {\n        let t = \"[\";\n        for (const i of e) t += `${s(i)},`;\n        return `${t}]`;\n      }\n      let t = \"{\";\n      for (const i of Object.keys(e).sort()) t += `${i}:${s(e[i])},`;\n      return `${t}}`;\n    }\n    function i(t) {\n      let i = \"\";\n      for (const o of e.bm) (\"model\" !== t.type || \"minzoom\" !== o && \"maxzoom\" !== o) && (i += `/${s(t[o])}`);\n      return i;\n    }\n    class o {\n      constructor(e) {\n        this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, e && this.replace(e);\n      }\n      replace(e, t) {\n        this._layerConfigs = {}, this._layers = {}, this.update(e, [], t);\n      }\n      update(t, o, n) {\n        this._options = n;\n        for (const s of t) this._layerConfigs[s.id] = s, (this._layers[s.id] = e.cv(s, this.scope, null, this._options)).compileFilter(n), this.keyCache[s.id] && delete this.keyCache[s.id];\n        for (const e of o) delete this.keyCache[e], delete this._layerConfigs[e], delete this._layers[e];\n        this.familiesBySource = {};\n        const r = function (e, t) {\n          const o = {};\n          for (let n = 0; n < e.length; n++) {\n            const r = e[n];\n            let a = t && t[r.id];\n            !a && (a = i(r), \"line\" === r.type && r.paint) && function e(t) {\n              return \"string\" == typeof t && \"line-progress\" === t || (Array.isArray(t) ? t.some(e) : !(!t || \"object\" != typeof t) && Object.values(t).some(e));\n            }(r.paint[\"line-width\"]) && (a += `/${s(r.paint[\"line-width\"])}`), t && (t[r.id] = a);\n            let l = o[a];\n            l || (l = o[a] = []), l.push(r);\n          }\n          const n = [];\n          for (const e in o) n.push(o[e]);\n          return n;\n        }(Object.values(this._layerConfigs), this.keyCache);\n        for (const e of r) {\n          const t = e.map(e => this._layers[e.id]),\n            s = t[0];\n          if (\"none\" === s.visibility) continue;\n          const i = s.source || \"\";\n          let o = this.familiesBySource[i];\n          o || (o = this.familiesBySource[i] = {});\n          const n = s.sourceLayer || \"_geojsonTileLayer\";\n          let r = o[n];\n          r || (r = o[n] = []), r.push(t);\n        }\n      }\n    }\n    const n = 1 * e.d_;\n    class r {\n      constructor(t) {\n        const s = {},\n          i = [];\n        for (const e in t) {\n          const o = t[e],\n            r = s[e] = {};\n          for (const e in o.glyphs) {\n            const t = o.glyphs[+e];\n            if (!t || 0 === t.bitmap.width || 0 === t.bitmap.height) continue;\n            const s = t.metrics.localGlyph ? n : 1,\n              a = {\n                x: 0,\n                y: 0,\n                w: t.bitmap.width + 2 * s,\n                h: t.bitmap.height + 2 * s\n              };\n            i.push(a), r[e] = a;\n          }\n        }\n        const {\n            w: o,\n            h: r\n          } = e.H(i),\n          a = new e.dZ({\n            width: o || 1,\n            height: r || 1\n          });\n        for (const i in t) {\n          const o = t[i];\n          for (const t in o.glyphs) {\n            const r = o.glyphs[+t];\n            if (!r || 0 === r.bitmap.width || 0 === r.bitmap.height) continue;\n            const l = s[i][t],\n              c = r.metrics.localGlyph ? n : 1;\n            e.dZ.copy(r.bitmap, a, {\n              x: 0,\n              y: 0\n            }, {\n              x: l.x + c,\n              y: l.y + c\n            }, r.bitmap);\n          }\n        }\n        this.image = a, this.positions = s;\n      }\n    }\n    e.dY(r, \"GlyphAtlas\");\n    class a {\n      constructor(t) {\n        this.tileID = new e.aH(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.tileZoom = t.tileZoom, this.uid = t.uid, this.zoom = t.zoom, this.lut = t.lut, this.canonical = t.tileID.canonical, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.scope = t.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t.showCollisionBoxes, this.collectResourceTiming = !!t.request && t.request.collectResourceTiming, this.promoteId = t.promoteId, this.isSymbolTile = t.isSymbolTile, this.tileTransform = e.aR(t.tileID.canonical, t.projection), this.projection = t.projection, this.worldview = t.worldview, this.localizableLayerIds = t.localizableLayerIds, this.brightness = t.brightness, this.extraShadowCaster = !!t.extraShadowCaster, this.tessellationStep = t.tessellationStep, this.scaleFactor = t.scaleFactor;\n      }\n      parse(t, s, i, o, n) {\n        this.status = \"parsing\", this.data = t, this.collisionBoxArray = new e.aX();\n        const a = new e.d$(Object.keys(t.layers).sort()),\n          c = new e.e0(this.tileID, this.promoteId);\n        c.bucketLayerIDs = [];\n        const h = {},\n          u = new e.e1(256, 256),\n          d = {\n            featureIndex: c,\n            iconDependencies: new Map(),\n            patternDependencies: new Map(),\n            glyphDependencies: {},\n            lineAtlas: u,\n            availableImages: i,\n            brightness: this.brightness,\n            scaleFactor: this.scaleFactor,\n            elevationFeatures: void 0\n          },\n          p = s.familiesBySource[this.source];\n        for (const s in p) {\n          const o = t.layers[s];\n          if (!o) continue;\n          let n = !1,\n            r = !1,\n            u = !1;\n          for (const e of p[s]) \"symbol\" === e[0].type ? n = !0 : r = !0, e[0].is3D() && \"model\" !== e[0].type && (u = !0);\n          if (this.extraShadowCaster && !u) continue;\n          if (!0 === this.isSymbolTile && !n) continue;\n          if (!1 === this.isSymbolTile && !r) continue;\n          1 === o.version && e.w(`Vector tile source \"${this.source}\" layer \"${s}\" does not use vector tile spec v2 and therefore may have some rendering errors.`);\n          const f = a.encode(s),\n            g = [];\n          let m = !1;\n          for (let t = 0, i = 0; t < o.length; t++) {\n            const n = o.feature(t),\n              r = c.getId(n, s);\n            if (this.localizableLayerIds && this.localizableLayerIds.has(s)) {\n              const e = n.properties ? n.properties.worldview : null;\n              if (this.worldview && \"string\" == typeof e) if (\"all\" === e) n.properties.$localized = !0;else {\n                if (!e.split(\",\").includes(this.worldview)) continue;\n                n.properties.$localized = !0, n.properties.worldview = this.worldview;\n              }\n            }\n            !m && n.properties && n.properties.hasOwnProperty(e.e2) && (m = !0), g.push({\n              feature: n,\n              id: r,\n              index: i,\n              sourceLayerIndex: f\n            }), i++;\n          }\n          m && !d.elevationFeatures && t.layers.hasOwnProperty(e.e3) && (d.elevationFeatures = e.e4.parseFrom(t.layers[e.e3], this.canonical));\n          for (const t of p[s]) {\n            const s = t[0];\n            (!this.extraShadowCaster || s.is3D() && \"model\" !== s.type) && (void 0 !== this.isSymbolTile && \"symbol\" === s.type !== this.isSymbolTile || s.minzoom && this.zoom < Math.floor(s.minzoom) || s.maxzoom && this.zoom >= s.maxzoom || \"none\" !== s.visibility && (l(t, this.zoom, d.brightness, i), (h[s.id] = s.createBucket({\n              index: c.bucketLayerIDs.length,\n              layers: t,\n              zoom: this.zoom,\n              lut: this.lut,\n              canonical: this.canonical,\n              pixelRatio: this.pixelRatio,\n              overscaling: this.overscaling,\n              collisionBoxArray: this.collisionBoxArray,\n              sourceLayerIndex: f,\n              sourceID: this.source,\n              projection: this.projection.spec,\n              tessellationStep: this.tessellationStep\n            })).populate(g, d, this.tileID.canonical, this.tileTransform), c.bucketLayerIDs.push(t.map(t => e.C(t.id, t.scope)))));\n          }\n        }\n        let f, g, m, y, x, w;\n        u.trim();\n        const b = {\n            type: \"maybePrepare\",\n            isSymbolTile: this.isSymbolTile,\n            zoom: this.zoom\n          },\n          v = () => {\n            if (f) return this.status = \"done\", n(f);\n            if (this.extraShadowCaster) this.status = \"done\", n(null, {\n              buckets: Object.values(h).filter(e => !e.isEmpty()),\n              featureIndex: c,\n              collisionBoxArray: null,\n              glyphAtlasImage: null,\n              lineAtlas: null,\n              imageAtlas: null,\n              brightness: d.brightness,\n              glyphMap: null,\n              iconMap: null,\n              glyphPositions: null\n            });else if (g && m && y) {\n              const t = new r(g),\n                s = new Map();\n              for (const [t, i] of m.entries()) {\n                const {\n                  imagePosition: o\n                } = e.e7(t, i, e.e8);\n                s.set(t, o);\n              }\n              const n = {};\n              for (const o in h) {\n                const r = h[o];\n                r instanceof e.aY && (l(r.layers, this.zoom, d.brightness, i), n[o] = e.e9(r, g, t.positions, m, s, this.tileID.canonical, this.tileZoom, this.scaleFactor, this.pixelRatio));\n              }\n              const a = {\n                iconsPending: !0,\n                patternsPending: !0\n              };\n              this.rasterizeIfNeeded(o, m, x, () => {\n                a.iconsPending = !1, I(n, t, a);\n              }), this.rasterizeIfNeeded(o, y, w, () => {\n                a.patternsPending = !1, I(n, t, a);\n              });\n            }\n          },\n          I = (t, s, o, r) => {\n            if (o.iconsPending || o.patternsPending) return;\n            const a = new e.ea(m, y, this.lut);\n            for (const s in h) {\n              const o = h[s];\n              if (s in t) e.eb(o, t[s], this.showCollisionBoxes, i, this.tileID.canonical, this.tileZoom, this.projection, this.brightness, m, a);else if (o.hasPattern && (o instanceof e.b2 || o instanceof e.b3 || o instanceof e.d8)) {\n                l(o.layers, this.zoom, d.brightness, i);\n                const e = Object.fromEntries(a.patternPositions);\n                o.addFeatures(d, this.tileID.canonical, e, i, this.tileTransform, this.brightness);\n              }\n            }\n            this.status = \"done\", n(null, {\n              buckets: Object.values(h).filter(e => !e.isEmpty()),\n              featureIndex: c,\n              collisionBoxArray: this.collisionBoxArray,\n              glyphAtlasImage: s.image,\n              lineAtlas: u,\n              imageAtlas: a,\n              brightness: d.brightness\n            });\n          };\n        if (!this.extraShadowCaster) {\n          const t = e.e5(d.glyphDependencies, e => Object.keys(e).map(Number));\n          Object.keys(t).length ? o.send(\"getGlyphs\", {\n            uid: this.uid,\n            stacks: t,\n            scope: this.scope\n          }, (e, t) => {\n            f || (f = e, g = t, v());\n          }, void 0, !1, b) : g = {};\n          const s = Array.from(d.iconDependencies.keys()).map(t => e.I.parse(t));\n          s.length ? o.send(\"getImages\", {\n            images: s,\n            source: this.source,\n            scope: this.scope,\n            tileID: this.tileID,\n            type: \"icons\"\n          }, (e, t) => {\n            f || (f = e, m = new Map(), x = this.updateImageMapAndGetImageTaskQueue(m, t, d.iconDependencies), v());\n          }, void 0, !1, b) : (m = new Map(), x = new Map());\n          const i = Array.from(d.patternDependencies.keys()).map(t => e.I.parse(t));\n          i.length ? o.send(\"getImages\", {\n            images: i,\n            source: this.source,\n            scope: this.scope,\n            tileID: this.tileID,\n            type: \"patterns\"\n          }, (e, t) => {\n            f || (f = e, y = new Map(), w = this.updateImageMapAndGetImageTaskQueue(y, t, d.patternDependencies), v());\n          }, void 0, !1, b) : (y = new Map(), w = new Map());\n        }\n        if (d.elevationFeatures && d.elevationFeatures.length > 0) {\n          const t = [];\n          for (const s of Object.values(h)) if (s instanceof e.b3) {\n            const e = s.getUnevaluatedPortalGraph();\n            e && t.push(e);\n          }\n          const s = e.e6.evaluate(t);\n          for (const t of Object.values(h)) t instanceof e.b3 && t.setEvaluatedPortalGraph(s);\n        }\n        v();\n      }\n      rasterizeIfNeeded(e, t, s, i) {\n        Array.from(t.values()).some(e => e.usvg) ? this.rasterize(e, t, s, i) : i();\n      }\n      updateImageMapAndGetImageTaskQueue(e, t, s) {\n        const i = new Map();\n        for (const o of t.keys()) {\n          const n = s.get(o) || [];\n          for (const s of n) {\n            const o = s.toString(),\n              n = t.get(s.id.toString());\n            n.usvg ? i.has(o) || (i.set(o, s), e.set(o, Object.assign({}, n))) : e.set(o, n);\n          }\n        }\n        return i;\n      }\n      rasterize(e, t, s, i) {\n        this.rasterizeTask = e.send(\"rasterizeImages\", {\n          scope: this.scope,\n          tasks: s\n        }, (e, s) => {\n          if (!e) for (const [e, i] of s.entries()) {\n            const s = Object.assign(t.get(e), {\n              data: i\n            });\n            t.set(e, s);\n          }\n          i();\n        });\n      }\n      cancelRasterize() {\n        this.rasterizeTask && this.rasterizeTask.cancel();\n      }\n    }\n    function l(t, s, i, o) {\n      const n = new e.aa(s, {\n        brightness: i\n      });\n      for (const e of t) e.recalculate(n, o);\n    }\n    class c extends e.E {\n      constructor(t, s, i, o, n, r) {\n        super(), this.actor = t, this.layerIndex = s, this.availableImages = i, this.loadVectorData = n || e.aE, this.loading = {}, this.loaded = {}, this.deduped = new e.aD(t.scheduler), this.isSpriteLoaded = o, this.scheduler = t.scheduler, this.brightness = r;\n      }\n      loadTile(s, i) {\n        const o = s.uid,\n          n = s && s.request,\n          r = n && n.collectResourceTiming,\n          l = this.loading[o] = new a(s);\n        l.abort = this.loadVectorData(s, (a, c) => {\n          const h = !this.loading[o];\n          if (delete this.loading[o], l.cancelRasterize(), h || a || !c) return l.status = \"done\", h || (this.loaded[o] = l), i(a);\n          const u = c.rawData,\n            d = {};\n          c.expires && (d.expires = c.expires), c.cacheControl && (d.cacheControl = c.cacheControl), l.vectorTile = c.vectorTile || new e.ec.VectorTile(new e.bi(u));\n          const p = () => {\n            l.parse(l.vectorTile, this.layerIndex, this.availableImages, this.actor, (s, o) => {\n              if (s || !o) return i(s);\n              const a = {};\n              if (r) {\n                const e = t(n);\n                e.length > 0 && (a.resourceTiming = JSON.parse(JSON.stringify(e)));\n              }\n              i(null, e.l({\n                rawTileData: u.slice(0)\n              }, o, d, a));\n            });\n          };\n          this.isSpriteLoaded ? p() : this.once(\"isSpriteLoaded\", () => {\n            this.scheduler ? this.scheduler.add(p, {\n              type: \"parseTile\",\n              isSymbolTile: s.isSymbolTile,\n              zoom: s.tileZoom\n            }) : p();\n          }), this.loaded = this.loaded || {}, this.loaded[o] = l;\n        });\n      }\n      reloadTile(t, s) {\n        const i = this.loaded,\n          o = t.uid;\n        if (i && i[o]) {\n          const n = i[o];\n          n.scaleFactor = t.scaleFactor, n.showCollisionBoxes = t.showCollisionBoxes, n.projection = t.projection, n.brightness = t.brightness, n.tileTransform = e.aR(t.tileID.canonical, t.projection), n.extraShadowCaster = t.extraShadowCaster, n.lut = t.lut;\n          const r = (e, t) => {\n            const i = n.reloadCallback;\n            i && (delete n.reloadCallback, n.parse(n.vectorTile, this.layerIndex, this.availableImages, this.actor, i)), s(e, t);\n          };\n          \"parsing\" === n.status ? n.reloadCallback = r : \"done\" === n.status && (n.vectorTile ? n.parse(n.vectorTile, this.layerIndex, this.availableImages, this.actor, r) : r());\n        } else s(null, void 0);\n      }\n      abortTile(e, t) {\n        const s = e.uid,\n          i = this.loading[s];\n        i && (i.abort && i.abort(), delete this.loading[s]), t();\n      }\n      removeTile(e, t) {\n        const s = this.loaded,\n          i = e.uid;\n        s && s[i] && delete s[i], t();\n      }\n    }\n    class h {\n      loadTile(t, s) {\n        const {\n            uid: i,\n            encoding: o,\n            rawImageData: n,\n            padding: r\n          } = t,\n          a = ImageBitmap && n instanceof ImageBitmap ? this.getImageData(n, r) : n;\n        s(null, new e.ed(i, a, o, r < 1));\n      }\n      reloadTile(e, t) {\n        t(null, null);\n      }\n      abortTile(e, t) {\n        t();\n      }\n      removeTile(e, t) {\n        t();\n      }\n      getImageData(e, t) {\n        this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e.width, e.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext(\"2d\", {\n          willReadFrequently: !0\n        })), this.offscreenCanvas.width = e.width, this.offscreenCanvas.height = e.height, this.offscreenCanvasContext.drawImage(e, 0, 0, e.width, e.height);\n        const s = this.offscreenCanvasContext.getImageData(-t, -t, e.width + 2 * t, e.height + 2 * t);\n        return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), s;\n      }\n    }\n    e.bh.setPbf(e.bi);\n    class u {\n      constructor(t) {\n        this._mrt = new e.bh(t.partial ? 30 : 1 / 0), this._isHeaderLoaded = !1, this.uid = t.uid, this.tileID = t.tileID, this.source = t.source;\n      }\n      parse(t, s) {\n        const i = this._mrt;\n        this.status = \"parsing\", this._entireBuffer = t;\n        try {\n          i.parseHeader(t), this._isHeaderLoaded = !0;\n          const o = [];\n          for (const s in i.layers) {\n            const n = i.getLayer(s),\n              r = n.getDataRange(n.getBandList()),\n              a = i.createDecodingTask(r),\n              l = t.slice(r.firstByte, r.lastByte + 1),\n              c = e.bh.performDecoding(l, a).then(e => a.complete(null, e)).catch(e => a.complete(e, null));\n            o.push(c);\n          }\n          Promise.allSettled(o).then(() => s(null, i));\n        } catch (e) {\n          s(e);\n        }\n      }\n    }\n    class d {\n      constructor(e) {\n        this.actor = e, this.loading = {}, this.loaded = {};\n      }\n      loadTile(t, s) {\n        const i = t.uid,\n          o = t.request,\n          n = this.loading[i] = new u(t),\n          {\n            cancel: r\n          } = e.bj(o, (e, t, o, r) => {\n            const a = !this.loading[i];\n            if (delete this.loading[i], a || e || !t) return n.status = \"done\", a || (this.loaded[i] = n), s(e);\n            n.parse(t, (e, t) => {\n              if (e || !t) return s(e);\n              s(null, t, o, r);\n            }), this.loaded[i] = n;\n          });\n        n.abort = r;\n      }\n      reloadTile(e, t) {\n        t(null, void 0);\n      }\n      abortTile(e, t) {\n        const s = e.uid,\n          i = this.loading[s];\n        i && (i.abort && i.abort(), delete this.loading[s]), t();\n      }\n      removeTile(e, t) {\n        const s = e.uid;\n        this.loaded[s] && delete this.loaded[s], t();\n      }\n      decodeRasterArray({\n        task: t,\n        buffer: s\n      }, i) {\n        e.bh.performDecoding(s, t).then(e => i(null, e)).catch(e => i(e));\n      }\n    }\n    const p = e.ec.VectorTileFeature.prototype.toGeoJSON;\n    class f {\n      constructor(t) {\n        this._feature = t, this.extent = e.ai, this.type = t.type, this.properties = t.tags, \"id\" in t && !isNaN(t.id) && (this.id = parseInt(t.id, 10));\n      }\n      loadGeometry() {\n        if (1 === this._feature.type) {\n          const t = [];\n          for (const s of this._feature.geometry) t.push([new e.P(s[0], s[1])]);\n          return t;\n        }\n        {\n          const t = [];\n          for (const s of this._feature.geometry) {\n            const i = [];\n            for (const t of s) i.push(new e.P(t[0], t[1]));\n            t.push(i);\n          }\n          return t;\n        }\n      }\n      toGeoJSON(e, t, s) {\n        return p.call(this, e, t, s);\n      }\n    }\n    class g {\n      constructor(t) {\n        this.layers = {\n          _geojsonTileLayer: this\n        }, this.name = \"_geojsonTileLayer\", this.extent = e.ai, this.length = t.length, this._features = t;\n      }\n      feature(e) {\n        return new f(this._features[e]);\n      }\n    }\n    const m = 64 / 4096,\n      y = 128;\n    class x {\n      constructor() {\n        this.features = new Map();\n      }\n      clear() {\n        this.features.clear();\n      }\n      load(e = [], t) {\n        for (const s of e) {\n          const e = s.id;\n          if (null == e) continue;\n          let i = this.features.get(e);\n          i && this.updateCache(i, t), s.geometry ? (i = b(s), this.updateCache(i, t), this.features.set(e, i)) : this.features.delete(e), this.updateCache(i, t);\n        }\n      }\n      updateCache(e, t) {\n        for (const {\n          canonical: s,\n          uid: i\n        } of Object.values(t)) {\n          const {\n            z: o,\n            x: n,\n            y: r\n          } = s;\n          w(e, Math.pow(2, o), n, r) && delete t[i];\n        }\n      }\n      getTile(e, t, s) {\n        const i = Math.pow(2, e),\n          o = [];\n        for (const e of this.features.values()) w(e, i, t, s) && o.push(M(e, i, t, s));\n        return {\n          features: o\n        };\n      }\n      getFeatures() {\n        return [...this.features.values()];\n      }\n    }\n    function w({\n      minX: e,\n      minY: t,\n      maxX: s,\n      maxY: i\n    }, o, n, r) {\n      return e < (n + 1 + m) / o && t < (r + 1 + m) / o && s > (n - m) / o && i > (r - m) / o;\n    }\n    function b(e) {\n      const {\n        id: t,\n        geometry: s,\n        properties: i\n      } = e;\n      if (!s) return;\n      if (\"GeometryCollection\" === s.type) throw new Error(\"GeometryCollection not supported in dynamic mode.\");\n      const {\n          type: o,\n          coordinates: n\n        } = s,\n        r = {\n          id: t,\n          type: 1,\n          geometry: [],\n          tags: i,\n          minX: 1 / 0,\n          minY: 1 / 0,\n          maxX: -1 / 0,\n          maxY: -1 / 0\n        },\n        a = r.geometry;\n      if (\"Point\" === o) v(n, a, r);else if (\"MultiPoint\" === o) for (const e of n) v(e, a, r);else if (\"LineString\" === o) r.type = 2, I(n, a, r);else if (\"MultiLineString\" === o) r.type = 2, S(n, a, r);else if (\"Polygon\" === o) r.type = 3, S(n, a, r, !0);else {\n        if (\"MultiPolygon\" !== o) throw new Error(\"Input data is not a valid GeoJSON object.\");\n        r.type = 3;\n        for (const e of n) S(e, a, r, !0);\n      }\n      return r;\n    }\n    function v([t, s], i, o) {\n      const n = e.av(t);\n      let r = e.aC(s);\n      r = r < 0 ? 0 : r > 1 ? 1 : r, i.push(n, r), o.minX = Math.min(o.minX, n), o.minY = Math.min(o.minY, r), o.maxX = Math.max(o.maxX, n), o.maxY = Math.max(o.maxY, r);\n    }\n    function I(e, t, s, i = !1, o = !1) {\n      const n = [];\n      for (const t of e) v(t, n, s);\n      t.push(n), i && function (e, t) {\n        let s = 0;\n        for (let t = 0, i = e.length, o = i - 2; t < i; o = t, t += 2) s += (e[t] - e[o]) * (e[t + 1] + e[o + 1]);\n        if (s > 0 === t) for (let t = 0, s = e.length; t < s / 2; t += 2) {\n          const i = e[t],\n            o = e[t + 1];\n          e[t] = e[s - 2 - t], e[t + 1] = e[s - 1 - t], e[s - 2 - t] = i, e[s - 1 - t] = o;\n        }\n      }(n, o);\n    }\n    function S(e, t, s, i = !1) {\n      for (let o = 0; o < e.length; o++) I(e[o], t, s, i, 0 === o);\n    }\n    function M(t, s, i, o) {\n      const {\n          id: n,\n          type: r,\n          geometry: a,\n          tags: l\n        } = t,\n        c = [];\n      if (1 === r) !function (t, s, i, o, n) {\n        for (let r = 0; r < t.length; r += 2) {\n          const a = Math.round(e.ai * (t[r + 0] * s - i)),\n            l = Math.round(e.ai * (t[r + 1] * s - o));\n          n.push([a, l]);\n        }\n      }(a, s, i, o, c);else for (const e of a) T(e, s, i, o, c);\n      return {\n        id: n,\n        type: r,\n        geometry: c,\n        tags: l\n      };\n    }\n    function T(t, s, i, o, n) {\n      const r = -y,\n        a = e.ai + y;\n      let l;\n      for (let c = 0; c < t.length - 2; c += 2) {\n        let h = Math.round(e.ai * (t[c + 0] * s - i)),\n          u = Math.round(e.ai * (t[c + 1] * s - o)),\n          d = Math.round(e.ai * (t[c + 2] * s - i)),\n          p = Math.round(e.ai * (t[c + 3] * s - o));\n        const f = d - h,\n          g = p - u;\n        h < r && d < r || (h < r ? (u += Math.round(g * ((r - h) / f)), h = r) : d < r && (p = u + Math.round(g * ((r - h) / f)), d = r), u < r && p < r || (u < r ? (h += Math.round(f * ((r - u) / g)), u = r) : p < r && (d = h + Math.round(f * ((r - u) / g)), p = r), h >= a && d >= a || (h >= a ? (u += Math.round(g * ((a - h) / f)), h = a) : d >= a && (p = u + Math.round(g * ((a - h) / f)), d = a), u >= a && p >= a || (u >= a ? (h += Math.round(f * ((a - u) / g)), u = a) : p >= a && (d = h + Math.round(f * ((a - u) / g)), p = a), l && h === l[l.length - 1][0] && u === l[l.length - 1][1] || (l = [[h, u]], n.push(l)), l.push([d, p])))));\n      }\n    }\n    var P,\n      k,\n      C,\n      _ = {\n        exports: {}\n      },\n      L = function () {\n        if (C) return _.exports;\n        C = 1;\n        var t = e.eg(),\n          s = function () {\n            if (k) return P;\n            k = 1;\n            var t = e.ee(),\n              s = e.ef().VectorTileFeature;\n            function i(e, t) {\n              this.options = t || {}, this.features = e, this.length = e.length;\n            }\n            function o(e, t) {\n              this.id = \"number\" == typeof e.id ? e.id : void 0, this.type = e.type, this.rawGeometry = 1 === e.type ? [e.geometry] : e.geometry, this.properties = e.tags, this.extent = t || 4096;\n            }\n            return P = i, i.prototype.feature = function (e) {\n              return new o(this.features[e], this.options.extent);\n            }, o.prototype.loadGeometry = function () {\n              var e = this.rawGeometry;\n              this.geometry = [];\n              for (var s = 0; s < e.length; s++) {\n                for (var i = e[s], o = [], n = 0; n < i.length; n++) o.push(new t(i[n][0], i[n][1]));\n                this.geometry.push(o);\n              }\n              return this.geometry;\n            }, o.prototype.bbox = function () {\n              this.geometry || this.loadGeometry();\n              for (var e = this.geometry, t = 1 / 0, s = -1 / 0, i = 1 / 0, o = -1 / 0, n = 0; n < e.length; n++) for (var r = e[n], a = 0; a < r.length; a++) {\n                var l = r[a];\n                t = Math.min(t, l.x), s = Math.max(s, l.x), i = Math.min(i, l.y), o = Math.max(o, l.y);\n              }\n              return [t, i, s, o];\n            }, o.prototype.toGeoJSON = s.prototype.toGeoJSON, P;\n          }();\n        function i(e) {\n          var s = new t();\n          return function (e, t) {\n            for (var s in e.layers) t.writeMessage(3, o, e.layers[s]);\n          }(e, s), s.finish();\n        }\n        function o(e, t) {\n          var s;\n          t.writeVarintField(15, e.version || 1), t.writeStringField(1, e.name || \"\"), t.writeVarintField(5, e.extent || 4096);\n          var i = {\n            keys: [],\n            values: [],\n            keycache: {},\n            valuecache: {}\n          };\n          for (s = 0; s < e.length; s++) i.feature = e.feature(s), t.writeMessage(2, n, i);\n          var o = i.keys;\n          for (s = 0; s < o.length; s++) t.writeStringField(3, o[s]);\n          var r = i.values;\n          for (s = 0; s < r.length; s++) t.writeMessage(4, h, r[s]);\n        }\n        function n(e, t) {\n          var s = e.feature;\n          void 0 !== s.id && t.writeVarintField(1, s.id), t.writeMessage(2, r, e), t.writeVarintField(3, s.type), t.writeMessage(4, c, s);\n        }\n        function r(e, t) {\n          var s = e.feature,\n            i = e.keys,\n            o = e.values,\n            n = e.keycache,\n            r = e.valuecache;\n          for (var a in s.properties) {\n            var l = s.properties[a],\n              c = n[a];\n            if (null !== l) {\n              void 0 === c && (i.push(a), n[a] = c = i.length - 1), t.writeVarint(c);\n              var h = typeof l;\n              \"string\" !== h && \"boolean\" !== h && \"number\" !== h && (l = JSON.stringify(l));\n              var u = h + \":\" + l,\n                d = r[u];\n              void 0 === d && (o.push(l), r[u] = d = o.length - 1), t.writeVarint(d);\n            }\n          }\n        }\n        function a(e, t) {\n          return (t << 3) + (7 & e);\n        }\n        function l(e) {\n          return e << 1 ^ e >> 31;\n        }\n        function c(e, t) {\n          for (var s = e.loadGeometry(), i = e.type, o = 0, n = 0, r = s.length, c = 0; c < r; c++) {\n            var h = s[c],\n              u = 1;\n            1 === i && (u = h.length), t.writeVarint(a(1, u));\n            for (var d = 3 === i ? h.length - 1 : h.length, p = 0; p < d; p++) {\n              1 === p && 1 !== i && t.writeVarint(a(2, d - 1));\n              var f = h[p].x - o,\n                g = h[p].y - n;\n              t.writeVarint(l(f)), t.writeVarint(l(g)), o += f, n += g;\n            }\n            3 === i && t.writeVarint(a(7, 1));\n          }\n        }\n        function h(e, t) {\n          var s = typeof e;\n          \"string\" === s ? t.writeStringField(1, e) : \"boolean\" === s ? t.writeBooleanField(7, e) : \"number\" === s && (e % 1 != 0 ? t.writeDoubleField(3, e) : e < 0 ? t.writeSVarintField(6, e) : t.writeVarintField(5, e));\n        }\n        return _.exports = i, _.exports.fromVectorTileJs = i, _.exports.fromGeojsonVt = function (e, t) {\n          t = t || {};\n          var o = {};\n          for (var n in e) o[n] = new s(e[n].features, t), o[n].name = n, o[n].version = t.version, o[n].extent = t.extent;\n          return i({\n            layers: o\n          });\n        }, _.exports.GeoJSONWrapper = s, _.exports;\n      }(),\n      z = e.eh(L);\n    const D = {\n        minZoom: 0,\n        maxZoom: 16,\n        minPoints: 2,\n        radius: 40,\n        extent: 512,\n        nodeSize: 64,\n        log: !1,\n        generateId: !1,\n        reduce: null,\n        map: e => e\n      },\n      j = Math.fround || (O = new Float32Array(1), e => (O[0] = +e, O[0]));\n    var O;\n    const F = 3,\n      A = 5,\n      Z = 6;\n    class E {\n      constructor(e) {\n        this.options = Object.assign(Object.create(D), e), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];\n      }\n      load(e) {\n        const {\n          log: t,\n          minZoom: s,\n          maxZoom: i\n        } = this.options;\n        t && console.time(\"total time\");\n        const o = `prepare ${e.length} points`;\n        t && console.time(o), this.points = e;\n        const n = [];\n        for (let t = 0; t < e.length; t++) {\n          const s = e[t];\n          if (!s.geometry) continue;\n          const [i, o] = s.geometry.coordinates,\n            r = j(B(i)),\n            a = j(G(o));\n          n.push(r, a, 1 / 0, t, -1, 1), this.options.reduce && n.push(0);\n        }\n        let r = this.trees[i + 1] = this._createTree(n);\n        t && console.timeEnd(o);\n        for (let e = i; e >= s; e--) {\n          const s = +Date.now();\n          r = this.trees[e] = this._createTree(this._cluster(r, e)), t && console.log(\"z%d: %d clusters in %dms\", e, r.numItems, +Date.now() - s);\n        }\n        return t && console.timeEnd(\"total time\"), this;\n      }\n      getClusters(e, t) {\n        let s = ((e[0] + 180) % 360 + 360) % 360 - 180;\n        const i = Math.max(-90, Math.min(90, e[1]));\n        let o = 180 === e[2] ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180;\n        const n = Math.max(-90, Math.min(90, e[3]));\n        if (e[2] - e[0] >= 360) s = -180, o = 180;else if (s > o) {\n          const e = this.getClusters([s, i, 180, n], t),\n            r = this.getClusters([-180, i, o, n], t);\n          return e.concat(r);\n        }\n        const r = this.trees[this._limitZoom(t)],\n          a = r.range(B(s), G(n), B(o), G(i)),\n          l = r.data,\n          c = [];\n        for (const e of a) {\n          const t = this.stride * e;\n          c.push(l[t + A] > 1 ? N(l, t, this.clusterProps) : this.points[l[t + F]]);\n        }\n        return c;\n      }\n      getChildren(e) {\n        const t = this._getOriginId(e),\n          s = this._getOriginZoom(e),\n          i = \"No cluster with the specified id.\",\n          o = this.trees[s];\n        if (!o) throw new Error(i);\n        const n = o.data;\n        if (t * this.stride >= n.length) throw new Error(i);\n        const r = this.options.radius / (this.options.extent * Math.pow(2, s - 1)),\n          a = o.within(n[t * this.stride], n[t * this.stride + 1], r),\n          l = [];\n        for (const t of a) {\n          const s = t * this.stride;\n          n[s + 4] === e && l.push(n[s + A] > 1 ? N(n, s, this.clusterProps) : this.points[n[s + F]]);\n        }\n        if (0 === l.length) throw new Error(i);\n        return l;\n      }\n      getLeaves(e, t, s) {\n        const i = [];\n        return this._appendLeaves(i, e, t = t || 10, s = s || 0, 0), i;\n      }\n      getTile(e, t, s) {\n        const i = this.trees[this._limitZoom(e)],\n          o = Math.pow(2, e),\n          {\n            extent: n,\n            radius: r\n          } = this.options,\n          a = r / n,\n          l = (s - a) / o,\n          c = (s + 1 + a) / o,\n          h = {\n            features: []\n          };\n        return this._addTileFeatures(i.range((t - a) / o, l, (t + 1 + a) / o, c), i.data, t, s, o, h), 0 === t && this._addTileFeatures(i.range(1 - a / o, l, 1, c), i.data, o, s, o, h), t === o - 1 && this._addTileFeatures(i.range(0, l, a / o, c), i.data, -1, s, o, h), h.features.length ? h : null;\n      }\n      getClusterExpansionZoom(e) {\n        let t = this._getOriginZoom(e) - 1;\n        for (; t <= this.options.maxZoom;) {\n          const s = this.getChildren(e);\n          if (t++, 1 !== s.length) break;\n          e = s[0].properties.cluster_id;\n        }\n        return t;\n      }\n      _appendLeaves(e, t, s, i, o) {\n        const n = this.getChildren(t);\n        for (const t of n) {\n          const n = t.properties;\n          if (n && n.cluster ? o + n.point_count <= i ? o += n.point_count : o = this._appendLeaves(e, n.cluster_id, s, i, o) : o < i ? o++ : e.push(t), e.length === s) break;\n        }\n        return o;\n      }\n      _createTree(t) {\n        const s = new e.bE(t.length / this.stride | 0, this.options.nodeSize, Float32Array);\n        for (let e = 0; e < t.length; e += this.stride) s.add(t[e], t[e + 1]);\n        return s.finish(), s.data = t, s;\n      }\n      _addTileFeatures(e, t, s, i, o, n) {\n        for (const r of e) {\n          const e = r * this.stride,\n            a = t[e + A] > 1;\n          let l, c, h;\n          if (a) l = X(t, e, this.clusterProps), c = t[e], h = t[e + 1];else {\n            const s = this.points[t[e + F]];\n            l = s.properties;\n            const [i, o] = s.geometry.coordinates;\n            c = B(i), h = G(o);\n          }\n          const u = {\n            type: 1,\n            geometry: [[Math.round(this.options.extent * (c * o - s)), Math.round(this.options.extent * (h * o - i))]],\n            tags: l\n          };\n          let d;\n          d = a || this.options.generateId ? t[e + F] : this.points[t[e + F]].id, void 0 !== d && (u.id = d), n.features.push(u);\n        }\n      }\n      _limitZoom(e) {\n        return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1));\n      }\n      _cluster(e, t) {\n        const {\n            radius: s,\n            extent: i,\n            reduce: o,\n            minPoints: n\n          } = this.options,\n          r = s / (i * Math.pow(2, t)),\n          a = e.data,\n          l = [],\n          c = this.stride;\n        for (let s = 0; s < a.length; s += c) {\n          if (a[s + 2] <= t) continue;\n          a[s + 2] = t;\n          const i = a[s],\n            h = a[s + 1],\n            u = e.within(a[s], a[s + 1], r),\n            d = a[s + A];\n          let p = d;\n          for (const e of u) {\n            const s = e * c;\n            a[s + 2] > t && (p += a[s + A]);\n          }\n          if (p > d && p >= n) {\n            let e,\n              n = i * d,\n              r = h * d,\n              f = -1;\n            const g = (s / c << 5) + (t + 1) + this.points.length;\n            for (const i of u) {\n              const l = i * c;\n              if (a[l + 2] <= t) continue;\n              a[l + 2] = t;\n              const h = a[l + A];\n              n += a[l] * h, r += a[l + 1] * h, a[l + 4] = g, o && (e || (e = this._map(a, s, !0), f = this.clusterProps.length, this.clusterProps.push(e)), o(e, this._map(a, l)));\n            }\n            a[s + 4] = g, l.push(n / p, r / p, 1 / 0, g, -1, p), o && l.push(f);\n          } else {\n            for (let e = 0; e < c; e++) l.push(a[s + e]);\n            if (p > 1) for (const e of u) {\n              const s = e * c;\n              if (!(a[s + 2] <= t)) {\n                a[s + 2] = t;\n                for (let e = 0; e < c; e++) l.push(a[s + e]);\n              }\n            }\n          }\n        }\n        return l;\n      }\n      _getOriginId(e) {\n        return e - this.points.length >> 5;\n      }\n      _getOriginZoom(e) {\n        return (e - this.points.length) % 32;\n      }\n      _map(e, t, s) {\n        if (e[t + A] > 1) {\n          const i = this.clusterProps[e[t + Z]];\n          return s ? Object.assign({}, i) : i;\n        }\n        const i = this.points[e[t + F]].properties,\n          o = this.options.map(i);\n        return s && o === i ? Object.assign({}, o) : o;\n      }\n    }\n    function N(e, t, s) {\n      return {\n        type: \"Feature\",\n        id: e[t + F],\n        properties: X(e, t, s),\n        geometry: {\n          type: \"Point\",\n          coordinates: [(i = e[t], 360 * (i - .5)), Y(e[t + 1])]\n        }\n      };\n      var i;\n    }\n    function X(e, t, s) {\n      const i = e[t + A],\n        o = i >= 1e4 ? `${Math.round(i / 1e3)}k` : i >= 1e3 ? Math.round(i / 100) / 10 + \"k\" : i,\n        n = e[t + Z],\n        r = -1 === n ? {} : Object.assign({}, s[n]);\n      return Object.assign(r, {\n        cluster: !0,\n        cluster_id: e[t + F],\n        point_count: i,\n        point_count_abbreviated: o\n      });\n    }\n    function B(e) {\n      return e / 360 + .5;\n    }\n    function G(e) {\n      const t = Math.sin(e * Math.PI / 180),\n        s = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;\n      return s < 0 ? 0 : s > 1 ? 1 : s;\n    }\n    function Y(e) {\n      const t = (180 - 360 * e) * Math.PI / 180;\n      return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;\n    }\n    function R(e, t, s, i) {\n      let o = i;\n      const n = t + (s - t >> 1);\n      let r,\n        a = s - t;\n      const l = e[t],\n        c = e[t + 1],\n        h = e[s],\n        u = e[s + 1];\n      for (let i = t + 3; i < s; i += 3) {\n        const t = J(e[i], e[i + 1], l, c, h, u);\n        if (t > o) r = i, o = t;else if (t === o) {\n          const e = Math.abs(i - n);\n          e < a && (r = i, a = e);\n        }\n      }\n      o > i && (r - t > 3 && R(e, t, r, i), e[r + 2] = o, s - r > 3 && R(e, r, s, i));\n    }\n    function J(e, t, s, i, o, n) {\n      let r = o - s,\n        a = n - i;\n      if (0 !== r || 0 !== a) {\n        const l = ((e - s) * r + (t - i) * a) / (r * r + a * a);\n        l > 1 ? (s = o, i = n) : l > 0 && (s += r * l, i += a * l);\n      }\n      return r = e - s, a = t - i, r * r + a * a;\n    }\n    function V(e, t, s, i) {\n      const o = {\n        id: e ?? null,\n        type: t,\n        geometry: s,\n        tags: i,\n        minX: 1 / 0,\n        minY: 1 / 0,\n        maxX: -1 / 0,\n        maxY: -1 / 0\n      };\n      if (\"Point\" === t || \"MultiPoint\" === t || \"LineString\" === t) $(o, s);else if (\"Polygon\" === t) $(o, s[0]);else if (\"MultiLineString\" === t) for (const e of s) $(o, e);else if (\"MultiPolygon\" === t) for (const e of s) $(o, e[0]);\n      return o;\n    }\n    function $(e, t) {\n      for (let s = 0; s < t.length; s += 3) e.minX = Math.min(e.minX, t[s]), e.minY = Math.min(e.minY, t[s + 1]), e.maxX = Math.max(e.maxX, t[s]), e.maxY = Math.max(e.maxY, t[s + 1]);\n    }\n    function W(e, t, s, i) {\n      if (!t.geometry) return;\n      const o = t.geometry.coordinates;\n      if (o && 0 === o.length) return;\n      const n = t.geometry.type,\n        r = Math.pow(s.tolerance / ((1 << s.maxZoom) * s.extent), 2);\n      let a = [],\n        l = t.id;\n      if (s.promoteId ? l = t.properties[s.promoteId] : s.generateId && (l = i || 0), \"Point\" === n) q(o, a);else if (\"MultiPoint\" === n) for (const e of o) q(e, a);else if (\"LineString\" === n) U(o, a, r, !1);else if (\"MultiLineString\" === n) {\n        if (s.lineMetrics) {\n          for (const s of o) a = [], U(s, a, r, !1), e.push(V(l, \"LineString\", a, t.properties));\n          return;\n        }\n        H(o, a, r, !1);\n      } else if (\"Polygon\" === n) H(o, a, r, !0);else {\n        if (\"MultiPolygon\" !== n) {\n          if (\"GeometryCollection\" === n) {\n            for (const o of t.geometry.geometries) W(e, {\n              id: l,\n              geometry: o,\n              properties: t.properties\n            }, s, i);\n            return;\n          }\n          throw new Error(\"Input data is not a valid GeoJSON object.\");\n        }\n        for (const e of o) {\n          const t = [];\n          H(e, t, r, !0), a.push(t);\n        }\n      }\n      e.push(V(l, n, a, t.properties));\n    }\n    function q(e, t) {\n      t.push(Q(e[0]), K(e[1]), 0);\n    }\n    function U(e, t, s, i) {\n      let o,\n        n,\n        r = 0;\n      for (let s = 0; s < e.length; s++) {\n        const a = Q(e[s][0]),\n          l = K(e[s][1]);\n        t.push(a, l, 0), s > 0 && (r += i ? (o * l - a * n) / 2 : Math.sqrt(Math.pow(a - o, 2) + Math.pow(l - n, 2))), o = a, n = l;\n      }\n      const a = t.length - 3;\n      t[2] = 1, R(t, 0, a, s), t[a + 2] = 1, t.size = Math.abs(r), t.start = 0, t.end = t.size;\n    }\n    function H(e, t, s, i) {\n      for (let o = 0; o < e.length; o++) {\n        const n = [];\n        U(e[o], n, s, i), t.push(n);\n      }\n    }\n    function Q(e) {\n      return e / 360 + .5;\n    }\n    function K(e) {\n      const t = Math.sin(e * Math.PI / 180),\n        s = .5 - .25 * Math.log((1 + t) / (1 - t)) / Math.PI;\n      return s < 0 ? 0 : s > 1 ? 1 : s;\n    }\n    function ee(e, t, s, i, o, n, r, a) {\n      if (i /= t, n >= (s /= t) && r < i) return e;\n      if (r < s || n >= i) return null;\n      const l = [];\n      for (const t of e) {\n        const e = t.geometry;\n        let n = t.type;\n        const r = 0 === o ? t.minX : t.minY,\n          c = 0 === o ? t.maxX : t.maxY;\n        if (r >= s && c < i) {\n          l.push(t);\n          continue;\n        }\n        if (c < s || r >= i) continue;\n        let h = [];\n        if (\"Point\" === n || \"MultiPoint\" === n) te(e, h, s, i, o);else if (\"LineString\" === n) se(e, h, s, i, o, !1, a.lineMetrics);else if (\"MultiLineString\" === n) oe(e, h, s, i, o, !1);else if (\"Polygon\" === n) oe(e, h, s, i, o, !0);else if (\"MultiPolygon\" === n) for (const t of e) {\n          const e = [];\n          oe(t, e, s, i, o, !0), e.length && h.push(e);\n        }\n        if (h.length) {\n          if (a.lineMetrics && \"LineString\" === n) {\n            for (const e of h) l.push(V(t.id, n, e, t.tags));\n            continue;\n          }\n          \"LineString\" !== n && \"MultiLineString\" !== n || (1 === h.length ? (n = \"LineString\", h = h[0]) : n = \"MultiLineString\"), \"Point\" !== n && \"MultiPoint\" !== n || (n = 3 === h.length ? \"Point\" : \"MultiPoint\"), l.push(V(t.id, n, h, t.tags));\n        }\n      }\n      return l.length ? l : null;\n    }\n    function te(e, t, s, i, o) {\n      for (let n = 0; n < e.length; n += 3) {\n        const r = e[n + o];\n        r >= s && r <= i && ne(t, e[n], e[n + 1], e[n + 2]);\n      }\n    }\n    function se(e, t, s, i, o, n, r) {\n      let a = ie(e);\n      const l = 0 === o ? re : ae;\n      let c,\n        h,\n        u = e.start;\n      for (let d = 0; d < e.length - 3; d += 3) {\n        const p = e[d],\n          f = e[d + 1],\n          g = e[d + 2],\n          m = e[d + 3],\n          y = e[d + 4],\n          x = 0 === o ? p : f,\n          w = 0 === o ? m : y;\n        let b = !1;\n        r && (c = Math.sqrt(Math.pow(p - m, 2) + Math.pow(f - y, 2))), x < s ? w > s && (h = l(a, p, f, m, y, s), r && (a.start = u + c * h)) : x > i ? w < i && (h = l(a, p, f, m, y, i), r && (a.start = u + c * h)) : ne(a, p, f, g), w < s && x >= s && (h = l(a, p, f, m, y, s), b = !0), w > i && x <= i && (h = l(a, p, f, m, y, i), b = !0), !n && b && (r && (a.end = u + c * h), t.push(a), a = ie(e)), r && (u += c);\n      }\n      let d = e.length - 3;\n      const p = e[d],\n        f = e[d + 1],\n        g = 0 === o ? p : f;\n      g >= s && g <= i && ne(a, p, f, e[d + 2]), d = a.length - 3, n && d >= 3 && (a[d] !== a[0] || a[d + 1] !== a[1]) && ne(a, a[0], a[1], a[2]), a.length && t.push(a);\n    }\n    function ie(e) {\n      const t = [];\n      return t.size = e.size, t.start = e.start, t.end = e.end, t;\n    }\n    function oe(e, t, s, i, o, n) {\n      for (const r of e) se(r, t, s, i, o, n, !1);\n    }\n    function ne(e, t, s, i) {\n      e.push(t, s, i);\n    }\n    function re(e, t, s, i, o, n) {\n      const r = (n - t) / (i - t);\n      return ne(e, n, s + (o - s) * r, 1), r;\n    }\n    function ae(e, t, s, i, o, n) {\n      const r = (n - s) / (o - s);\n      return ne(e, t + (i - t) * r, n, 1), r;\n    }\n    function le(e, t) {\n      const s = [];\n      for (let i = 0; i < e.length; i++) {\n        const o = e[i],\n          n = o.type;\n        let r;\n        if (\"Point\" === n || \"MultiPoint\" === n || \"LineString\" === n) r = ce(o.geometry, t);else if (\"MultiLineString\" === n || \"Polygon\" === n) {\n          r = [];\n          for (const e of o.geometry) r.push(ce(e, t));\n        } else if (\"MultiPolygon\" === n) {\n          r = [];\n          for (const e of o.geometry) {\n            const s = [];\n            for (const i of e) s.push(ce(i, t));\n            r.push(s);\n          }\n        }\n        s.push(V(o.id, n, r, o.tags));\n      }\n      return s;\n    }\n    function ce(e, t) {\n      const s = [];\n      s.size = e.size, void 0 !== e.start && (s.start = e.start, s.end = e.end);\n      for (let i = 0; i < e.length; i += 3) s.push(e[i] + t, e[i + 1], e[i + 2]);\n      return s;\n    }\n    function he(e, t) {\n      if (e.transformed) return e;\n      const s = 1 << e.z,\n        i = e.x,\n        o = e.y;\n      for (const n of e.features) {\n        const e = n.geometry,\n          r = n.type;\n        if (n.geometry = [], 1 === r) for (let r = 0; r < e.length; r += 2) n.geometry.push(ue(e[r], e[r + 1], t, s, i, o));else for (let r = 0; r < e.length; r++) {\n          const a = [];\n          for (let n = 0; n < e[r].length; n += 2) a.push(ue(e[r][n], e[r][n + 1], t, s, i, o));\n          n.geometry.push(a);\n        }\n      }\n      return e.transformed = !0, e;\n    }\n    function ue(e, t, s, i, o, n) {\n      return [Math.round(s * (e * i - o)), Math.round(s * (t * i - n))];\n    }\n    function de(e, t, s, i, o) {\n      const n = t === o.maxZoom ? 0 : o.tolerance / ((1 << t) * o.extent),\n        r = {\n          features: [],\n          numPoints: 0,\n          numSimplified: 0,\n          numFeatures: e.length,\n          source: null,\n          x: s,\n          y: i,\n          z: t,\n          transformed: !1,\n          minX: 2,\n          minY: 1,\n          maxX: -1,\n          maxY: 0\n        };\n      for (const t of e) pe(r, t, n, o);\n      return r;\n    }\n    function pe(e, t, s, i) {\n      const o = t.geometry,\n        n = t.type,\n        r = [];\n      if (e.minX = Math.min(e.minX, t.minX), e.minY = Math.min(e.minY, t.minY), e.maxX = Math.max(e.maxX, t.maxX), e.maxY = Math.max(e.maxY, t.maxY), \"Point\" === n || \"MultiPoint\" === n) for (let t = 0; t < o.length; t += 3) r.push(o[t], o[t + 1]), e.numPoints++, e.numSimplified++;else if (\"LineString\" === n) fe(r, o, e, s, !1, !1);else if (\"MultiLineString\" === n || \"Polygon\" === n) for (let t = 0; t < o.length; t++) fe(r, o[t], e, s, \"Polygon\" === n, 0 === t);else if (\"MultiPolygon\" === n) for (let t = 0; t < o.length; t++) {\n        const i = o[t];\n        for (let t = 0; t < i.length; t++) fe(r, i[t], e, s, !0, 0 === t);\n      }\n      if (r.length) {\n        let s = t.tags || null;\n        if (\"LineString\" === n && i.lineMetrics) {\n          s = {};\n          for (const e in t.tags) s[e] = t.tags[e];\n          s.mapbox_clip_start = o.start / o.size, s.mapbox_clip_end = o.end / o.size;\n        }\n        const a = {\n          geometry: r,\n          type: \"Polygon\" === n || \"MultiPolygon\" === n ? 3 : \"LineString\" === n || \"MultiLineString\" === n ? 2 : 1,\n          tags: s\n        };\n        null !== t.id && (a.id = t.id), e.features.push(a);\n      }\n    }\n    function fe(e, t, s, i, o, n) {\n      const r = i * i;\n      if (i > 0 && t.size < (o ? r : i)) return void (s.numPoints += t.length / 3);\n      const a = [];\n      for (let e = 0; e < t.length; e += 3) (0 === i || t[e + 2] > r) && (s.numSimplified++, a.push(t[e], t[e + 1])), s.numPoints++;\n      o && function (e, t) {\n        let s = 0;\n        for (let t = 0, i = e.length, o = i - 2; t < i; o = t, t += 2) s += (e[t] - e[o]) * (e[t + 1] + e[o + 1]);\n        if (s > 0 === t) for (let t = 0, s = e.length; t < s / 2; t += 2) {\n          const i = e[t],\n            o = e[t + 1];\n          e[t] = e[s - 2 - t], e[t + 1] = e[s - 1 - t], e[s - 2 - t] = i, e[s - 1 - t] = o;\n        }\n      }(a, n), e.push(a);\n    }\n    const ge = {\n      maxZoom: 14,\n      indexMaxZoom: 5,\n      indexMaxPoints: 1e5,\n      tolerance: 3,\n      extent: 4096,\n      buffer: 64,\n      lineMetrics: !1,\n      promoteId: null,\n      generateId: !1,\n      debug: 0\n    };\n    class me {\n      constructor(e, t) {\n        const s = (t = this.options = function (e, t) {\n          for (const s in t) e[s] = t[s];\n          return e;\n        }(Object.create(ge), t)).debug;\n        if (s && console.time(\"preprocess data\"), t.maxZoom < 0 || t.maxZoom > 24) throw new Error(\"maxZoom should be in the 0-24 range\");\n        if (t.promoteId && t.generateId) throw new Error(\"promoteId and generateId cannot be used together.\");\n        let i = function (e, t) {\n          const s = [];\n          if (\"FeatureCollection\" === e.type) for (let i = 0; i < e.features.length; i++) W(s, e.features[i], t, i);else W(s, \"Feature\" === e.type ? e : {\n            geometry: e\n          }, t);\n          return s;\n        }(e, t);\n        this.tiles = {}, this.tileCoords = [], s && (console.timeEnd(\"preprocess data\"), console.log(\"index: maxZoom: %d, maxPoints: %d\", t.indexMaxZoom, t.indexMaxPoints), console.time(\"generate tiles\"), this.stats = {}, this.total = 0), i = function (e, t) {\n          const s = t.buffer / t.extent;\n          let i = e;\n          const o = ee(e, 1, -1 - s, s, 0, -1, 2, t),\n            n = ee(e, 1, 1 - s, 2 + s, 0, -1, 2, t);\n          return (o || n) && (i = ee(e, 1, -s, 1 + s, 0, -1, 2, t) || [], o && (i = le(o, 1).concat(i)), n && (i = i.concat(le(n, -1)))), i;\n        }(i, t), i.length && this.splitTile(i, 0, 0, 0), s && (i.length && console.log(\"features: %d, points: %d\", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd(\"generate tiles\"), console.log(\"tiles generated:\", this.total, JSON.stringify(this.stats)));\n      }\n      splitTile(e, t, s, i, o, n, r) {\n        const a = [e, t, s, i],\n          l = this.options,\n          c = l.debug;\n        for (; a.length;) {\n          i = a.pop(), s = a.pop(), t = a.pop(), e = a.pop();\n          const h = 1 << t,\n            u = ye(t, s, i);\n          let d = this.tiles[u];\n          if (!d && (c > 1 && console.time(\"creation\"), d = this.tiles[u] = de(e, t, s, i, l), this.tileCoords.push({\n            z: t,\n            x: s,\n            y: i\n          }), c)) {\n            c > 1 && (console.log(\"tile z%d-%d-%d (features: %d, points: %d, simplified: %d)\", t, s, i, d.numFeatures, d.numPoints, d.numSimplified), console.timeEnd(\"creation\"));\n            const e = `z${t}`;\n            this.stats[e] = (this.stats[e] || 0) + 1, this.total++;\n          }\n          if (d.source = e, null == o) {\n            if (t === l.indexMaxZoom || d.numPoints <= l.indexMaxPoints) continue;\n          } else {\n            if (t === l.maxZoom || t === o) continue;\n            if (null != o) {\n              const e = o - t;\n              if (s !== n >> e || i !== r >> e) continue;\n            }\n          }\n          if (d.source = null, 0 === e.length) continue;\n          c > 1 && console.time(\"clipping\");\n          const p = .5 * l.buffer / l.extent,\n            f = .5 - p,\n            g = .5 + p,\n            m = 1 + p;\n          let y = null,\n            x = null,\n            w = null,\n            b = null,\n            v = ee(e, h, s - p, s + g, 0, d.minX, d.maxX, l),\n            I = ee(e, h, s + f, s + m, 0, d.minX, d.maxX, l);\n          e = null, v && (y = ee(v, h, i - p, i + g, 1, d.minY, d.maxY, l), x = ee(v, h, i + f, i + m, 1, d.minY, d.maxY, l), v = null), I && (w = ee(I, h, i - p, i + g, 1, d.minY, d.maxY, l), b = ee(I, h, i + f, i + m, 1, d.minY, d.maxY, l), I = null), c > 1 && console.timeEnd(\"clipping\"), a.push(y || [], t + 1, 2 * s, 2 * i), a.push(x || [], t + 1, 2 * s, 2 * i + 1), a.push(w || [], t + 1, 2 * s + 1, 2 * i), a.push(b || [], t + 1, 2 * s + 1, 2 * i + 1);\n        }\n      }\n      getTile(e, t, s) {\n        e = +e, t = +t, s = +s;\n        const i = this.options,\n          {\n            extent: o,\n            debug: n\n          } = i;\n        if (e < 0 || e > 24) return null;\n        const r = 1 << e,\n          a = ye(e, t = t + r & r - 1, s);\n        if (this.tiles[a]) return he(this.tiles[a], o);\n        n > 1 && console.log(\"drilling down to z%d-%d-%d\", e, t, s);\n        let l,\n          c = e,\n          h = t,\n          u = s;\n        for (; !l && c > 0;) c--, h >>= 1, u >>= 1, l = this.tiles[ye(c, h, u)];\n        return l && l.source ? (n > 1 && (console.log(\"found parent tile z%d-%d-%d\", c, h, u), console.time(\"drilling down\")), this.splitTile(l.source, c, h, u, e, t, s), n > 1 && console.timeEnd(\"drilling down\"), this.tiles[a] ? he(this.tiles[a], o) : null) : null;\n      }\n    }\n    function ye(e, t, s) {\n      return 32 * ((1 << e) * s + t) + e;\n    }\n    function xe(e, t) {\n      const s = e.tileID.canonical;\n      if (!this._geoJSONIndex) return void t(null, null);\n      const i = this._geoJSONIndex.getTile(s.z, s.x, s.y);\n      if (!i) return void t(null, null);\n      const o = new g(i.features);\n      let n = z(o);\n      0 === n.byteOffset && n.byteLength === n.buffer.byteLength || (n = new Uint8Array(n)), t(null, {\n        vectorTile: o,\n        rawData: n.buffer\n      });\n    }\n    class we extends c {\n      constructor(e, t, s, i, o, n) {\n        super(e, t, s, i, xe, n), o && (this.loadGeoJSON = o), this._dynamicIndex = new x();\n      }\n      loadData(s, i) {\n        const o = s && s.request,\n          n = o && o.collectResourceTiming;\n        this.loadGeoJSON(s, (r, a) => {\n          if (r || !a) return i(r);\n          if (\"object\" != typeof a) return i(new Error(`Input data given to '${s.source}' is not a valid GeoJSON object.`));\n          {\n            try {\n              if (s.filter) {\n                const t = e.X(s.filter, {\n                  type: \"boolean\",\n                  \"property-type\": \"data-driven\",\n                  overridable: !1,\n                  transition: !1\n                });\n                if (\"error\" === t.result) throw new Error(t.value.map(e => `${e.key}: ${e.message}`).join(\", \"));\n                a.features = a.features.filter(e => t.value.evaluate({\n                  zoom: 0\n                }, e));\n              }\n              s.dynamic ? (\"Feature\" === a.type && (a = {\n                type: \"FeatureCollection\",\n                features: [a]\n              }), s.append || (this._dynamicIndex.clear(), this.loaded = {}), this._dynamicIndex.load(a.features, this.loaded), s.cluster && (a.features = this._dynamicIndex.getFeatures())) : this.loaded = {}, this._geoJSONIndex = s.cluster ? new E(function ({\n                superclusterOptions: t,\n                clusterProperties: s\n              }) {\n                if (!s || !t) return t;\n                const i = {},\n                  o = {},\n                  n = {\n                    accumulated: null,\n                    zoom: 0\n                  },\n                  r = {\n                    properties: null\n                  },\n                  a = Object.keys(s);\n                for (const t of a) {\n                  const [n, r] = s[t],\n                    a = e.X(r),\n                    l = e.X(\"string\" == typeof n ? [n, [\"accumulated\"], [\"get\", t]] : n);\n                  i[t] = a.value, o[t] = l.value;\n                }\n                return t.map = e => {\n                  r.properties = e;\n                  const t = {};\n                  for (const e of a) t[e] = i[e].evaluate(n, r);\n                  return t;\n                }, t.reduce = (e, t) => {\n                  r.properties = t;\n                  for (const t of a) n.accumulated = e[t], e[t] = o[t].evaluate(n, r);\n                }, t;\n              }(s)).load(a.features) : s.dynamic ? this._dynamicIndex : function (e, t) {\n                return new me(e, t);\n              }(a, s.geojsonVtOptions);\n            } catch (e) {\n              return i(e);\n            }\n            const r = {};\n            if (n) {\n              const e = t(o);\n              e && (r.resourceTiming = {}, r.resourceTiming[s.source] = JSON.parse(JSON.stringify(e)));\n            }\n            i(null, r);\n          }\n        });\n      }\n      reloadTile(e, t) {\n        const s = this.loaded;\n        return s && s[e.uid] ? e.partial ? t(null, void 0) : super.reloadTile(e, t) : this.loadTile(e, t);\n      }\n      loadGeoJSON(t, s) {\n        if (t.request) e.n(t.request, s);else {\n          if (\"string\" != typeof t.data) return s(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));\n          try {\n            return s(null, JSON.parse(t.data));\n          } catch (e) {\n            return s(new Error(`Input data given to '${t.source}' is not a valid GeoJSON object.`));\n          }\n        }\n      }\n      getClusterExpansionZoom(e, t) {\n        try {\n          t(null, this._geoJSONIndex.getClusterExpansionZoom(e.clusterId));\n        } catch (e) {\n          t(e);\n        }\n      }\n      getClusterChildren(e, t) {\n        try {\n          t(null, this._geoJSONIndex.getChildren(e.clusterId));\n        } catch (e) {\n          t(e);\n        }\n      }\n      getClusterLeaves(e, t) {\n        try {\n          t(null, this._geoJSONIndex.getLeaves(e.clusterId, e.limit, e.offset));\n        } catch (e) {\n          t(e);\n        }\n      }\n    }\n    class be {\n      constructor(t, s) {\n        this.tileID = new e.aH(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y), this.tileZoom = t.tileZoom, this.uid = t.uid, this.zoom = t.zoom, this.canonical = t.tileID.canonical, this.pixelRatio = t.pixelRatio, this.tileSize = t.tileSize, this.source = t.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = t.projection, this.brightness = s;\n      }\n      parse(t, s, i, o) {\n        this.status = \"parsing\";\n        const n = new e.aH(i.tileID.overscaledZ, i.tileID.wrap, i.tileID.canonical.z, i.tileID.canonical.x, i.tileID.canonical.y),\n          r = [],\n          a = s.familiesBySource[i.source],\n          l = new e.e0(n, i.promoteId);\n        return l.bucketLayerIDs = [], l.is3DTile = !0, e.ei(t).then(t => {\n          if (!t) return o(new Error(\"Could not parse tile\"));\n          const s = e.ej(t, 1 / e.cd(i.tileID.canonical)),\n            c = t.json.extensionsUsed && t.json.extensionsUsed.includes(\"MAPBOX_mesh_features\") || t.json.asset.extras && t.json.asset.extras.MAPBOX_mesh_features,\n            h = t.json.extensionsUsed && t.json.extensionsUsed.includes(\"EXT_meshopt_compression\"),\n            u = new e.aa(this.zoom, {\n              brightness: this.brightness\n            });\n          for (const t in a) for (const i of a[t]) {\n            const t = i[0];\n            l.bucketLayerIDs.push(i.map(t => e.C(t.id, t.scope))), t.recalculate(u, []);\n            const o = new e.ek(i, s, n, c, h, this.brightness, l);\n            c || (o.needsUpload = !0), r.push(o), o.evaluate(t);\n          }\n          this.status = \"done\", o(null, {\n            buckets: r,\n            featureIndex: l,\n            collisionBoxArray: null,\n            glyphAtlasImage: null,\n            lineAtlas: null,\n            imageAtlas: null,\n            brightness: null\n          });\n        }).catch(e => o(new Error(e.message)));\n      }\n    }\n    class ve {\n      constructor(e, t, s, i, o, n) {\n        this.actor = e, this.layerIndex = t, this.availableImages = s, this.brightness = n, this.loading = {}, this.loaded = {};\n      }\n      loadTile(t, s) {\n        const i = t.uid,\n          o = this.loading[i] = new be(t, this.brightness);\n        e.bj(t.request, (e, n) => {\n          const r = !this.loading[i];\n          return delete this.loading[i], r || e ? (o.status = \"done\", r || (this.loaded[i] = o), s(e)) : n && 0 !== n.byteLength ? void o.parse(n, this.layerIndex, t, (e, t) => {\n            o.status = \"done\", this.loaded = this.loaded || {}, this.loaded[i] = o, e || !t ? s(e) : s(null, t);\n          }) : (o.status = \"done\", this.loaded[i] = o, s());\n        });\n      }\n      reloadTile(e, t) {\n        const s = this.loaded,\n          i = e.uid;\n        if (s && s[i]) {\n          const o = s[i];\n          o.projection = e.projection, o.brightness = e.brightness;\n          const n = (s, i) => {\n            o.reloadCallback && (delete o.reloadCallback, this.loadTile(e, t)), t(s, i);\n          };\n          \"parsing\" === o.status ? o.reloadCallback = n : \"done\" === o.status && this.loadTile(e, t);\n        }\n      }\n      abortTile(e, t) {\n        const s = e.uid;\n        this.loading[s] && delete this.loading[s], t();\n      }\n      removeTile(e, t) {\n        const s = this.loaded,\n          i = e.uid;\n        s && s[i] && delete s[i], t();\n      }\n    }\n    class Ie {\n      constructor(t) {\n        this.self = t, this.actor = new e.el(t, this), this.layerIndexes = {}, this.availableImages = {}, this.isSpriteLoaded = {}, this.imageRasterizer = new e.y(), this.projections = {}, this.defaultProjection = e.bP({\n          name: \"mercator\"\n        }), this.workerSourceTypes = {\n          vector: c,\n          geojson: we,\n          \"raster-dem\": h,\n          \"raster-array\": d,\n          \"batched-model\": ve\n        }, this.workerSources = {}, this.self.registerWorkerSource = (e, t) => {\n          if (this.workerSourceTypes[e]) throw new Error(`Worker source with name \"${e}\" already registered.`);\n          this.workerSourceTypes[e] = t;\n        }, this.self.registerRTLTextPlugin = t => {\n          if (e.em.isParsed()) throw new Error(\"RTL text plugin already registered.\");\n          e.em.applyArabicShaping = t.applyArabicShaping, e.em.processBidirectionalText = t.processBidirectionalText, e.em.processStyledBidirectionalText = t.processStyledBidirectionalText;\n        };\n      }\n      clearCaches(e, t, s) {\n        delete this.layerIndexes[e], delete this.availableImages[e], delete this.workerSources[e], s();\n      }\n      checkIfReady(e, t, s) {\n        s();\n      }\n      setReferrer(e, t) {\n        this.referrer = t;\n      }\n      spriteLoaded(t, {\n        scope: s,\n        isLoaded: i\n      }) {\n        if (this.isSpriteLoaded[t] || (this.isSpriteLoaded[t] = {}), this.isSpriteLoaded[t][s] = i, this.workerSources[t] && this.workerSources[t][s]) for (const o in this.workerSources[t][s]) {\n          const n = this.workerSources[t][s][o];\n          for (const t in n) {\n            const s = n[t];\n            s instanceof c && (s.isSpriteLoaded = i, s.fire(new e.A(\"isSpriteLoaded\")));\n          }\n        }\n      }\n      setImages(e, {\n        scope: t,\n        images: s\n      }, i) {\n        if (this.availableImages[e] || (this.availableImages[e] = {}), this.availableImages[e][t] = s, this.workerSources[e] && this.workerSources[e][t]) {\n          for (const i in this.workerSources[e][t]) {\n            const o = this.workerSources[e][t][i];\n            for (const e in o) o[e].availableImages = s;\n          }\n          i();\n        } else i();\n      }\n      setProjection(t, s) {\n        this.projections[t] = e.bP(s);\n      }\n      setBrightness(e, t, s) {\n        this.brightness = t, s();\n      }\n      setLayers(e, t, s) {\n        this.getLayerIndex(e, t.scope).replace(t.layers, t.options), s();\n      }\n      updateLayers(e, t, s) {\n        this.getLayerIndex(e, t.scope).update(t.layers, t.removedIds, t.options), s();\n      }\n      loadTile(e, t, s) {\n        t.projection = this.projections[e] || this.defaultProjection, this.getWorkerSource(e, t.type, t.source, t.scope).loadTile(t, s);\n      }\n      decodeRasterArray(e, t, s) {\n        this.getWorkerSource(e, t.type, t.source, t.scope).decodeRasterArray(t, s);\n      }\n      reloadTile(e, t, s) {\n        t.projection = this.projections[e] || this.defaultProjection, this.getWorkerSource(e, t.type, t.source, t.scope).reloadTile(t, s);\n      }\n      abortTile(e, t, s) {\n        this.getWorkerSource(e, t.type, t.source, t.scope).abortTile(t, s);\n      }\n      removeTile(e, t, s) {\n        this.getWorkerSource(e, t.type, t.source, t.scope).removeTile(t, s);\n      }\n      removeSource(e, t, s) {\n        if (!(this.workerSources[e] && this.workerSources[e][t.scope] && this.workerSources[e][t.scope][t.type] && this.workerSources[e][t.scope][t.type][t.source])) return;\n        const i = this.workerSources[e][t.scope][t.type][t.source];\n        delete this.workerSources[e][t.scope][t.type][t.source], void 0 !== i.removeSource ? i.removeSource(t, s) : s();\n      }\n      loadWorkerSource(e, t, s) {\n        try {\n          this.self.importScripts(t.url), s();\n        } catch (e) {\n          s(e.toString());\n        }\n      }\n      syncRTLPluginState(t, s, i) {\n        try {\n          e.em.setState(s);\n          const t = e.em.getPluginURL();\n          if (e.em.isLoaded() && !e.em.isParsed() && null != t) {\n            this.self.importScripts(t);\n            const s = e.em.isParsed();\n            i(s ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t}`), s);\n          }\n        } catch (e) {\n          i(e.toString());\n        }\n      }\n      setDracoUrl(e, t) {\n        this.dracoUrl = t;\n      }\n      getAvailableImages(e, t) {\n        this.availableImages[e] || (this.availableImages[e] = {});\n        let s = this.availableImages[e][t];\n        return s || (s = []), s;\n      }\n      getLayerIndex(e, t) {\n        this.layerIndexes[e] || (this.layerIndexes[e] = {});\n        let s = this.layerIndexes[e][t];\n        return s || (s = this.layerIndexes[e][t] = new o(), s.scope = t), s;\n      }\n      getWorkerSource(e, t, s, i) {\n        const o = this.workerSources;\n        return o[e] || (o[e] = {}), o[e][i] || (o[e][i] = {}), o[e][i][t] || (o[e][i][t] = {}), this.isSpriteLoaded[e] || (this.isSpriteLoaded[e] = {}), o[e][i][t][s] || (o[e][i][t][s] = new this.workerSourceTypes[t]({\n          send: (t, s, i, o, n, r) => {\n            this.actor.send(t, s, i, e, n, r);\n          },\n          scheduler: this.actor.scheduler\n        }, this.getLayerIndex(e, i), this.getAvailableImages(e, i), this.isSpriteLoaded[e][i], void 0, this.brightness)), o[e][i][t][s];\n      }\n      rasterizeImages(e, t, s) {\n        const i = new Map();\n        for (const [s, {\n          image: o,\n          imageVariant: n\n        }] of t.tasks.entries()) {\n          const r = this.imageRasterizer.rasterize(n, o, t.scope, e);\n          i.set(s, r);\n        }\n        s(void 0, i);\n      }\n      removeRasterizedImages(e, t, s) {\n        this.imageRasterizer.removeImagesFromCacheByIds(t.imageIds, t.scope, e), s();\n      }\n      enforceCacheSizeLimit(t, s) {\n        e.en(s);\n      }\n      getWorkerPerformanceMetrics(e, t, s) {\n        s(void 0, void 0);\n      }\n    }\n    return \"undefined\" != typeof WorkerGlobalScope && \"undefined\" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new Ie(self)), Ie;\n  });\n  define([\"./shared\"], function (e) {\n    var t = \"3.11.0\";\n    const i = {\n        create: \"create\",\n        load: \"load\",\n        fullLoad: \"fullLoad\"\n      },\n      o = {\n        mark(e) {\n          performance.mark(e);\n        },\n        measure(e, t, i) {\n          performance.measure(e, t, i);\n        }\n      };\n    function s(t) {\n      const i = t.name.split(\"?\")[0];\n      return e.a(i) && i.includes(\"mapbox-gl.js\") ? \"javascript\" : e.a(i) && i.includes(\"mapbox-gl.css\") ? \"css\" : e.b(i) ? \"fontRange\" : e.c(i) ? \"sprite\" : e.i(i) ? \"style\" : e.d(i) ? \"tilejson\" : \"other\";\n    }\n    var r,\n      n = {},\n      a = function () {\n        if (r) return n;\n        function e(e) {\n          return !t(e);\n        }\n        function t(t) {\n          return \"undefined\" == typeof window || \"undefined\" == typeof document ? \"not a browser\" : function () {\n            if (!(\"Worker\" in window && \"Blob\" in window && \"URL\" in window)) return !1;\n            var e,\n              t,\n              i = new Blob([\"\"], {\n                type: \"text/javascript\"\n              }),\n              o = URL.createObjectURL(i);\n            try {\n              t = new Worker(o), e = !0;\n            } catch (t) {\n              e = !1;\n            }\n            return t && t.terminate(), URL.revokeObjectURL(o), e;\n          }() ? function () {\n            var e = document.createElement(\"canvas\");\n            e.width = e.height = 1;\n            var t = e.getContext(\"2d\");\n            if (!t) return !1;\n            var i = t.getImageData(0, 0, 1, 1);\n            return i && i.width === e.width;\n          }() ? (void 0 === i[o = t && t.failIfMajorPerformanceCaveat] && (i[o] = function (t) {\n            var i,\n              o = function (t) {\n                var i = document.createElement(\"canvas\"),\n                  o = Object.create(e.webGLContextAttributes);\n                return o.failIfMajorPerformanceCaveat = t, i.getContext(\"webgl2\", o);\n              }(t);\n            if (!o) return !1;\n            try {\n              i = o.createShader(o.VERTEX_SHADER);\n            } catch (e) {\n              return !1;\n            }\n            return !(!i || o.isContextLost()) && (o.shaderSource(i, \"void main() {}\"), o.compileShader(i), !0 === o.getShaderParameter(i, o.COMPILE_STATUS));\n          }(o)), i[o] ? document.documentMode ? \"insufficient ECMAScript 6 support\" : void 0 : \"insufficient WebGL2 support\") : \"insufficient Canvas/getImageData support\" : \"insufficient worker support\";\n          var o;\n        }\n        r = 1, n.supported = e, n.notSupportedReason = t;\n        var i = {};\n        return e.webGLContextAttributes = {\n          antialias: !1,\n          alpha: !0,\n          stencil: !0,\n          depth: !0\n        }, n;\n      }();\n    function l(e, t, i) {\n      const o = document.createElement(e);\n      return null != t && (o.className = t), i && i.appendChild(o), o;\n    }\n    function c(e, t, i) {\n      const o = document.createElementNS(\"http://www.w3.org/2000/svg\", e);\n      for (const e of Object.keys(t)) o.setAttributeNS(null, e, String(t[e]));\n      return i && i.appendChild(o), o;\n    }\n    const h = \"undefined\" != typeof document ? document.documentElement && document.documentElement.style : null,\n      d = h && void 0 !== h.userSelect ? \"userSelect\" : \"WebkitUserSelect\";\n    let u;\n    function _() {\n      h && d && (u = h[d], h[d] = \"none\");\n    }\n    function p() {\n      h && d && (h[d] = u);\n    }\n    function f(e) {\n      e.preventDefault(), e.stopPropagation(), window.removeEventListener(\"click\", f, !0);\n    }\n    function m() {\n      window.addEventListener(\"click\", f, !0), window.setTimeout(() => {\n        window.removeEventListener(\"click\", f, !0);\n      }, 0);\n    }\n    function g(e, t) {\n      const i = e.getBoundingClientRect();\n      return x(e, i, t);\n    }\n    function v(e, t) {\n      const i = e.getBoundingClientRect(),\n        o = [];\n      for (let s = 0; s < t.length; s++) o.push(x(e, i, t[s]));\n      return o;\n    }\n    function y(e) {\n      return /firefox/i.test(navigator.userAgent) && /macintosh/i.test(navigator.userAgent) && 2 === e.button && e.ctrlKey ? 0 : e.button;\n    }\n    function x(t, i, o) {\n      const s = t.offsetWidth === i.width ? 1 : t.offsetWidth / i.width;\n      return new e.P((o.clientX - i.left) * s, (o.clientY - i.top) * s);\n    }\n    const b = \"01\",\n      w = \"NO_ACCESS_TOKEN\";\n    class T {\n      constructor(e, t, i) {\n        this._transformRequestFn = e, this._customAccessToken = t, this._silenceAuthErrors = !!i, this._createSkuToken();\n      }\n      _createSkuToken() {\n        const e = function () {\n          let e = \"\";\n          for (let t = 0; t < 10; t++) e += \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"[Math.floor(62 * Math.random())];\n          return {\n            token: [\"1\", b, e].join(\"\"),\n            tokenExpiresAt: Date.now() + 432e5\n          };\n        }();\n        this._skuToken = e.token, this._skuTokenExpiresAt = e.tokenExpiresAt;\n      }\n      _isSkuTokenExpired() {\n        return Date.now() > this._skuTokenExpiresAt;\n      }\n      transformRequest(e, t) {\n        return this._transformRequestFn && this._transformRequestFn(e, t) || {\n          url: e\n        };\n      }\n      normalizeStyleURL(i, o) {\n        if (!e.f(i)) return i;\n        const s = S(i);\n        return s.params.push(`sdk=js-${t}`), s.path = `/styles/v1${s.path}`, this._makeAPIURL(s, this._customAccessToken || o);\n      }\n      normalizeGlyphsURL(t, i) {\n        if (!e.f(t)) return t;\n        const o = S(t);\n        return o.path = `/fonts/v1${o.path}`, this._makeAPIURL(o, this._customAccessToken || i);\n      }\n      normalizeModelURL(t, i) {\n        if (!e.f(t)) return t;\n        const o = S(t);\n        return o.path = `/models/v1${o.path}`, this._makeAPIURL(o, this._customAccessToken || i);\n      }\n      normalizeSourceURL(t, i, o, s) {\n        if (!e.f(t)) return t;\n        const r = S(t);\n        return r.path = `/v4/${r.authority}.json`, r.params.push(\"secure\"), o && r.params.push(`language=${o}`), s && r.params.push(`worldview=${s}`), this._makeAPIURL(r, this._customAccessToken || i);\n      }\n      normalizeIconsetURL(t, i) {\n        const o = S(t);\n        return e.f(t) ? (o.path = `/styles/v1${o.path}/iconset.pbf`, this._makeAPIURL(o, this._customAccessToken || i)) : C(o);\n      }\n      normalizeSpriteURL(t, i, o, s) {\n        const r = S(t);\n        return e.f(t) ? (r.path = `/styles/v1${r.path}/sprite${i}${o}`, this._makeAPIURL(r, this._customAccessToken || s)) : (r.path += `${i}${o}`, C(r));\n      }\n      normalizeTileURL(t, i, o) {\n        if (this._isSkuTokenExpired() && this._createSkuToken(), t && !e.f(t)) return t;\n        const s = S(t);\n        s.path = s.path.replace(/(\\.(png|jpg)\\d*)(?=$)/, `${i || o && \"raster\" !== s.authority && 512 === o ? \"@2x\" : \"\"}${e.m.supported ? \".webp\" : \"$1\"}`), \"raster\" === s.authority ? s.path = `/${e.e.RASTER_URL_PREFIX}${s.path}` : \"rasterarrays\" === s.authority ? s.path = `/${e.e.RASTERARRAYS_URL_PREFIX}${s.path}` : \"3dtiles\" === s.authority ? s.path = `/${e.e.TILES3D_URL_PREFIX}${s.path}` : (s.path = s.path.replace(/^.+\\/v4\\//, \"/\"), s.path = `/${e.e.TILE_URL_VERSION}${s.path}`);\n        const r = this._customAccessToken || function (e) {\n          for (const t of e) {\n            const e = t.match(/^access_token=(.*)$/);\n            if (e) return e[1];\n          }\n          return null;\n        }(s.params) || e.e.ACCESS_TOKEN;\n        return e.e.REQUIRE_ACCESS_TOKEN && r && this._skuToken && s.params.push(`sku=${this._skuToken}`), this._makeAPIURL(s, r);\n      }\n      canonicalizeTileURL(t, i) {\n        const o = S(t);\n        if (!o.path.match(/^(\\/v4\\/|\\/(raster|rasterarrays)\\/v1\\/)/) || !o.path.match(/\\.[\\w]+$/)) return t;\n        let s = \"mapbox://\";\n        o.path.match(/^\\/raster\\/v1\\//) ? s += `raster/${o.path.replace(`/${e.e.RASTER_URL_PREFIX}/`, \"\")}` : o.path.match(/^\\/rasterarrays\\/v1\\//) ? s += `rasterarrays/${o.path.replace(`/${e.e.RASTERARRAYS_URL_PREFIX}/`, \"\")}` : s += `tiles/${o.path.replace(`/${e.e.TILE_URL_VERSION}/`, \"\")}`;\n        let r = o.params;\n        return i && (r = r.filter(e => !e.match(/^access_token=/))), r.length && (s += `?${r.join(\"&\")}`), s;\n      }\n      canonicalizeTileset(t, i) {\n        const o = !!i && e.f(i),\n          s = [];\n        for (const i of t.tiles || []) e.h(i) ? s.push(this.canonicalizeTileURL(i, o)) : s.push(i);\n        return s;\n      }\n      _makeAPIURL(t, i) {\n        const o = \"See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes\",\n          s = S(e.e.API_URL);\n        if (t.protocol = s.protocol, t.authority = s.authority, \"http\" === t.protocol) {\n          const e = t.params.indexOf(\"secure\");\n          e >= 0 && t.params.splice(e, 1);\n        }\n        if (\"/\" !== s.path && (t.path = `${s.path}${t.path}`), !e.e.REQUIRE_ACCESS_TOKEN) return C(t);\n        if (i = i || e.e.ACCESS_TOKEN, !this._silenceAuthErrors) {\n          if (!i) throw new Error(`An API access token is required to use Mapbox GL. ${o}`);\n          if (\"s\" === i[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${o}`);\n        }\n        return t.params = t.params.filter(e => -1 === e.indexOf(\"access_token\")), t.params.push(`access_token=${i || \"\"}`), C(t);\n      }\n    }\n    const E = /^(\\w+):\\/\\/([^/?]*)(\\/[^?]+)?\\??(.+)?/;\n    function S(e) {\n      const t = e.match(E);\n      if (!t) throw new Error(\"Unable to parse URL object\");\n      return {\n        protocol: t[1],\n        authority: t[2],\n        path: t[3] || \"/\",\n        params: t[4] ? t[4].split(\"&\") : []\n      };\n    }\n    function C(e) {\n      const t = e.params.length ? `?${e.params.join(\"&\")}` : \"\";\n      return `${e.protocol}://${e.authority}${e.path}${t}`;\n    }\n    const I = \"mapbox.eventData\";\n    function R(t) {\n      if (!t) return null;\n      const i = t.split(\".\");\n      if (!i || 3 !== i.length) return null;\n      try {\n        return JSON.parse(e.j(i[1]));\n      } catch (e) {\n        return null;\n      }\n    }\n    class D {\n      constructor(e) {\n        this.type = e, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;\n      }\n      getStorageKey(t) {\n        const i = R(e.e.ACCESS_TOKEN);\n        let o = \"\";\n        return o = i && i.u ? e.k(i.u) : e.e.ACCESS_TOKEN || \"\", t ? `${I}.${t}:${o}` : `${I}:${o}`;\n      }\n      fetchEventData() {\n        const t = e.s(\"localStorage\"),\n          i = this.getStorageKey(),\n          o = this.getStorageKey(\"uuid\");\n        if (t) try {\n          const e = localStorage.getItem(i);\n          e && (this.eventData = JSON.parse(e));\n          const t = localStorage.getItem(o);\n          t && (this.anonId = t);\n        } catch (t) {\n          e.w(\"Unable to read from LocalStorage\");\n        }\n      }\n      saveEventData() {\n        const t = e.s(\"localStorage\"),\n          i = this.getStorageKey(),\n          o = this.getStorageKey(\"uuid\"),\n          s = this.anonId;\n        if (t && s) try {\n          localStorage.setItem(o, s), Object.keys(this.eventData).length >= 1 && localStorage.setItem(i, JSON.stringify(this.eventData));\n        } catch (t) {\n          e.w(\"Unable to write to LocalStorage\");\n        }\n      }\n      processRequests(e) {}\n      postEvent(t, i, o, s) {\n        if (!e.e.EVENTS_URL) return;\n        const r = S(e.e.EVENTS_URL);\n        r.params.push(`access_token=${s || e.e.ACCESS_TOKEN || \"\"}`);\n        const n = {\n            event: this.type,\n            created: new Date(t).toISOString()\n          },\n          a = i ? e.l(n, i) : n,\n          l = {\n            url: C(r),\n            headers: {\n              \"Content-Type\": \"text/plain\"\n            },\n            body: JSON.stringify([a])\n          };\n        this.pendingRequest = e.p(l, e => {\n          this.pendingRequest = null, o(e), this.saveEventData(), this.processRequests(s);\n        });\n      }\n      queueRequest(e, t) {\n        this.queue.push(e), this.processRequests(t);\n      }\n    }\n    const A = new class extends D {\n        constructor(e) {\n          super(\"appUserTurnstile\"), this._customAccessToken = e;\n        }\n        postTurnstileEvent(t, i) {\n          e.e.EVENTS_URL && e.e.ACCESS_TOKEN && Array.isArray(t) && t.some(t => e.f(t) || e.h(t)) && this.queueRequest(Date.now(), i);\n        }\n        processRequests(i) {\n          if (this.pendingRequest || 0 === this.queue.length) return;\n          this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();\n          const o = R(e.e.ACCESS_TOKEN),\n            s = o ? o.u : e.e.ACCESS_TOKEN;\n          let r = s !== this.eventData.tokenU;\n          e.v(this.anonId) || (this.anonId = e.u(), r = !0);\n          const n = this.queue.shift();\n          if (this.eventData.lastSuccess) {\n            const e = new Date(this.eventData.lastSuccess),\n              t = new Date(n),\n              i = (n - this.eventData.lastSuccess) / 864e5;\n            r = r || i >= 1 || i < -1 || e.getDate() !== t.getDate();\n          } else r = !0;\n          r ? this.postEvent(n, {\n            sdkIdentifier: \"mapbox-gl-js\",\n            sdkVersion: t,\n            skuId: b,\n            \"enabled.telemetry\": !1,\n            userId: this.anonId\n          }, e => {\n            e || (this.eventData.lastSuccess = n, this.eventData.tokenU = s);\n          }, i) : this.processRequests();\n        }\n      }(),\n      L = A.postTurnstileEvent.bind(A),\n      M = new class extends D {\n        constructor() {\n          super(\"map.load\"), this.success = {}, this.skuToken = \"\";\n        }\n        postMapLoadEvent(t, i, o, s) {\n          this.skuToken = i, this.errorCb = s, e.e.EVENTS_URL && (o || e.e.ACCESS_TOKEN ? this.queueRequest({\n            id: t,\n            timestamp: Date.now()\n          }, o) : this.errorCb(new Error(w)));\n        }\n        processRequests(i) {\n          if (this.pendingRequest || 0 === this.queue.length) return;\n          const {\n            id: o,\n            timestamp: s\n          } = this.queue.shift();\n          o && this.success[o] || (this.anonId || this.fetchEventData(), e.v(this.anonId) || (this.anonId = e.u()), this.postEvent(s, {\n            sdkIdentifier: \"mapbox-gl-js\",\n            sdkVersion: t,\n            skuId: b,\n            skuToken: this.skuToken,\n            userId: this.anonId\n          }, e => {\n            e ? this.errorCb(e) : o && (this.success[o] = !0);\n          }, i));\n        }\n        remove() {\n          this.errorCb = null;\n        }\n      }(),\n      P = M.postMapLoadEvent.bind(M),\n      z = new class extends D {\n        constructor() {\n          super(\"style.load\"), this.eventIdPerMapInstanceMap = new Map(), this.mapInstanceIdMap = new WeakMap();\n        }\n        getMapInstanceId(t) {\n          let i = this.mapInstanceIdMap.get(t);\n          return i || (i = e.u(), this.mapInstanceIdMap.set(t, i)), i;\n        }\n        getEventId(e) {\n          const t = this.eventIdPerMapInstanceMap.get(e) || 0;\n          return this.eventIdPerMapInstanceMap.set(e, t + 1), t;\n        }\n        postStyleLoadEvent(t, i) {\n          const {\n            map: o,\n            style: s,\n            importedStyles: r\n          } = i;\n          if (!e.e.EVENTS_URL || !t && !e.e.ACCESS_TOKEN) return;\n          const n = this.getMapInstanceId(o),\n            a = {\n              mapInstanceId: n,\n              eventId: this.getEventId(n),\n              style: s\n            };\n          r.length && (a.importedStyles = r), this.queueRequest({\n            timestamp: Date.now(),\n            payload: a\n          }, t);\n        }\n        processRequests(e) {\n          if (this.pendingRequest || 0 === this.queue.length) return;\n          const {\n            timestamp: t,\n            payload: i\n          } = this.queue.shift();\n          this.postEvent(t, i, () => {}, e);\n        }\n      }(),\n      O = z.postStyleLoadEvent.bind(z),\n      F = new class extends D {\n        constructor() {\n          super(\"gljs.performance\");\n        }\n        postPerformanceEvent(t, i) {\n          e.e.EVENTS_URL && (t || e.e.ACCESS_TOKEN) && this.queueRequest({\n            timestamp: Date.now(),\n            performanceData: i\n          }, t);\n        }\n        processRequests(o) {\n          if (this.pendingRequest || 0 === this.queue.length) return;\n          const {\n              timestamp: r,\n              performanceData: n\n            } = this.queue.shift(),\n            a = function (o) {\n              const r = performance.getEntriesByType(\"resource\"),\n                n = performance.getEntriesByType(\"mark\"),\n                a = function (e) {\n                  const t = {};\n                  if (e) for (const i in e) if (\"other\" !== i) for (const o of e[i]) {\n                    const e = `${i}ResolveRangeMin`,\n                      s = `${i}ResolveRangeMax`,\n                      r = `${i}RequestCount`,\n                      n = `${i}RequestCachedCount`;\n                    t[e] = Math.min(t[e] || 1 / 0, o.startTime), t[s] = Math.max(t[s] || -1 / 0, o.responseEnd);\n                    const a = e => {\n                      void 0 === t[e] && (t[e] = 0), ++t[e];\n                    };\n                    void 0 !== o.transferSize && 0 === o.transferSize && a(n), a(r);\n                  }\n                  return t;\n                }(function (e, t) {\n                  const i = {};\n                  if (e) for (const o of e) {\n                    const e = t(o);\n                    void 0 === i[e] && (i[e] = []), i[e].push(o);\n                  }\n                  return i;\n                }(r, s)),\n                l = window.devicePixelRatio,\n                c = navigator.connection || navigator.mozConnection || navigator.webkitConnection,\n                h = c ? c.effectiveType : void 0,\n                d = {\n                  counters: [],\n                  metadata: [],\n                  attributes: []\n                },\n                u = (e, t, i) => {\n                  null != i && e.push({\n                    name: t,\n                    value: i.toString()\n                  });\n                };\n              for (const e in a) u(d.counters, e, a[e]);\n              if (o.interactionRange[0] !== 1 / 0 && o.interactionRange[1] !== -1 / 0 && (u(d.counters, \"interactionRangeMin\", o.interactionRange[0]), u(d.counters, \"interactionRangeMax\", o.interactionRange[1])), n) for (const e of Object.keys(i)) {\n                const t = i[e],\n                  o = n.find(e => e.name === t);\n                o && u(d.counters, t, o.startTime);\n              }\n              return u(d.counters, \"visibilityHidden\", o.visibilityHidden), u(d.attributes, \"style\", function (t) {\n                if (t) for (const i of t) {\n                  const t = i.name.split(\"?\")[0];\n                  if (e.i(t)) {\n                    const e = t.split(\"/\").slice(-2);\n                    if (2 === e.length) return `mapbox://styles/${e[0]}/${e[1]}`;\n                  }\n                }\n              }(r)), u(d.attributes, \"terrainEnabled\", o.terrainEnabled ? \"true\" : \"false\"), u(d.attributes, \"fogEnabled\", o.fogEnabled ? \"true\" : \"false\"), u(d.attributes, \"projection\", o.projection), u(d.attributes, \"zoom\", o.zoom), u(d.metadata, \"devicePixelRatio\", l), u(d.metadata, \"connectionEffectiveType\", h), u(d.metadata, \"navigatorUserAgent\", navigator.userAgent), u(d.metadata, \"screenWidth\", window.screen.width), u(d.metadata, \"screenHeight\", window.screen.height), u(d.metadata, \"windowWidth\", window.innerWidth), u(d.metadata, \"windowHeight\", window.innerHeight), u(d.metadata, \"mapWidth\", o.width / l), u(d.metadata, \"mapHeight\", o.height / l), u(d.metadata, \"webglRenderer\", o.renderer), u(d.metadata, \"webglVendor\", o.vendor), u(d.metadata, \"sdkVersion\", t), u(d.metadata, \"sdkIdentifier\", \"mapbox-gl-js\"), d;\n            }(n);\n          for (const e of a.metadata);\n          for (const e of a.counters);\n          for (const e of a.attributes);\n          this.postEvent(r, a, () => {}, o);\n        }\n      }(),\n      k = F.postPerformanceEvent.bind(F),\n      B = new class extends D {\n        constructor() {\n          super(\"map.auth\"), this.success = {}, this.skuToken = \"\";\n        }\n        getSession(t, i, o, s) {\n          if (!e.e.API_URL || !e.e.SESSION_PATH) return;\n          const r = S(e.e.API_URL + e.e.SESSION_PATH);\n          r.params.push(`sku=${i || \"\"}`), r.params.push(`access_token=${s || e.e.ACCESS_TOKEN || \"\"}`);\n          const n = {\n            url: C(r),\n            headers: {\n              \"Content-Type\": \"text/plain\"\n            }\n          };\n          this.pendingRequest = e.g(n, e => {\n            this.pendingRequest = null, o(e), this.saveEventData(), this.processRequests(s);\n          });\n        }\n        getSessionAPI(t, i, o, s) {\n          this.skuToken = i, this.errorCb = s, e.e.SESSION_PATH && e.e.API_URL && (o || e.e.ACCESS_TOKEN ? this.queueRequest({\n            id: t,\n            timestamp: Date.now()\n          }, o) : this.errorCb(new Error(w)));\n        }\n        processRequests(e) {\n          if (this.pendingRequest || 0 === this.queue.length) return;\n          const {\n            id: t,\n            timestamp: i\n          } = this.queue.shift();\n          t && this.success[t] || this.getSession(i, this.skuToken, e => {\n            e ? this.errorCb(e) : t && (this.success[t] = !0);\n          }, e);\n        }\n        remove() {\n          this.errorCb = null;\n        }\n      }(),\n      N = B.getSessionAPI.bind(B),\n      U = new Set();\n    function V(e, t) {\n      t ? U.add(e) : U.delete(e);\n    }\n    class G {\n      constructor() {\n        this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = new Set(), this._updatedImages = new Set();\n      }\n      isDirty() {\n        return this._changed;\n      }\n      setDirty() {\n        this._changed = !0;\n      }\n      getUpdatedSourceCaches() {\n        return this._updatedSourceCaches;\n      }\n      updateSourceCache(e, t) {\n        this._updatedSourceCaches[e] = t, this.setDirty();\n      }\n      discardSourceCacheUpdate(e) {\n        delete this._updatedSourceCaches[e];\n      }\n      updateLayer(e) {\n        const t = e.scope;\n        this._updatedLayers[t] = this._updatedLayers[t] || new Set(), this._updatedLayers[t].add(e.id), this.setDirty();\n      }\n      removeLayer(e) {\n        const t = e.scope;\n        this._removedLayers[t] = this._removedLayers[t] || {}, this._updatedLayers[t] = this._updatedLayers[t] || new Set(), this._removedLayers[t][e.id] = e, this._updatedLayers[t].delete(e.id), this._updatedPaintProps.delete(e.fqid), this.setDirty();\n      }\n      getRemovedLayer(e) {\n        return this._removedLayers[e.scope] ? this._removedLayers[e.scope][e.id] : null;\n      }\n      discardLayerRemoval(e) {\n        this._removedLayers[e.scope] && delete this._removedLayers[e.scope][e.id];\n      }\n      getLayerUpdatesByScope() {\n        const e = {};\n        for (const t in this._updatedLayers) e[t] = e[t] || {}, e[t].updatedIds = Array.from(this._updatedLayers[t].values());\n        for (const t in this._removedLayers) e[t] = e[t] || {}, e[t].removedIds = Object.keys(this._removedLayers[t]);\n        return e;\n      }\n      getUpdatedPaintProperties() {\n        return this._updatedPaintProps;\n      }\n      updatePaintProperties(e) {\n        this._updatedPaintProps.add(e.fqid), this.setDirty();\n      }\n      getUpdatedImages() {\n        return Array.from(this._updatedImages.values());\n      }\n      updateImage(t) {\n        this._updatedImages.add(e.I.toString(t)), this.setDirty();\n      }\n      resetUpdatedImages() {\n        this._updatedImages.clear();\n      }\n      reset() {\n        this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages.clear();\n      }\n    }\n    function j(e) {\n      const {\n        userImage: t\n      } = e;\n      return !!(t && t.render && t.render()) && (e.data.replace(new Uint8Array(t.data.buffer)), !0);\n    }\n    class q extends e.E {\n      constructor(t) {\n        super(), this._images = {}, this._iconsets = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = {}, this.requestors = [], this.patterns = {}, this.patternsInFlight = new Set(), this.atlasImage = {}, this.atlasTexture = {}, this.dirty = !0, this.spriteFormat = t, \"raster\" !== t && e.t() && (this.imageRasterizerDispatcher = new e.D(e.x(), this, \"Image Rasterizer Worker\", 1));\n      }\n      get imageRasterizer() {\n        return this._imageRasterizer || (this._imageRasterizer = new e.y()), this._imageRasterizer;\n      }\n      createScope(t) {\n        this._images[t] = {}, this._iconsets[t] = {}, this.loaded[t] = !1, this.updatedImages[t] = new Set(), this.patterns[t] = {}, this.callbackDispatchedThisFrame[t] = new Set(), this.atlasImage[t] = new e.r({\n          width: 1,\n          height: 1\n        });\n      }\n      createIconset(e, t) {\n        this._iconsets[e][t] = {};\n      }\n      isLoaded() {\n        for (const e in this.loaded) if (!this.loaded[e]) return !1;\n        return !0;\n      }\n      setLoaded(e, t) {\n        if (this.loaded[t] !== e && (this.loaded[t] = e, e)) {\n          for (const {\n            ids: e,\n            callback: i\n          } of this.requestors) this._notify(e, t, i);\n          this.requestors = [];\n        }\n      }\n      hasImage(e, t) {\n        return !!this.getImage(e, t);\n      }\n      getImage(e, t) {\n        return (e.iconsetId ? this._iconsets[t][e.iconsetId] : this._images[t])[e.name];\n      }\n      addImage(e, t, i) {\n        const o = e.iconsetId ? this._iconsets[t][e.iconsetId] : this._images[t];\n        this._validate(e, i) && (o[e.name] = i);\n      }\n      _validate(t, i) {\n        let o = !0;\n        return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new e.z(new Error(`Image \"${t.name}\" has invalid \"stretchX\" value`))), o = !1), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new e.z(new Error(`Image \"${t.name}\" has invalid \"stretchY\" value`))), o = !1), this._validateContent(i.content, i) || (this.fire(new e.z(new Error(`Image \"${t.name}\" has invalid \"content\" value`))), o = !1), o;\n      }\n      _validateStretch(e, t) {\n        if (!e) return !0;\n        let i = 0;\n        for (const o of e) {\n          if (o[0] < i || o[1] < o[0] || t < o[1]) return !1;\n          i = o[1];\n        }\n        return !0;\n      }\n      _validateContent(e, t) {\n        if (!e) return !0;\n        if (4 !== e.length) return !1;\n        if (!t.usvg) {\n          if (e[0] < 0 || t.data.width < e[0]) return !1;\n          if (e[1] < 0 || t.data.height < e[1]) return !1;\n          if (e[2] < 0 || t.data.width < e[2]) return !1;\n          if (e[3] < 0 || t.data.height < e[3]) return !1;\n        }\n        return !(e[2] < e[0] || e[3] < e[1]);\n      }\n      updateImage(e, t, i) {\n        const o = e.iconsetId ? this._iconsets[t][e.iconsetId] : this._images[t];\n        i.version = o[e.name].version + 1, o[e.name] = i, this.updatedImages[t].add(e), this.removeFromImageRasterizerCache(e, t);\n      }\n      clearUpdatedImages(e) {\n        this.updatedImages[e].clear();\n      }\n      removeFromImageRasterizerCache(t, i) {\n        if (\"raster\" !== this.spriteFormat) if (e.t()) {\n          const e = {\n            imageIds: [t],\n            scope: i\n          };\n          this.imageRasterizerDispatcher.getActor().send(\"removeRasterizedImages\", e);\n        } else this.imageRasterizer.removeImagesFromCacheByIds([t], i);\n      }\n      removeImage(e, t) {\n        const i = e.iconsetId ? this._iconsets[t][e.iconsetId] : this._images[t],\n          o = i[e.name];\n        delete i[e.name], delete this.patterns[t][e.name], this.removeFromImageRasterizerCache(e, t), o.userImage && o.userImage.onRemove && o.userImage.onRemove();\n      }\n      listImages(t) {\n        const i = [];\n        for (const o of Object.keys(this._images[t])) i.push(new e.I(o));\n        for (const o in this._iconsets[t]) for (const s of Object.keys(this._iconsets[t][o])) i.push(new e.I({\n          name: s,\n          iconsetId: o\n        }));\n        return i;\n      }\n      getImages(e, t, i) {\n        let o = !0;\n        const s = !!this.loaded[t];\n        if (!s) for (const i of e) (i.iconsetId ? this._iconsets[t][i.iconsetId] : this._images[t])[i.name] || (o = !1);\n        s || o ? this._notify(e, t, i) : this.requestors.push({\n          ids: e,\n          scope: t,\n          callback: i\n        });\n      }\n      rasterizeImages({\n        scope: e,\n        tasks: t\n      }, i) {\n        const o = new Map();\n        for (const [i, s] of t.entries()) {\n          const t = this.getImage(s.id, e);\n          t && o.set(i, {\n            image: t,\n            imageVariant: s\n          });\n        }\n        this._rasterizeImages(e, o, i);\n      }\n      _rasterizeImages(t, i, o) {\n        if (e.t()) this.imageRasterizerDispatcher.getActor().send(\"rasterizeImages\", {\n          tasks: i,\n          scope: t\n        }, o);else {\n          const e = new Map();\n          for (const [o, {\n            image: s,\n            imageVariant: r\n          }] of i.entries()) e.set(o, this.imageRasterizer.rasterize(r, s, t, 0));\n          o(void 0, e);\n        }\n      }\n      getUpdatedImages(e) {\n        return this.updatedImages[e] || new Set();\n      }\n      _notify(t, i, o) {\n        const s = new Map();\n        for (const o of t) {\n          o.iconsetId && (this._iconsets[i][o.iconsetId] = this._iconsets[i][o.iconsetId] || {});\n          const t = (o.iconsetId ? this._iconsets[i][o.iconsetId] : this._images[i])[o.name];\n          if (!t) {\n            if (o.iconsetId) continue;\n            e.w(`Image \"${o.name}\" could not be loaded. Please make sure you have added the image with map.addImage() or a \"sprite\" property in your style. You can provide missing images by listening for the \"styleimagemissing\" map event.`), this.fire(new e.A(\"styleimagemissing\", {\n              id: o.name\n            }));\n            continue;\n          }\n          const r = {\n            data: t.usvg ? null : t.data.clone(),\n            pixelRatio: t.pixelRatio,\n            sdf: t.sdf,\n            usvg: t.usvg,\n            version: t.version,\n            stretchX: t.stretchX,\n            stretchY: t.stretchY,\n            content: t.content,\n            hasRenderCallback: Boolean(t.userImage && t.userImage.render)\n          };\n          t.usvg && Object.assign(r, {\n            width: t.icon.usvg_tree.width,\n            height: t.icon.usvg_tree.height\n          }), s.set(e.I.toString(o), r);\n        }\n        o(null, s);\n      }\n      getPixelSize(e) {\n        const {\n          width: t,\n          height: i\n        } = this.atlasImage[e];\n        return {\n          width: t,\n          height: i\n        };\n      }\n      getPattern(t, i, o) {\n        const s = this.patterns[i][t.name],\n          r = this.getImage(t, i);\n        if (!r) return null;\n        if (s) {\n          if (s.position.version === r.version) return s.position;\n          s.position.version = r.version;\n        } else {\n          if (r.usvg && !r.data) {\n            const s = this.getPatternInFlightId(t.toString(), i);\n            if (this.patternsInFlight.has(s)) return null;\n            this.patternsInFlight.add(s);\n            const n = new e.B(t).scaleSelf(e.q.devicePixelRatio),\n              a = new Map([[n.toString(), {\n                image: r,\n                imageVariant: n\n              }]]);\n            return this._rasterizeImages(i, a, (e, t) => this.storePatternImage(n, i, r, o, t)), null;\n          }\n          this.storePattern(t, i, r);\n        }\n        return this._updatePatternAtlas(i, o), this.patterns[i][t.name].position;\n      }\n      getPatternInFlightId(t, i) {\n        return e.C(t, i);\n      }\n      hasPatternsInFlight() {\n        return 0 !== this.patternsInFlight.size;\n      }\n      storePatternImage(e, t, i, o, s) {\n        const r = e.toString(),\n          n = s ? s.get(r) : void 0;\n        n && (i.data = n, this.storePattern(e.id, t, i), this._updatePatternAtlas(t, o), this.patternsInFlight.delete(this.getPatternInFlightId(e.id.toString(), t)));\n      }\n      storePattern(t, i, o) {\n        const s = {\n            w: o.data.width + 2 * e.F,\n            h: o.data.height + 2 * e.F,\n            x: 0,\n            y: 0\n          },\n          r = new e.G(s, o, e.F);\n        this.patterns[i][t.name] = {\n          bin: s,\n          position: r\n        };\n      }\n      bind(t, i) {\n        const o = t.gl;\n        let s = this.atlasTexture[i];\n        s ? this.dirty && (s.update(this.atlasImage[i]), this.dirty = !1) : (s = new e.T(t, this.atlasImage[i], o.RGBA8), this.atlasTexture[i] = s), s.bind(o.LINEAR, o.CLAMP_TO_EDGE);\n      }\n      _updatePatternAtlas(t, i) {\n        const o = [];\n        for (const e in this.patterns[t]) o.push(this.patterns[t][e].bin);\n        const {\n            w: s,\n            h: r\n          } = e.H(o),\n          n = this.atlasImage[t];\n        n.resize({\n          width: s || 1,\n          height: r || 1\n        });\n        for (const o in this.patterns[t]) {\n          const {\n            bin: s,\n            position: r\n          } = this.patterns[t][o];\n          let a = r.padding;\n          const l = s.x + a,\n            c = s.y + a,\n            h = this._images[t][o].data,\n            d = h.width,\n            u = h.height;\n          a = a > 1 ? a - 1 : a, e.r.copy(h, n, {\n            x: 0,\n            y: 0\n          }, {\n            x: l,\n            y: c\n          }, {\n            width: d,\n            height: u\n          }, i), e.r.copy(h, n, {\n            x: 0,\n            y: u - a\n          }, {\n            x: l,\n            y: c - a\n          }, {\n            width: d,\n            height: a\n          }, i), e.r.copy(h, n, {\n            x: 0,\n            y: 0\n          }, {\n            x: l,\n            y: c + u\n          }, {\n            width: d,\n            height: a\n          }, i), e.r.copy(h, n, {\n            x: d - a,\n            y: 0\n          }, {\n            x: l - a,\n            y: c\n          }, {\n            width: a,\n            height: u\n          }, i), e.r.copy(h, n, {\n            x: 0,\n            y: 0\n          }, {\n            x: l + d,\n            y: c\n          }, {\n            width: a,\n            height: u\n          }, i), e.r.copy(h, n, {\n            x: d - a,\n            y: u - a\n          }, {\n            x: l - a,\n            y: c - a\n          }, {\n            width: a,\n            height: a\n          }, i), e.r.copy(h, n, {\n            x: 0,\n            y: u - a\n          }, {\n            x: l + d,\n            y: c - a\n          }, {\n            width: a,\n            height: a\n          }, i), e.r.copy(h, n, {\n            x: 0,\n            y: 0\n          }, {\n            x: l + d,\n            y: c + u\n          }, {\n            width: a,\n            height: a\n          }, i), e.r.copy(h, n, {\n            x: d - a,\n            y: 0\n          }, {\n            x: l - a,\n            y: c + u\n          }, {\n            width: a,\n            height: a\n          }, i);\n        }\n        this.dirty = !0;\n      }\n      beginFrame() {\n        for (const e in this._images) this.callbackDispatchedThisFrame[e] = new Set();\n      }\n      dispatchRenderCallbacks(e, t) {\n        for (const i of e) {\n          if (this.callbackDispatchedThisFrame[t].has(i.toString())) continue;\n          this.callbackDispatchedThisFrame[t].add(i.toString());\n          const e = (i.iconsetId ? this._iconsets[t][i.iconsetId] : this._images[t])[i.name];\n          j(e) && this.updateImage(i, t, e);\n        }\n      }\n    }\n    function H(t) {\n      const i = t.key,\n        o = t.value,\n        s = t.valueSpec || {},\n        r = t.objectElementValidators || {},\n        n = t.style,\n        a = t.styleSpec;\n      let l = [];\n      const c = e.K(o);\n      if (\"object\" !== c) return [new e.V(i, o, `object expected, ${c} found`)];\n      for (const t in o) {\n        const c = t.split(\".\")[0];\n        let h;\n        r[c] ? h = r[c] : s[c] ? h = _e : r[\"*\"] ? h = r[\"*\"] : s[\"*\"] && (h = _e), h ? l = l.concat(h({\n          key: (i ? `${i}.` : i) + t,\n          value: o[t],\n          valueSpec: s[c] || s[\"*\"],\n          style: n,\n          styleSpec: a,\n          object: o,\n          objectKey: t\n        }, o)) : l.push(new e.J(i, o[t], `unknown property \"${t}\"`));\n      }\n      for (const t in s) r[t] || s[t].required && void 0 === s[t].default && void 0 === o[t] && l.push(new e.V(i, o, `missing required property \"${t}\"`));\n      return l;\n    }\n    function Z(t) {\n      const i = t.value,\n        o = t.valueSpec,\n        s = t.style,\n        r = t.styleSpec,\n        n = t.key,\n        a = t.arrayElementValidator || _e;\n      if (\"array\" !== e.K(i)) return [new e.V(n, i, `array expected, ${e.K(i)} found`)];\n      if (o.length && i.length !== o.length) return [new e.V(n, i, `array length ${o.length} expected, length ${i.length} found`)];\n      if (o[\"min-length\"] && i.length < o[\"min-length\"]) return [new e.V(n, i, `array length at least ${o[\"min-length\"]} expected, length ${i.length} found`)];\n      let l = {\n        type: o.value,\n        values: o.values,\n        minimum: o.minimum,\n        maximum: o.maximum,\n        function: void 0\n      };\n      r.$version < 7 && (l.function = o.function), \"object\" === e.K(o.value) && (l = o.value);\n      let c = [];\n      for (let e = 0; e < i.length; e++) c = c.concat(a({\n        array: i,\n        arrayIndex: e,\n        value: i[e],\n        valueSpec: l,\n        style: s,\n        styleSpec: r,\n        key: `${n}[${e}]`\n      }, !0));\n      return c;\n    }\n    function W(t) {\n      const i = t.key,\n        o = t.value,\n        s = t.valueSpec;\n      let r = e.K(o);\n      if (\"number\" === r && o != o && (r = \"NaN\"), \"number\" !== r) return [new e.V(i, o, `number expected, ${r} found`)];\n      if (\"minimum\" in s) {\n        let r = s.minimum;\n        if (\"array\" === e.K(s.minimum) && (r = s.minimum[t.arrayIndex]), o < r) return [new e.V(i, o, `${o} is less than the minimum value ${r}`)];\n      }\n      if (\"maximum\" in s) {\n        let r = s.maximum;\n        if (\"array\" === e.K(s.maximum) && (r = s.maximum[t.arrayIndex]), o > r) return [new e.V(i, o, `${o} is greater than the maximum value ${r}`)];\n      }\n      return [];\n    }\n    function $(t) {\n      const i = t.valueSpec,\n        o = e.M(t.value.type);\n      let s,\n        r,\n        n,\n        a = {};\n      const l = \"categorical\" !== o && void 0 === t.value.property,\n        c = !l,\n        h = \"array\" === e.K(t.value.stops) && \"array\" === e.K(t.value.stops[0]) && \"object\" === e.K(t.value.stops[0][0]),\n        d = H({\n          key: t.key,\n          value: t.value,\n          valueSpec: t.styleSpec.function,\n          style: t.style,\n          styleSpec: t.styleSpec,\n          objectElementValidators: {\n            stops: function (t) {\n              if (\"identity\" === o) return [new e.V(t.key, t.value, 'identity function may not have a \"stops\" property')];\n              let i = [];\n              const s = t.value;\n              return i = i.concat(Z({\n                key: t.key,\n                value: s,\n                valueSpec: t.valueSpec,\n                style: t.style,\n                styleSpec: t.styleSpec,\n                arrayElementValidator: u\n              })), \"array\" === e.K(s) && 0 === s.length && i.push(new e.V(t.key, s, \"array must have at least one stop\")), i;\n            },\n            default: function (e) {\n              return _e({\n                key: e.key,\n                value: e.value,\n                valueSpec: i,\n                style: e.style,\n                styleSpec: e.styleSpec\n              });\n            }\n          }\n        });\n      return \"identity\" === o && l && d.push(new e.V(t.key, t.value, 'missing required property \"property\"')), \"identity\" === o || t.value.stops || d.push(new e.V(t.key, t.value, 'missing required property \"stops\"')), \"exponential\" === o && t.valueSpec.expression && !e.N(t.valueSpec) && d.push(new e.V(t.key, t.value, \"exponential functions not supported\")), t.styleSpec.$version >= 8 && (c && !e.O(t.valueSpec) ? d.push(new e.V(t.key, t.value, \"property functions not supported\")) : l && !e.Q(t.valueSpec) && d.push(new e.V(t.key, t.value, \"zoom functions not supported\"))), \"categorical\" !== o && !h || void 0 !== t.value.property || d.push(new e.V(t.key, t.value, '\"property\" property is required')), d;\n      function u(t) {\n        let o = [];\n        const s = t.value,\n          l = t.key;\n        if (\"array\" !== e.K(s)) return [new e.V(l, s, `array expected, ${e.K(s)} found`)];\n        if (2 !== s.length) return [new e.V(l, s, `array length 2 expected, length ${s.length} found`)];\n        if (h) {\n          if (\"object\" !== e.K(s[0])) return [new e.V(l, s, `object expected, ${e.K(s[0])} found`)];\n          if (void 0 === s[0].zoom) return [new e.V(l, s, \"object stop key must have zoom\")];\n          if (void 0 === s[0].value) return [new e.V(l, s, \"object stop key must have value\")];\n          const i = e.M(s[0].zoom);\n          if (\"number\" != typeof i) return [new e.V(l, s[0].zoom, \"stop zoom values must be numbers\")];\n          if (n && n > i) return [new e.V(l, s[0].zoom, \"stop zoom values must appear in ascending order\")];\n          i !== n && (n = i, r = void 0, a = {}), o = o.concat(H({\n            key: `${l}[0]`,\n            value: s[0],\n            valueSpec: {\n              zoom: {}\n            },\n            style: t.style,\n            styleSpec: t.styleSpec,\n            objectElementValidators: {\n              zoom: W,\n              value: _\n            }\n          }));\n        } else o = o.concat(_({\n          key: `${l}[0]`,\n          value: s[0],\n          valueSpec: {},\n          style: t.style,\n          styleSpec: t.styleSpec\n        }, s));\n        return e.S(e.U(s[1])) ? o.concat([new e.V(`${l}[1]`, s[1], \"expressions are not allowed in function stops.\")]) : o.concat(_e({\n          key: `${l}[1]`,\n          value: s[1],\n          valueSpec: i,\n          style: t.style,\n          styleSpec: t.styleSpec\n        }));\n      }\n      function _(t, n) {\n        const l = e.K(t.value),\n          c = e.M(t.value),\n          h = null !== t.value ? t.value : n;\n        if (s) {\n          if (l !== s) return [new e.V(t.key, h, `${l} stop domain type must match previous stop domain type ${s}`)];\n        } else s = l;\n        if (\"number\" !== l && \"string\" !== l && \"boolean\" !== l && \"number\" != typeof c && \"string\" != typeof c && \"boolean\" != typeof c) return [new e.V(t.key, h, \"stop domain value must be a number, string, or boolean\")];\n        if (\"number\" !== l && \"categorical\" !== o) {\n          let s = `number expected, ${l} found`;\n          return e.O(i) && void 0 === o && (s += '\\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`.'), [new e.V(t.key, h, s)];\n        }\n        return \"categorical\" !== o || \"number\" !== l || \"number\" == typeof c && isFinite(c) && Math.floor(c) === c ? \"categorical\" !== o && \"number\" === l && \"number\" == typeof c && \"number\" == typeof r && void 0 !== r && c < r ? [new e.V(t.key, h, \"stop domain values must appear in ascending order\")] : (r = c, \"categorical\" === o && c in a ? [new e.V(t.key, h, \"stop domain values must be unique\")] : (a[c] = !0, [])) : [new e.V(t.key, h, `integer expected, found ${String(c)}`)];\n      }\n    }\n    function X(t) {\n      const i = (\"property\" === t.expressionContext ? e.W : e.X)(e.U(t.value), t.valueSpec);\n      if (\"error\" === i.result) return i.value.map(i => new e.V(`${t.key}${i.key}`, t.value, i.message));\n      const o = i.value.expression || i.value._styleExpression.expression;\n      if (\"property\" === t.expressionContext && \"text-font\" === t.propertyKey && !o.outputDefined()) return [new e.V(t.key, t.value, `Invalid data expression for \"${t.propertyKey}\". Output values must be contained as literals within the expression.`)];\n      if (\"property\" === t.expressionContext && \"layout\" === t.propertyType && !e.Y(o)) return [new e.V(t.key, t.value, '\"feature-state\" data expressions are not supported with layout properties.')];\n      if (\"filter\" === t.expressionContext) return K(o, t);\n      if (t.expressionContext && 0 === t.expressionContext.indexOf(\"cluster\")) {\n        if (!e.Z(o, [\"zoom\", \"feature-state\"])) return [new e.V(t.key, t.value, '\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.')];\n        if (\"cluster-initial\" === t.expressionContext && !e._(o)) return [new e.V(t.key, t.value, \"Feature data expressions are not supported with initial expression part of cluster properties.\")];\n      }\n      return [];\n    }\n    function K(t, i) {\n      const o = new Set([\"zoom\", \"feature-state\", \"pitch\", \"distance-from-center\"]);\n      if (i.valueSpec && i.valueSpec.expression) for (const e of i.valueSpec.expression.parameters) o.delete(e);\n      if (0 === o.size) return [];\n      const s = [];\n      return t instanceof e.$ && o.has(t.name) ? [new e.V(i.key, i.value, `[\"${t.name}\"] expression is not supported in a filter for a ${i.object.type} layer with id: ${i.object.id}`)] : (t.eachChild(e => {\n        s.push(...K(e, i));\n      }), s);\n    }\n    function Y(t) {\n      const i = t.key,\n        o = t.value,\n        s = t.valueSpec,\n        r = [];\n      return Array.isArray(s.values) ? -1 === s.values.indexOf(e.M(o)) && r.push(new e.V(i, o, `expected one of [${s.values.join(\", \")}], ${JSON.stringify(o)} found`)) : -1 === Object.keys(s.values).indexOf(e.M(o)) && r.push(new e.V(i, o, `expected one of [${Object.keys(s.values).join(\", \")}], ${JSON.stringify(o)} found`)), r;\n    }\n    function J(t) {\n      return e.a1(e.U(t.value)) ? X(e.L({}, t, {\n        expressionContext: \"filter\",\n        valueSpec: t.styleSpec[`filter_${t.layerType || \"fill\"}`]\n      })) : Q(t);\n    }\n    function Q(t) {\n      const i = t.value,\n        o = t.key;\n      if (\"array\" !== e.K(i)) return [new e.V(o, i, `array expected, ${e.K(i)} found`)];\n      const s = t.styleSpec;\n      let r,\n        n = [];\n      if (i.length < 1) return [new e.V(o, i, \"filter array must have at least 1 element\")];\n      switch (n = n.concat(Y({\n        key: `${o}[0]`,\n        value: i[0],\n        valueSpec: s.filter_operator,\n        style: t.style,\n        styleSpec: t.styleSpec\n      })), e.M(i[0])) {\n        case \"<\":\n        case \"<=\":\n        case \">\":\n        case \">=\":\n          i.length >= 2 && \"$type\" === e.M(i[1]) && n.push(new e.V(o, i, `\"$type\" cannot be use with operator \"${i[0]}\"`));\n        case \"==\":\n        case \"!=\":\n          3 !== i.length && n.push(new e.V(o, i, `filter array for operator \"${i[0]}\" must have 3 elements`));\n        case \"in\":\n        case \"!in\":\n          i.length >= 2 && (r = e.K(i[1]), \"string\" !== r && n.push(new e.V(`${o}[1]`, i[1], `string expected, ${r} found`)));\n          for (let a = 2; a < i.length; a++) r = e.K(i[a]), \"$type\" === e.M(i[1]) ? n = n.concat(Y({\n            key: `${o}[${a}]`,\n            value: i[a],\n            valueSpec: s.geometry_type,\n            style: t.style,\n            styleSpec: t.styleSpec\n          })) : \"string\" !== r && \"number\" !== r && \"boolean\" !== r && n.push(new e.V(`${o}[${a}]`, i[a], `string, number, or boolean expected, ${r} found`));\n          break;\n        case \"any\":\n        case \"all\":\n        case \"none\":\n          for (let e = 1; e < i.length; e++) n = n.concat(Q({\n            key: `${o}[${e}]`,\n            value: i[e],\n            style: t.style,\n            styleSpec: t.styleSpec\n          }));\n          break;\n        case \"has\":\n        case \"!has\":\n          r = e.K(i[1]), 2 !== i.length ? n.push(new e.V(o, i, `filter array for \"${i[0]}\" operator must have 2 elements`)) : \"string\" !== r && n.push(new e.V(`${o}[1]`, i[1], `string expected, ${r} found`));\n      }\n      return n;\n    }\n    function ee(t, i) {\n      const o = t.key,\n        s = t.style,\n        r = t.layer,\n        n = t.styleSpec,\n        a = t.value,\n        l = t.objectKey,\n        c = n[`${i}_${t.layerType}`];\n      if (!c) return [];\n      const h = l.match(/^(.*)-use-theme$/);\n      if (\"paint\" === i && h && c[h[1]]) return e.S(a) ? [].concat(_e({\n        key: t.key,\n        value: a,\n        valueSpec: {\n          type: \"string\",\n          expression: {\n            interpolated: !1,\n            parameters: [\"zoom\", \"feature\"]\n          },\n          \"property-type\": \"data-driven\"\n        },\n        style: s,\n        styleSpec: n,\n        expressionContext: \"property\",\n        propertyType: i,\n        propertyKey: l\n      })) : _e({\n        key: o,\n        value: a,\n        valueSpec: {\n          type: \"string\"\n        },\n        style: s,\n        styleSpec: n\n      });\n      const d = l.match(/^(.*)-transition$/);\n      if (\"paint\" === i && d && c[d[1]] && c[d[1]].transition) return _e({\n        key: o,\n        value: a,\n        valueSpec: n.transition,\n        style: s,\n        styleSpec: n\n      });\n      const u = t.valueSpec || c[l];\n      if (!u) return [new e.J(o, a, `unknown property \"${l}\"`)];\n      let _;\n      if (\"string\" === e.K(a) && e.O(u) && !u.tokens && (_ = /^{([^}]+)}$/.exec(a))) {\n        const t = `\\`{ \"type\": \"identity\", \"property\": ${_ ? JSON.stringify(_[1]) : '\"_\"'} }\\``;\n        return [new e.V(o, a, `\"${l}\" does not support interpolation syntax\\nUse an identity property function instead: ${t}.`)];\n      }\n      const p = [];\n      if (\"symbol\" === t.layerType) \"text-field\" !== l || !s || s.glyphs || s.imports || p.push(new e.V(o, a, 'use of \"text-field\" requires a style \"glyphs\" property')), \"text-font\" === l && e.a2(e.U(a)) && \"identity\" === e.M(a.type) && p.push(new e.V(o, a, '\"text-font\" does not support identity functions'));else if (\"model\" === t.layerType && \"paint\" === i && r && r.layout && r.layout.hasOwnProperty(\"model-id\") && e.O(u) && (e.a3(u) || e.Q(u))) {\n        const t = e.W(e.U(a), u),\n          i = t.value.expression || t.value._styleExpression.expression;\n        i && !e.Z(i, [\"measure-light\"]) && (\"model-emissive-strength\" === l && e._(i) && e.Y(i) || p.push(new e.V(o, a, `${l} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));\n      }\n      return p.concat(_e({\n        key: t.key,\n        value: a,\n        valueSpec: u,\n        style: s,\n        styleSpec: n,\n        expressionContext: \"property\",\n        propertyType: i,\n        propertyKey: l\n      }));\n    }\n    function te(e) {\n      return ee(e, \"paint\");\n    }\n    function ie(e) {\n      return ee(e, \"layout\");\n    }\n    function oe(t) {\n      let i = [];\n      const o = t.value,\n        s = t.key,\n        r = t.style,\n        n = t.styleSpec;\n      o.type || o.ref || i.push(new e.V(s, o, 'either \"type\" or \"ref\" is required'));\n      let a = e.M(o.type);\n      const l = e.M(o.ref);\n      if (o.id) {\n        const n = e.M(o.id);\n        for (let a = 0; a < t.arrayIndex; a++) {\n          const t = r.layers[a];\n          e.M(t.id) === n && i.push(new e.V(s, o.id, `duplicate layer id \"${o.id}\", previously used at line ${t.id.__line__}`));\n        }\n      }\n      if (\"ref\" in o) {\n        let t;\n        [\"type\", \"source\", \"source-layer\", \"filter\", \"layout\"].forEach(t => {\n          t in o && i.push(new e.V(s, o[t], `\"${t}\" is prohibited for ref layers`));\n        }), r.layers.forEach(i => {\n          e.M(i.id) === l && (t = i);\n        }), t ? t.ref ? i.push(new e.V(s, o.ref, \"ref cannot reference another ref layer\")) : a = e.M(t.type) : \"string\" == typeof l && i.push(new e.V(s, o.ref, `ref layer \"${l}\" not found`));\n      } else if (\"background\" !== a && \"sky\" !== a && \"slot\" !== a) if (o.source) {\n        const t = r.sources && r.sources[o.source],\n          n = t && e.M(t.type);\n        t ? \"vector\" === n && \"raster\" === a ? i.push(new e.V(s, o.source, `layer \"${o.id}\" requires a raster source`)) : \"raster\" === n && \"raster\" !== a ? i.push(new e.V(s, o.source, `layer \"${o.id}\" requires a vector source`)) : \"vector\" !== n || o[\"source-layer\"] ? \"raster-dem\" === n && \"hillshade\" !== a ? i.push(new e.V(s, o.source, \"raster-dem source can only be used with layer type 'hillshade'.\")) : \"raster-array\" !== n || [\"raster\", \"raster-particle\"].includes(a) ? \"line\" !== a || !o.paint || !o.paint[\"line-gradient\"] && !o.paint[\"line-trim-offset\"] || \"geojson\" === n && t.lineMetrics ? \"raster-particle\" === a && \"raster-array\" !== n && i.push(new e.V(s, o.source, `layer \"${o.id}\" requires a 'raster-array' source.`)) : i.push(new e.V(s, o, `layer \"${o.id}\" specifies a line-gradient, which requires a GeoJSON source with \\`lineMetrics\\` enabled.`)) : i.push(new e.V(s, o.source, \"raster-array source can only be used with layer type 'raster'.\")) : i.push(new e.V(s, o, `layer \"${o.id}\" must specify a \"source-layer\"`)) : i.push(new e.V(s, o.source, `source \"${o.source}\" not found`));\n      } else i.push(new e.V(s, o, 'missing required property \"source\"'));\n      return i = i.concat(H({\n        key: s,\n        value: o,\n        valueSpec: n.layer,\n        style: t.style,\n        styleSpec: t.styleSpec,\n        objectElementValidators: {\n          \"*\": () => [],\n          type: () => _e({\n            key: `${s}.type`,\n            value: o.type,\n            valueSpec: n.layer.type,\n            style: t.style,\n            styleSpec: t.styleSpec,\n            object: o,\n            objectKey: \"type\"\n          }),\n          filter: t => J(e.L({\n            layerType: a\n          }, t)),\n          layout: t => H({\n            layer: o,\n            key: t.key,\n            value: t.value,\n            valueSpec: {},\n            style: t.style,\n            styleSpec: t.styleSpec,\n            objectElementValidators: {\n              \"*\": t => ie(e.L({\n                layerType: a\n              }, t))\n            }\n          }),\n          paint: t => H({\n            layer: o,\n            key: t.key,\n            value: t.value,\n            valueSpec: {},\n            style: t.style,\n            styleSpec: t.styleSpec,\n            objectElementValidators: {\n              \"*\": t => te(e.L({\n                layerType: a,\n                layer: o\n              }, t))\n            }\n          })\n        }\n      })), i;\n    }\n    function se(t) {\n      const i = t.value,\n        o = t.key,\n        s = e.K(i);\n      return \"string\" !== s ? [new e.V(o, i, `string expected, ${s} found`)] : [];\n    }\n    const re = {\n      promoteId: function t({\n        key: i,\n        value: o\n      }) {\n        if (\"string\" === e.K(o)) return se({\n          key: i,\n          value: o\n        });\n        if (Array.isArray(o)) {\n          const t = [],\n            s = e.U(o),\n            r = e.X(s);\n          return \"error\" === r.result && r.value.forEach(o => {\n            t.push(new e.V(`${i}${o.key}`, null, `${o.message}`));\n          }), e.Z(r.value.expression, [\"zoom\", \"heatmap-density\", \"line-progress\", \"raster-value\", \"sky-radial-progress\", \"accumulated\", \"is-supported-script\", \"pitch\", \"distance-from-center\", \"measure-light\", \"raster-particle-speed\"]) || t.push(new e.V(`${i}`, null, \"promoteId expression should be only feature dependent\")), t;\n        }\n        {\n          const e = [];\n          for (const s in o) e.push(...t({\n            key: `${i}.${s}`,\n            value: o[s]\n          }));\n          return e;\n        }\n      }\n    };\n    function ne(t) {\n      const i = t.value,\n        o = t.key,\n        s = t.styleSpec,\n        r = t.style;\n      if (!i.type) return [new e.V(o, i, '\"type\" is required')];\n      const n = e.M(i.type);\n      let a = [];\n      switch ([\"vector\", \"raster\", \"raster-dem\", \"raster-array\"].includes(n) && (i.url || i.tiles || a.push(new e.J(o, i, 'Either \"url\" or \"tiles\" is required.'))), n) {\n        case \"vector\":\n        case \"raster\":\n        case \"raster-dem\":\n        case \"raster-array\":\n          return a = a.concat(H({\n            key: o,\n            value: i,\n            valueSpec: s[`source_${n.replace(\"-\", \"_\")}`],\n            style: t.style,\n            styleSpec: s,\n            objectElementValidators: re\n          })), a;\n        case \"geojson\":\n          if (a = H({\n            key: o,\n            value: i,\n            valueSpec: s.source_geojson,\n            style: r,\n            styleSpec: s,\n            objectElementValidators: re\n          }), i.cluster) for (const e in i.clusterProperties) {\n            const [t, s] = i.clusterProperties[e],\n              r = \"string\" == typeof t ? [t, [\"accumulated\"], [\"get\", e]] : t;\n            a.push(...X({\n              key: `${o}.${e}.map`,\n              value: s,\n              expressionContext: \"cluster-map\"\n            })), a.push(...X({\n              key: `${o}.${e}.reduce`,\n              value: r,\n              expressionContext: \"cluster-reduce\"\n            }));\n          }\n          return a;\n        case \"video\":\n          return H({\n            key: o,\n            value: i,\n            valueSpec: s.source_video,\n            style: r,\n            styleSpec: s\n          });\n        case \"image\":\n          return H({\n            key: o,\n            value: i,\n            valueSpec: s.source_image,\n            style: r,\n            styleSpec: s\n          });\n        case \"canvas\":\n          return [new e.V(o, null, \"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.\", \"source.canvas\")];\n        default:\n          return Y({\n            key: `${o}.type`,\n            value: i.type,\n            valueSpec: {\n              values: ae(s)\n            },\n            style: r,\n            styleSpec: s\n          });\n      }\n    }\n    function ae(e) {\n      return e.source.reduce((t, i) => {\n        const o = e[i];\n        return \"enum\" === o.type.type && (t = t.concat(Object.keys(o.type.values))), t;\n      }, []);\n    }\n    function le(t) {\n      const i = t.value,\n        o = t.styleSpec,\n        s = o.light,\n        r = t.style;\n      let n = [];\n      const a = e.K(i);\n      if (void 0 === i) return n;\n      if (\"object\" !== a) return n = n.concat([new e.V(\"light\", i, `object expected, ${a} found`)]), n;\n      for (const t in i) {\n        const a = t.match(/^(.*)-transition$/),\n          l = t.match(/^(.*)-use-theme$/);\n        n = n.concat(l && s[l[1]] ? _e({\n          key: t,\n          value: i[t],\n          valueSpec: {\n            type: \"string\"\n          },\n          style: r,\n          styleSpec: o\n        }) : a && s[a[1]] && s[a[1]].transition ? _e({\n          key: t,\n          value: i[t],\n          valueSpec: o.transition,\n          style: r,\n          styleSpec: o\n        }) : s[t] ? _e({\n          key: t,\n          value: i[t],\n          valueSpec: s[t],\n          style: r,\n          styleSpec: o\n        }) : [new e.V(t, i[t], `unknown property \"${t}\"`)]);\n      }\n      return n;\n    }\n    function ce(t) {\n      const i = t.value;\n      let o = [];\n      if (!i) return o;\n      const s = e.K(i);\n      if (\"object\" !== s) return o = o.concat([new e.V(\"light-3d\", i, `object expected, ${s} found`)]), o;\n      const r = t.styleSpec,\n        n = r[\"light-3d\"],\n        a = t.key,\n        l = t.style,\n        c = t.style.lights;\n      for (const t of [\"type\", \"id\"]) if (!(t in i)) return o = o.concat([new e.V(\"light-3d\", i, `missing property ${t} on light`)]), o;\n      if (i.type && c) for (let s = 0; s < t.arrayIndex; s++) {\n        const t = e.M(i.type),\n          r = c[s];\n        e.M(r.type) === t && o.push(new e.V(a, i.id, `duplicate light type \"${i.type}\", previously defined at line ${r.id.__line__}`));\n      }\n      const h = `properties_light_${i.type}`;\n      if (!(h in r)) return o = o.concat([new e.V(\"light-3d\", i, `Invalid light type ${i.type}`)]), o;\n      const d = r[h];\n      for (const s in i) if (\"properties\" === s) {\n        const n = i[s],\n          a = e.K(n);\n        if (\"object\" !== a) return o = o.concat([new e.V(\"properties\", n, `object expected, ${a} found`)]), o;\n        for (const i in n) o = o.concat(d[i] ? _e({\n          key: i,\n          value: n[i],\n          valueSpec: d[i],\n          style: l,\n          styleSpec: r\n        }) : [new e.J(t.key, n[i], `unknown property \"${i}\"`)]);\n      } else {\n        const t = s.match(/^(.*)-transition$/),\n          a = s.match(/^(.*)-use-theme$/);\n        o = o.concat(a && n[a[1]] ? _e({\n          key: s,\n          value: i[s],\n          valueSpec: {\n            type: \"string\"\n          },\n          style: l,\n          styleSpec: r\n        }) : t && n[t[1]] && n[t[1]].transition ? _e({\n          key: s,\n          value: i[s],\n          valueSpec: r.transition,\n          style: l,\n          styleSpec: r\n        }) : n[s] ? _e({\n          key: s,\n          value: i[s],\n          valueSpec: n[s],\n          style: l,\n          styleSpec: r\n        }) : [new e.J(s, i[s], `unknown property \"${s}\"`)]);\n      }\n      return o;\n    }\n    function he(t) {\n      const i = t.value,\n        o = t.key,\n        s = t.style,\n        r = t.styleSpec,\n        n = r.terrain;\n      let a = [];\n      const l = e.K(i);\n      if (void 0 === i) return a;\n      if (\"null\" === l) return a;\n      if (\"object\" !== l) return a = a.concat([new e.V(\"terrain\", i, `object expected, ${l} found`)]), a;\n      for (const t in i) {\n        const o = t.match(/^(.*)-transition$/),\n          l = t.match(/^(.*)-use-theme$/);\n        a = a.concat(l && n[l[1]] ? _e({\n          key: t,\n          value: i[t],\n          valueSpec: {\n            type: \"string\"\n          },\n          style: s,\n          styleSpec: r\n        }) : o && n[o[1]] && n[o[1]].transition ? _e({\n          key: t,\n          value: i[t],\n          valueSpec: r.transition,\n          style: s,\n          styleSpec: r\n        }) : n[t] ? _e({\n          key: t,\n          value: i[t],\n          valueSpec: n[t],\n          style: s,\n          styleSpec: r\n        }) : [new e.J(t, i[t], `unknown property \"${t}\"`)]);\n      }\n      if (i.source) {\n        const t = s.sources && s.sources[i.source],\n          r = t && e.M(t.type);\n        t ? \"raster-dem\" !== r && a.push(new e.V(o, i.source, `terrain cannot be used with a source of type ${String(r)}, it only be used with a \"raster-dem\" source type`)) : a.push(new e.V(o, i.source, `source \"${i.source}\" not found`));\n      } else a.push(new e.V(o, i, 'terrain is missing required property \"source\"'));\n      return a;\n    }\n    function de(t) {\n      const i = t.value,\n        o = t.style,\n        s = t.styleSpec,\n        r = s.fog;\n      let n = [];\n      const a = e.K(i);\n      if (void 0 === i) return n;\n      if (\"object\" !== a) return n = n.concat([new e.V(\"fog\", i, `object expected, ${a} found`)]), n;\n      for (const t in i) {\n        const a = t.match(/^(.*)-transition$/),\n          l = t.match(/^(.*)-use-theme$/);\n        n = n.concat(l && r[l[1]] ? _e({\n          key: t,\n          value: i[t],\n          valueSpec: {\n            type: \"string\"\n          },\n          style: o,\n          styleSpec: s\n        }) : a && r[a[1]] && r[a[1]].transition ? _e({\n          key: t,\n          value: i[t],\n          valueSpec: s.transition,\n          style: o,\n          styleSpec: s\n        }) : r[t] ? _e({\n          key: t,\n          value: i[t],\n          valueSpec: r[t],\n          style: o,\n          styleSpec: s\n        }) : [new e.J(t, i[t], `unknown property \"${t}\"`)]);\n      }\n      return n;\n    }\n    const ue = {\n      \"*\": () => [],\n      array: Z,\n      boolean: function (t) {\n        const i = t.value,\n          o = t.key,\n          s = e.K(i);\n        return \"boolean\" !== s ? [new e.V(o, i, `boolean expected, ${s} found`)] : [];\n      },\n      number: W,\n      color: function (t) {\n        const i = t.key,\n          o = t.value,\n          s = e.K(o);\n        return \"string\" !== s ? [new e.V(i, o, `color expected, ${s} found`)] : null === e.a0.parseCSSColor(o) ? [new e.V(i, o, `color expected, \"${o}\" found`)] : [];\n      },\n      enum: Y,\n      filter: J,\n      function: $,\n      layer: oe,\n      object: H,\n      source: ne,\n      model: e.a4,\n      light: le,\n      \"light-3d\": ce,\n      terrain: he,\n      fog: de,\n      string: se,\n      formatted: function (e) {\n        return 0 === se(e).length ? [] : X(e);\n      },\n      resolvedImage: function (e) {\n        return 0 === se(e).length ? [] : X(e);\n      },\n      projection: function (t) {\n        const i = t.value,\n          o = t.styleSpec,\n          s = o.projection,\n          r = t.style;\n        let n = [];\n        const a = e.K(i);\n        if (\"object\" === a) for (const e in i) n = n.concat(_e({\n          key: e,\n          value: i[e],\n          valueSpec: s[e],\n          style: r,\n          styleSpec: o\n        }));else \"string\" !== a && (n = n.concat([new e.V(\"projection\", i, `object or string expected, ${a} found`)]));\n        return n;\n      },\n      import: function (t) {\n        const {\n            value: i,\n            styleSpec: o\n          } = t,\n          {\n            data: s,\n            ...r\n          } = i;\n        Object.defineProperty(r, \"__line__\", {\n          value: i.__line__,\n          enumerable: !1\n        });\n        let n = H(e.L({}, t, {\n          value: r,\n          valueSpec: o.import\n        }));\n        return \"\" === e.M(r.id) && n.push(new e.V(`${t.key}.id`, r, \"import id can't be an empty string\")), s && (n = n.concat(fe(s, o, {\n          key: `${t.key}.data`\n        }))), n;\n      },\n      iconset: function (t) {\n        const i = t.value,\n          o = t.key,\n          s = t.styleSpec,\n          r = t.style;\n        if (!i.type) return [new e.V(o, i, '\"type\" is required')];\n        const n = e.M(i.type);\n        let a = [];\n        if (a = a.concat(H({\n          key: o,\n          value: i,\n          valueSpec: s[`iconset_${n}`],\n          style: r,\n          styleSpec: s\n        })), \"source\" === n && i.source) {\n          const t = r.sources && r.sources[i.source],\n            s = t && e.M(t.type);\n          t ? \"raster-array\" !== s && a.push(new e.V(o, i.source, `iconset cannot be used with a source of type ${String(s)}, it only be used with a \"raster-array\" source type`)) : a.push(new e.V(o, i.source, `source \"${i.source}\" not found`));\n        }\n        return a;\n      }\n    };\n    function _e(t, i = !1) {\n      const o = t.value,\n        s = t.valueSpec,\n        r = t.styleSpec;\n      if (s.expression && e.a2(e.M(o))) return $(t);\n      if (s.expression && e.S(e.U(o))) return X(t);\n      if (s.type && ue[s.type]) {\n        const o = ue[s.type](t);\n        return !0 === i && o.length > 0 && \"array\" === e.K(t.value) ? X(t) : o;\n      }\n      return H(e.L({}, t, {\n        valueSpec: s.type ? r[s.type] : s\n      }));\n    }\n    function pe(t) {\n      const i = t.value,\n        o = t.key,\n        s = se(t);\n      return s.length || (-1 === i.indexOf(\"{fontstack}\") && s.push(new e.V(o, i, '\"glyphs\" url must include a \"{fontstack}\" token')), -1 === i.indexOf(\"{range}\") && s.push(new e.V(o, i, '\"glyphs\" url must include a \"{range}\" token'))), s;\n    }\n    function fe(t, i = e.a5, o = {}) {\n      return _e({\n        key: o.key || \"\",\n        value: t,\n        valueSpec: i.$root,\n        styleSpec: i,\n        style: t,\n        objectElementValidators: {\n          glyphs: pe,\n          \"*\": () => []\n        }\n      });\n    }\n    function me(t, i = e.a5) {\n      return De(fe(t, i));\n    }\n    const ge = e => De(ne(e)),\n      ve = e => De(le(e)),\n      ye = e => De(ce(e)),\n      xe = e => De(he(e)),\n      be = e => De(de(e)),\n      we = t => De(function (t) {\n        const i = t.value,\n          o = t.style,\n          s = t.styleSpec,\n          r = s.snow;\n        let n = [];\n        const a = e.K(i);\n        if (void 0 === i) return n;\n        if (\"object\" !== a) return n = n.concat([new e.V(\"snow\", i, `object expected, ${a} found`)]), n;\n        for (const t in i) {\n          const a = t.match(/^(.*)-transition$/);\n          n = n.concat(a && r[a[1]] && r[a[1]].transition ? _e({\n            key: t,\n            value: i[t],\n            valueSpec: s.transition,\n            style: o,\n            styleSpec: s\n          }) : r[t] ? _e({\n            key: t,\n            value: i[t],\n            valueSpec: r[t],\n            style: o,\n            styleSpec: s\n          }) : [new e.J(t, i[t], `unknown property \"${t}\"`)]);\n        }\n        return n;\n      }(t)),\n      Te = t => De(function (t) {\n        const i = t.value,\n          o = t.style,\n          s = t.styleSpec,\n          r = s.rain;\n        let n = [];\n        const a = e.K(i);\n        if (void 0 === i) return n;\n        if (\"object\" !== a) return n = n.concat([new e.V(\"rain\", i, `object expected, ${a} found`)]), n;\n        for (const t in i) {\n          const a = t.match(/^(.*)-transition$/);\n          n = n.concat(a && r[a[1]] && r[a[1]].transition ? _e({\n            key: t,\n            value: i[t],\n            valueSpec: s.transition,\n            style: o,\n            styleSpec: s\n          }) : r[t] ? _e({\n            key: t,\n            value: i[t],\n            valueSpec: r[t],\n            style: o,\n            styleSpec: s\n          }) : [new e.J(t, i[t], `unknown property \"${t}\"`)]);\n        }\n        return n;\n      }(t)),\n      Ee = e => De(oe(e)),\n      Se = e => De(J(e)),\n      Ce = e => De(te(e)),\n      Ie = e => De(ie(e)),\n      Re = t => De(e.a4(t));\n    function De(e) {\n      return e.slice().sort((e, t) => e.line && t.line ? e.line - t.line : 0);\n    }\n    function Ae(t, i) {\n      let o = !1;\n      if (i && i.length) for (const s of i) s instanceof e.J ? e.w(s.message) : (t.fire(new e.z(new Error(s.message))), o = !0);\n      return o;\n    }\n    let Le;\n    class Me extends e.E {\n      constructor(t, i = \"flat\") {\n        super(), this._transitionable = new e.a6(Le || (Le = new e.a7({\n          anchor: new e.a8(e.a5.light.anchor),\n          position: new e.a9(e.a5.light.position),\n          color: new e.a8(e.a5.light.color),\n          intensity: new e.a8(e.a5.light.intensity)\n        }))), this.setLight(t, i), this._transitioning = this._transitionable.untransitioned();\n      }\n      getLight() {\n        return this._transitionable.serialize();\n      }\n      setLight(e, t, i = {}) {\n        this._validate(ve, e, i) || (this._transitionable.setTransitionOrValue(e), this.id = t);\n      }\n      updateTransitions(e) {\n        this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n      }\n      hasTransition() {\n        return this._transitioning.hasTransition();\n      }\n      recalculate(e) {\n        this.properties = this._transitioning.possiblyEvaluate(e);\n      }\n      _validate(t, i, o) {\n        return (!o || !1 !== o.validate) && Ae(this, t.call(me, e.l({\n          value: i,\n          style: {\n            glyphs: !0,\n            sprite: !0\n          },\n          styleSpec: e.a5\n        })));\n      }\n    }\n    let Pe = class extends e.E {\n      constructor(t, i, o, s) {\n        super(), this.scope = o, this._transitionable = new e.a6(new e.a7({\n          source: new e.a8(e.a5.terrain.source),\n          exaggeration: new e.a8(e.a5.terrain.exaggeration)\n        }), o, s), this._transitionable.setTransitionOrValue(t, s), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i;\n      }\n      get() {\n        return this._transitionable.serialize();\n      }\n      set(e, t) {\n        this._transitionable.setTransitionOrValue(e, t);\n      }\n      updateTransitions(e) {\n        this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n      }\n      hasTransition() {\n        return this._transitioning.hasTransition();\n      }\n      recalculate(e) {\n        this.properties = this._transitioning.possiblyEvaluate(e);\n      }\n      getExaggeration(t) {\n        return this._transitioning.possiblyEvaluate(new e.aa(t)).get(\"exaggeration\");\n      }\n      getAttenuationRange() {\n        if (!this.isZoomDependent()) return null;\n        const t = this._transitionable._values.exaggeration;\n        if (!t) return null;\n        const i = t.value.expression;\n        if (!i) return null;\n        let o = -1,\n          s = -1,\n          r = 1;\n        for (const t of i.zoomStops) r = i.evaluate(new e.aa(t)), r > .01 ? (o = t, s = -1) : s = t;\n        return r < .01 && o > 0 && s > o ? [o, s] : null;\n      }\n      isZoomDependent() {\n        const t = this._transitionable._values.exaggeration;\n        return null != t && null != t.value && null != t.value.expression && t.value.expression instanceof e.ab;\n      }\n    };\n    const ze = 45,\n      Oe = 65,\n      Fe = .05;\n    function ke(t, i, o, s) {\n      const r = e.ae(ze, Oe, o),\n        [n, a] = Be(t, s);\n      let l = 1 - Math.min(1, Math.exp((i - n) / (a - n) * -6));\n      return l *= l * l, l = Math.min(1, 1.00747 * l), l * r * t.alpha;\n    }\n    function Be(e, t) {\n      const i = .5 / Math.tan(.5 * t);\n      return [e.range[0] + i, e.range[1] + i];\n    }\n    function Ne(t, i, o, s, r) {\n      const n = e.ad.vec3.transformMat4([], [i, o, s], r.mercatorFogMatrix);\n      return ke(t, e.ad.vec3.length(n), r.pitch, r._fov);\n    }\n    function Ue(t, i, o, s, r, n, a) {\n      const l = [[o, s, 0], [r, s, 0], [r, n, 0], [o, n, 0]];\n      let c = Number.MAX_VALUE,\n        h = -Number.MAX_VALUE;\n      for (const t of l) {\n        const o = e.ad.vec3.transformMat4([], t, i),\n          s = e.ad.vec3.length(o);\n        c = Math.min(c, s), h = Math.max(h, s);\n      }\n      return [ke(t, c, a.pitch, a._fov), ke(t, h, a.pitch, a._fov)];\n    }\n    class Ve extends e.E {\n      constructor(t, i, o, s) {\n        super();\n        const r = new e.a7({\n          range: new e.a8(e.a5.fog.range),\n          color: new e.a8(e.a5.fog.color),\n          \"color-use-theme\": new e.a8({\n            type: \"string\",\n            \"property-type\": \"data-constant\",\n            default: \"default\"\n          }),\n          \"high-color\": new e.a8(e.a5.fog[\"high-color\"]),\n          \"high-color-use-theme\": new e.a8({\n            type: \"string\",\n            \"property-type\": \"data-constant\",\n            default: \"default\"\n          }),\n          \"space-color\": new e.a8(e.a5.fog[\"space-color\"]),\n          \"space-color-use-theme\": new e.a8({\n            type: \"string\",\n            \"property-type\": \"data-constant\",\n            default: \"default\"\n          }),\n          \"horizon-blend\": new e.a8(e.a5.fog[\"horizon-blend\"]),\n          \"star-intensity\": new e.a8(e.a5.fog[\"star-intensity\"]),\n          \"vertical-range\": new e.a8(e.a5.fog[\"vertical-range\"])\n        });\n        this._transitionable = new e.a6(r, o, new Map(s)), this.set(t, s), this._transitioning = this._transitionable.untransitioned(), this._transform = i, this.properties = new e.af(r), this.scope = o;\n      }\n      get state() {\n        const t = this._transform,\n          i = \"globe\" === t.projection.name,\n          o = e.ag(t.zoom),\n          s = this.properties.get(\"range\"),\n          r = [.5, 3];\n        return {\n          range: i ? [e.ah(r[0], s[0], o), e.ah(r[1], s[1], o)] : s,\n          horizonBlend: this.properties.get(\"horizon-blend\"),\n          alpha: this.properties.get(\"color\").a\n        };\n      }\n      get() {\n        return this._transitionable.serialize();\n      }\n      set(t, i, o = {}) {\n        if (this._validate(be, t, o)) return;\n        const s = e.l({}, t);\n        for (const t of Object.keys(e.a5.fog)) void 0 === s[t] && (s[t] = e.a5.fog[t].default);\n        this._options = s, this._transitionable.setTransitionOrValue(this._options, i);\n      }\n      getOpacity(t) {\n        if (!this._transform.projection.supportsFog) return 0;\n        const i = this.properties && this.properties.get(\"color\") || 1;\n        return (\"globe\" === this._transform.projection.name ? 1 : e.ae(ze, Oe, t)) * i.a;\n      }\n      getOpacityAtLatLng(t, i) {\n        return this._transform.projection.supportsFog ? function (t, i, o) {\n          const s = e.ac.fromLngLat(i),\n            r = o.elevation ? o.elevation.getAtPointOrZero(s) : 0;\n          return Ne(t, s.x, s.y, r, o);\n        }(this.state, t, i) : 0;\n      }\n      getOpacityForTile(t) {\n        if (!this._transform.projection.supportsFog) return [1, 1];\n        const i = this._transform.calculateFogTileMatrix(t.toUnwrapped());\n        return Ue(this.state, i, 0, 0, e.ai, e.ai, this._transform);\n      }\n      getOpacityForBounds(e, t, i, o, s) {\n        return this._transform.projection.supportsFog ? Ue(this.state, e, t, i, o, s, this._transform) : [1, 1];\n      }\n      getFovAdjustedRange(e) {\n        return this._transform.projection.supportsFog ? Be(this.state, e) : [0, 1];\n      }\n      isVisibleOnFrustum(t) {\n        if (!this._transform.projection.supportsFog) return !1;\n        const i = [4, 5, 6, 7];\n        for (const o of i) {\n          const i = t.points[o];\n          let s;\n          if (i[2] >= 0) s = i;else {\n            const r = t.points[o - 4];\n            s = e.aj(r, i, r[2] / (r[2] - i[2]));\n          }\n          if (Ne(this.state, s[0], s[1], 0, this._transform) >= Fe) return !0;\n        }\n        return !1;\n      }\n      updateConfig(e) {\n        this._transitionable.setTransitionOrValue(this._options, new Map(e));\n      }\n      updateTransitions(e) {\n        this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n      }\n      hasTransition() {\n        return this._transitioning.hasTransition();\n      }\n      recalculate(e) {\n        this.properties = this._transitioning.possiblyEvaluate(e);\n      }\n      _validate(t, i, o) {\n        return (!o || !1 !== o.validate) && Ae(this, t.call(me, e.l({\n          value: i,\n          style: {\n            glyphs: !0,\n            sprite: !0\n          },\n          styleSpec: e.a5\n        })));\n      }\n    }\n    let Ge,\n      je,\n      qe,\n      He,\n      Ze = class extends e.E {\n        constructor(t, i, o, s) {\n          super();\n          const r = Ge || (Ge = new e.a7({\n            density: new e.a8(e.a5.snow.density),\n            intensity: new e.a8(e.a5.snow.intensity),\n            color: new e.a8(e.a5.snow.color),\n            opacity: new e.a8(e.a5.snow.opacity),\n            vignette: new e.a8(e.a5.snow.vignette),\n            \"vignette-color\": new e.a8(e.a5.snow[\"vignette-color\"]),\n            \"center-thinning\": new e.a8(e.a5.snow[\"center-thinning\"]),\n            direction: new e.a8(e.a5.snow.direction),\n            \"flake-size\": new e.a8(e.a5.snow[\"flake-size\"])\n          }));\n          this._transitionable = new e.a6(r, o, new Map(s)), this.set(t, s), this._transitioning = this._transitionable.untransitioned(), this.properties = new e.af(r), this.scope = o;\n        }\n        get state() {\n          const t = this.properties.get(\"opacity\"),\n            i = this.properties.get(\"color\"),\n            o = this.properties.get(\"direction\"),\n            s = e.ak(o[0]),\n            r = -Math.max(e.ak(o[1]), .01),\n            n = [Math.cos(s) * Math.cos(r), Math.sin(s) * Math.cos(r), Math.sin(r)],\n            a = this.properties.get(\"vignette\"),\n            l = this.properties.get(\"vignette-color\");\n          return l.a = a, {\n            density: this.properties.get(\"density\"),\n            intensity: this.properties.get(\"intensity\"),\n            color: new e.al(i.r, i.g, i.b, i.a * t),\n            direction: n,\n            centerThinning: this.properties.get(\"center-thinning\"),\n            flakeSize: this.properties.get(\"flake-size\"),\n            vignetteColor: l\n          };\n        }\n        get() {\n          return this._transitionable.serialize();\n        }\n        set(t, i, o = {}) {\n          if (this._validate(we, t, o)) return;\n          const s = e.l({}, t);\n          for (const t of Object.keys(e.a5.snow)) void 0 === s[t] && (s[t] = e.a5.snow[t].default);\n          this._options = s, this._transitionable.setTransitionOrValue(this._options, i);\n        }\n        updateConfig(e) {\n          this._transitionable.setTransitionOrValue(this._options, new Map(e));\n        }\n        updateTransitions(e) {\n          this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n        }\n        hasTransition() {\n          return this._transitioning.hasTransition();\n        }\n        recalculate(e) {\n          this.properties = this._transitioning.possiblyEvaluate(e);\n        }\n        _validate(t, i, o) {\n          return (!o || !1 !== o.validate) && Ae(this, t.call(me, e.l({\n            value: i,\n            style: {\n              glyphs: !0,\n              sprite: !0\n            },\n            styleSpec: e.a5\n          })));\n        }\n      },\n      We = class extends e.E {\n        constructor(t, i, o, s) {\n          super();\n          const r = je || (je = new e.a7({\n            density: new e.a8(e.a5.rain.density),\n            intensity: new e.a8(e.a5.rain.intensity),\n            color: new e.a8(e.a5.rain.color),\n            opacity: new e.a8(e.a5.rain.opacity),\n            vignette: new e.a8(e.a5.rain.vignette),\n            \"vignette-color\": new e.a8(e.a5.rain[\"vignette-color\"]),\n            \"center-thinning\": new e.a8(e.a5.rain[\"center-thinning\"]),\n            direction: new e.a8(e.a5.rain.direction),\n            \"droplet-size\": new e.a8(e.a5.rain[\"droplet-size\"]),\n            \"distortion-strength\": new e.a8(e.a5.rain[\"distortion-strength\"])\n          }));\n          this._transitionable = new e.a6(r, o, new Map(s)), this.set(t, s), this._transitioning = this._transitionable.untransitioned(), this.properties = new e.af(r), this.scope = o;\n        }\n        get state() {\n          const t = this.properties.get(\"opacity\"),\n            i = this.properties.get(\"color\"),\n            o = this.properties.get(\"direction\"),\n            s = e.ak(o[0]),\n            r = -Math.max(e.ak(o[1]), .01),\n            n = [Math.cos(s) * Math.cos(r), Math.sin(s) * Math.cos(r), Math.sin(r)],\n            a = this.properties.get(\"vignette-color\");\n          return a.a = this.properties.get(\"vignette\"), {\n            density: this.properties.get(\"density\"),\n            intensity: this.properties.get(\"intensity\"),\n            color: new e.al(i.r, i.g, i.b, i.a * t),\n            direction: n,\n            centerThinning: this.properties.get(\"center-thinning\"),\n            dropletSize: this.properties.get(\"droplet-size\"),\n            distortionStrength: this.properties.get(\"distortion-strength\"),\n            vignetteColor: a\n          };\n        }\n        get() {\n          return this._transitionable.serialize();\n        }\n        set(t, i, o = {}) {\n          if (this._validate(Te, t, o)) return;\n          const s = e.l({}, t);\n          for (const t of Object.keys(e.a5.rain)) void 0 === s[t] && (s[t] = e.a5.rain[t].default);\n          this._options = s, this._transitionable.setTransitionOrValue(this._options, i);\n        }\n        updateConfig(e) {\n          this._transitionable.setTransitionOrValue(this._options, new Map(e));\n        }\n        updateTransitions(e) {\n          this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n        }\n        hasTransition() {\n          return this._transitioning.hasTransition();\n        }\n        recalculate(e) {\n          this.properties = this._transitioning.possiblyEvaluate(e);\n        }\n        _validate(t, i, o) {\n          return (!o || !1 !== o.validate) && Ae(this, t.call(me, e.l({\n            value: i,\n            style: {\n              glyphs: !0,\n              sprite: !0\n            },\n            styleSpec: e.a5\n          })));\n        }\n      };\n    class $e extends e.E {\n      constructor(t, i, o, s) {\n        super(), this.scope = o, this._options = t, this.properties = new e.af(i), this._transitionable = new e.a6(i, o, new Map(s)), this._transitionable.setTransitionOrValue(t.properties), this._transitioning = this._transitionable.untransitioned();\n      }\n      updateConfig(e) {\n        this._transitionable.setTransitionOrValue(this._options.properties, new Map(e));\n      }\n      updateTransitions(e) {\n        this._transitioning = this._transitionable.transitioned(e, this._transitioning);\n      }\n      hasTransition() {\n        return this._transitioning.hasTransition();\n      }\n      recalculate(e) {\n        this.properties = this._transitioning.possiblyEvaluate(e);\n      }\n      get() {\n        return this._options.properties = this._transitionable.serialize(), this._options;\n      }\n      set(e, t) {\n        this._options = e, this._transitionable.setTransitionOrValue(e.properties, t);\n      }\n      shadowsEnabled() {\n        return !!this.properties && !0 === this.properties.get(\"cast-shadows\");\n      }\n    }\n    class Xe {\n      constructor(e, t, i, o) {\n        this.screenBounds = e, this.cameraPoint = t, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o);\n      }\n      static createFromScreenPoints(t, i) {\n        let o, s;\n        if (t instanceof e.P || \"number\" == typeof t[0]) {\n          const r = e.P.convert(t);\n          o = [r], s = i.isPointAboveHorizon(r);\n        } else {\n          const r = e.P.convert(t[0]),\n            n = e.P.convert(t[1]);\n          o = [r, n], s = e.an(r, n).every(e => i.isPointAboveHorizon(e));\n        }\n        return new Xe(o, i.getCameraPoint(), s, i);\n      }\n      isPointQuery() {\n        return 1 === this.screenBounds.length;\n      }\n      bufferedScreenGeometry(t) {\n        return e.an(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t);\n      }\n      bufferedCameraGeometry(t) {\n        const i = this.screenBounds[0],\n          o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1],\n          s = e.an(i, o, 0, !1);\n        return this.cameraPoint.y > o.y && (this.cameraPoint.x > i.x && this.cameraPoint.x < o.x ? s.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o.x ? s[2] = this.cameraPoint : this.cameraPoint.x <= i.x && (s[3] = this.cameraPoint)), e.ao(s, t);\n      }\n      bufferedCameraGeometryGlobe(t) {\n        const i = this.screenBounds[0],\n          o = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1],\n          s = e.an(i, o, t),\n          r = this.cameraPoint.clone();\n        switch (3 * ((r.y > i.y) + (r.y > o.y)) + ((r.x > i.x) + (r.x > o.x))) {\n          case 0:\n            s[0] = r, s[4] = r.clone();\n            break;\n          case 1:\n            s.splice(1, 0, r);\n            break;\n          case 2:\n            s[1] = r;\n            break;\n          case 3:\n            s.splice(4, 0, r);\n            break;\n          case 5:\n            s.splice(2, 0, r);\n            break;\n          case 6:\n            s[3] = r;\n            break;\n          case 7:\n            s.splice(3, 0, r);\n            break;\n          case 8:\n            s[2] = r;\n        }\n        return s;\n      }\n      containsTile(t, i, o, s = 0) {\n        const r = t.queryPadding / i._pixelsPerMercatorPixel + 1,\n          n = o ? this._bufferedCameraMercator(r, i) : this._bufferedScreenMercator(r, i);\n        let a = t.tileID.wrap + (n.unwrapped ? s : 0);\n        const l = n.polygon.map(i => e.ap(t.tileTransform, i, a));\n        if (!e.aq(l, 0, 0, e.ai, e.ai)) return;\n        a = t.tileID.wrap + (this.screenGeometryMercator.unwrapped ? s : 0);\n        const c = this.screenGeometryMercator.polygon.map(i => e.ar(t.tileTransform, i, a)),\n          h = c.map(t => new e.P(t[0], t[1])),\n          d = i.getFreeCameraOptions().position || new e.ac(0, 0, 0),\n          u = e.ar(t.tileTransform, d, a),\n          _ = c.map(t => {\n            const i = e.ad.vec3.sub(t, t, u);\n            return e.ad.vec3.normalize(i, i), new e.as(u, i);\n          }),\n          p = e.at(t, 1, i.zoom) * i._pixelsPerMercatorPixel;\n        return {\n          queryGeometry: this,\n          tilespaceGeometry: h,\n          tilespaceRays: _,\n          bufferedTilespaceGeometry: l,\n          bufferedTilespaceBounds: (f = e.au(l), f.min.x = e.ay(f.min.x, 0, e.ai), f.min.y = e.ay(f.min.y, 0, e.ai), f.max.x = e.ay(f.max.x, 0, e.ai), f.max.y = e.ay(f.max.y, 0, e.ai), f),\n          tile: t,\n          tileID: t.tileID,\n          pixelToTileUnitsFactor: p\n        };\n        var f;\n      }\n      _bufferedScreenMercator(e, t) {\n        const i = Je(e);\n        if (this._screenRaycastCache[i]) return this._screenRaycastCache[i];\n        {\n          let o;\n          return o = \"globe\" === t.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e), t) : {\n            polygon: this.bufferedScreenGeometry(e).map(e => t.pointCoordinate3D(e)),\n            unwrapped: !0\n          }, this._screenRaycastCache[i] = o, o;\n        }\n      }\n      _bufferedCameraMercator(e, t) {\n        const i = Je(e);\n        if (this._cameraRaycastCache[i]) return this._cameraRaycastCache[i];\n        {\n          let o;\n          return o = \"globe\" === t.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e), t) : {\n            polygon: this.bufferedCameraGeometry(e).map(e => t.pointCoordinate3D(e)),\n            unwrapped: !0\n          }, this._cameraRaycastCache[i] = o, o;\n        }\n      }\n      _projectAndResample(t, i) {\n        const o = function (t, i) {\n          const o = e.ad.mat4.multiply([], i.pixelMatrix, i.globeMatrix),\n            s = [0, -e.az, 0, 1],\n            r = [0, e.az, 0, 1],\n            n = [0, 0, 0, 1];\n          e.ad.vec4.transformMat4(s, s, o), e.ad.vec4.transformMat4(r, r, o), e.ad.vec4.transformMat4(n, n, o);\n          const a = new e.P(s[0] / s[3], s[1] / s[3]),\n            l = new e.P(r[0] / r[3], r[1] / r[3]),\n            c = e.aw(t, a) && s[3] < n[3],\n            h = e.aw(t, l) && r[3] < n[3];\n          if (!c && !h) return null;\n          const d = function (e, t, i) {\n            for (let o = 1; o < e.length; o++) {\n              const s = Ye(t.pointCoordinate3D(e[o - 1]).x),\n                r = Ye(t.pointCoordinate3D(e[o]).x);\n              if (i < 0) {\n                if (s < r) return {\n                  idx: o,\n                  t: -s / (r - 1 - s)\n                };\n              } else if (r < s) return {\n                idx: o,\n                t: (1 - s) / (r + 1 - s)\n              };\n            }\n            return null;\n          }(t, i, c ? -1 : 1);\n          if (!d) return null;\n          const {\n            idx: u,\n            t: _\n          } = d;\n          let p = u > 1 ? Ke(t.slice(0, u), i) : [],\n            f = u < t.length ? Ke(t.slice(u), i) : [];\n          p = p.map(t => new e.P(Ye(t.x), t.y)), f = f.map(t => new e.P(Ye(t.x), t.y));\n          const m = [...p];\n          0 === m.length && m.push(f[f.length - 1]);\n          const g = e.ah(m[m.length - 1].y, (0 === f.length ? p[0] : f[0]).y, _);\n          let v;\n          return v = c ? [new e.P(0, g), new e.P(0, 0), new e.P(1, 0), new e.P(1, g)] : [new e.P(1, g), new e.P(1, 1), new e.P(0, 1), new e.P(0, g)], m.push(...v), 0 === f.length ? m.push(p[0]) : m.push(...f), {\n            polygon: m.map(t => new e.ac(t.x, t.y)),\n            unwrapped: !1\n          };\n        }(t, i);\n        if (o) return o;\n        const s = function (t, i) {\n          let o = !1,\n            s = -1 / 0,\n            r = 0;\n          for (let e = 0; e < t.length - 1; e++) t[e].x > s && (s = t[e].x, r = e);\n          for (let e = 0; e < t.length - 1; e++) {\n            const i = (r + e) % (t.length - 1),\n              s = t[i],\n              n = t[i + 1];\n            Math.abs(s.x - n.x) > .5 && (s.x < n.x ? (s.x += 1, 0 === i && (t[t.length - 1].x += 1)) : (n.x += 1, i + 1 === t.length - 1 && (t[0].x += 1)), o = !0);\n          }\n          const n = e.av(i.center.lng);\n          return o && n < Math.abs(n - 1) && t.forEach(e => {\n            e.x -= 1;\n          }), {\n            polygon: t,\n            unwrapped: o\n          };\n        }(Ke(t, i).map(t => new e.P(Ye(t.x), t.y)), i);\n        return {\n          polygon: s.polygon.map(t => new e.ac(t.x, t.y)),\n          unwrapped: s.unwrapped\n        };\n      }\n    }\n    function Ke(t, i) {\n      return e.ax(t, e => {\n        const t = i.pointCoordinate3D(e);\n        e.x = t.x, e.y = t.y;\n      }, 1 / 256);\n    }\n    function Ye(e) {\n      return e < 0 ? 1 + e % 1 : e % 1;\n    }\n    function Je(e) {\n      return 100 * e | 0;\n    }\n    function Qe(t, i, o, s, r) {\n      const n = function (o, s) {\n          if (o) return r(o);\n          if (s) {\n            if (t.url && s.tiles && t.tiles && delete t.tiles, s.variants) {\n              if (!Array.isArray(s.variants)) return r(new Error(\"variants must be an array\"));\n              for (const t of s.variants) {\n                if (null == t || \"object\" != typeof t || t.constructor !== Object) return r(new Error(\"variant must be an object\"));\n                if (!Array.isArray(t.capabilities)) return r(new Error(\"capabilities must be an array\"));\n                if (1 === t.capabilities.length && \"meshopt\" === t.capabilities[0]) {\n                  s = e.l(s, t);\n                  break;\n                }\n              }\n            }\n            const o = e.aA(e.l({}, s, t), [\"tilejson\", \"tiles\", \"minzoom\", \"maxzoom\", \"attribution\", \"mapbox_logo\", \"bounds\", \"scheme\", \"tileSize\", \"encoding\", \"vector_layers\", \"raster_layers\", \"worldview_options\", \"worldview_default\", \"worldview\"]);\n            o.tiles = i.canonicalizeTileset(o, t.url), r(null, o);\n          }\n        },\n        a = function (e, t, i) {\n          if (!e) return null;\n          if (!t && !i) return e;\n          i = i || e.worldview_default;\n          const o = Object.values(e.language || {});\n          if (0 === o.length) return null;\n          const s = Object.values(e.worldview || {});\n          if (0 === s.length) return null;\n          const r = o.every(e => e === t),\n            n = s.every(e => e === i);\n          return r && n ? e : t in (e.language_options || {}) || i in (e.worldview_options || {}) ? null : e.language_options && e.worldview_options ? e : null;\n        }(t.data, o, s);\n      return a ? e.q.frame(() => n(null, a)) : t.url ? e.n(i.transformRequest(i.normalizeSourceURL(t.url, null, o, s), e.R.Source), n) : e.q.frame(() => {\n        const {\n          data: e,\n          ...i\n        } = t;\n        n(null, i);\n      });\n    }\n    class et {\n      constructor(t, i, o) {\n        this.bounds = e.aB.convert(this.validateBounds(t)), this.minzoom = i || 0, this.maxzoom = o || 24;\n      }\n      validateBounds(e) {\n        return Array.isArray(e) && 4 === e.length ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90];\n      }\n      contains(t) {\n        const i = Math.pow(2, t.z),\n          o = Math.floor(e.av(this.bounds.getWest()) * i),\n          s = Math.floor(e.aC(this.bounds.getNorth()) * i),\n          r = Math.ceil(e.av(this.bounds.getEast()) * i),\n          n = Math.ceil(e.aC(this.bounds.getSouth()) * i);\n        return t.x >= o && t.x < r && t.y >= s && t.y < n;\n      }\n    }\n    class tt extends e.E {\n      constructor(t, i, o, s) {\n        if (super(), this.id = t, this.dispatcher = o, this.type = \"vector\", this.minzoom = 0, this.maxzoom = 22, this.scheme = \"xyz\", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, e.l(this, e.aA(i, [\"url\", \"scheme\", \"tileSize\", \"promoteId\"])), this._options = e.l({\n          type: \"vector\"\n        }, i), this._collectResourceTiming = !!i.collectResourceTiming, 512 !== this.tileSize) throw new Error(\"vector tile sources must have a tileSize of 512\");\n        this.setEventedParent(s), this._tileWorkers = {}, this._deduped = new e.aD();\n      }\n      load(t) {\n        this._loaded = !1, this.fire(new e.A(\"dataloading\", {\n          dataType: \"source\"\n        }));\n        const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language,\n          o = this.map.getWorldview();\n        this._tileJSONRequest = Qe(this._options, this.map._requestManager, i, o, (s, r) => {\n          if (this._tileJSONRequest = null, this._loaded = !0, s) i && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`), o && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`), this.fire(new e.z(s));else if (r) {\n            if (e.l(this, r), this.hasWorldviews = !!r.worldview_options, r.worldview_default && (this.worldviewDefault = r.worldview_default), r.vector_layers) {\n              this.vectorLayers = r.vector_layers, this.vectorLayerIds = [], this.localizableLayerIds = new Set();\n              for (const e of r.vector_layers) this.vectorLayerIds.push(e.id), r.worldview && r.worldview[e.source] && this.localizableLayerIds.add(e.id);\n            }\n            r.bounds && (this.tileBounds = new et(r.bounds, this.minzoom, this.maxzoom)), L(r.tiles, this.map._requestManager._customAccessToken), this.fire(new e.A(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"metadata\"\n            })), this.fire(new e.A(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"content\"\n            }));\n          }\n          t && t(s);\n        });\n      }\n      loaded() {\n        return this._loaded;\n      }\n      hasTile(e) {\n        return !this.tileBounds || this.tileBounds.contains(e.canonical);\n      }\n      onAdd(e) {\n        this.map = e, this.load();\n      }\n      reload() {\n        this.cancelTileJSONRequest();\n        const t = e.C(this.id, this.scope);\n        this.load(() => this.map.style.clearSource(t));\n      }\n      setTiles(e) {\n        return this._options.tiles = e, this.reload(), this;\n      }\n      setUrl(e) {\n        return this.url = e, this._options.url = e, this.reload(), this;\n      }\n      onRemove(e) {\n        this.cancelTileJSONRequest();\n      }\n      serialize() {\n        return e.l({}, this._options);\n      }\n      loadTile(t, i) {\n        const o = t.tileID.canonical.url(this.tiles, this.scheme),\n          s = this.map._requestManager.normalizeTileURL(o),\n          r = this.map._requestManager.transformRequest(s, e.R.Tile),\n          n = this.map.style ? this.map.style.getLut(this.scope) : null,\n          a = n ? {\n            image: n.image.clone()\n          } : null,\n          l = {\n            request: r,\n            data: void 0,\n            uid: t.uid,\n            tileID: t.tileID,\n            tileZoom: t.tileZoom,\n            zoom: t.tileID.overscaledZ,\n            maxZoom: this.maxzoom,\n            lut: a,\n            tileSize: this.tileSize * t.tileID.overscaleFactor(),\n            type: this.type,\n            source: this.id,\n            scope: this.scope,\n            pixelRatio: e.q.devicePixelRatio,\n            showCollisionBoxes: this.map.showCollisionBoxes,\n            promoteId: this.promoteId,\n            isSymbolTile: t.isSymbolTile,\n            brightness: this.map.style && this.map.style.getBrightness() || 0,\n            extraShadowCaster: t.isExtraShadowCaster,\n            tessellationStep: this.map._tessellationStep,\n            scaleFactor: this.map.getScaleFactor()\n          };\n        if (this.hasWorldviews && e.f(o) && (l.worldview = this.map.getWorldview() || this.worldviewDefault, l.localizableLayerIds = this.localizableLayerIds), l.request.collectResourceTiming = this._collectResourceTiming, t.actor && \"expired\" !== t.state) \"loading\" === t.state ? t.reloadCallback = i : t.request = t.actor.send(\"reloadTile\", l, c.bind(this));else if (t.actor = this._tileWorkers[s] = this._tileWorkers[s] || this.dispatcher.getActor(), this.dispatcher.ready) t.request = t.actor.send(\"loadTile\", l, c.bind(this), void 0, !0);else {\n          const i = e.aE.call({\n            deduped: this._deduped\n          }, l, (e, i) => {\n            e || !i ? c.call(this, e) : (l.data = {\n              cacheControl: i.cacheControl,\n              expires: i.expires,\n              rawData: i.rawData.slice(0)\n            }, t.actor && t.actor.send(\"loadTile\", l, c.bind(this), void 0, !0));\n          }, !0);\n          t.request = {\n            cancel: i\n          };\n        }\n        function c(o, s) {\n          return delete t.request, t.aborted ? i(null) : o && 404 !== o.status ? i(o) : (s && s.resourceTiming && (t.resourceTiming = s.resourceTiming), this.map._refreshExpiredTiles && s && t.setExpiryData(s), t.loadVectorData(s, this.map.painter), e.aF(this.dispatcher), i(null), void (t.reloadCallback && (this.loadTile(t, t.reloadCallback), t.reloadCallback = null)));\n        }\n      }\n      abortTile(e) {\n        e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send(\"abortTile\", {\n          uid: e.uid,\n          type: this.type,\n          source: this.id,\n          scope: this.scope\n        });\n      }\n      unloadTile(e, t) {\n        e.actor && e.actor.send(\"removeTile\", {\n          uid: e.uid,\n          type: this.type,\n          source: this.id,\n          scope: this.scope\n        }), e.destroy();\n      }\n      hasTransition() {\n        return !1;\n      }\n      afterUpdate() {\n        this._tileWorkers = {};\n      }\n      cancelTileJSONRequest() {\n        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n      }\n    }\n    class it extends e.E {\n      constructor(t, i, o, s) {\n        super(), this.id = t, this.dispatcher = o, this.setEventedParent(s), this.type = \"raster\", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = \"xyz\", this.tileSize = 512, this._loaded = !1, this._options = e.l({\n          type: \"raster\"\n        }, i), e.l(this, e.aA(i, [\"url\", \"scheme\", \"tileSize\"]));\n      }\n      load(t) {\n        this._loaded = !1, this.fire(new e.A(\"dataloading\", {\n          dataType: \"source\"\n        })), this._tileJSONRequest = Qe(this._options, this.map._requestManager, null, null, (i, o) => {\n          this._tileJSONRequest = null, this._loaded = !0, i ? this.fire(new e.z(i)) : o && (e.l(this, o), o.raster_layers && (this.rasterLayers = o.raster_layers, this.rasterLayerIds = this.rasterLayers.map(e => e.id)), o.bounds && (this.tileBounds = new et(o.bounds, this.minzoom, this.maxzoom)), L(o.tiles), this.fire(new e.A(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"metadata\"\n          })), this.fire(new e.A(\"data\", {\n            dataType: \"source\",\n            sourceDataType: \"content\"\n          }))), t && t(i);\n        });\n      }\n      loaded() {\n        return this._loaded;\n      }\n      onAdd(e) {\n        this.map = e, this.load();\n      }\n      reload() {\n        this.cancelTileJSONRequest();\n        const t = e.C(this.id, this.scope);\n        this.load(() => this.map.style.clearSource(t));\n      }\n      setTiles(e) {\n        return this._options.tiles = e, this.reload(), this;\n      }\n      setUrl(e) {\n        return this.url = e, this._options.url = e, this.reload(), this;\n      }\n      onRemove(e) {\n        this.cancelTileJSONRequest();\n      }\n      serialize() {\n        return e.l({}, this._options);\n      }\n      hasTile(e) {\n        return !this.tileBounds || this.tileBounds.contains(e.canonical);\n      }\n      loadTile(t, i) {\n        const o = e.q.devicePixelRatio >= 2,\n          s = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), o, this.tileSize);\n        t.request = e.o(this.map._requestManager.transformRequest(s, e.R.Tile), (o, s, r, n) => (delete t.request, t.aborted ? (t.state = \"unloaded\", i(null)) : o ? (t.state = \"errored\", i(o)) : s ? (this.map._refreshExpiredTiles && t.setExpiryData({\n          cacheControl: r,\n          expires: n\n        }), t.setTexture(s, this.map.painter), t.state = \"loaded\", e.aF(this.dispatcher), void i(null)) : i(null)));\n      }\n      abortTile(e, t) {\n        e.request && (e.request.cancel(), delete e.request), t && t();\n      }\n      unloadTile(t, i) {\n        t.texture && t.texture instanceof e.T ? (t.destroy(!0), t.texture && t.texture instanceof e.T && this.map.painter.saveTileTexture(t.texture)) : t.destroy(), i && i();\n      }\n      hasTransition() {\n        return !1;\n      }\n      cancelTileJSONRequest() {\n        this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n      }\n    }\n    class ot extends it {\n      constructor(t, i, o, s) {\n        super(t, i, o, s), this.type = \"raster-array\", this.maxzoom = 22, this.partial = !0, this.iconsets = {}, this._options = e.l({\n          type: \"raster-array\"\n        }, i);\n      }\n      triggerRepaint(e) {\n        const t = this.map.painter._terrain,\n          i = this.map.style.getSourceCache(this.id);\n        t && t.enabled && i && t._clearRenderCacheForTile(i.id, e.tileID), this.map.triggerRepaint();\n      }\n      loadTile(t, i) {\n        const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize),\n          s = this.map._requestManager.transformRequest(o, e.R.Tile),\n          r = {\n            request: s,\n            uid: t.uid,\n            tileID: t.tileID,\n            type: this.type,\n            source: this.id,\n            scope: this.scope,\n            partial: this.partial\n          };\n        t.source = this.id, t.scope = this.scope, t.requestParams = s, t.actor || (t.actor = this.dispatcher.getActor());\n        const n = (o, s, r, n) => {\n          if (delete t.request, t.aborted) return t.state = \"unloaded\", i(null);\n          if (o) {\n            if (\"AbortError\" === o.name) return;\n            return t.state = \"errored\", i(o);\n          }\n          if (this.map._refreshExpiredTiles && s && t.setExpiryData({\n            cacheControl: r,\n            expires: n\n          }), this.partial) t.state = \"empty\";else {\n            if (!s) return i(null);\n            t.state = \"loaded\", t._isHeaderLoaded = !0, t._mrt = s;\n            const o = new Map();\n            for (const i in t._mrt.layers) {\n              const s = t.getLayer(i);\n              if (s) for (const t of s.getBandList()) {\n                const {\n                    bytes: r,\n                    tileSize: n,\n                    buffer: a\n                  } = s.getBandView(t),\n                  l = n + 2 * a,\n                  c = {\n                    data: new e.r({\n                      width: l,\n                      height: l\n                    }, r),\n                    pixelRatio: 2,\n                    sdf: !1,\n                    usvg: !1,\n                    version: 0\n                  };\n                o.set(`${i}/${t}`, c);\n              }\n            }\n            for (const e in this.iconsets) this.iconsets[e].addIcons(o);\n          }\n          i(null);\n        };\n        t.request = this.partial ? t.fetchHeader(void 0, n.bind(this)) : t.actor.send(\"loadTile\", r, n.bind(this), void 0, !0);\n      }\n      abortTile(e) {\n        e.request && (e.request.cancel(), delete e.request), e.actor && e.actor.send(\"abortTile\", {\n          uid: e.uid,\n          type: this.type,\n          source: this.id,\n          scope: this.scope\n        });\n      }\n      unloadTile(t, i) {\n        const o = t.texture;\n        o && o instanceof e.T ? (t.destroy(!0), this.map.painter.saveTileTexture(o)) : (t.destroy(), t.flushQueues(), t._isHeaderLoaded = !1, delete t._mrt, delete t.textureDescriptor), t.fbo && (t.fbo.destroy(), delete t.fbo), delete t.request, delete t.requestParams, delete t.neighboringTiles, t.state = \"unloaded\";\n      }\n      prepareTile(t, i, o) {\n        t._isHeaderLoaded && (\"empty\" !== t.state && (t.state = \"reloading\"), t.fetchBand(i, o, (i, o) => {\n          if (i) return t.state = \"errored\", this.fire(new e.z(i)), void this.triggerRepaint(t);\n          o && (t._isHeaderLoaded = !0, t.setTexture(o, this.map.painter), t.state = \"loaded\", this.triggerRepaint(t));\n        }));\n      }\n      getInitialBand(e) {\n        if (!this.rasterLayers) return 0;\n        const t = this.rasterLayers.find(({\n            id: t\n          }) => t === e),\n          i = t && t.fields,\n          o = i && i.bands && i.bands;\n        return o ? o[0] : 0;\n      }\n      getTextureDescriptor(t, i, o) {\n        if (!t) return;\n        const s = i.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];\n        if (!s) return;\n        let r = null;\n        i instanceof e.aI ? r = i.paint.get(\"raster-array-band\") : i instanceof e.aJ && (r = i.paint.get(\"raster-particle-array-band\"));\n        const n = r || this.getInitialBand(s);\n        if (null != n) if (t.textureDescriptor) {\n          if (!t.updateNeeded(s, n) || o) return Object.assign({}, t.textureDescriptor, {\n            texture: t.texture\n          });\n        } else this.prepareTile(t, s, n);\n      }\n      addIconset(e, t) {\n        this.iconsets[e] = t, this.partial = !1;\n      }\n    }\n    const st = {\n        vector: tt,\n        raster: it,\n        \"raster-dem\": class extends it {\n          constructor(t, i, o, s) {\n            super(t, i, o, s), this.type = \"raster-dem\", this.maxzoom = 22, this._options = e.l({\n              type: \"raster-dem\"\n            }, i), this.encoding = i.encoding || \"mapbox\";\n          }\n          loadTile(t, i) {\n            const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);\n            function s(e, o) {\n              e && (t.state = \"errored\", i(e)), o && (t.dem = o, t.dem.onDeserialize(), t.needsHillshadePrepare = !0, t.needsDEMTextureUpload = !0, t.state = \"loaded\", i(null));\n            }\n            t.request = e.o(this.map._requestManager.transformRequest(o, e.R.Tile), function (o, r, n, a) {\n              if (delete t.request, t.aborted) t.state = \"unloaded\", i(null);else if (o) t.state = \"errored\", i(o);else if (r) {\n                this.map._refreshExpiredTiles && t.setExpiryData({\n                  cacheControl: n,\n                  expires: a\n                });\n                const i = ImageBitmap && r instanceof ImageBitmap && e.t(),\n                  o = 1 - (r.width - e.aG(r.width)) / 2;\n                o < 1 || t.neighboringTiles || (t.neighboringTiles = this._getNeighboringTiles(t.tileID));\n                const l = i ? r : e.q.getImageData(r, o),\n                  c = {\n                    uid: t.uid,\n                    tileID: t.tileID,\n                    source: this.id,\n                    type: this.type,\n                    scope: this.scope,\n                    rawImageData: l,\n                    encoding: this.encoding,\n                    padding: o\n                  };\n                t.actor && \"expired\" !== t.state || (t.actor = this.dispatcher.getActor(), t.actor.send(\"loadTile\", c, s.bind(this), void 0, !0));\n              }\n            }.bind(this));\n          }\n          _getNeighboringTiles(t) {\n            const i = t.canonical,\n              o = Math.pow(2, i.z),\n              s = (i.x - 1 + o) % o,\n              r = 0 === i.x ? t.wrap - 1 : t.wrap,\n              n = (i.x + 1 + o) % o,\n              a = i.x + 1 === o ? t.wrap + 1 : t.wrap,\n              l = {};\n            return l[new e.aH(t.overscaledZ, r, i.z, s, i.y).key] = {\n              backfilled: !1\n            }, l[new e.aH(t.overscaledZ, a, i.z, n, i.y).key] = {\n              backfilled: !1\n            }, i.y > 0 && (l[new e.aH(t.overscaledZ, r, i.z, s, i.y - 1).key] = {\n              backfilled: !1\n            }, l[new e.aH(t.overscaledZ, t.wrap, i.z, i.x, i.y - 1).key] = {\n              backfilled: !1\n            }, l[new e.aH(t.overscaledZ, a, i.z, n, i.y - 1).key] = {\n              backfilled: !1\n            }), i.y + 1 < o && (l[new e.aH(t.overscaledZ, r, i.z, s, i.y + 1).key] = {\n              backfilled: !1\n            }, l[new e.aH(t.overscaledZ, t.wrap, i.z, i.x, i.y + 1).key] = {\n              backfilled: !1\n            }, l[new e.aH(t.overscaledZ, a, i.z, n, i.y + 1).key] = {\n              backfilled: !1\n            }), l;\n          }\n        },\n        \"raster-array\": ot,\n        geojson: class extends e.E {\n          constructor(t, i, o, s) {\n            super(), this.id = t, this.type = \"geojson\", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._loaded = !1, this.actor = o.getActor(), this.setEventedParent(s), this._data = i.data, this._options = e.l({}, i), this._collectResourceTiming = i.collectResourceTiming, void 0 !== i.maxzoom && (this.maxzoom = i.maxzoom), void 0 !== i.minzoom && (this.minzoom = i.minzoom), i.type && (this.type = i.type), i.attribution && (this.attribution = i.attribution), this.promoteId = i.promoteId;\n            const r = e.ai / this.tileSize;\n            this.workerOptions = e.l({\n              source: this.id,\n              scope: this.scope,\n              cluster: i.cluster || !1,\n              geojsonVtOptions: {\n                buffer: (void 0 !== i.buffer ? i.buffer : 128) * r,\n                tolerance: (void 0 !== i.tolerance ? i.tolerance : .375) * r,\n                extent: e.ai,\n                maxZoom: this.maxzoom,\n                lineMetrics: i.lineMetrics || !1,\n                generateId: i.generateId || !1\n              },\n              superclusterOptions: {\n                maxZoom: void 0 !== i.clusterMaxZoom ? i.clusterMaxZoom : this.maxzoom - 1,\n                minPoints: Math.max(2, i.clusterMinPoints || 2),\n                extent: e.ai,\n                radius: (void 0 !== i.clusterRadius ? i.clusterRadius : 50) * r,\n                log: !1,\n                generateId: i.generateId || !1\n              },\n              clusterProperties: i.clusterProperties,\n              filter: i.filter,\n              dynamic: i.dynamic\n            }, i.workerOptions);\n          }\n          onAdd(e) {\n            this.map = e, this.setData(this._data);\n          }\n          setData(e) {\n            return this._data = e, this._updateWorkerData(), this;\n          }\n          updateData(t) {\n            if (!this._options.dynamic) return this.fire(new e.z(new Error(\"Can't call updateData on a GeoJSON source with dynamic set to false.\")));\n            if (\"string\" != typeof t && (\"Feature\" === t.type && (t = {\n              type: \"FeatureCollection\",\n              features: [t]\n            }), \"FeatureCollection\" !== t.type)) return this.fire(new e.z(new Error(\"Data to update should be a feature or a feature collection.\")));\n            if (this._coalesce && \"string\" != typeof t && \"string\" != typeof this._data && \"FeatureCollection\" === this._data.type) {\n              const e = new Map();\n              for (const t of this._data.features) e.set(t.id, t);\n              for (const i of t.features) e.set(i.id, i);\n              this._data.features = [...e.values()];\n            } else this._data = t;\n            return this._updateWorkerData(!0), this;\n          }\n          getClusterExpansionZoom(e, t) {\n            return this.actor.send(\"geojson.getClusterExpansionZoom\", {\n              clusterId: e,\n              source: this.id,\n              scope: this.scope\n            }, t), this;\n          }\n          getClusterChildren(e, t) {\n            return this.actor.send(\"geojson.getClusterChildren\", {\n              clusterId: e,\n              source: this.id,\n              scope: this.scope\n            }, t), this;\n          }\n          getClusterLeaves(e, t, i, o) {\n            return this.actor.send(\"geojson.getClusterLeaves\", {\n              source: this.id,\n              scope: this.scope,\n              clusterId: e,\n              limit: t,\n              offset: i\n            }, o), this;\n          }\n          _updateWorkerData(t = !1) {\n            if (this._pendingLoad) return void (this._coalesce = !0);\n            this.fire(new e.A(\"dataloading\", {\n              dataType: \"source\"\n            })), this._loaded = !1;\n            const i = e.l({\n              append: t\n            }, this.workerOptions);\n            i.scope = this.scope;\n            const o = this._data;\n            \"string\" == typeof o ? (i.request = this.map._requestManager.transformRequest(e.q.resolveURL(o), e.R.Source), i.request.collectResourceTiming = this._collectResourceTiming) : i.data = JSON.stringify(o), this._pendingLoad = this.actor.send(`${this.type}.loadData`, i, (i, o) => {\n              if (this._loaded = !0, this._pendingLoad = null, i) this.fire(new e.z(i));else {\n                const i = {\n                  dataType: \"source\",\n                  sourceDataType: this._metadataFired ? \"content\" : \"metadata\"\n                };\n                this._collectResourceTiming && o && o.resourceTiming && o.resourceTiming[this.id] && (i.resourceTiming = o.resourceTiming[this.id]), t && (this._partialReload = !0), this.fire(new e.A(\"data\", i)), this._partialReload = !1, this._metadataFired = !0;\n              }\n              this._coalesce && (this._updateWorkerData(t), this._coalesce = !1);\n            });\n          }\n          loaded() {\n            return this._loaded;\n          }\n          reload() {\n            const t = e.C(this.id, this.scope);\n            this.map.style.clearSource(t), this._updateWorkerData();\n          }\n          loadTile(t, i) {\n            const o = t.actor ? \"reloadTile\" : \"loadTile\";\n            t.actor = this.actor;\n            const s = this.map.style ? this.map.style.getLut(this.scope) : null,\n              r = s ? {\n                image: s.image.clone()\n              } : null,\n              n = this._partialReload,\n              a = {\n                type: this.type,\n                uid: t.uid,\n                tileID: t.tileID,\n                tileZoom: t.tileZoom,\n                zoom: t.tileID.overscaledZ,\n                maxZoom: this.maxzoom,\n                tileSize: this.tileSize,\n                source: this.id,\n                lut: r,\n                scope: this.scope,\n                pixelRatio: e.q.devicePixelRatio,\n                showCollisionBoxes: this.map.showCollisionBoxes,\n                promoteId: this.promoteId,\n                brightness: this.map.style && this.map.style.getBrightness() || 0,\n                scaleFactor: this.map.getScaleFactor(),\n                partial: n\n              };\n            t.request = this.actor.send(o, a, (e, s) => n && !s ? (t.state = \"loaded\", i(null)) : (delete t.request, t.destroy(), t.aborted ? i(null) : e ? i(e) : (t.loadVectorData(s, this.map.painter, \"reloadTile\" === o), i(null))), void 0, \"loadTile\" === o);\n          }\n          abortTile(e) {\n            e.request && (e.request.cancel(), delete e.request), e.aborted = !0;\n          }\n          unloadTile(e, t) {\n            this.actor.send(\"removeTile\", {\n              uid: e.uid,\n              type: this.type,\n              source: this.id,\n              scope: this.scope\n            }), e.destroy();\n          }\n          onRemove(e) {\n            this._pendingLoad && this._pendingLoad.cancel();\n          }\n          serialize() {\n            return e.l({}, this._options, {\n              type: this.type,\n              data: this._data\n            });\n          }\n          hasTransition() {\n            return !1;\n          }\n        },\n        video: class extends e.aK {\n          constructor(e, t, i, o) {\n            super(e, t, i, o), this.roundZoom = !0, this.type = \"video\", this.options = t;\n          }\n          load() {\n            this._loaded = !1;\n            const t = this.options;\n            this.urls = [];\n            for (const i of t.urls) this.urls.push(this.map._requestManager.transformRequest(i, e.R.Source).url);\n            e.aL(this.urls, (t, i) => {\n              this._loaded = !0, t ? this.fire(new e.z(t)) : i && (this.video = i, this.video.loop = !0, this.video.setAttribute(\"playsinline\", \"\"), this.video.addEventListener(\"playing\", () => {\n                this.map.triggerRepaint();\n              }), this.map && this.video.play(), this._finishLoading());\n            });\n          }\n          pause() {\n            this.video && this.video.pause();\n          }\n          play() {\n            this.video && this.video.play();\n          }\n          seek(t) {\n            if (this.video) {\n              const i = this.video.seekable;\n              t < i.start(0) || t > i.end(0) ? this.fire(new e.z(new e.V(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = t;\n            }\n          }\n          getVideo() {\n            return this.video;\n          }\n          onAdd(e) {\n            this.map || (this.map = e, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));\n          }\n          prepare() {\n            if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;\n            const t = this.map.painter.context,\n              i = t.gl;\n            this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new e.T(t, this.video, i.RGBA8), this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t);\n          }\n          serialize() {\n            return {\n              type: \"video\",\n              urls: this.urls,\n              coordinates: this.coordinates\n            };\n          }\n          hasTransition() {\n            return this.video && !this.video.paused;\n          }\n        },\n        image: e.aK,\n        model: class extends e.E {\n          constructor(e, t, i, o) {\n            super(), this.id = e, this.type = \"model\", this.models = [], this._loaded = !1, this._options = t;\n          }\n          load() {\n            const t = [];\n            for (const i in this._options.models) {\n              const o = this._options.models[i],\n                s = e.aN(this.map._requestManager.transformRequest(o.uri, e.R.Model).url).then(t => {\n                  if (!t) return;\n                  const s = e.aO(t),\n                    r = new e.aP(i, o.position, o.orientation, s);\n                  r.computeBoundsAndApplyParent(), this.models.push(r);\n                }).catch(t => {\n                  this.fire(new e.z(new Error(`Could not load model ${i} from ${o.uri}: ${t.message}`)));\n                });\n              t.push(s);\n            }\n            return Promise.allSettled(t).then(() => {\n              this._loaded = !0, this.fire(new e.A(\"data\", {\n                dataType: \"source\",\n                sourceDataType: \"metadata\"\n              }));\n            }).catch(t => {\n              this.fire(new e.z(new Error(`Could not load models: ${t.message}`)));\n            });\n          }\n          onAdd(e) {\n            this.map = e, this.load();\n          }\n          hasTransition() {\n            return !1;\n          }\n          loaded() {\n            return this._loaded;\n          }\n          getModels() {\n            return this.models;\n          }\n          loadTile(e, t) {}\n          serialize() {\n            return {\n              type: \"model\"\n            };\n          }\n        },\n        \"batched-model\": class extends e.E {\n          constructor(e, t, i, o) {\n            super(), this.type = \"batched-model\", this.id = e, this.tileSize = 512, this._options = t, this.tiles = this._options.tiles, this.maxzoom = t.maxzoom || 19, this.minzoom = t.minzoom || 0, this.roundZoom = !0, this.usedInConflation = !0, this.dispatcher = i, this.reparseOverscaled = !1, this.scheme = \"xyz\", this._loaded = !1, this.setEventedParent(o);\n          }\n          onAdd(e) {\n            this.map = e, this.load();\n          }\n          reload() {\n            this.cancelTileJSONRequest();\n            const t = e.C(this.id, this.scope);\n            this.load(() => this.map.style.clearSource(t));\n          }\n          cancelTileJSONRequest() {\n            this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);\n          }\n          load(t) {\n            this._loaded = !1, this.fire(new e.A(\"dataloading\", {\n              dataType: \"source\"\n            }));\n            const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language,\n              o = this.map.getWorldview();\n            this._tileJSONRequest = Qe(this._options, this.map._requestManager, i, o, (s, r) => {\n              this._tileJSONRequest = null, this._loaded = !0, s ? (i && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`), o && 2 !== o.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o}`), this.fire(new e.z(s))) : r && (e.l(this, r), r.bounds && (this.tileBounds = new et(r.bounds, this.minzoom, this.maxzoom)), L(r.tiles, this.map._requestManager._customAccessToken), this.fire(new e.A(\"data\", {\n                dataType: \"source\",\n                sourceDataType: \"metadata\"\n              })), this.fire(new e.A(\"data\", {\n                dataType: \"source\",\n                sourceDataType: \"content\"\n              }))), t && t(s);\n            });\n          }\n          hasTransition() {\n            return !1;\n          }\n          hasTile(e) {\n            return !this.tileBounds || this.tileBounds.contains(e.canonical);\n          }\n          loaded() {\n            return this._loaded;\n          }\n          loadTile(t, i) {\n            const o = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme)),\n              s = {\n                request: this.map._requestManager.transformRequest(o, e.R.Tile),\n                data: void 0,\n                uid: t.uid,\n                tileID: t.tileID,\n                tileZoom: t.tileZoom,\n                zoom: t.tileID.overscaledZ,\n                tileSize: this.tileSize * t.tileID.overscaleFactor(),\n                type: this.type,\n                source: this.id,\n                scope: this.scope,\n                showCollisionBoxes: this.map.showCollisionBoxes,\n                isSymbolTile: t.isSymbolTile,\n                brightness: this.map.style && this.map.style.getBrightness() || 0,\n                pixelRatio: e.q.devicePixelRatio,\n                promoteId: this.promoteId\n              };\n            if (t.actor && \"expired\" !== t.state) {\n              if (\"loading\" === t.state) t.reloadCallback = i;else {\n                if (t.buckets) {\n                  const e = Object.values(t.buckets);\n                  for (const t of e) t.dirty = !0;\n                  return void (t.state = \"loaded\");\n                }\n                t.request = t.actor.send(\"reloadTile\", s, r.bind(this));\n              }\n            } else t.actor = this.dispatcher.getActor(), t.request = t.actor.send(\"loadTile\", s, r.bind(this), void 0, !0);\n            function r(e, o) {\n              return t.aborted ? i(null) : e && 404 !== e.status ? i(e) : (this.map._refreshExpiredTiles && o && t.setExpiryData(o), t.loadModelData(o, this.map.painter), t.state = \"loaded\", void i(null));\n            }\n          }\n          serialize() {\n            return e.l({}, this._options);\n          }\n        },\n        canvas: class extends e.aK {\n          constructor(t, i, o, s) {\n            super(t, i, o, s), i.coordinates ? Array.isArray(i.coordinates) && 4 === i.coordinates.length && !i.coordinates.some(e => !Array.isArray(e) || 2 !== e.length || e.some(e => \"number\" != typeof e)) || this.fire(new e.z(new e.V(`sources.${t}`, null, '\"coordinates\" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.z(new e.V(`sources.${t}`, null, 'missing required property \"coordinates\"'))), i.animate && \"boolean\" != typeof i.animate && this.fire(new e.z(new e.V(`sources.${t}`, null, 'optional \"animate\" property must be a boolean value'))), i.canvas ? \"string\" == typeof i.canvas || i.canvas instanceof HTMLCanvasElement || this.fire(new e.z(new e.V(`sources.${t}`, null, '\"canvas\" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.z(new e.V(`sources.${t}`, null, 'missing required property \"canvas\"'))), this.options = i, this.animate = void 0 === i.animate || i.animate;\n          }\n          load() {\n            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.z(new Error(\"Canvas dimensions cannot be less than or equal to zero.\"))) : (this.play = function () {\n              this._playing = !0, this.map.triggerRepaint();\n            }, this.pause = function () {\n              this._playing && (this.prepare(), this._playing = !1);\n            }, this._finishLoading());\n          }\n          getCanvas() {\n            return this.canvas;\n          }\n          onAdd(e) {\n            this.map = e, this.load(), this.canvas && this.animate && this.play();\n          }\n          onRemove(e) {\n            this.pause();\n          }\n          prepare() {\n            let t = !1;\n            if (this.canvas.width !== this.width && (this.width = this.canvas.width, t = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, t = !0), this._hasInvalidDimensions()) return;\n            if (0 === Object.keys(this.tiles).length) return;\n            const i = this.map.painter.context;\n            this.texture ? !t && !this._playing || this.texture instanceof e.aM || this.texture.update(this.canvas, {\n              premultiply: !0\n            }) : this.texture = new e.T(i, this.canvas, i.gl.RGBA8, {\n              premultiply: !0\n            }), this._prepareData(i);\n          }\n          serialize() {\n            return {\n              type: \"canvas\",\n              coordinates: this.coordinates\n            };\n          }\n          hasTransition() {\n            return this._playing;\n          }\n          _hasInvalidDimensions() {\n            for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;\n            return !1;\n          }\n        },\n        custom: class extends e.E {\n          constructor(t, i, o, s) {\n            super(), this.id = t, this.type = \"custom\", this._dataType = \"raster\", this._dispatcher = o, this._implementation = i, this.setEventedParent(s), this.scheme = \"xyz\", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = !1, this.roundZoom = !0, this._implementation || this.fire(new e.z(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.z(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new et(this._implementation.bounds, this.minzoom, this.maxzoom)), i.update = this._update.bind(this), i.clearTiles = this._clearTiles.bind(this), i.coveringTiles = this._coveringTiles.bind(this), e.l(this, e.aA(i, [\"dataType\", \"scheme\", \"minzoom\", \"maxzoom\", \"tileSize\", \"attribution\", \"minTileCacheSize\", \"maxTileCacheSize\"]));\n          }\n          serialize() {\n            return e.aA(this, [\"type\", \"scheme\", \"minzoom\", \"maxzoom\", \"tileSize\", \"attribution\"]);\n          }\n          load() {\n            this._loaded = !0, this.fire(new e.A(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"metadata\"\n            })), this.fire(new e.A(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"content\"\n            }));\n          }\n          loaded() {\n            return this._loaded;\n          }\n          onAdd(t) {\n            this.map = t, this._loaded = !1, this.fire(new e.A(\"dataloading\", {\n              dataType: \"source\"\n            })), this._implementation.onAdd && this._implementation.onAdd(t), this.load();\n          }\n          onRemove(e) {\n            this._implementation.onRemove && this._implementation.onRemove(e);\n          }\n          hasTile(e) {\n            if (this._implementation.hasTile) {\n              const {\n                x: t,\n                y: i,\n                z: o\n              } = e.canonical;\n              return this._implementation.hasTile({\n                x: t,\n                y: i,\n                z: o\n              });\n            }\n            return !this.tileBounds || this.tileBounds.contains(e.canonical);\n          }\n          loadTile(e, t) {\n            const {\n                x: i,\n                y: o,\n                z: s\n              } = e.tileID.canonical,\n              r = new AbortController();\n            e.request = Promise.resolve(this._implementation.loadTile({\n              x: i,\n              y: o,\n              z: s\n            }, {\n              signal: r.signal\n            })).then(function (i) {\n              return delete e.request, e.aborted ? (e.state = \"unloaded\", t(null)) : void 0 === i ? (e.state = \"errored\", t(null)) : null === i ? (this.loadTileData(e, {\n                width: this.tileSize,\n                height: this.tileSize,\n                data: null\n              }), e.state = \"loaded\", t(null)) : function (e) {\n                return e instanceof ImageData || e instanceof HTMLCanvasElement || e instanceof ImageBitmap || e instanceof HTMLImageElement;\n              }(i) ? (this.loadTileData(e, i), e.state = \"loaded\", void t(null)) : (e.state = \"errored\", t(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));\n            }.bind(this)).catch(i => {\n              \"AbortError\" !== i.name && (e.state = \"errored\", t(i));\n            }), e.request.cancel = () => r.abort();\n          }\n          loadTileData(e, t) {\n            e.setTexture(t, this.map.painter);\n          }\n          unloadTile(t, i) {\n            if (t.texture && t.texture instanceof e.T ? (t.destroy(!0), t.texture && t.texture instanceof e.T && this.map.painter.saveTileTexture(t.texture)) : t.destroy(), this._implementation.unloadTile) {\n              const {\n                x: e,\n                y: i,\n                z: o\n              } = t.tileID.canonical;\n              this._implementation.unloadTile({\n                x: e,\n                y: i,\n                z: o\n              });\n            }\n            i && i();\n          }\n          abortTile(e, t) {\n            e.request && e.request.cancel && (e.request.cancel(), delete e.request), t && t();\n          }\n          hasTransition() {\n            return !1;\n          }\n          _coveringTiles() {\n            return this.map.transform.coveringTiles({\n              tileSize: this.tileSize,\n              minzoom: this.minzoom,\n              maxzoom: this.maxzoom,\n              roundZoom: this.roundZoom\n            }).map(e => ({\n              x: e.canonical.x,\n              y: e.canonical.y,\n              z: e.canonical.z\n            }));\n          }\n          _clearTiles() {\n            const t = e.C(this.id, this.scope);\n            this.map.style.clearSource(t);\n          }\n          _update() {\n            this.fire(new e.A(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"content\"\n            }));\n          }\n        }\n      },\n      rt = function (t, i, o, s) {\n        const r = new st[i.type](t, i, o, s);\n        if (r.id !== t) throw new Error(`Expected Source id to be ${t} instead of ${r.id}`);\n        return e.aQ([\"load\", \"abort\", \"unload\", \"serialize\", \"prepare\"], r), r;\n      };\n    function nt(e, t, i = \"\") {\n      return `${i}:${t.id || \"\"}:${t.layer.id}:${function (e) {\n        if (\"layerId\" in e) return `layer:${e.layerId}`;\n        {\n          const {\n            featuresetId: t,\n            importId: i\n          } = e;\n          return `featureset:${t}${i ? `:import:${i}` : \"\"}`;\n        }\n      }(e.target)}`;\n    }\n    function at(e, t, i, o = \"\") {\n      if (e.uniqueFeatureID) {\n        const s = nt(e, t, o);\n        if (i.has(s)) return !0;\n        i.add(s);\n      }\n      return !1;\n    }\n    function lt(e, t, i, o, s = !1) {\n      const r = t.sourceCache.transform,\n        n = t.sourceCache.tilesIn(e, t.has3DLayers, s);\n      n.sort(dt);\n      const a = [];\n      for (const e of n) {\n        const n = e.tile.queryRenderedFeatures(t, e, i, o, r, s);\n        Object.keys(n).length && a.push({\n          wrappedTileID: e.tile.tileID.wrapped().key,\n          queryResults: n\n        });\n      }\n      return 0 === a.length ? {} : function (e) {\n        const t = {},\n          i = {};\n        for (const o of e) {\n          const e = o.queryResults,\n            s = o.wrappedTileID,\n            r = i[s] = i[s] || {};\n          for (const i in e) {\n            const o = e[i],\n              s = r[i] = r[i] || {},\n              n = t[i] = t[i] || [];\n            for (const e of o) s[e.featureIndex] || (s[e.featureIndex] = !0, n.push(e));\n          }\n        }\n        return t;\n      }(a);\n    }\n    function ct(e, t, i, o, s) {\n      const r = {},\n        n = o.queryRenderedSymbols(e),\n        a = [];\n      for (const e of Object.keys(n).map(Number)) a.push(s[e]);\n      a.sort(dt);\n      for (const e of a) {\n        const o = e.featureIndex.lookupSymbolFeatures(n[e.bucketInstanceId], e.bucketIndex, e.sourceLayerIndex, t, i);\n        for (const t in o) {\n          const i = r[t] = r[t] || [],\n            s = o[t];\n          s.sort((t, i) => {\n            const o = e.featureSortOrder;\n            if (o) {\n              const e = o.indexOf(t.featureIndex);\n              return o.indexOf(i.featureIndex) - e;\n            }\n            return i.featureIndex - t.featureIndex;\n          });\n          for (const e of s) i.push(e);\n        }\n      }\n      return r;\n    }\n    function ht(e, t) {\n      const i = e.getRenderableIds().map(t => e.getTileByID(t)),\n        o = [],\n        s = {};\n      for (let e = 0; e < i.length; e++) {\n        const r = i[e],\n          n = r.tileID.canonical.key;\n        s[n] || (s[n] = !0, r.querySourceFeatures(o, t));\n      }\n      return o;\n    }\n    function dt(e, t) {\n      const i = e.tileID,\n        o = t.tileID;\n      return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x;\n    }\n    function ut(e, t) {\n      const i = {};\n      if (!t) return i;\n      for (const o of e) {\n        const e = o.layerIds.map(e => t.getLayer(e)).filter(Boolean);\n        if (0 !== e.length) {\n          o.layers = e, o.stateDependentLayerIds && (o.stateDependentLayers = o.stateDependentLayerIds.map(t => e.filter(e => e.id === t)[0]));\n          for (const t of e) i[t.fqid] = o;\n        }\n      }\n      return i;\n    }\n    const _t = 32,\n      pt = 33,\n      ft = new Uint16Array(8184);\n    for (let e = 0; e < 2046; e++) {\n      let t = e + 2,\n        i = 0,\n        o = 0,\n        s = 0,\n        r = 0,\n        n = 0,\n        a = 0;\n      for (1 & t ? s = r = n = _t : i = o = a = _t; (t >>= 1) > 1;) {\n        const e = i + s >> 1,\n          l = o + r >> 1;\n        1 & t ? (s = i, r = o, i = n, o = a) : (i = s, o = r, s = n, r = a), n = e, a = l;\n      }\n      const l = 4 * e;\n      ft[l + 0] = i, ft[l + 1] = o, ft[l + 2] = s, ft[l + 3] = r;\n    }\n    const mt = new Uint16Array(2178),\n      gt = new Uint8Array(1089),\n      vt = new Uint16Array(1089);\n    function yt(e) {\n      return 0 === e ? -.03125 : 32 === e ? .03125 : 0;\n    }\n    const xt = (() => ({\n      type: 2,\n      extent: e.ai,\n      loadGeometry: () => [[new e.P(0, 0), new e.P(e.ai + 1, 0), new e.P(e.ai + 1, e.ai + 1), new e.P(0, e.ai + 1), new e.P(0, 0)]]\n    }))();\n    class bt {\n      constructor(t, i, o, s, r) {\n        this.tileID = t, this.uid = e.aW(), this.uses = 0, this.tileSize = i, this.tileZoom = o, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.isRaster = r, s && s.style && (this._lastUpdatedBrightness = s.style.getBrightness()), this.expiredRequestCount = 0, this.state = \"loading\", s && s.transform && (this.projection = s.transform.projection);\n      }\n      registerFadeDuration(t) {\n        const i = t + this.timeAdded;\n        i < e.q.now() || this.fadeEndTime && i < this.fadeEndTime || (this.fadeEndTime = i);\n      }\n      wasRequested() {\n        return \"errored\" === this.state || \"loaded\" === this.state || \"reloading\" === this.state;\n      }\n      get tileTransform() {\n        return this._tileTransform || (this._tileTransform = e.aR(this.tileID.canonical, this.projection)), this._tileTransform;\n      }\n      loadVectorData(t, i, o) {\n        if (this.unloadVectorData(), this.state = \"loaded\", t) {\n          t.featureIndex && (this.latestFeatureIndex = t.featureIndex, t.rawTileData ? (this.latestRawTileData = t.rawTileData, this.latestFeatureIndex.rawTileData = t.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t.collisionBoxArray, this.buckets = ut(t.buckets, i.style), this.hasSymbolBuckets = !1;\n          for (const t in this.buckets) {\n            const i = this.buckets[t];\n            if (i instanceof e.aY) {\n              if (this.hasSymbolBuckets = !0, !o) break;\n              i.justReloaded = !0;\n            }\n          }\n          if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const t in this.buckets) {\n            const i = this.buckets[t];\n            if (i instanceof e.aY && i.hasRTLText) {\n              this.hasRTLText = !0, e.aZ();\n              break;\n            }\n          }\n          this.queryPadding = 0;\n          for (const e in this.buckets) {\n            const t = this.buckets[e],\n              o = i.style.getOwnLayer(e);\n            if (!o) continue;\n            const s = o.queryRadius(t);\n            this.queryPadding = Math.max(this.queryPadding, s);\n          }\n          t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage), t.lineAtlas && (this.lineAtlas = t.lineAtlas), this._lastUpdatedBrightness = t.brightness;\n        } else this.collisionBoxArray = new e.aX();\n      }\n      unloadVectorData() {\n        if (this.hasData()) {\n          for (const e in this.buckets) this.buckets[e].destroy();\n          this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = \"unloaded\";\n        }\n      }\n      loadModelData(e, t, i) {\n        e && (e.resourceTiming && (this.resourceTiming = e.resourceTiming), this.buckets = Object.assign({}, this.buckets, ut(e.buckets, t.style)), e.featureIndex && (this.latestFeatureIndex = e.featureIndex));\n      }\n      getBucket(e) {\n        return this.buckets[e.fqid];\n      }\n      upload(t) {\n        for (const e in this.buckets) {\n          const i = this.buckets[e];\n          i.uploadPending() && i.upload(t);\n        }\n        const i = t.gl,\n          o = this.imageAtlas;\n        o && !o.uploaded && (this.imageAtlasTexture = new e.T(t, o.image, i.RGBA8, {\n          useMipmap: !!o.patternPositions.size\n        }), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new e.T(t, this.glyphAtlasImage, i.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new e.T(t, this.lineAtlas.image, i.R8), this.lineAtlas.uploaded = !0);\n      }\n      prepare(e, t, i) {\n        if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture, i), !t || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) return;\n        const o = t.style.getBrightness();\n        (this._lastUpdatedBrightness || o) && (this._lastUpdatedBrightness && o && Math.abs(this._lastUpdatedBrightness - o) < .001 || (this.updateBuckets(t, this._lastUpdatedBrightness !== o), this._lastUpdatedBrightness = o));\n      }\n      queryRenderedFeatures(t, i, o, s, r, n) {\n        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData && !this.latestFeatureIndex.is3DTile) return {};\n        const a = function (t, i) {\n          const o = e.ad.mat4.fromScaling([], [.5 * t.width, .5 * -t.height, 1]);\n          return e.ad.mat4.translate(o, o, [1, -1, 0]), e.ad.mat4.multiply(o, o, t.calculateProjMatrix(i.toUnwrapped())), Float32Array.from(o);\n        }(r, this.tileID);\n        return this.latestFeatureIndex.query(t, {\n          tilespaceGeometry: i,\n          pixelPosMatrix: a,\n          transform: s,\n          availableImages: o,\n          tileTransform: this.tileTransform\n        });\n      }\n      querySourceFeatures(t, i) {\n        const o = this.latestFeatureIndex;\n        if (!o || !o.rawTileData) return;\n        const s = o.loadVTLayers(),\n          r = i ? i.sourceLayer : \"\",\n          n = s._geojsonTileLayer || s[r];\n        if (!n) return;\n        const a = e.a_(i && i.filter),\n          {\n            z: l,\n            x: c,\n            y: h\n          } = this.tileID.canonical,\n          d = {\n            z: l,\n            x: c,\n            y: h\n          };\n        for (let i = 0; i < n.length; i++) {\n          const s = n.feature(i);\n          if (a.needGeometry) {\n            const t = e.a$(s, !0);\n            if (!a.filter(new e.aa(this.tileID.overscaledZ), t, this.tileID.canonical)) continue;\n          } else if (!a.filter(new e.aa(this.tileID.overscaledZ), s)) continue;\n          const u = o.getId(s, r),\n            _ = new e.b0(s, l, c, h, u);\n          _.tile = d, t.push(_);\n        }\n      }\n      loaded() {\n        return \"loaded\" === this.state || \"errored\" === this.state;\n      }\n      hasData() {\n        return \"loaded\" === this.state || \"reloading\" === this.state || \"expired\" === this.state;\n      }\n      patternsLoaded() {\n        return !!this.imageAtlas && !!this.imageAtlas.patternPositions.size;\n      }\n      setExpiryData(t) {\n        const i = this.expirationTime;\n        if (t.cacheControl) {\n          const i = e.b1(t.cacheControl);\n          i[\"max-age\"] && (this.expirationTime = Date.now() + 1e3 * i[\"max-age\"]);\n        } else t.expires && (this.expirationTime = new Date(t.expires).getTime());\n        if (this.expirationTime) {\n          const e = Date.now();\n          let t = !1;\n          if (this.expirationTime > e) t = !1;else if (i) {\n            if (this.expirationTime < i) t = !0;else {\n              const o = this.expirationTime - i;\n              o ? this.expirationTime = e + Math.max(o, 3e4) : t = !0;\n            }\n          } else t = !0;\n          t ? (this.expiredRequestCount++, this.state = \"expired\") : this.expiredRequestCount = 0;\n        }\n      }\n      getExpiryTimeout() {\n        if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);\n      }\n      refreshFeatureState(e) {\n        this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) && e && this.updateBuckets(e);\n      }\n      updateBuckets(t, i) {\n        if (!this.latestFeatureIndex) return;\n        if (!t.style) return;\n        const o = this.latestFeatureIndex.loadVTLayers(),\n          s = t.style.listImages(),\n          r = t.style.getBrightness();\n        for (const n in this.buckets) {\n          if (!t.style.hasLayer(n)) continue;\n          const a = this.buckets[n],\n            l = a.layers[0],\n            c = l.sourceLayer || \"_geojsonTileLayer\",\n            h = o[c],\n            d = t.style.getLayerSourceCache(l);\n          let u = {};\n          d && (u = d._state.getState(c, void 0));\n          const _ = this.imageAtlas ? Object.fromEntries(this.imageAtlas.patternPositions) : {},\n            p = Object.keys(u).length > 0 && !i;\n          p && !a.stateDependentLayers.length && !i || a.update(u, h, s, _, p ? a.stateDependentLayers : a.layers, i, r), (a instanceof e.b2 || a instanceof e.b3) && t._terrain && t._terrain.enabled && d && a.uploadPending() && t._terrain._clearRenderCacheForTile(d.id, this.tileID);\n          const f = t && t.style && t.style.getOwnLayer(n);\n          f && (this.queryPadding = Math.max(this.queryPadding, f.queryRadius(a)));\n        }\n      }\n      holdingForFade() {\n        return void 0 !== this.symbolFadeHoldUntil;\n      }\n      symbolFadeFinished() {\n        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < e.q.now();\n      }\n      clearFadeHold() {\n        this.symbolFadeHoldUntil = void 0;\n      }\n      setHoldDuration(t) {\n        this.symbolFadeHoldUntil = e.q.now() + t;\n      }\n      setTexture(t, i) {\n        const o = i.context,\n          s = o.gl;\n        this.texture = this.texture || i.getTileTexture(t.width), this.texture && this.texture instanceof e.T ? this.texture.update(t) : (this.texture = new e.T(o, t, s.RGBA8, {\n          useMipmap: !0\n        }), this.texture.bind(s.LINEAR, s.CLAMP_TO_EDGE));\n      }\n      setDependencies(e, t) {\n        const i = {};\n        for (const e of t) i[e] = !0;\n        this.dependencies[e] = i;\n      }\n      hasDependency(e, t) {\n        for (const i of e) {\n          const e = this.dependencies[i];\n          if (e) for (const i of t) if (e[i]) return !0;\n        }\n        return !1;\n      }\n      clearQueryDebugViz() {}\n      _makeDebugTileBoundsBuffers(t, i) {\n        if (!i || \"mercator\" === i.name || this._tileDebugBuffer) return;\n        const o = e.b4(xt, this.tileID.canonical, this.tileTransform)[0],\n          s = new e.b5(),\n          r = new e.b6();\n        for (let e = 0; e < o.length; e++) {\n          const {\n            x: t,\n            y: i\n          } = o[e];\n          s.emplaceBack(t, i), r.emplaceBack(e);\n        }\n        r.emplaceBack(0), this._tileDebugIndexBuffer = t.createIndexBuffer(r), this._tileDebugBuffer = t.createVertexBuffer(s, e.b7.members), this._tileDebugSegments = e.b8.simpleSegment(0, 0, s.length, r.length);\n      }\n      _makeTileBoundsBuffers(t, i) {\n        if (this._tileBoundsBuffer || !i || \"mercator\" === i.name) return;\n        const o = e.b4(xt, this.tileID.canonical, this.tileTransform)[0];\n        let s, r;\n        if (this.isRaster) {\n          const t = function (t, i) {\n            const o = e.aR(t, i),\n              s = Math.pow(2, t.z);\n            for (let r = 0; r < pt; r++) for (let n = 0; n < pt; n++) {\n              const a = e.aS((t.x + (n + yt(n)) / _t) / s),\n                l = e.aT((t.y + (r + yt(r)) / _t) / s),\n                c = i.project(a, l),\n                h = r * pt + n;\n              mt[2 * h + 0] = Math.round((c.x * o.scale - o.x) * e.ai), mt[2 * h + 1] = Math.round((c.y * o.scale - o.y) * e.ai);\n            }\n            gt.fill(0), vt.fill(0);\n            for (let e = 2045; e >= 0; e--) {\n              const t = 4 * e,\n                i = ft[t + 0],\n                o = ft[t + 1],\n                s = ft[t + 2],\n                r = ft[t + 3],\n                n = i + s >> 1,\n                a = o + r >> 1,\n                l = n + a - o,\n                c = a + i - n,\n                h = o * pt + i,\n                d = r * pt + s,\n                u = a * pt + n,\n                _ = Math.hypot((mt[2 * h + 0] + mt[2 * d + 0]) / 2 - mt[2 * u + 0], (mt[2 * h + 1] + mt[2 * d + 1]) / 2 - mt[2 * u + 1]) >= 16;\n              gt[u] = gt[u] || (_ ? 1 : 0), e < 1022 && (gt[u] = gt[u] || gt[(o + c >> 1) * pt + (i + l >> 1)] || gt[(r + c >> 1) * pt + (s + l >> 1)]);\n            }\n            const r = new e.aU(),\n              n = new e.aV();\n            let a = 0;\n            function l(t, i) {\n              const o = i * pt + t;\n              return 0 === vt[o] && (r.emplaceBack(mt[2 * o + 0], mt[2 * o + 1], t * e.ai / _t, i * e.ai / _t), vt[o] = ++a), vt[o] - 1;\n            }\n            function c(e, t, i, o, s, r) {\n              const a = e + i >> 1,\n                h = t + o >> 1;\n              if (Math.abs(e - s) + Math.abs(t - r) > 1 && gt[h * pt + a]) c(s, r, e, t, a, h), c(i, o, s, r, a, h);else {\n                const a = l(e, t),\n                  c = l(i, o),\n                  h = l(s, r);\n                n.emplaceBack(a, c, h);\n              }\n            }\n            return c(0, 0, _t, _t, _t, 0), c(_t, _t, 0, 0, 0, _t), {\n              vertices: r,\n              indices: n\n            };\n          }(this.tileID.canonical, i);\n          s = t.vertices, r = t.indices;\n        } else {\n          s = new e.aU(), r = new e.aV();\n          for (const {\n            x: e,\n            y: t\n          } of o) s.emplaceBack(e, t, 0, 0);\n          const t = e.b9(s.int16, void 0, 4);\n          for (let e = 0; e < t.length; e += 3) r.emplaceBack(t[e], t[e + 1], t[e + 2]);\n        }\n        this._tileBoundsBuffer = t.createVertexBuffer(s, e.ba.members), this._tileBoundsIndexBuffer = t.createIndexBuffer(r), this._tileBoundsSegments = e.b8.simpleSegment(0, 0, s.length, r.length);\n      }\n      _makeGlobeTileDebugBuffers(t, i) {\n        const o = i.projection;\n        if (!o || \"globe\" !== o.name || i.freezeTileCoverage) return;\n        const s = this.tileID.canonical,\n          r = e.bb(s, i),\n          n = e.bc(r),\n          a = e.ag(i.zoom);\n        let l;\n        a > 0 && (l = e.ad.mat4.invert(new Float64Array(16), i.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t, s, i, n, l, a), this._makeGlobeTileDebugTextBuffer(t, s, i, n, l, a);\n      }\n      _globePoint(t, i, o, s, r, n, a) {\n        let l = e.bd(t, i, o);\n        if (n) {\n          const r = 1 << o.z,\n            c = e.av(s.center.lng),\n            h = e.aC(s.center.lat),\n            d = (o.x + .5) / r - c;\n          let u = 0;\n          d > .5 ? u = -1 : d < -.5 && (u = 1);\n          let _ = (t / e.ai + o.x) / r + u,\n            p = (i / e.ai + o.y) / r;\n          _ = (_ - c) * s._pixelsPerMercatorPixel + c, p = (p - h) * s._pixelsPerMercatorPixel + h;\n          const f = [_ * s.worldSize, p * s.worldSize, 0];\n          e.ad.vec3.transformMat4(f, f, n), l = e.be(l, f, a);\n        }\n        return e.ad.vec3.transformMat4(l, l, r);\n      }\n      _makeGlobeTileDebugBorderBuffer(t, i, o, s, r, n) {\n        const a = new e.b5(),\n          l = new e.b6(),\n          c = new e.bf(),\n          h = (e, t, h, d, u) => {\n            const _ = (h - e) / (u - 1),\n              p = (d - t) / (u - 1),\n              f = a.length;\n            for (let h = 0; h < u; h++) {\n              const d = e + h * _,\n                u = t + h * p;\n              a.emplaceBack(d, u);\n              const m = this._globePoint(d, u, i, o, s, r, n);\n              c.emplaceBack(m[0], m[1], m[2]), l.emplaceBack(f + h);\n            }\n          },\n          d = e.ai;\n        h(0, 0, d, 0, 16), h(d, 0, d, d, 16), h(d, d, 0, d, 16), h(0, d, 0, 0, 16), this._tileDebugIndexBuffer = t.createIndexBuffer(l), this._tileDebugBuffer = t.createVertexBuffer(a, e.b7.members), this._globeTileDebugBorderBuffer = t.createVertexBuffer(c, e.bg.members), this._tileDebugSegments = e.b8.simpleSegment(0, 0, a.length, l.length);\n      }\n      _makeGlobeTileDebugTextBuffer(t, i, o, s, r, n) {\n        const a = e.ai / 4,\n          l = new e.b5(),\n          c = new e.aV(),\n          h = new e.bf(),\n          d = 25;\n        c.reserve(32), l.reserve(d), h.reserve(d);\n        const u = (e, t) => d * e + t;\n        for (let e = 0; e < d; e++) {\n          const t = e * a;\n          for (let e = 0; e < d; e++) {\n            const c = e * a;\n            l.emplaceBack(c, t);\n            const d = this._globePoint(c, t, i, o, s, r, n);\n            h.emplaceBack(d[0], d[1], d[2]);\n          }\n        }\n        for (let e = 0; e < 4; e++) for (let t = 0; t < 4; t++) {\n          const i = u(e, t),\n            o = u(e, t + 1),\n            s = u(e + 1, t),\n            r = u(e + 1, t + 1);\n          c.emplaceBack(i, o, s), c.emplaceBack(s, o, r);\n        }\n        this._tileDebugTextIndexBuffer = t.createIndexBuffer(c), this._tileDebugTextBuffer = t.createVertexBuffer(l, e.b7.members), this._globeTileDebugTextBuffer = t.createVertexBuffer(h, e.bg.members), this._tileDebugTextSegments = e.b8.simpleSegment(0, 0, d, 32);\n      }\n      destroy(t = !1) {\n        for (const e in this.buckets) this.buckets[e].destroy();\n        this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !t && this.texture && this.texture instanceof e.T && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = \"unloaded\";\n      }\n    }\n    e.bh.setPbf(e.bi);\n    class wt extends bt {\n      constructor(e, t, i, o, s) {\n        super(e, t, i, o, s), this._workQueue = [], this._fetchQueue = [], this._isHeaderLoaded = !1;\n      }\n      getLayers() {\n        return this._mrt ? Object.values(this._mrt.layers) : [];\n      }\n      getLayer(e) {\n        return this._mrt && this._mrt.getLayer(e);\n      }\n      setTexture(t, i) {\n        const o = i.context,\n          s = o.gl;\n        this.texture = this.texture || i.getTileTexture(t.width), this.texture && this.texture instanceof e.T ? this.texture.update(t, {\n          premultiply: !1\n        }) : this.texture = new e.T(o, t, s.RGBA8, {\n          premultiply: !1\n        });\n      }\n      flushQueues() {\n        for (; this._workQueue.length;) this._workQueue.pop()();\n        for (; this._fetchQueue.length;) this._fetchQueue.pop()();\n      }\n      fetchHeader(t = 16384, i) {\n        const o = this._mrt = new e.bh(30),\n          s = Object.assign({}, this.requestParams, {\n            headers: {\n              Range: \"bytes=0-\" + (t - 1)\n            }\n          });\n        return this.entireBuffer = null, this.request = e.bj(s, (e, s, r, n) => {\n          if (e) i(e);else try {\n            const e = o.getHeaderLength(s);\n            if (e > t) return void (this.request = this.fetchHeader(e, i));\n            o.parseHeader(s), this._isHeaderLoaded = !0;\n            let a = 0;\n            for (const e of Object.values(o.layers)) a = Math.max(a, e.dataIndex[e.dataIndex.length - 1].lastByte);\n            s.byteLength >= a && (this.entireBuffer = s), i(null, this.entireBuffer || s, r, n);\n          } catch (e) {\n            i(e);\n          }\n        }), this.request;\n      }\n      fetchBand(t, i, o) {\n        const s = this._mrt;\n        if (!this._isHeaderLoaded || !s) return void o(new Error(\"Tile header is not ready\"));\n        const r = this.actor;\n        if (!r) return void o(new Error(\"Can't fetch tile band without an actor\"));\n        let n;\n        const a = (e, s) => {\n            n.complete(e, s), e ? o(e) : (this.updateTextureDescriptor(t, i), o(null, this.textureDescriptor && this.textureDescriptor.img));\n          },\n          l = (e, t) => {\n            if (e) return o(e);\n            const i = r.send(\"decodeRasterArray\", {\n              type: \"raster-array\",\n              source: this.source,\n              scope: this.scope,\n              tileID: this.tileID,\n              uid: this.uid,\n              buffer: t,\n              task: n\n            }, a, void 0, !0);\n            this._workQueue.push(() => {\n              i && i.cancel(), n.cancel();\n            });\n          },\n          c = s.getLayer(t);\n        if (!c) return void o(new Error(`Unknown sourceLayer \"${t}\"`));\n        if (c.hasDataForBand(i)) return this.updateTextureDescriptor(t, i), void o(null, this.textureDescriptor ? this.textureDescriptor.img : null);\n        const h = c.getDataRange([i]);\n        if (n = s.createDecodingTask(h), !n || n.tasks.length) {\n          if (this.flushQueues(), this.entireBuffer) l(null, this.entireBuffer.slice(h.firstByte, h.lastByte + 1));else {\n            const t = Object.assign({}, this.requestParams, {\n                headers: {\n                  Range: `bytes=${h.firstByte}-${h.lastByte}`\n                }\n              }),\n              i = e.bj(t, l);\n            this._fetchQueue.push(() => {\n              i.cancel(), n.cancel();\n            });\n          }\n        } else o(null);\n      }\n      updateNeeded(e, t) {\n        return (!this.textureDescriptor || this.textureDescriptor.band !== t || this.textureDescriptor.layer !== e) && \"errored\" !== this.state;\n      }\n      updateTextureDescriptor(t, i) {\n        if (!this._mrt) return;\n        const o = this._mrt.getLayer(t);\n        if (!o || !o.hasBand(i) || !o.hasDataForBand(i)) return;\n        const {\n            bytes: s,\n            tileSize: r,\n            buffer: n,\n            offset: a,\n            scale: l\n          } = o.getBandView(i),\n          c = r + 2 * n,\n          h = new e.r({\n            width: c,\n            height: c\n          }, s),\n          d = this.texture;\n        d && d instanceof e.T && d.update(h, {\n          premultiply: !1\n        }), this.textureDescriptor = {\n          layer: t,\n          band: i,\n          img: h,\n          buffer: n,\n          offset: a,\n          tileSize: r,\n          format: o.pixelFormat,\n          mix: [l, 256 * l, 65536 * l, 16777216 * l]\n        };\n      }\n    }\n    class Tt {\n      constructor(e, t) {\n        this.max = e, this.onRemove = t, this.reset();\n      }\n      reset() {\n        for (const e in this.data) for (const t of this.data[e]) t.timeout && clearTimeout(t.timeout), this.onRemove(t.value);\n        return this.data = {}, this.order = [], this;\n      }\n      add(e, t, i) {\n        const o = e.wrapped().key;\n        void 0 === this.data[o] && (this.data[o] = []);\n        const s = {\n          value: t,\n          timeout: void 0\n        };\n        if (void 0 !== i && (s.timeout = setTimeout(() => {\n          this.remove(e, s);\n        }, i)), this.data[o].push(s), this.order.push(o), this.order.length > this.max) {\n          const e = this._getAndRemoveByKey(this.order[0]);\n          e && this.onRemove(e);\n        }\n        return this;\n      }\n      has(e) {\n        return e.wrapped().key in this.data;\n      }\n      getAndRemove(e) {\n        return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null;\n      }\n      _getAndRemoveByKey(e) {\n        const t = this.data[e].shift();\n        return t.timeout && clearTimeout(t.timeout), 0 === this.data[e].length && delete this.data[e], this.order.splice(this.order.indexOf(e), 1), t.value;\n      }\n      getByKey(e) {\n        const t = this.data[e];\n        return t ? t[0].value : null;\n      }\n      get(e) {\n        return this.has(e) ? this.data[e.wrapped().key][0].value : null;\n      }\n      remove(e, t) {\n        if (!this.has(e)) return this;\n        const i = e.wrapped().key,\n          o = void 0 === t ? 0 : this.data[i].indexOf(t),\n          s = this.data[i][o];\n        return this.data[i].splice(o, 1), s.timeout && clearTimeout(s.timeout), 0 === this.data[i].length && delete this.data[i], this.onRemove(s.value), this.order.splice(this.order.indexOf(i), 1), this;\n      }\n      setMaxSize(e) {\n        for (this.max = e; this.order.length > this.max;) {\n          const e = this._getAndRemoveByKey(this.order[0]);\n          e && this.onRemove(e);\n        }\n        return this;\n      }\n      filter(e) {\n        const t = [];\n        for (const i in this.data) for (const o of this.data[i]) e(o.value) || t.push(o);\n        for (const e of t) this.remove(e.value.tileID, e);\n      }\n    }\n    class Et {\n      constructor() {\n        this.state = {}, this.stateChanges = {}, this.deletedStates = {};\n      }\n      updateState(t, i, o) {\n        const s = String(i);\n        if (this.stateChanges[t] = this.stateChanges[t] || {}, this.stateChanges[t][s] = this.stateChanges[t][s] || {}, e.l(this.stateChanges[t][s], o), null === this.deletedStates[t]) {\n          this.deletedStates[t] = {};\n          for (const e in this.state[t]) e !== s && (this.deletedStates[t][e] = null);\n        } else if (this.deletedStates[t] && null === this.deletedStates[t][s]) {\n          this.deletedStates[t][s] = {};\n          for (const e in this.state[t][s]) o[e] || (this.deletedStates[t][s][e] = null);\n        } else for (const e in o) this.deletedStates[t] && this.deletedStates[t][s] && null === this.deletedStates[t][s][e] && delete this.deletedStates[t][s][e];\n      }\n      removeFeatureState(e, t, i) {\n        if (null === this.deletedStates[e]) return;\n        const o = String(t);\n        if (this.deletedStates[e] = this.deletedStates[e] || {}, i && void 0 !== t) null !== this.deletedStates[e][o] && (this.deletedStates[e][o] = this.deletedStates[e][o] || {}, this.deletedStates[e][o][i] = null);else if (void 0 !== t) {\n          if (this.stateChanges[e] && this.stateChanges[e][o]) for (i in this.deletedStates[e][o] = {}, this.stateChanges[e][o]) this.deletedStates[e][o][i] = null;else this.deletedStates[e][o] = null;\n        } else this.deletedStates[e] = null;\n      }\n      getState(t, i) {\n        const o = this.state[t] || {},\n          s = this.stateChanges[t] || {},\n          r = this.deletedStates[t];\n        if (null === r) return {};\n        if (void 0 !== i) {\n          const t = String(i),\n            n = e.l({}, o[t], s[t]);\n          if (r) {\n            const e = r[i];\n            if (null === e) return {};\n            for (const t in e) delete n[t];\n          }\n          return n;\n        }\n        const n = e.l({}, o, s);\n        if (r) for (const e in r) delete n[e];\n        return n;\n      }\n      initializeTileState(e, t) {\n        e.refreshFeatureState(t);\n      }\n      coalesceChanges(t, i) {\n        const o = {};\n        for (const t in this.stateChanges) {\n          this.state[t] = this.state[t] || {};\n          const i = {};\n          for (const o in this.stateChanges[t]) this.state[t][o] || (this.state[t][o] = {}), e.l(this.state[t][o], this.stateChanges[t][o]), i[o] = this.state[t][o];\n          o[t] = i;\n        }\n        for (const t in this.deletedStates) {\n          this.state[t] = this.state[t] || {};\n          const i = {};\n          if (null === this.deletedStates[t]) for (const e in this.state[t]) i[e] = {}, this.state[t][e] = {};else for (const e in this.deletedStates[t]) {\n            if (null === this.deletedStates[t][e]) this.state[t][e] = {};else if (this.state[t][e]) for (const i of Object.keys(this.deletedStates[t][e])) delete this.state[t][e][i];\n            i[e] = this.state[t][e];\n          }\n          o[t] = o[t] || {}, e.l(o[t], i);\n        }\n        if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(o).length) for (const e in t) t[e].refreshFeatureState(i);\n      }\n    }\n    class St extends e.E {\n      constructor(e, t, i) {\n        super(), this.id = e, this._onlySymbols = i, t.on(\"data\", e => {\n          \"source\" === e.dataType && \"metadata\" === e.sourceDataType && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && \"source\" === e.dataType && \"content\" === e.sourceDataType && (this.reload(), this.transform && this.update(this.transform));\n        }), t.on(\"error\", () => {\n          this._sourceErrored = !0;\n        }), this._source = t, this._tiles = {}, this._cache = new Tt(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = t.minTileCacheSize, this._maxTileCacheSize = t.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = !1, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new Et(), this._isRaster = \"raster\" === this._source.type || \"raster-dem\" === this._source.type || \"raster-array\" === this._source.type || \"custom\" === this._source.type && \"raster\" === this._source._dataType;\n      }\n      onAdd(e) {\n        this.map = e, this._minTileCacheSize = void 0 === this._minTileCacheSize && e ? e._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && e ? e._maxTileCacheSize : this._maxTileCacheSize;\n      }\n      loaded() {\n        if (this._sourceErrored) return !0;\n        if (!this._sourceLoaded) return !1;\n        if (!this._source.loaded()) return !1;\n        for (const e in this._tiles) if (!this._tiles[e].loaded()) return !1;\n        return !0;\n      }\n      getSource() {\n        return this._source;\n      }\n      pause() {\n        this._paused = !0;\n      }\n      resume() {\n        if (!this._paused) return;\n        const e = this._shouldReloadOnResume;\n        this._paused = !1, this._shouldReloadOnResume = !1, e && this.reload(), this.transform && this.update(this.transform);\n      }\n      _loadTile(e, t) {\n        return e.isSymbolTile = this._onlySymbols, e.isExtraShadowCaster = this._shadowCasterTiles[e.tileID.key], this._source.loadTile(e, t);\n      }\n      _unloadTile(e) {\n        if (this._source.unloadTile) return this._source.unloadTile(e);\n      }\n      _abortTile(e) {\n        if (this._source.abortTile) return this._source.abortTile(e);\n      }\n      serialize() {\n        return this._source.serialize();\n      }\n      prepare(e) {\n        this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);\n        for (const t in this._tiles) {\n          const i = this._tiles[t];\n          i.upload(e), i.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);\n        }\n      }\n      getIds() {\n        return Object.values(this._tiles).map(e => e.tileID).sort(Ct).map(e => e.key);\n      }\n      getRenderableIds(t, i) {\n        const o = [];\n        for (const e in this._tiles) this._isIdRenderable(+e, t, i) && o.push(this._tiles[e]);\n        return t ? o.sort((t, i) => {\n          const o = t.tileID,\n            s = i.tileID,\n            r = new e.P(o.canonical.x, o.canonical.y)._rotate(this.transform.angle),\n            n = new e.P(s.canonical.x, s.canonical.y)._rotate(this.transform.angle);\n          return o.overscaledZ - s.overscaledZ || n.y - r.y || n.x - r.x;\n        }).map(e => e.tileID.key) : o.map(e => e.tileID).sort(Ct).map(e => e.key);\n      }\n      hasRenderableParent(e) {\n        const t = this.findLoadedParent(e, 0);\n        return !!t && this._isIdRenderable(t.tileID.key);\n      }\n      _isIdRenderable(e, t, i) {\n        return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (t || !this._tiles[e].holdingForFade()) && (i || !this._shadowCasterTiles[e]);\n      }\n      reload() {\n        if (this._paused) this._shouldReloadOnResume = !0;else {\n          this._cache.reset();\n          for (const e in this._tiles) \"errored\" !== this._tiles[e].state && this._reloadTile(+e, \"reloading\");\n        }\n      }\n      _reloadTile(e, t) {\n        const i = this._tiles[e];\n        i && (\"loading\" !== i.state && (i.state = t), this._loadTile(i, this._tileLoaded.bind(this, i, e, t)));\n      }\n      _tileLoaded(t, i, o, s) {\n        if (s) {\n          if (t.state = \"errored\", 404 !== s.status) this._source.fire(new e.z(s, {\n            tile: t\n          }));else {\n            if (this._source.fire(new e.A(\"data\", {\n              dataType: \"source\",\n              sourceDataType: \"error\",\n              sourceId: this._source.id,\n              tile: t\n            })), !(t.tileID.key in this._loadedParentTiles)) return;\n            if (\"raster-dem\" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {\n              const e = this.map.painter.terrain;\n              this.update(this.transform, e.getScaledDemTileSize(), !0), e.resetTileLookupCache(this.id);\n            } else this.update(this.transform);\n          }\n        } else t.timeAdded = e.q.now(), \"expired\" === o && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(i, t), \"raster-dem\" === this._source.type && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), this._source.fire(new e.A(\"data\", {\n          dataType: \"source\",\n          tile: t,\n          coord: t.tileID,\n          sourceCacheId: this.id\n        }));\n      }\n      _backfillDEM(e) {\n        const t = this.getRenderableIds();\n        for (let o = 0; o < t.length; o++) {\n          const s = t[o];\n          if (e.neighboringTiles && e.neighboringTiles[s]) {\n            const t = this.getTileByID(s);\n            i(e, t), i(t, e);\n          }\n        }\n        function i(e, t) {\n          if (!e.dem || e.dem.borderReady) return;\n          e.needsHillshadePrepare = !0, e.needsDEMTextureUpload = !0;\n          let i = t.tileID.canonical.x - e.tileID.canonical.x;\n          const o = t.tileID.canonical.y - e.tileID.canonical.y,\n            s = Math.pow(2, e.tileID.canonical.z),\n            r = t.tileID.key;\n          0 === i && 0 === o || Math.abs(o) > 1 || (Math.abs(i) > 1 && (1 === Math.abs(i + s) ? i += s : 1 === Math.abs(i - s) && (i -= s)), t.dem && e.dem && (e.dem.backfillBorder(t.dem, i, o), e.neighboringTiles && e.neighboringTiles[r] && (e.neighboringTiles[r].backfilled = !0)));\n        }\n      }\n      getTile(e) {\n        return this.getTileByID(e.key);\n      }\n      getTileByID(e) {\n        return this._tiles[e];\n      }\n      _retainLoadedChildren(e, t, i, o) {\n        for (const s in this._tiles) {\n          let r = this._tiles[s];\n          if (o[s] || !r.hasData() || r.tileID.overscaledZ <= t || r.tileID.overscaledZ > i) continue;\n          let n = r.tileID;\n          for (; r && r.tileID.overscaledZ > t + 1;) {\n            const e = r.tileID.scaledTo(r.tileID.overscaledZ - 1);\n            r = this._tiles[e.key], r && r.hasData() && (n = e);\n          }\n          let a = n;\n          for (; a.overscaledZ > t;) if (a = a.scaledTo(a.overscaledZ - 1), e[a.key]) {\n            o[n.key] = n;\n            break;\n          }\n        }\n      }\n      findLoadedParent(e, t) {\n        if (e.key in this._loadedParentTiles) {\n          const i = this._loadedParentTiles[e.key];\n          return i && i.tileID.overscaledZ >= t ? i : null;\n        }\n        for (let i = e.overscaledZ - 1; i >= t; i--) {\n          const t = e.scaledTo(i),\n            o = this._getLoadedTile(t);\n          if (o) return o;\n        }\n      }\n      _getLoadedTile(e) {\n        const t = this._tiles[e.key];\n        return t && t.hasData() ? t : this._cache.getByKey(this._source.reparseOverscaled ? e.wrapped().key : e.canonical.key);\n      }\n      updateCacheSize(e, t) {\n        t = t || this._source.tileSize;\n        const i = Math.ceil(e.width / t) + 1,\n          o = Math.ceil(e.height / t) + 1,\n          s = Math.floor(i * o * 5),\n          r = \"number\" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, s) : s,\n          n = \"number\" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, r) : r;\n        this._cache.setMaxSize(n);\n      }\n      handleWrapJump(e) {\n        const t = Math.round((e - (void 0 === this._prevLng ? e : this._prevLng)) / 360);\n        if (this._prevLng = e, t) {\n          const e = {};\n          for (const i in this._tiles) {\n            const o = this._tiles[i];\n            o.tileID = o.tileID.unwrapTo(o.tileID.wrap + t), e[o.tileID.key] = o;\n          }\n          this._tiles = e;\n          for (const e in this._timers) clearTimeout(this._timers[e]), delete this._timers[e];\n          for (const e in this._tiles) this._setTileReloadTimer(+e, this._tiles[e]);\n        }\n      }\n      update(t, i, o, s) {\n        if (this.transform = t, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;\n        if (this.usedForTerrain && !o) return;\n        this.updateCacheSize(t, i), \"globe\" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {};\n        const r = \"batched-model\" === this._source.type;\n        let n,\n          a = this._source.maxzoom;\n        const l = this.map && this.map.painter ? this.map.painter._terrain : null;\n        if (l && l.sourceCache === this && l.attenuationRange()) {\n          const e = l.attenuationRange()[0],\n            t = Math.floor(e) - Math.log2(l.getDemUpscale());\n          a > t && (a = t);\n        }\n        if (this.used || this.usedForTerrain) {\n          if (this._source.tileID) n = t.getVisibleUnwrappedCoordinates(this._source.tileID).map(t => new e.aH(t.canonical.z, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y));else if (0 !== this.tileCoverLift) {\n            const s = t.clone();\n            s.tileCoverLift = this.tileCoverLift, n = s.coveringTiles({\n              tileSize: i || this._source.tileSize,\n              minzoom: this._source.minzoom,\n              maxzoom: a,\n              roundZoom: this._source.roundZoom && !o,\n              reparseOverscaled: this._source.reparseOverscaled,\n              isTerrainDEM: this.usedForTerrain,\n              calculateQuadrantVisibility: r\n            }), this._source.minzoom <= 1 && \"globe\" === t.projection.name && (n.push(new e.aH(1, 0, 1, 0, 0)), n.push(new e.aH(1, 0, 1, 1, 0)), n.push(new e.aH(1, 0, 1, 0, 1)), n.push(new e.aH(1, 0, 1, 1, 1)));\n          } else if (n = t.coveringTiles({\n            tileSize: i || this._source.tileSize,\n            minzoom: this._source.minzoom,\n            maxzoom: a,\n            roundZoom: this._source.roundZoom && !o,\n            reparseOverscaled: this._source.reparseOverscaled,\n            isTerrainDEM: this.usedForTerrain,\n            calculateQuadrantVisibility: r\n          }), this._source.hasTile) {\n            const e = this._source.hasTile.bind(this._source);\n            n = n.filter(t => e(t));\n          }\n        } else n = [];\n        if (n.length > 0 && this.castsShadows && s && \"globe\" !== this.transform.projection.name && !this.usedForTerrain && !It(this._source.type)) {\n          const e = t.coveringZoomLevel({\n              tileSize: i || this._source.tileSize,\n              roundZoom: this._source.roundZoom && !o\n            }),\n            a = Math.min(e, this._source.maxzoom);\n          if (r) {\n            const e = t.extendTileCover(n, a);\n            for (const t of e) n.push(t);\n          } else {\n            const e = t.extendTileCover(n, a, s);\n            for (const t of e) this._shadowCasterTiles[t.key] = !0, n.push(t);\n          }\n        }\n        const c = this._updateRetainedTiles(n);\n        if (It(this._source.type) && 0 !== n.length) {\n          const t = {},\n            i = {},\n            o = Object.keys(c);\n          for (const s of o) {\n            const o = c[s],\n              r = this._tiles[s];\n            if (!r || r.fadeEndTime && r.fadeEndTime <= e.q.now()) continue;\n            const n = this.findLoadedParent(o, Math.max(o.overscaledZ - St.maxOverzooming, this._source.minzoom));\n            n && (this._addTile(n.tileID), t[n.tileID.key] = n.tileID), i[s] = o;\n          }\n          const s = n[n.length - 1].overscaledZ;\n          for (const e in this._tiles) {\n            const t = this._tiles[e];\n            if (c[e] || !t.hasData()) continue;\n            let o = t.tileID;\n            for (; o.overscaledZ > s;) {\n              o = o.scaledTo(o.overscaledZ - 1);\n              const s = this._tiles[o.key];\n              if (s && s.hasData() && i[o.key]) {\n                c[e] = t.tileID;\n                break;\n              }\n            }\n          }\n          for (const e in t) c[e] || (this._coveredTiles[e] = !0, c[e] = t[e]);\n        }\n        for (const e in c) this._tiles[e].clearFadeHold();\n        const h = e.bk(this._tiles, c);\n        for (const e of h) {\n          const t = this._tiles[e];\n          t.hasSymbolBuckets && !t.holdingForFade() ? t.setHoldDuration(this.map._fadeDuration) : t.hasSymbolBuckets && !t.symbolFadeFinished() || this._removeTile(+e);\n        }\n        this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();\n      }\n      releaseSymbolFadeTiles() {\n        for (const e in this._tiles) this._tiles[e].holdingForFade() && this._removeTile(+e);\n      }\n      _updateRetainedTiles(e) {\n        const t = {};\n        if (0 === e.length) return t;\n        const i = {},\n          o = e.reduce((e, t) => Math.min(e, t.overscaledZ), 1 / 0),\n          s = e[0].overscaledZ,\n          r = Math.max(s - St.maxOverzooming, this._source.minzoom),\n          n = Math.max(s + St.maxUnderzooming, this._source.minzoom),\n          a = {};\n        for (const i of e) {\n          const e = this._addTile(i);\n          t[i.key] = i, e.hasData() || o < this._source.maxzoom && (a[i.key] = i);\n        }\n        this._retainLoadedChildren(a, o, n, t);\n        for (const o of e) {\n          let e = this._tiles[o.key];\n          if (e.hasData()) continue;\n          if (o.canonical.z >= this._source.maxzoom) {\n            const e = o.children(this._source.maxzoom)[0],\n              i = this.getTile(e);\n            if (i && i.hasData()) {\n              t[e.key] = e;\n              continue;\n            }\n          } else {\n            const e = o.children(this._source.maxzoom);\n            if (t[e[0].key] && t[e[1].key] && t[e[2].key] && t[e[3].key]) continue;\n          }\n          let s = e.wasRequested();\n          for (let n = o.overscaledZ - 1; n >= r; --n) {\n            const r = o.scaledTo(n);\n            if (i[r.key]) break;\n            if (i[r.key] = !0, e = this.getTile(r), !e && s && (e = this._addTile(r)), e && (t[r.key] = r, s = e.wasRequested(), e.hasData())) break;\n          }\n        }\n        return t;\n      }\n      _updateLoadedParentTileCache() {\n        this._loadedParentTiles = {};\n        for (const e in this._tiles) {\n          const t = [];\n          let i,\n            o = this._tiles[e].tileID;\n          for (; o.overscaledZ > 0;) {\n            if (o.key in this._loadedParentTiles) {\n              i = this._loadedParentTiles[o.key];\n              break;\n            }\n            t.push(o.key);\n            const e = o.scaledTo(o.overscaledZ - 1);\n            if (i = this._getLoadedTile(e), i) break;\n            o = e;\n          }\n          for (const e of t) this._loadedParentTiles[e] = i;\n        }\n      }\n      _addTile(t) {\n        let i = this._tiles[t.key];\n        if (i) return !0 !== i.isExtraShadowCaster || !!this._shadowCasterTiles[t.key] || this._reloadTile(t.key, \"reloading\"), i;\n        i = this._cache.getAndRemove(t), i && (this._setTileReloadTimer(t.key, i), i.tileID = t, this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]), delete this._cacheTimers[t.key], this._setTileReloadTimer(t.key, i)));\n        const o = Boolean(i);\n        if (!o) {\n          const e = this.map ? this.map.painter : null,\n            o = this._source.tileSize * t.overscaleFactor();\n          i = \"raster-array\" === this._source.type ? new wt(t, o, this.transform.tileZoom, e, this._isRaster) : new bt(t, o, this.transform.tileZoom, e, this._isRaster), this._loadTile(i, this._tileLoaded.bind(this, i, t.key, i.state));\n        }\n        return i ? (i.uses++, this._tiles[t.key] = i, o || this._source.fire(new e.A(\"dataloading\", {\n          tile: i,\n          coord: i.tileID,\n          dataType: \"source\"\n        })), i) : null;\n      }\n      _setTileReloadTimer(e, t) {\n        e in this._timers && (clearTimeout(this._timers[e]), delete this._timers[e]);\n        const i = t.getExpiryTimeout();\n        i && (this._timers[e] = setTimeout(() => {\n          this._reloadTile(e, \"expired\"), delete this._timers[e];\n        }, i));\n      }\n      _removeTile(e) {\n        const t = this._tiles[e];\n        t && (t.uses--, delete this._tiles[e], this._timers[e] && (clearTimeout(this._timers[e]), delete this._timers[e]), t.uses > 0 || (t.hasData() && \"reloading\" !== t.state || \"empty\" === t.state ? this._cache.add(t.tileID, t, t.getExpiryTimeout()) : (t.aborted = !0, this._abortTile(t), this._unloadTile(t))));\n      }\n      clearTiles() {\n        this._shouldReloadOnResume = !1, this._paused = !1;\n        for (const e in this._tiles) this._removeTile(+e);\n        this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);\n      }\n      tilesIn(t, i, o) {\n        const s = [],\n          r = this.transform;\n        if (!r) return s;\n        const n = \"globe\" === r.projection.name,\n          a = e.av(r.center.lng);\n        for (const l in this._tiles) {\n          const c = this._tiles[l];\n          if (o && c.clearQueryDebugViz(), c.holdingForFade()) continue;\n          let h;\n          if (n) {\n            const t = c.tileID.canonical;\n            if (0 === t.z) {\n              const i = [Math.abs(e.ay(a, ...Rt(t, -1)) - a), Math.abs(e.ay(a, ...Rt(t, 1)) - a)];\n              h = [0, 2 * i.indexOf(Math.min(...i)) - 1];\n            } else {\n              const i = [Math.abs(e.ay(a, ...Rt(t, -1)) - a), Math.abs(e.ay(a, ...Rt(t, 0)) - a), Math.abs(e.ay(a, ...Rt(t, 1)) - a)];\n              h = [i.indexOf(Math.min(...i)) - 1];\n            }\n          } else h = [0];\n          for (const e of h) {\n            const o = t.containsTile(c, r, i, e);\n            o && s.push(o);\n          }\n        }\n        return s;\n      }\n      getShadowCasterCoordinates() {\n        return this._getRenderableCoordinates(!1, !0);\n      }\n      getVisibleCoordinates(e) {\n        return this._getRenderableCoordinates(e);\n      }\n      _getRenderableCoordinates(e, t) {\n        const i = this.getRenderableIds(e, t).map(e => this._tiles[e].tileID),\n          o = \"globe\" === this.transform.projection.name;\n        for (const e of i) e.projMatrix = this.transform.calculateProjMatrix(e.toUnwrapped()), e.expandedProjMatrix = o ? this.transform.calculateProjMatrix(e.toUnwrapped(), !1, !0) : e.projMatrix;\n        return i;\n      }\n      sortCoordinatesByDistance(e) {\n        const t = e.slice(),\n          i = this.transform._camera.position,\n          o = this.transform._camera.forward(),\n          s = {};\n        for (const e of t) {\n          const t = 1 / (1 << e.canonical.z);\n          s[e.key] = ((e.canonical.x + .5) * t + e.wrap - i[0]) * o[0] + ((e.canonical.y + .5) * t - i[1]) * o[1] - i[2] * o[2];\n        }\n        return t.sort((e, t) => s[e.key] - s[t.key]), t;\n      }\n      hasTransition() {\n        if (this._source.hasTransition()) return !0;\n        if (It(this._source.type)) for (const t in this._tiles) {\n          const i = this._tiles[t];\n          if (void 0 !== i.fadeEndTime && i.fadeEndTime >= e.q.now()) return !0;\n        }\n        return !1;\n      }\n      setFeatureState(e, t, i) {\n        this._state.updateState(e = e || \"_geojsonTileLayer\", t, i);\n      }\n      removeFeatureState(e, t, i) {\n        this._state.removeFeatureState(e = e || \"_geojsonTileLayer\", t, i);\n      }\n      getFeatureState(e, t) {\n        return this._state.getState(e = e || \"_geojsonTileLayer\", t);\n      }\n      setDependencies(e, t, i) {\n        const o = this._tiles[e];\n        o && o.setDependencies(t, i);\n      }\n      reloadTilesForDependencies(e, t) {\n        for (const i in this._tiles) this._tiles[i].hasDependency(e, t) && this._reloadTile(+i, \"reloading\");\n        this._cache.filter(i => !i.hasDependency(e, t));\n      }\n      _preloadTiles(t, i) {\n        if (!this._sourceLoaded) {\n          const e = () => {\n            this._sourceLoaded && (this._source.off(\"data\", e), this._preloadTiles(t, i));\n          };\n          return void this._source.on(\"data\", e);\n        }\n        const o = new Map(),\n          s = Array.isArray(t) ? t : [t],\n          r = this.map.painter.terrain,\n          n = this.usedForTerrain && r ? r.getScaledDemTileSize() : this._source.tileSize;\n        for (const e of s) {\n          const t = e.coveringTiles({\n            tileSize: n,\n            minzoom: this._source.minzoom,\n            maxzoom: this._source.maxzoom,\n            roundZoom: this._source.roundZoom && !this.usedForTerrain,\n            reparseOverscaled: this._source.reparseOverscaled,\n            isTerrainDEM: this.usedForTerrain\n          });\n          for (const e of t) o.set(e.key, e);\n          this.usedForTerrain && e.updateElevation(!1);\n        }\n        const a = Array.from(o.values());\n        e.bl(a, (e, t) => {\n          const i = new bt(e, this._source.tileSize * e.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);\n          this._loadTile(i, e => {\n            \"raster-dem\" === this._source.type && i.dem && this._backfillDEM(i), t(e, i);\n          });\n        }, i);\n      }\n    }\n    function Ct(e, t) {\n      const i = Math.abs(2 * e.wrap) - +(e.wrap < 0),\n        o = Math.abs(2 * t.wrap) - +(t.wrap < 0);\n      return e.overscaledZ - t.overscaledZ || o - i || t.canonical.y - e.canonical.y || t.canonical.x - e.canonical.x;\n    }\n    function It(e) {\n      return \"raster\" === e || \"image\" === e || \"video\" === e || \"custom\" === e;\n    }\n    function Rt(e, t) {\n      const i = 1 << e.z;\n      return [e.x / i + t, (e.x + 1) / i + t];\n    }\n    St.maxOverzooming = 10, St.maxUnderzooming = 3;\n    class Dt {\n      constructor(e) {\n        this.style = e, this.layersGotHidden = !1, this.layers = [];\n      }\n      processLayersChanged() {\n        this.layers = [];\n        const e = !1,\n          t = !1;\n        for (const i in this.style._mergedLayers) {\n          const o = this.style._mergedLayers[i];\n          if (\"fill-extrusion\" === o.type) this.layers.push({\n            layer: o,\n            visible: e,\n            visibilityChanged: t\n          });else if (\"model\" === o.type) {\n            const i = this.style.getLayerSource(o);\n            i && \"batched-model\" === i.type && this.layers.push({\n              layer: o,\n              visible: e,\n              visibilityChanged: t\n            });\n          }\n        }\n      }\n      onNewFrame(e) {\n        this.layersGotHidden = !1;\n        for (const t of this.layers) {\n          const i = t.layer;\n          let o = !1;\n          \"fill-extrusion\" === i.type ? o = !i.isHidden(e) && i.paint.get(\"fill-extrusion-opacity\") > 0 : \"model\" === i.type && (o = !i.isHidden(e) && i.paint.get(\"model-opacity\").constantOr(1) > 0), this.layersGotHidden = this.layersGotHidden || !o && t.visible, t.visible = o;\n        }\n      }\n      updateZOffset(e, t) {\n        this.currentBuildingBuckets = [];\n        for (const e of this.layers) {\n          const i = e.layer,\n            o = this.style.getLayerSourceCache(i);\n          let s = 1;\n          \"fill-extrusion\" === i.type && (s = e.visible ? i.paint.get(\"fill-extrusion-vertical-scale\") : 0);\n          let r = o ? o.getTile(t) : null;\n          if (!r && o && t.canonical.z > o.getSource().minzoom) {\n            let e = t.scaledTo(Math.min(o.getSource().maxzoom, t.overscaledZ - 1));\n            for (; e.overscaledZ >= o.getSource().minzoom && (r = o.getTile(e), !r && 0 !== e.overscaledZ);) e = e.scaledTo(e.overscaledZ - 1);\n          }\n          this.currentBuildingBuckets.push({\n            bucket: r ? r.getBucket(i) : null,\n            tileID: r ? r.tileID : t,\n            verticalScale: s\n          });\n        }\n        e.hasAnyZOffset = !1;\n        let i = !1;\n        for (let o = 0; o < e.symbolInstances.length; o++) {\n          const s = e.symbolInstances.get(o),\n            r = s.zOffset,\n            n = this._getHeightAtTileOffset(t, s.tileAnchorX, s.tileAnchorY);\n          s.zOffset = n !== Number.NEGATIVE_INFINITY ? n : r, i || r === s.zOffset || (i = !0), e.hasAnyZOffset || 0 === s.zOffset || (e.hasAnyZOffset = !0);\n        }\n        i && (e.zOffsetBuffersNeedUpload = !0, e.zOffsetSortDirty = !0);\n      }\n      _mapCoordToOverlappingTile(t, i, o, s) {\n        let r = i,\n          n = o;\n        if (t.canonical.z !== s.canonical.z) {\n          const a = s.canonical,\n            l = 1 / (1 << t.canonical.z - a.z);\n          r = (i + t.canonical.x * e.ai) * l - a.x * e.ai | 0, n = (o + t.canonical.y * e.ai) * l - a.y * e.ai | 0;\n        }\n        return {\n          tileX: r,\n          tileY: n\n        };\n      }\n      _getHeightAtTileOffset(e, t, i) {\n        let o, s;\n        for (let r = 0; r < this.layers.length; ++r) {\n          if (\"fill-extrusion\" !== this.layers[r].layer.type) continue;\n          const {\n            bucket: n,\n            tileID: a,\n            verticalScale: l\n          } = this.currentBuildingBuckets[r];\n          if (!n) continue;\n          const {\n              tileX: c,\n              tileY: h\n            } = this._mapCoordToOverlappingTile(e, t, i, a),\n            d = n.getHeightAtTileCoord(c, h);\n          d && void 0 !== d.height && (d.hidden ? o = d.height : s = Math.max(d.height * l, s || 0));\n        }\n        if (void 0 !== s) return s;\n        for (let s = 0; s < this.layers.length; ++s) {\n          const r = this.layers[s];\n          if (\"model\" !== r.layer.type || !r.visible) continue;\n          const {\n            bucket: n,\n            tileID: a\n          } = this.currentBuildingBuckets[s];\n          if (!n) continue;\n          const {\n              tileX: l,\n              tileY: c\n            } = this._mapCoordToOverlappingTile(e, t, i, a),\n            h = n.getHeightAtTileCoord(l, c);\n          if (h && !h.hidden) return void 0 === h.height && void 0 !== o ? Math.min(h.maxHeight, o) * h.verticalScale : h.height ? h.height * h.verticalScale : Number.NEGATIVE_INFINITY;\n        }\n        return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;\n      }\n    }\n    function At(t, i) {\n      const o = {};\n      for (const e in t) \"ref\" !== e && (o[e] = t[e]);\n      return e.bm.forEach(e => {\n        e in i && (o[e] = i[e]);\n      }), o;\n    }\n    function Lt(e) {\n      e = e.slice();\n      const t = Object.create(null);\n      for (let i = 0; i < e.length; i++) t[e[i].id] = e[i];\n      for (let i = 0; i < e.length; i++) \"ref\" in e[i] && (e[i] = At(e[i], t[e[i].ref]));\n      return e;\n    }\n    const Mt = {\n      setStyle: \"setStyle\",\n      addLayer: \"addLayer\",\n      removeLayer: \"removeLayer\",\n      setPaintProperty: \"setPaintProperty\",\n      setLayoutProperty: \"setLayoutProperty\",\n      setSlot: \"setSlot\",\n      setFilter: \"setFilter\",\n      addSource: \"addSource\",\n      removeSource: \"removeSource\",\n      setGeoJSONSourceData: \"setGeoJSONSourceData\",\n      setLayerZoomRange: \"setLayerZoomRange\",\n      setLayerProperty: \"setLayerProperty\",\n      setCenter: \"setCenter\",\n      setZoom: \"setZoom\",\n      setBearing: \"setBearing\",\n      setPitch: \"setPitch\",\n      setSprite: \"setSprite\",\n      setGlyphs: \"setGlyphs\",\n      setTransition: \"setTransition\",\n      setLight: \"setLight\",\n      setTerrain: \"setTerrain\",\n      setFog: \"setFog\",\n      setSnow: \"setSnow\",\n      setRain: \"setRain\",\n      setCamera: \"setCamera\",\n      setLights: \"setLights\",\n      setProjection: \"setProjection\",\n      addImport: \"addImport\",\n      removeImport: \"removeImport\",\n      updateImport: \"updateImport\"\n    };\n    function Pt(e, t, i) {\n      i.push({\n        command: Mt.addSource,\n        args: [e, t[e]]\n      });\n    }\n    function zt(e, t, i) {\n      t.push({\n        command: Mt.removeSource,\n        args: [e]\n      }), i[e] = !0;\n    }\n    function Ot(e, t, i, o) {\n      zt(e, i, o), Pt(e, t, i);\n    }\n    function Ft(t, i, o) {\n      let s;\n      for (s in t[o]) if (t[o].hasOwnProperty(s) && \"data\" !== s && !e.bn(t[o][s], i[o][s])) return !1;\n      for (s in i[o]) if (i[o].hasOwnProperty(s) && \"data\" !== s && !e.bn(t[o][s], i[o][s])) return !1;\n      return !0;\n    }\n    function kt(t, i, o, s, r, n) {\n      let a;\n      for (a in i = i || {}, t = t || {}) t.hasOwnProperty(a) && (e.bn(t[a], i[a]) || o.push({\n        command: n,\n        args: [s, a, i[a], r]\n      }));\n      for (a in i) i.hasOwnProperty(a) && !t.hasOwnProperty(a) && (e.bn(t[a], i[a]) || o.push({\n        command: n,\n        args: [s, a, i[a], r]\n      }));\n    }\n    function Bt(e) {\n      return e.id;\n    }\n    function Nt(e, t) {\n      return e[t.id] = t, e;\n    }\n    class Ut {\n      constructor(e, t) {\n        this.reset(e, t);\n      }\n      reset(e, t) {\n        this.points = e || [], this._distances = [0];\n        for (let e = 1; e < this.points.length; e++) this._distances[e] = this._distances[e - 1] + this.points[e].dist(this.points[e - 1]);\n        this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t || 0, .5 * this.length), this.paddedLength = this.length - 2 * this.padding;\n      }\n      lerp(t) {\n        if (1 === this.points.length) return this.points[0];\n        t = e.ay(t, 0, 1);\n        let i = 1,\n          o = this._distances[i];\n        const s = t * this.paddedLength + this.padding;\n        for (; o < s && i < this._distances.length;) o = this._distances[++i];\n        const r = i - 1,\n          n = this._distances[r],\n          a = o - n,\n          l = a > 0 ? (s - n) / a : 0;\n        return this.points[r].mult(1 - l).add(this.points[i].mult(l));\n      }\n    }\n    class Vt {\n      constructor(e, t, i) {\n        const o = this.boxCells = [],\n          s = this.circleCells = [];\n        this.xCellCount = Math.ceil(e / i), this.yCellCount = Math.ceil(t / i);\n        for (let e = 0; e < this.xCellCount * this.yCellCount; e++) o.push([]), s.push([]);\n        this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e, this.height = t, this.xScale = this.xCellCount / e, this.yScale = this.yCellCount / t, this.boxUid = 0, this.circleUid = 0;\n      }\n      keysLength() {\n        return this.boxKeys.length + this.circleKeys.length;\n      }\n      insert(e, t, i, o, s) {\n        this._forEachCell(t, i, o, s, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e), this.bboxes.push(t), this.bboxes.push(i), this.bboxes.push(o), this.bboxes.push(s);\n      }\n      insertCircle(e, t, i, o) {\n        this._forEachCell(t - o, i - o, t + o, i + o, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e), this.circles.push(t), this.circles.push(i), this.circles.push(o);\n      }\n      _insertBoxCell(e, t, i, o, s, r) {\n        this.boxCells[s].push(r);\n      }\n      _insertCircleCell(e, t, i, o, s, r) {\n        this.circleCells[s].push(r);\n      }\n      _query(e, t, i, o, s, r) {\n        if (i < 0 || e > this.width || o < 0 || t > this.height) return !s && [];\n        const n = [];\n        if (e <= 0 && t <= 0 && this.width <= i && this.height <= o) {\n          if (s) return !0;\n          for (let e = 0; e < this.boxKeys.length; e++) n.push({\n            key: this.boxKeys[e],\n            x1: this.bboxes[4 * e],\n            y1: this.bboxes[4 * e + 1],\n            x2: this.bboxes[4 * e + 2],\n            y2: this.bboxes[4 * e + 3]\n          });\n          for (let e = 0; e < this.circleKeys.length; e++) {\n            const t = this.circles[3 * e],\n              i = this.circles[3 * e + 1],\n              o = this.circles[3 * e + 2];\n            n.push({\n              key: this.circleKeys[e],\n              x1: t - o,\n              y1: i - o,\n              x2: t + o,\n              y2: i + o\n            });\n          }\n          return r ? n.filter(r) : n;\n        }\n        return this._forEachCell(e, t, i, o, this._queryCell, n, {\n          hitTest: s,\n          seenUids: {\n            box: {},\n            circle: {}\n          }\n        }, r), s ? n.length > 0 : n;\n      }\n      _queryCircle(e, t, i, o, s) {\n        const r = e - i,\n          n = e + i,\n          a = t - i,\n          l = t + i;\n        if (n < 0 || r > this.width || l < 0 || a > this.height) return !o && [];\n        const c = [];\n        return this._forEachCell(r, a, n, l, this._queryCellCircle, c, {\n          hitTest: o,\n          circle: {\n            x: e,\n            y: t,\n            radius: i\n          },\n          seenUids: {\n            box: {},\n            circle: {}\n          }\n        }, s), o ? c.length > 0 : c;\n      }\n      query(e, t, i, o, s) {\n        return this._query(e, t, i, o, !1, s);\n      }\n      hitTest(e, t, i, o, s) {\n        return this._query(e, t, i, o, !0, s);\n      }\n      hitTestCircle(e, t, i, o) {\n        return this._queryCircle(e, t, i, !0, o);\n      }\n      _queryCell(e, t, i, o, s, r, n, a) {\n        const l = n.seenUids,\n          c = this.boxCells[s];\n        if (null !== c) {\n          const s = this.bboxes;\n          for (const h of c) if (!l.box[h]) {\n            l.box[h] = !0;\n            const c = 4 * h;\n            if (e <= s[c + 2] && t <= s[c + 3] && i >= s[c + 0] && o >= s[c + 1] && (!a || a(this.boxKeys[h]))) {\n              if (n.hitTest) return r.push(!0), !0;\n              r.push({\n                key: this.boxKeys[h],\n                x1: s[c],\n                y1: s[c + 1],\n                x2: s[c + 2],\n                y2: s[c + 3]\n              });\n            }\n          }\n        }\n        const h = this.circleCells[s];\n        if (null !== h) {\n          const s = this.circles;\n          for (const c of h) if (!l.circle[c]) {\n            l.circle[c] = !0;\n            const h = 3 * c;\n            if (this._circleAndRectCollide(s[h], s[h + 1], s[h + 2], e, t, i, o) && (!a || a(this.circleKeys[c]))) {\n              if (n.hitTest) return r.push(!0), !0;\n              {\n                const e = s[h],\n                  t = s[h + 1],\n                  i = s[h + 2];\n                r.push({\n                  key: this.circleKeys[c],\n                  x1: e - i,\n                  y1: t - i,\n                  x2: e + i,\n                  y2: t + i\n                });\n              }\n            }\n          }\n        }\n      }\n      _queryCellCircle(e, t, i, o, s, r, n, a) {\n        const l = n.circle,\n          c = n.seenUids,\n          h = this.boxCells[s];\n        if (null !== h) {\n          const e = this.bboxes;\n          for (const t of h) if (!c.box[t]) {\n            c.box[t] = !0;\n            const i = 4 * t;\n            if (this._circleAndRectCollide(l.x, l.y, l.radius, e[i + 0], e[i + 1], e[i + 2], e[i + 3]) && (!a || a(this.boxKeys[t]))) return r.push(!0), !0;\n          }\n        }\n        const d = this.circleCells[s];\n        if (null !== d) {\n          const e = this.circles;\n          for (const t of d) if (!c.circle[t]) {\n            c.circle[t] = !0;\n            const i = 3 * t;\n            if (this._circlesCollide(e[i], e[i + 1], e[i + 2], l.x, l.y, l.radius) && (!a || a(this.circleKeys[t]))) return r.push(!0), !0;\n          }\n        }\n      }\n      _forEachCell(e, t, i, o, s, r, n, a) {\n        const l = this._convertToXCellCoord(e),\n          c = this._convertToYCellCoord(t),\n          h = this._convertToXCellCoord(i),\n          d = this._convertToYCellCoord(o);\n        for (let u = l; u <= h; u++) for (let l = c; l <= d; l++) if (s.call(this, e, t, i, o, this.xCellCount * l + u, r, n, a)) return;\n      }\n      _convertToXCellCoord(e) {\n        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)));\n      }\n      _convertToYCellCoord(e) {\n        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)));\n      }\n      _circlesCollide(e, t, i, o, s, r) {\n        const n = o - e,\n          a = s - t,\n          l = i + r;\n        return l * l > n * n + a * a;\n      }\n      _circleAndRectCollide(e, t, i, o, s, r, n) {\n        const a = (r - o) / 2,\n          l = Math.abs(e - (o + a));\n        if (l > a + i) return !1;\n        const c = (n - s) / 2,\n          h = Math.abs(t - (s + c));\n        if (h > c + i) return !1;\n        if (l <= a || h <= c) return !0;\n        const d = l - a,\n          u = h - c;\n        return d * d + u * u <= i * i;\n      }\n    }\n    const Gt = {\n        unknown: 0,\n        flipRequired: 1,\n        flipNotRequired: 2\n      },\n      jt = Math.tan(85 * Math.PI / 180);\n    function qt(t, i, o, s, r, n, a) {\n      const l = e.ad.mat4.create();\n      if (o) {\n        if (\"globe\" === n.name) {\n          const t = e.bo(r, i);\n          e.ad.mat4.multiply(l, l, t);\n        } else {\n          const t = e.ad.mat2.invert([], a);\n          l[0] = t[0], l[1] = t[1], l[4] = t[2], l[5] = t[3], s || e.ad.mat4.rotateZ(l, l, r.angle);\n        }\n      } else e.ad.mat4.multiply(l, r.labelPlaneMatrix, t);\n      return l;\n    }\n    function Ht(e, t, i, o, s, r, n) {\n      const a = qt(e, t, i, o, s, r, n);\n      return \"globe\" === r.name && i || (a[2] = a[6] = a[10] = a[14] = 0), a;\n    }\n    function Zt(t, i, o, s, r, n, a) {\n      if (o) {\n        if (\"globe\" === n.name) {\n          const l = qt(t, i, o, s, r, n, a);\n          return e.ad.mat4.invert(l, l), e.ad.mat4.multiply(l, t, l), l;\n        }\n        {\n          const i = e.ad.mat4.clone(t),\n            o = e.ad.mat4.identity([]);\n          return o[0] = a[0], o[1] = a[1], o[4] = a[2], o[5] = a[3], e.ad.mat4.multiply(i, i, o), s || e.ad.mat4.rotateZ(i, i, -r.angle), i;\n        }\n      }\n      return r.glCoordMatrix;\n    }\n    function Wt(t, i, o, s) {\n      const r = [t, i, o, 1];\n      o ? e.ad.vec4.transformMat4(r, r, s) : si(r, r, s);\n      const n = r[3];\n      return r[0] /= n, r[1] /= n, r[2] /= n, r;\n    }\n    function $t(e, t) {\n      return Math.min(.5 + e / t * .5, 1.5);\n    }\n    function Xt(e, t) {\n      const i = e[0] / e[3],\n        o = e[1] / e[3];\n      return i >= -t[0] && i <= t[0] && o >= -t[1] && o <= t[1];\n    }\n    function Kt(t, i, o, s, r, n, a, l, c, h) {\n      const d = o.transform,\n        u = s ? t.textSizeData : t.iconSizeData,\n        _ = e.bp(u, o.transform.zoom),\n        p = \"globe\" === d.projection.name,\n        f = [256 / o.width * 2 + 1, 256 / o.height * 2 + 1],\n        m = s ? t.text.dynamicLayoutVertexArray : t.icon.dynamicLayoutVertexArray;\n      m.clear();\n      let g = null;\n      p && (g = s ? t.text.globeExtVertexArray : t.icon.globeExtVertexArray);\n      const v = t.lineVertexArray,\n        y = s ? t.text.placedSymbolArray : t.icon.placedSymbolArray,\n        x = o.transform.width / o.transform.height;\n      let b,\n        w = !1;\n      for (let s = 0; s < y.length; s++) {\n        const p = y.get(s),\n          {\n            numGlyphs: T,\n            writingMode: E\n          } = p;\n        if (E !== e.bq.vertical || w || b === e.bq.horizontal || (w = !0), b = E, (p.hidden || E === e.bq.vertical) && !w) {\n          oi(T, m);\n          continue;\n        }\n        w = !1;\n        const S = new e.P(p.tileAnchorX, p.tileAnchorY);\n        let {\n          x: C,\n          y: I,\n          z: R\n        } = d.projection.projectTilePoint(S.x, S.y, h.canonical);\n        if (c) {\n          const [e, t, i] = c(S);\n          C += e, I += t, R += i;\n        }\n        const D = [C, I, R, 1];\n        if (e.ad.vec4.transformMat4(D, D, i), !Xt(D, f)) {\n          oi(T, m);\n          continue;\n        }\n        const A = D[3],\n          L = $t(o.transform.getCameraToCenterDistance(d.projection), A),\n          M = e.br(u, _, p),\n          P = a ? M / L : M * L,\n          z = Wt(C, I, R, r);\n        if (z[3] <= 0) {\n          oi(T, m);\n          continue;\n        }\n        let O = {};\n        const F = e.ak(t.layers[0].layout.get(\"text-max-angle\")),\n          k = Math.cos(F),\n          B = a ? null : c,\n          N = Qt(p, P, !1, l, i, r, n, t.glyphOffsetArray, v, m, g, z, S, O, x, B, d.projection, h, a, k);\n        w = N.useVertical, B && N.needsFlipping && (O = {}), (N.notEnoughRoom || w || N.needsFlipping && Qt(p, P, !0, l, i, r, n, t.glyphOffsetArray, v, m, g, z, S, O, x, B, d.projection, h, a, k).notEnoughRoom) && oi(T, m);\n      }\n      s ? (t.text.dynamicLayoutVertexBuffer.updateData(m), g && t.text.globeExtVertexBuffer && t.text.globeExtVertexBuffer.updateData(g)) : (t.icon.dynamicLayoutVertexBuffer.updateData(m), g && t.icon.globeExtVertexBuffer && t.icon.globeExtVertexBuffer.updateData(g));\n    }\n    function Yt(e, t, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m) {\n      const {\n          lineStartIndex: g,\n          glyphStartIndex: v,\n          segment: y\n        } = a,\n        x = v + a.numGlyphs,\n        b = g + a.lineLength,\n        w = t.getoffsetX(v),\n        T = t.getoffsetX(x - 1),\n        E = ii(e * w, i, o, s, r, n, y, g, b, l, c, h, d, u, !0, _, p, f, m);\n      if (!E) return null;\n      const S = ii(e * T, i, o, s, r, n, y, g, b, l, c, h, d, u, !0, _, p, f, m);\n      return S ? {\n        first: E,\n        last: S\n      } : null;\n    }\n    function Jt(t, i, o, s) {\n      return t === e.bq.horizontal && Math.abs(s) > Math.abs(o) ? {\n        useVertical: !0\n      } : t === e.bq.vertical ? s > 0 ? {\n        needsFlipping: !0\n      } : null : i !== Gt.unknown && function (e, t) {\n        return 0 === e || Math.abs(t / e) > jt;\n      }(o, s) ? i === Gt.flipRequired ? {\n        needsFlipping: !0\n      } : null : o < 0 ? {\n        needsFlipping: !0\n      } : null;\n    }\n    function Qt(t, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v, y, x) {\n      const b = i / 24,\n        w = t.lineOffsetX * b,\n        T = t.lineOffsetY * b,\n        {\n          lineStartIndex: E,\n          glyphStartIndex: S,\n          numGlyphs: C,\n          segment: I,\n          writingMode: R,\n          flipState: D\n        } = t,\n        A = E + t.lineLength,\n        L = t => {\n          if (d) {\n            const [i, o, s] = t.up,\n              r = h.length;\n            e.bs(d, r + 0, i, o, s), e.bs(d, r + 1, i, o, s), e.bs(d, r + 2, i, o, s), e.bs(d, r + 3, i, o, s);\n          }\n          const [i, o, s] = t.point;\n          e.bt(h, i, o, s, t.angle);\n        };\n      if (C > 1) {\n        const e = Yt(b, l, w, T, o, u, _, t, c, n, p, m, !1, g, v, y, x);\n        if (!e) return {\n          notEnoughRoom: !0\n        };\n        if (s && !o) {\n          let [i, o, s] = e.first.point,\n            [r, n, l] = e.last.point;\n          [i, o] = Wt(i, o, s, a), [r, n] = Wt(r, n, l, a);\n          const c = Jt(R, D, (r - i) * f, n - o);\n          if (t.flipState = c && c.needsFlipping ? Gt.flipRequired : Gt.flipNotRequired, c) return c;\n        }\n        L(e.first);\n        for (let e = S + 1; e < S + C - 1; e++) {\n          const t = ii(b * l.getoffsetX(e), w, T, o, u, _, I, E, A, c, n, p, m, !1, !1, g, v, y, x);\n          if (!t) return h.length -= 4 * (e - S), {\n            notEnoughRoom: !0\n          };\n          L(t);\n        }\n        L(e.last);\n      } else {\n        if (s && !o) {\n          const i = Wt(_.x, _.y, 0, r),\n            o = E + I + 1,\n            s = new e.P(c.getx(o), c.gety(o)),\n            n = Wt(s.x, s.y, 0, r),\n            a = n[3] > 0 ? n : ti(_, s, i, 1, r, void 0, g, v.canonical),\n            l = Jt(R, D, (a[0] - i[0]) * f, a[1] - i[1]);\n          if (t.flipState = l && l.needsFlipping ? Gt.flipRequired : Gt.flipNotRequired, l) return l;\n        }\n        const i = ii(b * l.getoffsetX(S), w, T, o, u, _, I, E, A, c, n, p, m, !1, !1, g, v, y, x);\n        if (!i) return {\n          notEnoughRoom: !0\n        };\n        L(i);\n      }\n      return {};\n    }\n    function ei(e, t, i, o, s) {\n      const {\n        x: r,\n        y: n,\n        z: a\n      } = o.projectTilePoint(e.x, e.y, t);\n      if (!s) return Wt(r, n, a, i);\n      const [l, c, h] = s(e);\n      return Wt(r + l, n + c, a + h, i);\n    }\n    function ti(t, i, o, s, r, n, a, l) {\n      const c = ei(t.sub(i)._unit()._add(t), l, r, a, n);\n      return e.ad.vec3.sub(c, o, c), e.ad.vec3.normalize(c, c), e.ad.vec3.scaleAndAdd(c, o, c, s);\n    }\n    function ii(t, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v, y) {\n      const x = s ? t - i : t + i;\n      let b = x > 0 ? 1 : -1,\n        w = 0;\n      s && (b *= -1, w = Math.PI), b < 0 && (w += Math.PI);\n      let T = l + a + (b > 0 ? 0 : 1) | 0,\n        E = r,\n        S = r,\n        C = 0,\n        I = 0;\n      const R = Math.abs(x),\n        D = [],\n        A = [];\n      let L = n,\n        M = L,\n        P = e.ad.vec3.zero([]);\n      const z = () => ti(M, L, S, R - C + 1, d, _, m, g.canonical);\n      for (; C + I <= R;) {\n        if (T += b, T < l || T >= c) return null;\n        if (S = E, M = L, D.push(S), p && A.push(M), L = new e.P(h.getx(T), h.gety(T)), E = u[T], !E) {\n          const e = ei(L, g.canonical, d, m, _);\n          E = e[3] > 0 ? u[T] = e : z();\n        }\n        C += I;\n        const t = e.ad.vec3.sub([], E, S),\n          i = e.ad.vec3.distance(S, E);\n        if (o && i > 0 && I > 0 && e.ad.vec3.dot(P, t) / (I * i) < y) return null;\n        I = i, P = t;\n      }\n      f && _ && (u[T] && (E = z(), I = e.ad.vec3.distance(S, E), P = e.ad.vec3.sub([], E, S)), u[T] = E);\n      const O = (R - C) / I,\n        F = L.sub(M)._mult(O)._add(M),\n        k = e.ad.vec3.scaleAndAdd([], S, P, O);\n      let B = [0, 0, 1],\n        N = P[0],\n        U = P[1];\n      if (v && (B = m.upVector(g.canonical, F.x, F.y), 0 !== B[0] || 0 !== B[1] || 1 !== B[2])) {\n        const t = [B[2], 0, -B[0]],\n          i = e.ad.vec3.cross([], B, t);\n        e.ad.vec3.normalize(t, t), e.ad.vec3.normalize(i, i), N = e.ad.vec3.dot(P, t), U = e.ad.vec3.dot(P, i);\n      }\n      if (o) {\n        const t = e.ad.vec3.cross([], B, P);\n        e.ad.vec3.normalize(t, t), e.ad.vec3.scaleAndAdd(k, k, t, o * b);\n      }\n      const V = w + Math.atan2(U, N);\n      return D.push(k), p && A.push(F), {\n        point: k,\n        angle: V,\n        path: D,\n        tilePath: A,\n        up: B\n      };\n    }\n    function oi(e, t) {\n      const i = t.length,\n        o = i + 4 * e;\n      t.resize(o), t.float32.fill(-1 / 0, 4 * i, 4 * o);\n    }\n    function si(e, t, i) {\n      const o = t[0],\n        s = t[1];\n      return e[0] = i[0] * o + i[4] * s + i[12], e[1] = i[1] * o + i[5] * s + i[13], e[3] = i[3] * o + i[7] * s + i[15], e;\n    }\n    const ri = 100;\n    class ni {\n      constructor(e, t, i = new Vt(e.width + 200, e.height + 200, 25), o = new Vt(e.width + 200, e.height + 200, 25)) {\n        this.transform = e, this.grid = i, this.ignoredGrid = o, this.pitchfactor = Math.cos(e._pitch) * e.cameraToCenterDistance, this.screenRightBoundary = e.width + ri, this.screenBottomBoundary = e.height + ri, this.gridRightBoundary = e.width + 200, this.gridBottomBoundary = e.height + 200, this.fogState = t;\n      }\n      placeCollisionBox(e, t, i, o, s, r, n, a) {\n        let l = i.projectedAnchorX,\n          c = i.projectedAnchorY,\n          h = i.projectedAnchorZ;\n        const d = i.elevation,\n          u = i.tileID,\n          _ = e.getProjection();\n        if (d && u) {\n          const [e, t, o] = _.upVector(u.canonical, i.tileAnchorX, i.tileAnchorY),\n            s = _.upVectorScale(u.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;\n          l += e * d * s, c += t * d * s, h += o * d * s;\n        }\n        const p = this.projectAndGetPerspectiveRatio(n, l, c, h, i.tileID, \"globe\" === _.name || !!d || this.transform.pitch > 0, _),\n          f = r * p.perspectiveRatio,\n          m = (i.x1 * t + o.x - i.padding) * f + p.point.x,\n          g = (i.y1 * t + o.y - i.padding) * f + p.point.y,\n          v = (i.x2 * t + o.x + i.padding) * f + p.point.x,\n          y = (i.y2 * t + o.y + i.padding) * f + p.point.y,\n          x = p.perspectiveRatio <= .55 || p.occluded;\n        return !this.isInsideGrid(m, g, v, y) || !s && this.grid.hitTest(m, g, v, y, a) || x ? {\n          box: [],\n          offscreen: !1,\n          occluded: p.occluded\n        } : {\n          box: [m, g, v, y],\n          offscreen: this.isOffscreen(m, g, v, y),\n          occluded: !1\n        };\n      }\n      placeCollisionCircles(t, i, o, s, r, n, a, l, c, h, d, u, _, p, f) {\n        const m = [],\n          g = this.transform.elevation,\n          v = t.getProjection(),\n          y = g ? g.getAtTileOffsetFunc(f, this.transform.center.lat, this.transform.worldSize, v) : null,\n          x = new e.P(o.tileAnchorX, o.tileAnchorY);\n        let {\n          x: b,\n          y: w,\n          z: T\n        } = v.projectTilePoint(x.x, x.y, f.canonical);\n        if (y) {\n          const [e, t, i] = y(x);\n          b += e, w += t, T += i;\n        }\n        const E = \"globe\" === v.name,\n          S = this.projectAndGetPerspectiveRatio(a, b, w, T, f, E || !!g || this.transform.pitch > 0, v),\n          {\n            perspectiveRatio: C\n          } = S,\n          I = (d ? n / C : n * C) / e.bw,\n          R = Wt(b, w, T, l),\n          D = o.lineOffsetX * I,\n          A = o.lineOffsetY * I,\n          L = e.ak(t.layers[0].layout.get(\"text-max-angle\")),\n          M = Math.cos(L),\n          P = S.signedDistanceFromCamera > 0 ? Yt(I, r, D, A, !1, R, x, o, s, l, {}, g && !d ? y : null, d && !!g, v, f, d, M) : null;\n        let z = !1,\n          O = !1,\n          F = !0;\n        if (P && !S.occluded) {\n          const t = .5 * _ * C + p,\n            o = new e.P(-100, -100),\n            s = new e.P(this.screenRightBoundary, this.screenBottomBoundary),\n            r = new Ut(),\n            {\n              first: n,\n              last: a\n            } = P,\n            l = n.path.length;\n          let d = [];\n          for (let e = l - 1; e >= 1; e--) d.push(n.path[e]);\n          for (let e = 1; e < a.path.length; e++) d.push(a.path[e]);\n          const f = 2.5 * t;\n          c && (d = d.map(([e, t, i], o) => (y && !E && (i = y(o < l - 1 ? n.tilePath[l - 1 - o] : a.tilePath[o - l + 2])[2]), Wt(e, t, i, c))), d.some(e => e[3] <= 0) && (d = []));\n          let g = [];\n          if (d.length > 0) {\n            let t = 1 / 0,\n              i = -1 / 0,\n              r = 1 / 0,\n              n = -1 / 0;\n            for (const e of d) t = Math.min(t, e[0]), r = Math.min(r, e[1]), i = Math.max(i, e[0]), n = Math.max(n, e[1]);\n            i >= o.x && t <= s.x && n >= o.y && r <= s.y && (g = [d.map(t => new e.P(t[0], t[1]))], (t < o.x || i > s.x || r < o.y || n > s.y) && (g = e.bu(g, o.x, o.y, s.x, s.y)));\n          }\n          for (const e of g) {\n            r.reset(e, .25 * t);\n            let o = 0;\n            o = r.length <= .5 * t ? 1 : Math.ceil(r.paddedLength / f) + 1;\n            for (let e = 0; e < o; e++) {\n              const s = e / Math.max(o - 1, 1),\n                n = r.lerp(s),\n                a = n.x + ri,\n                l = n.y + ri;\n              m.push(a, l, t, 0);\n              const c = a - t,\n                d = l - t,\n                _ = a + t,\n                p = l + t;\n              if (F = F && this.isOffscreen(c, d, _, p), O = O || this.isInsideGrid(c, d, _, p), !i && this.grid.hitTestCircle(a, l, t, u) && (z = !0, !h)) return {\n                circles: [],\n                offscreen: !1,\n                collisionDetected: z,\n                occluded: !1\n              };\n            }\n          }\n        }\n        return {\n          circles: !h && z || !O ? [] : m,\n          offscreen: F,\n          collisionDetected: z,\n          occluded: S.occluded\n        };\n      }\n      queryRenderedSymbols(t) {\n        if (0 === t.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};\n        const i = [];\n        let o = 1 / 0,\n          s = 1 / 0,\n          r = -1 / 0,\n          n = -1 / 0;\n        for (const a of t) {\n          const t = new e.P(a.x + ri, a.y + ri);\n          o = Math.min(o, t.x), s = Math.min(s, t.y), r = Math.max(r, t.x), n = Math.max(n, t.y), i.push(t);\n        }\n        const a = this.grid.query(o, s, r, n).concat(this.ignoredGrid.query(o, s, r, n)),\n          l = {},\n          c = {};\n        for (const t of a) {\n          const o = t.key;\n          if (void 0 === l[o.bucketInstanceId] && (l[o.bucketInstanceId] = {}), l[o.bucketInstanceId][o.featureIndex]) continue;\n          const s = [new e.P(t.x1, t.y1), new e.P(t.x2, t.y1), new e.P(t.x2, t.y2), new e.P(t.x1, t.y2)];\n          e.bv(i, s) && (l[o.bucketInstanceId][o.featureIndex] = !0, void 0 === c[o.bucketInstanceId] && (c[o.bucketInstanceId] = []), c[o.bucketInstanceId].push(o.featureIndex));\n        }\n        return c;\n      }\n      insertCollisionBox(e, t, i, o, s) {\n        (t ? this.ignoredGrid : this.grid).insert({\n          bucketInstanceId: i,\n          featureIndex: o,\n          collisionGroupID: s\n        }, e[0], e[1], e[2], e[3]);\n      }\n      insertCollisionCircles(e, t, i, o, s) {\n        const r = t ? this.ignoredGrid : this.grid,\n          n = {\n            bucketInstanceId: i,\n            featureIndex: o,\n            collisionGroupID: s\n          };\n        for (let t = 0; t < e.length; t += 4) r.insertCircle(n, e[t], e[t + 1], e[t + 2]);\n      }\n      projectAndGetPerspectiveRatio(t, i, o, s, r, n, a) {\n        const l = [i, o, s, 1];\n        let c = !1;\n        if (s || this.transform.pitch > 0) {\n          if (e.ad.vec4.transformMat4(l, l, t), this.fogState && r && \"globe\" !== a.name) {\n            const t = function (t, i, o, s, r, n) {\n              const a = n.calculateFogTileMatrix(r),\n                l = [i, o, s];\n              return e.ad.vec3.transformMat4(l, l, a), ke(t, e.ad.vec3.length(l), n.pitch, n._fov);\n            }(this.fogState, i, o, s, r.toUnwrapped(), this.transform);\n            c = t > .9;\n          }\n        } else si(l, l, t);\n        const h = l[3];\n        return {\n          point: new e.P((l[0] / h + 1) / 2 * this.transform.width + ri, (-l[1] / h + 1) / 2 * this.transform.height + ri),\n          perspectiveRatio: Math.min(.5 + this.transform.getCameraToCenterDistance(a) / h * .5, 1.5),\n          signedDistanceFromCamera: h,\n          occluded: n && l[2] > h || c\n        };\n      }\n      isOffscreen(e, t, i, o) {\n        return i < ri || e >= this.screenRightBoundary || o < ri || t > this.screenBottomBoundary;\n      }\n      isInsideGrid(e, t, i, o) {\n        return i >= 0 && e < this.gridRightBoundary && o >= 0 && t < this.gridBottomBoundary;\n      }\n      getViewportMatrix() {\n        const t = e.ad.mat4.identity([]);\n        return e.ad.mat4.translate(t, t, [-100, -100, 0]), t;\n      }\n    }\n    function ai(t, i, o) {\n      const s = i.createTileMatrix(t, t.worldSize, o.toUnwrapped());\n      return e.ad.mat4.multiply(new Float32Array(16), t.projMatrix, s);\n    }\n    function li(e, t, i) {\n      if (t.projection.name === i.projection.name) return e.projMatrix;\n      const o = i.clone();\n      return o.setProjection(t.projection), ai(o, t.getProjection(), e);\n    }\n    function ci(e, t, i) {\n      return t.name === i.projection.name ? e.projMatrix : ai(i, t, e);\n    }\n    class hi {\n      constructor(e, t, i, o) {\n        this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? t : -t))) : o && i ? 1 : 0, this.placed = i;\n      }\n      isHidden() {\n        return 0 === this.opacity && !this.placed;\n      }\n    }\n    class di {\n      constructor(e, t, i, o, s, r = !1) {\n        this.text = new hi(e ? e.text : null, t, i, s), this.icon = new hi(e ? e.icon : null, t, o, s), this.clipped = r;\n      }\n      isHidden() {\n        return this.text.isHidden() && this.icon.isHidden();\n      }\n    }\n    class ui {\n      constructor(e, t, i, o = !1) {\n        this.text = e, this.icon = t, this.skipFade = i, this.clipped = o;\n      }\n    }\n    class _i {\n      constructor() {\n        this.invProjMatrix = e.ad.mat4.create(), this.viewportMatrix = e.ad.mat4.create(), this.circles = [];\n      }\n    }\n    class pi {\n      constructor(e, t, i, o, s) {\n        this.bucketInstanceId = e, this.featureIndex = t, this.sourceLayerIndex = i, this.bucketIndex = o, this.tileID = s;\n      }\n    }\n    class fi {\n      constructor(e) {\n        this.crossSourceCollisions = e, this.maxGroupID = 0, this.collisionGroups = {};\n      }\n      get(e) {\n        if (this.crossSourceCollisions) return {\n          ID: 0,\n          predicate: null\n        };\n        if (!this.collisionGroups[e]) {\n          const t = ++this.maxGroupID;\n          this.collisionGroups[e] = {\n            ID: t,\n            predicate: e => e.collisionGroupID === t\n          };\n        }\n        return this.collisionGroups[e];\n      }\n    }\n    function mi(t, i, o, s, r) {\n      const {\n          horizontalAlign: n,\n          verticalAlign: a\n        } = e.bD(t),\n        l = -(n - .5) * i,\n        c = -(a - .5) * o,\n        h = e.bC(t, s);\n      return new e.P(l + h[0] * r, c + h[1] * r);\n    }\n    function gi(t, i, o, s, r) {\n      const n = new e.P(t, i);\n      return o && n._rotate(s ? r : -r), n;\n    }\n    class vi {\n      constructor(e, t, i, o, s, r) {\n        this.transform = e.clone(), this.projection = e.projection.name, this.collisionIndex = new ni(this.transform, s), this.buildingIndex = r, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = t, this.retainedQueryData = {}, this.collisionGroups = new fi(i), this.collisionCircleArrays = {}, this.prevPlacement = o, o && (o.prevPlacement = void 0), this.placedOrientations = {};\n      }\n      getBucketParts(t, i, o, s, r = 1) {\n        const n = o.getBucket(i),\n          a = o.latestFeatureIndex;\n        if (!n || !a || i.fqid !== n.layerIds[0]) return;\n        const l = n.layers[0].layout,\n          c = n.layers[0].paint,\n          h = o.collisionBoxArray,\n          d = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ),\n          u = o.tileSize / e.ai,\n          _ = o.tileID.toUnwrapped();\n        this.transform.setProjection(n.projection);\n        const p = (f = o.tileID, m = n.getProjection(), g = this.transform, m.name === this.projection ? g.calculateProjMatrix(f.toUnwrapped()) : ai(g, m, f));\n        var f, m, g;\n        const v = \"map\" === l.get(\"text-pitch-alignment\"),\n          y = \"map\" === l.get(\"text-rotation-alignment\");\n        i.compileFilter(i.options);\n        const x = i.dynamicFilter(),\n          b = i.dynamicFilterNeedsFeature(),\n          w = this.transform.calculatePixelsToTileUnitsMatrix(o),\n          T = Ht(p, o.tileID.canonical, v, y, this.transform, n.getProjection(), w);\n        let E = null;\n        if (v) {\n          const t = Zt(p, o.tileID.canonical, v, y, this.transform, n.getProjection(), w);\n          E = e.ad.mat4.multiply([], this.transform.labelPlaneMatrix, t);\n        }\n        let S = null;\n        x && o.latestFeatureIndex && (S = {\n          unwrappedTileID: _,\n          dynamicFilter: x,\n          dynamicFilterNeedsFeature: b\n        }), this.retainedQueryData[n.bucketInstanceId] = new pi(n.bucketInstanceId, a, n.sourceLayerIndex, n.index, o.tileID);\n        const [C, I] = n.layers[0].layout.get(\"text-size-scale-range\"),\n          R = e.ay(r, C, I),\n          [D, A] = l.get(\"icon-size-scale-range\"),\n          L = e.ay(r, D, A),\n          M = {\n            bucket: n,\n            layout: l,\n            paint: c,\n            posMatrix: p,\n            textLabelPlaneMatrix: T,\n            labelToScreenMatrix: E,\n            clippingData: S,\n            scale: d,\n            textPixelRatio: u,\n            holdingForFade: o.holdingForFade(),\n            collisionBoxArray: h,\n            partiallyEvaluatedTextSize: e.bp(n.textSizeData, this.transform.zoom, R),\n            partiallyEvaluatedIconSize: e.bp(n.iconSizeData, this.transform.zoom, L),\n            collisionGroup: this.collisionGroups.get(n.sourceID),\n            latestFeatureIndex: o.latestFeatureIndex\n          };\n        if (s) for (const e of n.sortKeyRanges) {\n          const {\n            sortKey: i,\n            symbolInstanceStart: o,\n            symbolInstanceEnd: s\n          } = e;\n          t.push({\n            sortKey: i,\n            symbolInstanceStart: o,\n            symbolInstanceEnd: s,\n            parameters: M\n          });\n        } else t.push({\n          symbolInstanceStart: 0,\n          symbolInstanceEnd: n.symbolInstances.length,\n          parameters: M\n        });\n      }\n      attemptAnchorPlacement(e, t, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g) {\n        const {\n            textOffset0: v,\n            textOffset1: y,\n            crossTileID: x\n          } = d,\n          b = [v, y],\n          w = mi(e, i, o, b, s),\n          T = this.collisionIndex.placeCollisionBox(_, s, t, gi(w.x, w.y, r, n, this.transform.angle), h, a, l, c.predicate);\n        if (f) {\n          const e = _.getSymbolInstanceIconSize(g, this.transform.zoom, d.placedIconSymbolIndex);\n          if (0 === this.collisionIndex.placeCollisionBox(_, e, f, gi(w.x, w.y, r, n, this.transform.angle), h, a, l, c.predicate).box.length) return;\n        }\n        if (T.box.length > 0) {\n          let t;\n          return this.prevPlacement && this.prevPlacement.variableOffsets[x] && this.prevPlacement.placements[x] && this.prevPlacement.placements[x].text && (t = this.prevPlacement.variableOffsets[x].anchor), this.variableOffsets[x] = {\n            textOffset: b,\n            width: i,\n            height: o,\n            anchor: e,\n            textScale: s,\n            prevAnchor: t\n          }, this.markUsedJustification(_, e, d, p), _.allowVerticalPlacement && (this.markUsedOrientation(_, p, d), this.placedOrientations[x] = p), {\n            shift: w,\n            placedGlyphBoxes: T\n          };\n        }\n      }\n      placeLayerBucketPart(t, i, o, s, r = 1) {\n        const {\n            bucket: n,\n            layout: a,\n            paint: l,\n            posMatrix: c,\n            textLabelPlaneMatrix: h,\n            labelToScreenMatrix: d,\n            clippingData: u,\n            textPixelRatio: _,\n            holdingForFade: p,\n            collisionBoxArray: f,\n            partiallyEvaluatedTextSize: m,\n            partiallyEvaluatedIconSize: g,\n            collisionGroup: v,\n            latestFeatureIndex: y\n          } = t.parameters,\n          x = a.get(\"text-optional\"),\n          b = a.get(\"icon-optional\"),\n          w = a.get(\"text-allow-overlap\"),\n          T = a.get(\"icon-allow-overlap\"),\n          E = \"map\" === a.get(\"text-rotation-alignment\"),\n          S = \"map\" === a.get(\"text-pitch-alignment\"),\n          C = l.get(\"symbol-z-offset\"),\n          I = \"sea\" === a.get(\"symbol-elevation-reference\"),\n          [R, D] = a.get(\"text-size-scale-range\"),\n          [A, L] = a.get(\"icon-size-scale-range\"),\n          M = e.ay(r, R, D),\n          P = e.ay(r, A, L);\n        this.transform.setProjection(n.projection);\n        let z = w && (T || !n.hasIconData() || b),\n          O = T && (w || !n.hasTextData() || x);\n        const F = !C.isConstant();\n        !n.collisionArrays && f && n.deserializeCollisionBoxes(f), o && s && n.updateCollisionDebugBuffers(this.transform.zoom, f, M, P);\n        const k = (t, s, l) => {\n          const {\n            crossTileID: f,\n            numVerticalGlyphVertices: R\n          } = t;\n          let D = null;\n          if (u && u.dynamicFilterNeedsFeature || F) {\n            const e = this.retainedQueryData[n.bucketInstanceId];\n            D = y.loadFeature({\n              featureIndex: t.featureIndex,\n              bucketIndex: e.bucketIndex,\n              sourceLayerIndex: e.sourceLayerIndex,\n              layoutVertexArrayOffset: 0\n            });\n          }\n          if (u && !(0, u.dynamicFilter)({\n            zoom: this.transform.zoom,\n            pitch: this.transform.pitch\n          }, D, this.retainedQueryData[n.bucketInstanceId].tileID.canonical, new e.P(t.tileAnchorX, t.tileAnchorY), this.transform.calculateDistanceTileData(u.unwrappedTileID))) return this.placements[f] = new ui(!1, !1, !1, !0), void i.add(f);\n          const A = C.evaluate(D, {});\n          if (i.has(f)) return;\n          if (p) return void (this.placements[f] = new ui(!1, !1, !1));\n          let L = !1,\n            M = !1,\n            P = !0,\n            k = !1,\n            B = !1,\n            N = null,\n            U = {\n              box: null,\n              offscreen: null,\n              occluded: null\n            },\n            V = {\n              box: null,\n              offscreen: null,\n              occluded: null\n            },\n            G = null,\n            j = null,\n            q = null,\n            H = 0,\n            Z = 0,\n            W = 0;\n          l.textFeatureIndex ? H = l.textFeatureIndex : t.useRuntimeCollisionCircles && (H = t.featureIndex), l.verticalTextFeatureIndex && (Z = l.verticalTextFeatureIndex);\n          const $ = e => {\n              e.tileID = this.retainedQueryData[n.bucketInstanceId].tileID;\n              const i = this.transform.elevation;\n              e.elevation = I ? A : A + (i ? i.getAtTileOffset(e.tileID, e.tileAnchorX, e.tileAnchorY) : 0), e.elevation += t.zOffset;\n            },\n            X = l.textBox;\n          if (X) {\n            $(X);\n            const i = i => {\n                let o = e.bq.horizontal;\n                if (n.allowVerticalPlacement && !i && this.prevPlacement) {\n                  const e = this.prevPlacement.placedOrientations[f];\n                  e && (this.placedOrientations[f] = e, o = e, this.markUsedOrientation(n, o, t));\n                }\n                return o;\n              },\n              o = (t, i) => {\n                if (n.allowVerticalPlacement && R > 0 && l.verticalTextBox) {\n                  for (const o of n.writingModes) if (o === e.bq.vertical ? (U = i(), V = U) : U = t(), U && U.box && U.box.length) break;\n                } else U = t();\n              };\n            if (a.get(\"text-variable-anchor\")) {\n              let r = a.get(\"text-variable-anchor\");\n              if (this.prevPlacement && this.prevPlacement.variableOffsets[f]) {\n                const e = this.prevPlacement.variableOffsets[f];\n                r.indexOf(e.anchor) > 0 && (r = r.filter(t => t !== e.anchor), r.unshift(e.anchor));\n              }\n              const h = (e, i, o) => {\n                const a = n.getSymbolInstanceTextSize(m, t, this.transform.zoom, s),\n                  l = (e.x2 - e.x1) * a + 2 * e.padding,\n                  h = (e.y2 - e.y1) * a + 2 * e.padding,\n                  d = t.hasIconTextFit && !T ? i : null;\n                d && $(d);\n                let u = {\n                  box: [],\n                  offscreen: !1,\n                  occluded: !1\n                };\n                const p = w ? 2 * r.length : r.length;\n                for (let i = 0; i < p; ++i) {\n                  const p = this.attemptAnchorPlacement(r[i % r.length], e, l, h, a, E, S, _, c, v, i >= r.length, t, s, n, o, d, m, g);\n                  if (p && (u = p.placedGlyphBoxes, u && u.box && u.box.length)) {\n                    L = !0, N = p.shift;\n                    break;\n                  }\n                }\n                return u;\n              };\n              o(() => h(X, l.iconBox, e.bq.horizontal), () => {\n                const t = l.verticalTextBox;\n                return t && $(t), n.allowVerticalPlacement && !(U && U.box && U.box.length) && R > 0 && t ? h(t, l.verticalIconBox, e.bq.vertical) : {\n                  box: null,\n                  offscreen: null,\n                  occluded: null\n                };\n              }), U && (L = U.box, P = U.offscreen, k = U.occluded);\n              const d = i(!(!U || !U.box));\n              if (!L && this.prevPlacement) {\n                const e = this.prevPlacement.variableOffsets[f];\n                e && (this.variableOffsets[f] = e, this.markUsedJustification(n, e.anchor, t, d));\n              }\n            } else {\n              const a = (i, o) => {\n                const a = n.getSymbolInstanceTextSize(m, t, this.transform.zoom, s, r),\n                  l = this.collisionIndex.placeCollisionBox(n, a, i, new e.P(0, 0), w, _, c, v.predicate);\n                return l && l.box && l.box.length && (this.markUsedOrientation(n, o, t), this.placedOrientations[f] = o), l;\n              };\n              o(() => a(X, e.bq.horizontal), () => {\n                const t = l.verticalTextBox;\n                return n.allowVerticalPlacement && R > 0 && t ? ($(t), a(t, e.bq.vertical)) : {\n                  box: null,\n                  offscreen: null,\n                  occluded: null\n                };\n              }), i(!!(U && U.box && U.box.length));\n            }\n          }\n          if (G = U, L = G && G.box && G.box.length > 0, P = G && G.offscreen, k = G && G.occluded, t.useRuntimeCollisionCircles) {\n            const i = n.text.placedSymbolArray.get(t.centerJustifiedTextSymbolIndex >= 0 ? t.centerJustifiedTextSymbolIndex : t.verticalPlacedTextSymbolIndex),\n              s = e.br(n.textSizeData, m, i),\n              r = a.get(\"text-padding\");\n            j = this.collisionIndex.placeCollisionCircles(n, w, i, n.lineVertexArray, n.glyphOffsetArray, s, c, h, d, o, S, v.predicate, t.collisionCircleDiameter * s / e.bw, r, this.retainedQueryData[n.bucketInstanceId].tileID), L = w || j.circles.length > 0 && !j.collisionDetected, P = P && j.offscreen, k = j.occluded;\n          }\n          if (l.iconFeatureIndex && (W = l.iconFeatureIndex), l.iconBox) {\n            const i = i => {\n              $(i);\n              const o = t.hasIconTextFit && N ? gi(N.x, N.y, E, S, this.transform.angle) : new e.P(0, 0),\n                s = n.getSymbolInstanceIconSize(g, this.transform.zoom, t.placedIconSymbolIndex);\n              return this.collisionIndex.placeCollisionBox(n, s, i, o, T, _, c, v.predicate);\n            };\n            V && V.box && V.box.length && l.verticalIconBox ? (q = i(l.verticalIconBox), M = q.box.length > 0) : (q = i(l.iconBox), M = q.box.length > 0), P = P && q.offscreen, B = q.occluded;\n          }\n          const K = x || 0 === t.numHorizontalGlyphVertices && 0 === R,\n            Y = b || 0 === t.numIconVertices;\n          if (K || Y ? Y ? K || (M = M && L) : L = M && L : M = L = M && L, L && G && G.box && this.collisionIndex.insertCollisionBox(G.box, a.get(\"text-ignore-placement\"), n.bucketInstanceId, V && V.box && Z ? Z : H, v.ID), M && q && this.collisionIndex.insertCollisionBox(q.box, a.get(\"icon-ignore-placement\"), n.bucketInstanceId, W, v.ID), j && (L && this.collisionIndex.insertCollisionCircles(j.circles, a.get(\"text-ignore-placement\"), n.bucketInstanceId, H, v.ID), o)) {\n            const e = n.bucketInstanceId;\n            let t = this.collisionCircleArrays[e];\n            void 0 === t && (t = this.collisionCircleArrays[e] = new _i());\n            for (let e = 0; e < j.circles.length; e += 4) t.circles.push(j.circles[e + 0]), t.circles.push(j.circles[e + 1]), t.circles.push(j.circles[e + 2]), t.circles.push(j.collisionDetected ? 1 : 0);\n          }\n          const J = \"globe\" !== n.projection.name;\n          z = z && (J || !k), O = O && (J || !B), this.placements[f] = new ui(L || z, M || O, P || n.justReloaded), i.add(f);\n        };\n        if (\"offset\" === n.elevationType && this.buildingIndex && this.buildingIndex.updateZOffset(n, this.retainedQueryData[n.bucketInstanceId].tileID), \"road\" === n.elevationType && n.updateRoadElevation(), n.updateZOffset(), n.sortFeaturesByY) {\n          const t = n.getSortedSymbolIndexes(this.transform.angle);\n          for (let e = t.length - 1; e >= 0; --e) {\n            const i = t[e];\n            k(n.symbolInstances.get(i), i, n.collisionArrays[i]);\n          }\n          n.hasAnyZOffset && e.w(`${n.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);\n        } else if (n.hasAnyZOffset) {\n          const e = n.getSortedIndexesByZOffset();\n          for (let t = 0; t < e.length; ++t) {\n            const i = e[t];\n            k(n.symbolInstances.get(i), i, n.collisionArrays[i]);\n          }\n        } else for (let e = t.symbolInstanceStart; e < t.symbolInstanceEnd; e++) k(n.symbolInstances.get(e), e, n.collisionArrays[e]);\n        if (o && n.bucketInstanceId in this.collisionCircleArrays) {\n          const t = this.collisionCircleArrays[n.bucketInstanceId];\n          e.ad.mat4.invert(t.invProjMatrix, c), t.viewportMatrix = this.collisionIndex.getViewportMatrix();\n        }\n        n.justReloaded = !1;\n      }\n      markUsedJustification(t, i, o, s) {\n        const {\n            leftJustifiedTextSymbolIndex: r,\n            centerJustifiedTextSymbolIndex: n,\n            rightJustifiedTextSymbolIndex: a,\n            verticalPlacedTextSymbolIndex: l,\n            crossTileID: c\n          } = o,\n          h = e.bB(i),\n          d = s === e.bq.vertical ? l : \"left\" === h ? r : \"center\" === h ? n : \"right\" === h ? a : -1;\n        r >= 0 && (t.text.placedSymbolArray.get(r).crossTileID = d >= 0 && r !== d ? 0 : c), n >= 0 && (t.text.placedSymbolArray.get(n).crossTileID = d >= 0 && n !== d ? 0 : c), a >= 0 && (t.text.placedSymbolArray.get(a).crossTileID = d >= 0 && a !== d ? 0 : c), l >= 0 && (t.text.placedSymbolArray.get(l).crossTileID = d >= 0 && l !== d ? 0 : c);\n      }\n      markUsedOrientation(t, i, o) {\n        const s = i === e.bq.horizontal || i === e.bq.horizontalOnly ? i : 0,\n          r = i === e.bq.vertical ? i : 0,\n          {\n            leftJustifiedTextSymbolIndex: n,\n            centerJustifiedTextSymbolIndex: a,\n            rightJustifiedTextSymbolIndex: l,\n            verticalPlacedTextSymbolIndex: c\n          } = o,\n          h = t.text.placedSymbolArray;\n        n >= 0 && (h.get(n).placedOrientation = s), a >= 0 && (h.get(a).placedOrientation = s), l >= 0 && (h.get(l).placedOrientation = s), c >= 0 && (h.get(c).placedOrientation = r);\n      }\n      commit(e) {\n        this.commitTime = e, this.zoomAtLastRecencyCheck = this.transform.zoom;\n        const t = this.prevPlacement;\n        let i = !1;\n        this.prevZoomAdjustment = t ? t.zoomAdjustment(this.transform.zoom) : 0;\n        const o = t ? t.symbolFadeChange(e) : 1,\n          s = t ? t.opacities : {},\n          r = t ? t.variableOffsets : {},\n          n = t ? t.placedOrientations : {};\n        for (const e in this.placements) {\n          const t = this.placements[e],\n            r = s[e];\n          r ? (this.opacities[e] = new di(r, o, t.text, t.icon, null, t.clipped), i = i || t.text !== r.text.placed || t.icon !== r.icon.placed) : (this.opacities[e] = new di(null, o, t.text, t.icon, t.skipFade, t.clipped), i = i || t.text || t.icon);\n        }\n        for (const e in s) {\n          const t = s[e];\n          if (!this.opacities[e]) {\n            const s = new di(t, o, !1, !1);\n            s.isHidden() || (this.opacities[e] = s, i = i || t.text.placed || t.icon.placed);\n          }\n        }\n        for (const e in r) this.variableOffsets[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.variableOffsets[e] = r[e]);\n        for (const e in n) this.placedOrientations[e] || !this.opacities[e] || this.opacities[e].isHidden() || (this.placedOrientations[e] = n[e]);\n        i ? this.lastPlacementChangeTime = e : \"number\" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t ? t.lastPlacementChangeTime : e);\n      }\n      updateLayerOpacities(e, t, i, o) {\n        const s = new Set();\n        for (const r of t) {\n          const t = r.getBucket(e);\n          t && r.latestFeatureIndex && e.fqid === t.layerIds[0] && (this.updateBucketOpacities(t, s, r, r.collisionBoxArray, i, o, r.tileID, e.scope), \"offset\" === t.elevationType && this.buildingIndex && this.buildingIndex.updateZOffset(t, r.tileID), \"road\" === t.elevationType && t.updateRoadElevation(), t.updateZOffset());\n        }\n      }\n      updateBucketOpacities(t, i, o, s, r, n, a, l) {\n        t.hasTextData() && t.text.opacityVertexArray.clear(), t.hasIconData() && t.icon.opacityVertexArray.clear(), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();\n        const c = t.layers[0].layout,\n          h = t.layers[0].paint,\n          d = !!t.layers[0].dynamicFilter(),\n          u = new di(null, 0, !1, !1, !0),\n          _ = c.get(\"text-allow-overlap\"),\n          p = c.get(\"icon-allow-overlap\"),\n          f = c.get(\"text-variable-anchor\"),\n          m = \"map\" === c.get(\"text-rotation-alignment\"),\n          g = \"map\" === c.get(\"text-pitch-alignment\"),\n          v = h.get(\"symbol-z-offset\"),\n          y = \"sea\" === c.get(\"symbol-elevation-reference\"),\n          x = !v.isConstant(),\n          b = new di(null, 0, _ && (p || !t.hasIconData() || c.get(\"icon-optional\")), p && (_ || !t.hasTextData() || c.get(\"text-optional\")), !0);\n        !t.collisionArrays && s && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(s);\n        const w = (e, t, i) => {\n          for (let o = 0; o < t / 4; o++) e.opacityVertexArray.emplaceBack(i);\n        };\n        let T = 0;\n        n && t.updateReplacement(a, n);\n        for (let s = 0; s < t.symbolInstances.length; s++) {\n          const c = t.symbolInstances.get(s),\n            {\n              numHorizontalGlyphVertices: h,\n              numVerticalGlyphVertices: _,\n              crossTileID: p,\n              numIconVertices: E,\n              tileAnchorX: S,\n              tileAnchorY: C\n            } = c;\n          let I = null;\n          const R = this.retainedQueryData[t.bucketInstanceId];\n          x && c && R && (I = o.latestFeatureIndex.loadFeature({\n            featureIndex: c.featureIndex,\n            bucketIndex: R.bucketIndex,\n            sourceLayerIndex: R.sourceLayerIndex,\n            layoutVertexArrayOffset: 0\n          }));\n          const D = v.evaluate(I, {}),\n            A = i.has(p);\n          let L = this.opacities[p];\n          A ? L = u : L || (L = b, this.opacities[p] = L), i.add(p);\n          const M = h > 0 || _ > 0,\n            P = E > 0,\n            z = this.placedOrientations[p],\n            O = z === e.bq.vertical,\n            F = z === e.bq.horizontal || z === e.bq.horizontalOnly;\n          !M && !P || L.isHidden() || T++;\n          let k = !1;\n          if ((M || P) && n) for (const i of t.activeReplacements) {\n            if (e.bx(i, r, e.by.Symbol, l)) continue;\n            if (i.min.x > S || S > i.max.x || i.min.y > C || C > i.max.y) continue;\n            const t = e.bz(S, C, a.canonical, i.footprintTileId.canonical);\n            if (k = e.bA(t, i.footprint), k) break;\n          }\n          if (M) {\n            const e = k ? Ri : Ii(L.text);\n            w(t.text, h, O ? Ri : e), w(t.text, _, F ? Ri : e);\n            const i = L.text.isHidden(),\n              {\n                leftJustifiedTextSymbolIndex: o,\n                centerJustifiedTextSymbolIndex: s,\n                rightJustifiedTextSymbolIndex: r,\n                verticalPlacedTextSymbolIndex: n\n              } = c,\n              a = t.text.placedSymbolArray,\n              l = i || O ? 1 : 0;\n            o >= 0 && (a.get(o).hidden = l), s >= 0 && (a.get(s).hidden = l), r >= 0 && (a.get(r).hidden = l), n >= 0 && (a.get(n).hidden = i || F ? 1 : 0);\n            const d = this.variableOffsets[p];\n            d && this.markUsedJustification(t, d.anchor, c, z);\n            const u = this.placedOrientations[p];\n            u && (this.markUsedJustification(t, \"left\", c, u), this.markUsedOrientation(t, u, c));\n          }\n          if (P) {\n            const e = k ? Ri : Ii(L.icon),\n              {\n                placedIconSymbolIndex: i,\n                verticalPlacedIconSymbolIndex: o\n              } = c,\n              s = t.icon.placedSymbolArray,\n              r = L.icon.isHidden() ? 1 : 0;\n            i >= 0 && (w(t.icon, E, O ? Ri : e), s.get(i).hidden = r), o >= 0 && (w(t.icon, c.numVerticalIconVertices, F ? Ri : e), s.get(o).hidden = r);\n          }\n          if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {\n            const i = t.collisionArrays[s];\n            if (i) {\n              let o = new e.P(0, 0),\n                s = !0;\n              if (i.textBox || i.verticalTextBox) {\n                if (f) {\n                  const e = this.variableOffsets[p];\n                  e ? (o = mi(e.anchor, e.width, e.height, e.textOffset, e.textScale), m && o._rotate(g ? this.transform.angle : -this.transform.angle)) : s = !1;\n                }\n                d && (s = !L.clipped), i.textBox && yi(t.textCollisionBox.collisionVertexArray, L.text.placed, !s || O, D, y, o.x, o.y), i.verticalTextBox && yi(t.textCollisionBox.collisionVertexArray, L.text.placed, !s || F, D, y, o.x, o.y);\n              }\n              const r = s && Boolean(!F && i.verticalIconBox);\n              i.iconBox && yi(t.iconCollisionBox.collisionVertexArray, L.icon.placed, r, D, y, c.hasIconTextFit ? o.x : 0, c.hasIconTextFit ? o.y : 0), i.verticalIconBox && yi(t.iconCollisionBox.collisionVertexArray, L.icon.placed, !r, D, y, c.hasIconTextFit ? o.x : 0, c.hasIconTextFit ? o.y : 0);\n            }\n          }\n        }\n        if (t.fullyClipped = 0 === T, t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.bucketInstanceId in this.collisionCircleArrays) {\n          const e = this.collisionCircleArrays[t.bucketInstanceId];\n          t.placementInvProjMatrix = e.invProjMatrix, t.placementViewportMatrix = e.viewportMatrix, t.collisionCircleArray = e.circles, delete this.collisionCircleArrays[t.bucketInstanceId];\n        }\n      }\n      symbolFadeChange(e) {\n        return 0 === this.fadeDuration ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;\n      }\n      zoomAdjustment(e) {\n        return Math.max(0, (this.transform.zoom - e) / 1.5);\n      }\n      hasTransitions(e) {\n        return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration;\n      }\n      stillRecent(e, t) {\n        const i = this.zoomAtLastRecencyCheck === t ? 1 - this.zoomAdjustment(t) : 1;\n        return this.zoomAtLastRecencyCheck = t, this.commitTime + this.fadeDuration * i > e;\n      }\n      setStale() {\n        this.stale = !0;\n      }\n    }\n    function yi(e, t, i, o, s, r, n) {\n      e.emplaceBack(t ? 1 : 0, i ? 1 : 0, r || 0, n || 0, o, s ? 1 : 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, r || 0, n || 0, o, s ? 1 : 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, r || 0, n || 0, o, s ? 1 : 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, r || 0, n || 0, o, s ? 1 : 0);\n    }\n    const xi = Math.pow(2, 25),\n      bi = Math.pow(2, 24),\n      wi = Math.pow(2, 17),\n      Ti = Math.pow(2, 16),\n      Ei = Math.pow(2, 9),\n      Si = Math.pow(2, 8),\n      Ci = Math.pow(2, 1);\n    function Ii(e) {\n      if (0 === e.opacity && !e.placed) return 0;\n      if (1 === e.opacity && e.placed) return 4294967295;\n      const t = e.placed ? 1 : 0,\n        i = Math.floor(127 * e.opacity);\n      return i * xi + t * bi + i * wi + t * Ti + i * Ei + t * Si + i * Ci + t;\n    }\n    const Ri = 0;\n    class Di {\n      constructor(e) {\n        this._sortAcrossTiles = \"viewport-y\" !== e.layout.get(\"symbol-z-order\") && void 0 !== e.layout.get(\"symbol-sort-key\").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = new Set(), this._bucketParts = [];\n      }\n      continuePlacement(e, t, i, o, s, r) {\n        const n = this._bucketParts;\n        for (; this._currentTileIndex < e.length;) if (t.getBucketParts(n, o, e[this._currentTileIndex], this._sortAcrossTiles, r), this._currentTileIndex++, s()) return !0;\n        for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, n.sort((e, t) => e.sortKey - t.sortKey)); this._currentPartIndex < n.length;) {\n          const e = n[this._currentPartIndex];\n          if (t.placeLayerBucketPart(e, this._seenCrossTileIDs, i, 0 === e.symbolInstanceStart, r), this._currentPartIndex++, s()) return !0;\n        }\n        return !1;\n      }\n    }\n    class Ai {\n      constructor(e, t, i, o, s, r, n, a, l) {\n        this.placement = new vi(e, s, r, n, a, l), this._currentPlacementIndex = t.length - 1, this._forceFullPlacement = i, this._showCollisionBoxes = o, this._done = !1;\n      }\n      isDone() {\n        return this._done;\n      }\n      continuePlacement(t, i, o, s, r) {\n        const n = e.q.now(),\n          a = () => {\n            const t = e.q.now() - n;\n            return !this._forceFullPlacement && t > 2;\n          };\n        for (; this._currentPlacementIndex >= 0;) {\n          const n = i[t[this._currentPlacementIndex]],\n            l = this.placement.collisionIndex.transform.zoom;\n          if (\"symbol\" === n.type && (!n.minzoom || n.minzoom <= l) && (!n.maxzoom || n.maxzoom > l)) {\n            const t = n,\n              i = t.layout.get(\"symbol-z-elevate\"),\n              l = void 0 !== t.layout.get(\"symbol-sort-key\").constantOr(1),\n              c = t.layout.get(\"symbol-z-order\"),\n              h = \"viewport-y\" === c || \"auto\" === c && !(\"viewport-y\" !== c && l),\n              d = t.layout.get(\"text-allow-overlap\") || t.layout.get(\"icon-allow-overlap\") || t.layout.get(\"text-ignore-placement\") || t.layout.get(\"icon-ignore-placement\"),\n              u = h && d,\n              _ = this._inProgressLayer = this._inProgressLayer || new Di(t),\n              p = e.C(n.source, n.scope);\n            if (_.continuePlacement(i || u ? s[p] : o[p], this.placement, this._showCollisionBoxes, n, a, r)) return;\n            delete this._inProgressLayer;\n          }\n          this._currentPlacementIndex--;\n        }\n        this._done = !0;\n      }\n      commit(e) {\n        return this.placement.commit(e), this.placement;\n      }\n    }\n    const Li = 512 / e.ai / 2;\n    class Mi {\n      constructor(t, i, o) {\n        this.tileID = t, this.bucketInstanceId = o, this.index = new e.bE(i.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];\n        const s = t.canonical.x * e.ai,\n          r = t.canonical.y * e.ai;\n        for (let e = 0; e < i.length; e++) {\n          const {\n              key: t,\n              crossTileID: o,\n              tileAnchorX: n,\n              tileAnchorY: a\n            } = i.get(e),\n            l = Math.floor((s + n) * Li),\n            c = Math.floor((r + a) * Li);\n          this.index.add(l, c), this.keys.push(t), this.crossTileIDs.push(o);\n        }\n        this.index.finish();\n      }\n      findMatches(t, i, o) {\n        const s = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z),\n          r = Li / Math.pow(2, i.canonical.z - this.tileID.canonical.z),\n          n = i.canonical.x * e.ai,\n          a = i.canonical.y * e.ai;\n        for (let e = 0; e < t.length; e++) {\n          const i = t.get(e);\n          if (i.crossTileID) continue;\n          const {\n              key: l,\n              tileAnchorX: c,\n              tileAnchorY: h\n            } = i,\n            d = Math.floor((n + c) * r),\n            u = Math.floor((a + h) * r),\n            _ = this.index.range(d - s, u - s, d + s, u + s);\n          for (const e of _) {\n            const t = this.crossTileIDs[e];\n            if (this.keys[e] === l && !o.has(t)) {\n              o.add(t), i.crossTileID = t;\n              break;\n            }\n          }\n        }\n      }\n    }\n    class Pi {\n      constructor() {\n        this.maxCrossTileID = 0;\n      }\n      generate() {\n        return ++this.maxCrossTileID;\n      }\n    }\n    class zi {\n      constructor() {\n        this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;\n      }\n      handleWrapJump(e) {\n        const t = Math.round((e - this.lng) / 360);\n        if (0 !== t) for (const e in this.indexes) {\n          const i = this.indexes[e],\n            o = {};\n          for (const e in i) {\n            const s = i[e];\n            s.tileID = s.tileID.unwrapTo(s.tileID.wrap + t), o[s.tileID.key] = s;\n          }\n          this.indexes[e] = o;\n        }\n        this.lng = e;\n      }\n      addBucket(e, t, i) {\n        if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {\n          if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === t.bucketInstanceId) return !1;\n          this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key]);\n        }\n        for (let e = 0; e < t.symbolInstances.length; e++) t.symbolInstances.get(e).crossTileID = 0;\n        this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = new Set());\n        const o = this.usedCrossTileIDs[e.overscaledZ];\n        for (const i in this.indexes) {\n          const s = this.indexes[i];\n          if (Number(i) > e.overscaledZ) for (const i in s) {\n            const r = s[i];\n            r.tileID.isChildOf(e) && r.findMatches(t.symbolInstances, e, o);\n          } else {\n            const r = s[e.scaledTo(Number(i)).key];\n            r && r.findMatches(t.symbolInstances, e, o);\n          }\n        }\n        for (let e = 0; e < t.symbolInstances.length; e++) {\n          const s = t.symbolInstances.get(e);\n          s.crossTileID || (s.crossTileID = i.generate(), o.add(s.crossTileID));\n        }\n        return void 0 === this.indexes[e.overscaledZ] && (this.indexes[e.overscaledZ] = {}), this.indexes[e.overscaledZ][e.key] = new Mi(e, t.symbolInstances, t.bucketInstanceId), !0;\n      }\n      removeBucketCrossTileIDs(e, t) {\n        for (const i of t.crossTileIDs) this.usedCrossTileIDs[e].delete(i);\n      }\n      removeStaleBuckets(e) {\n        let t = !1;\n        for (const i in this.indexes) {\n          const o = this.indexes[i];\n          for (const s in o) e[o[s].bucketInstanceId] || (this.removeBucketCrossTileIDs(i, o[s]), delete o[s], t = !0);\n        }\n        return t;\n      }\n    }\n    class Oi {\n      constructor() {\n        this.layerIndexes = {}, this.crossTileIDs = new Pi(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};\n      }\n      addLayer(e, t, i, o) {\n        let s = this.layerIndexes[e.fqid];\n        void 0 === s && (s = this.layerIndexes[e.fqid] = new zi());\n        let r = !1;\n        const n = {};\n        \"globe\" !== o.name && s.handleWrapJump(i);\n        for (const i of t) {\n          const t = i.getBucket(e);\n          t && e.fqid === t.layerIds[0] && (t.bucketInstanceId || (t.bucketInstanceId = ++this.maxBucketInstanceId), s.addBucket(i.tileID, t, this.crossTileIDs) && (r = !0), n[t.bucketInstanceId] = !0);\n        }\n        return s.removeStaleBuckets(n) && (r = !0), r;\n      }\n      pruneUnusedLayers(e) {\n        const t = {};\n        e.forEach(e => {\n          t[e] = !0;\n        });\n        for (const e in this.layerIndexes) t[e] || delete this.layerIndexes[e];\n      }\n    }\n    const Fi = 771;\n    class ki {\n      constructor(e, t, i, o) {\n        this.blendFunction = e, this.blendColor = t, this.mask = i, this.blendEquation = o;\n      }\n    }\n    ki.Replace = [1, 0, 1, 0], ki.disabled = new ki(ki.Replace, e.al.transparent, [!1, !1, !1, !1]), ki.unblended = new ki(ki.Replace, e.al.transparent, [!0, !0, !0, !0]), ki.alphaBlended = new ki([1, Fi, 1, Fi], e.al.transparent, [!0, !0, !0, !0]), ki.alphaBlendedNonPremultiplied = new ki([770, Fi, 770, Fi], e.al.transparent, [!0, !0, !0, !0]), ki.multiply = new ki([774, 0, 774, 0], e.al.transparent, [!0, !0, !0, !0]);\n    class Bi {\n      constructor(e, t, i) {\n        this.func = e, this.mask = t, this.range = i;\n      }\n    }\n    Bi.ReadOnly = !1, Bi.ReadWrite = !0, Bi.disabled = new Bi(519, Bi.ReadOnly, [0, 1]);\n    const Ni = 7680;\n    class Ui {\n      constructor(e, t, i, o, s, r) {\n        this.test = e, this.ref = t, this.mask = i, this.fail = o, this.depthFail = s, this.pass = r;\n      }\n    }\n    Ui.disabled = new Ui({\n      func: 519,\n      mask: 0\n    }, 0, 0, Ni, Ni, Ni);\n    const Vi = 1029,\n      Gi = 2305;\n    class ji {\n      constructor(e, t, i) {\n        this.enable = e, this.mode = t, this.frontFace = i;\n      }\n    }\n    function qi(t, i) {\n      const o = e.bG(t, 3);\n      e.ad.mat4.fromQuat(t, i), e.bI(t, 3, o);\n    }\n    function Hi(t, i) {\n      const o = e.ad.quat.identity([]);\n      return e.ad.quat.rotateZ(o, o, -i), e.ad.quat.rotateX(o, o, -t), o;\n    }\n    function Zi(t, i) {\n      const o = [t[0], t[1], 0],\n        s = [i[0], i[1], 0];\n      if (e.ad.vec3.length(o) >= 1e-15) {\n        const t = e.ad.vec3.normalize([], o);\n        e.ad.vec3.scale(s, t, e.ad.vec3.dot(s, t)), i[0] = s[0], i[1] = s[1];\n      }\n      const r = e.ad.vec3.cross([], i, t);\n      if (e.ad.vec3.len(r) < 1e-15) return null;\n      const n = Math.atan2(-r[1], r[0]);\n      return Hi(Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2]), n);\n    }\n    ji.disabled = new ji(!1, Vi, Gi), ji.backCCW = new ji(!0, Vi, Gi), ji.backCW = new ji(!0, Vi, 2304), ji.frontCW = new ji(!0, 1028, 2304), ji.frontCCW = new ji(!0, 1028, Gi);\n    class Wi {\n      constructor(e, t) {\n        this.position = e, this.orientation = t;\n      }\n      get position() {\n        return this._position;\n      }\n      set position(t) {\n        if (t) {\n          const i = t instanceof e.ac ? t : new e.ac(t[0], t[1], t[2]);\n          this._renderWorldCopies && (i.x = e.bF(i.x, 0, 1)), this._position = i;\n        } else this._position = null;\n      }\n      lookAtPoint(t, i) {\n        if (this.orientation = null, !this.position) return;\n        const o = this.position,\n          s = this._elevation ? this._elevation.getAtPointOrZero(e.ac.fromLngLat(t)) : 0,\n          r = e.ac.fromLngLat(t, s),\n          n = [r.x - o.x, r.y - o.y, r.z - o.z];\n        i || (i = [0, 0, 1]), i[2] = Math.abs(i[2]), this.orientation = Zi(n, i);\n      }\n      setPitchBearing(t, i) {\n        this.orientation = Hi(e.ak(t), e.ak(-i));\n      }\n    }\n    class $i {\n      constructor(t, i) {\n        this._transform = e.ad.mat4.identity([]), this.orientation = i, this.position = t;\n      }\n      get mercatorPosition() {\n        const t = this.position;\n        return new e.ac(t[0], t[1], t[2]);\n      }\n      get position() {\n        const t = e.bG(this._transform, 3);\n        return [t[0], t[1], t[2]];\n      }\n      set position(t) {\n        var i;\n        t && e.bI(this._transform, 3, [(i = t)[0], i[1], i[2], 1]);\n      }\n      get orientation() {\n        return this._orientation;\n      }\n      set orientation(t) {\n        this._orientation = t || e.ad.quat.identity([]), t && qi(this._transform, this._orientation);\n      }\n      getPitchBearing() {\n        const e = this.forward(),\n          t = this.right();\n        return {\n          bearing: Math.atan2(-t[1], t[0]),\n          pitch: Math.atan2(Math.sqrt(e[0] * e[0] + e[1] * e[1]), -e[2])\n        };\n      }\n      setPitchBearing(e, t) {\n        this._orientation = Hi(e, t), qi(this._transform, this._orientation);\n      }\n      forward() {\n        const t = e.bG(this._transform, 2);\n        return [-t[0], -t[1], -t[2]];\n      }\n      up() {\n        const t = e.bG(this._transform, 1);\n        return [-t[0], -t[1], -t[2]];\n      }\n      right() {\n        const t = e.bG(this._transform, 0);\n        return [t[0], t[1], t[2]];\n      }\n      getCameraToWorld(t, i) {\n        const o = new Float64Array(16);\n        return e.ad.mat4.invert(o, this.getWorldToCamera(t, i)), o;\n      }\n      getCameraToWorldMercator() {\n        return this._transform;\n      }\n      getWorldToCameraPosition(t, i, o) {\n        const s = this.position;\n        e.ad.vec3.scale(s, s, -t);\n        const r = new Float64Array(16);\n        return e.ad.mat4.fromScaling(r, [o, o, o]), e.ad.mat4.translate(r, r, s), r[10] *= i, r;\n      }\n      getWorldToCamera(t, i) {\n        const o = new Float64Array(16),\n          s = new Float64Array(4),\n          r = this.position;\n        return e.ad.quat.conjugate(s, this._orientation), e.ad.vec3.scale(r, r, -t), e.ad.mat4.fromQuat(o, s), e.ad.mat4.translate(o, o, r), o[1] *= -1, o[5] *= -1, o[9] *= -1, o[13] *= -1, o[8] *= i, o[9] *= i, o[10] *= i, o[11] *= i, o;\n      }\n      getCameraToClipPerspective(t, i, o, s) {\n        const r = new Float64Array(16);\n        return e.ad.mat4.perspective(r, t, i, o, s), r;\n      }\n      getCameraToClipOrthographic(t, i, o, s, r, n) {\n        const a = new Float64Array(16);\n        return e.ad.mat4.ortho(a, t, i, o, s, r, n), a;\n      }\n      getDistanceToElevation(t, i = !1) {\n        const o = 0 === t ? 0 : e.bH(t, i ? e.aT(this.position[1]) : this.position[1]),\n          s = this.forward();\n        return (o - this.position[2]) / s[2];\n      }\n      clone() {\n        return new $i([...this.position], [...this.orientation]);\n      }\n    }\n    const Xi = {\n      BaseColor: 5,\n      MetallicRoughness: 6,\n      Normal: 7,\n      Occlusion: 8,\n      Emission: 9,\n      LUT: 10,\n      ShadowMap0: 11\n    };\n    class Ki {\n      constructor(e = 0, t = 0, i = 0, o = 0) {\n        if (isNaN(e) || e < 0 || isNaN(t) || t < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0) throw new Error(\"Invalid value for edge-insets, top, bottom, left and right must all be numbers\");\n        this.top = e, this.bottom = t, this.left = i, this.right = o;\n      }\n      interpolate(t, i, o) {\n        return null != i.top && null != t.top && (this.top = e.ah(t.top, i.top, o)), null != i.bottom && null != t.bottom && (this.bottom = e.ah(t.bottom, i.bottom, o)), null != i.left && null != t.left && (this.left = e.ah(t.left, i.left, o)), null != i.right && null != t.right && (this.right = e.ah(t.right, i.right, o)), this;\n      }\n      getCenter(t, i) {\n        const o = e.ay((this.left + t - this.right) / 2, 0, t),\n          s = e.ay((this.top + i - this.bottom) / 2, 0, i);\n        return new e.P(o, s);\n      }\n      equals(e) {\n        return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right;\n      }\n      clone() {\n        return new Ki(this.top, this.bottom, this.left, this.right);\n      }\n      toJSON() {\n        return {\n          top: this.top,\n          bottom: this.bottom,\n          left: this.left,\n          right: this.right\n        };\n      }\n    }\n    const Yi = 15;\n    class Ji {\n      constructor(t, i, o, s, r, n, a) {\n        this.tileSize = 512, this._renderWorldCopies = void 0 === r || r, this._minZoom = t || 0, this._maxZoom = i || 22, this._minPitch = o ?? 0, this._maxPitch = s ?? 60, this.setProjection(n), this.setMaxBounds(a), this.width = 0, this.height = 0, this._center = new e.bO(0, 0), this.zoom = 0, this.angle = 0, this._fov = .6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = !0, this._edgeInsets = new Ki(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new $i(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = \"ground\", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._tileCoverLift = 0, this.freezeTileCoverage = !1, this._horizonShift = .1, this._orthographicProjectionAtLowPitch = !1, this._allowWorldUnderZoom = !1;\n      }\n      clone() {\n        const e = new Ji(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection(), this.maxBounds);\n        return e._elevation = this._elevation, e._centerAltitude = this._centerAltitude, e._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e.tileSize = this.tileSize, e.mercatorFromTransition = this.mercatorFromTransition, e.width = this.width, e.height = this.height, e.cameraElevationReference = this.cameraElevationReference, e._center = this._center, e._setZoom(this.zoom), e._seaLevelZoom = this._seaLevelZoom, e.angle = this.angle, e._fov = this._fov, e._pitch = this._pitch, e._nearZ = this._nearZ, e._farZ = this._farZ, e._averageElevation = this._averageElevation, e._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, e._unmodified = this._unmodified, e._edgeInsets = this._edgeInsets.clone(), e._camera = this._camera.clone(), e._calcMatrices(), e.freezeTileCoverage = this.freezeTileCoverage, e.frustumCorners = this.frustumCorners, e._allowWorldUnderZoom = this._allowWorldUnderZoom, e;\n      }\n      get isOrthographic() {\n        return \"globe\" !== this.projection.name && this._orthographicProjectionAtLowPitch && this.pitch < Yi;\n      }\n      get elevation() {\n        return this._elevation;\n      }\n      set elevation(e) {\n        this._elevation !== e && (this._elevation = e, this._updateCameraOnTerrain(), this._calcMatrices());\n      }\n      get depthOcclusionForSymbolsAndCircles() {\n        return \"globe\" !== this.projection.name && !this.isOrthographic;\n      }\n      updateElevation(e, t = !1) {\n        const i = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;\n        (null == this._seaLevelZoom || i) && this._updateCameraOnTerrain(), (e || i) && this._constrainCamera(t), this._calcMatrices();\n      }\n      getProjection() {\n        return e.aA(this.projection, [\"name\", \"center\", \"parallels\"]);\n      }\n      setProjection(t) {\n        this.projectionOptions = t || {\n          name: \"mercator\"\n        };\n        const i = this.projection ? this.getProjection() : void 0;\n        this.projection = e.bP(this.projectionOptions);\n        const o = this.getProjection(),\n          s = !e.bn(i, o);\n        return s && this._calcMatrices(), this.mercatorFromTransition = !1, s;\n      }\n      setOrthographicProjectionAtLowPitch(e) {\n        return this._orthographicProjectionAtLowPitch !== e && (this._orthographicProjectionAtLowPitch = e, this._calcMatrices(), !0);\n      }\n      setMercatorFromTransition() {\n        const t = this.projection.name;\n        this.mercatorFromTransition = !0, this.projectionOptions = {\n          name: \"mercator\"\n        }, this.projection = e.bP({\n          name: \"mercator\"\n        });\n        const i = t !== this.projection.name;\n        return i && this._calcMatrices(), i;\n      }\n      get minZoom() {\n        return this._minZoom;\n      }\n      set minZoom(e) {\n        this._minZoom !== e && (this._minZoom = e, this.zoom = Math.max(this.zoom, e));\n      }\n      get maxZoom() {\n        return this._maxZoom;\n      }\n      set maxZoom(e) {\n        this._maxZoom !== e && (this._maxZoom = e, this.zoom = Math.min(this.zoom, e));\n      }\n      get minPitch() {\n        return this._minPitch;\n      }\n      set minPitch(e) {\n        this._minPitch !== e && (this._minPitch = e, this.pitch = Math.max(this.pitch, e));\n      }\n      get maxPitch() {\n        return this._maxPitch;\n      }\n      set maxPitch(e) {\n        this._maxPitch !== e && (this._maxPitch = e, this.pitch = Math.min(this.pitch, e));\n      }\n      get renderWorldCopies() {\n        return this._renderWorldCopies && !0 === this.projection.supportsWorldCopies;\n      }\n      set renderWorldCopies(e) {\n        void 0 === e ? e = !0 : null === e && (e = !1), this._renderWorldCopies = e;\n      }\n      get worldSize() {\n        return this.tileSize * this.scale;\n      }\n      get cameraWorldSizeForFog() {\n        const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);\n        return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));\n      }\n      get cameraWorldSize() {\n        const e = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);\n        return this._worldSizeFromZoom(this._zoomFromMercatorZ(e));\n      }\n      get pixelsPerMeter() {\n        return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);\n      }\n      get cameraPixelsPerMeter() {\n        return e.bH(1, this.center.lat) * this.cameraWorldSizeForFog;\n      }\n      get centerOffset() {\n        return this.centerPoint._sub(this.size._div(2));\n      }\n      get size() {\n        return new e.P(this.width, this.height);\n      }\n      get bearing() {\n        return e.bF(this.rotation, -180, 180);\n      }\n      set bearing(e) {\n        this.rotation = e;\n      }\n      get rotation() {\n        return -this.angle / Math.PI * 180;\n      }\n      set rotation(t) {\n        const i = -t * Math.PI / 180;\n        this.angle !== i && (this._unmodified = !1, this.angle = i, this._calcMatrices(), this.rotationMatrix = e.ad.mat2.create(), e.ad.mat2.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));\n      }\n      get pitch() {\n        return this._pitch / Math.PI * 180;\n      }\n      set pitch(t) {\n        const i = e.ay(t, this.minPitch, this.maxPitch) / 180 * Math.PI;\n        this._pitch !== i && (this._unmodified = !1, this._pitch = i, this._calcMatrices());\n      }\n      get aspect() {\n        return this.width / this.height;\n      }\n      get fov() {\n        return this._fov / Math.PI * 180;\n      }\n      set fov(t) {\n        t = Math.max(.01, Math.min(60, t)), this._fov !== t && (this._unmodified = !1, this._fov = e.ak(t), this._calcMatrices());\n      }\n      get fovX() {\n        return this._fov;\n      }\n      get fovY() {\n        const e = 1 / Math.tan(.5 * this.fovX);\n        return 2 * Math.atan(1 / this.aspect / e);\n      }\n      get averageElevation() {\n        return this._averageElevation;\n      }\n      set averageElevation(e) {\n        this._averageElevation = e, this._calcFogMatrices(), this._distanceTileDataCache = {};\n      }\n      get zoom() {\n        return this._zoom;\n      }\n      set zoom(e) {\n        const t = Math.min(Math.max(e, this.minZoom), this.maxZoom);\n        this._zoom !== t && (this._unmodified = !1, this._setZoom(t), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());\n      }\n      _setZoom(e) {\n        this._zoom = e, this.scale = this.zoomScale(e), this.tileZoom = Math.floor(e), this.zoomFraction = e - this.tileZoom;\n      }\n      get tileCoverLift() {\n        return this._tileCoverLift;\n      }\n      set tileCoverLift(e) {\n        this._tileCoverLift !== e && (this._tileCoverLift = e);\n      }\n      _updateCameraOnTerrain() {\n        const e = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY,\n          t = this.elevation && e === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;\n        if (!this._elevation || e === Number.NEGATIVE_INFINITY && (!t || !this._centerAltitude)) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);\n        const i = this._elevation;\n        t || this._centerAltitude && this._centerAltitudeValidForExaggeration && i.exaggeration() && this._centerAltitudeValidForExaggeration !== i.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * i.exaggeration(), this._centerAltitudeValidForExaggeration = i.exaggeration()) : (this._centerAltitude = e || 0, this._centerAltitudeValidForExaggeration = i.exaggeration()), this._updateSeaLevelZoom();\n      }\n      _updateSeaLevelZoom() {\n        void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));\n      }\n      sampleAverageElevation() {\n        if (!this._elevation) return 0;\n        const t = this._elevation,\n          i = [[.5, .2], [.3, .5], [.5, .5], [.7, .5], [.5, .8]],\n          o = this.horizonLineFromTop();\n        let s = 0,\n          r = 0;\n        for (let n = 0; n < i.length; n++) {\n          const a = new e.P(i[n][0] * this.width, o + i[n][1] * (this.height - o)),\n            l = t.pointCoordinate(a);\n          if (!l) continue;\n          const c = 1 / Math.hypot(l[0] - this._camera.position[0], l[1] - this._camera.position[1]);\n          s += l[3] * c, r += c;\n        }\n        return 0 === r ? NaN : s / r;\n      }\n      get center() {\n        return this._center;\n      }\n      set center(e) {\n        e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1, this._center = e, this._terrainEnabled() && (\"ground\" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());\n      }\n      _updateZoomFromElevation() {\n        if (null == this._seaLevelZoom || !this._elevation) return;\n        const e = this._seaLevelZoom,\n          t = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)),\n          i = this.pixelsPerMeter / this.worldSize * t,\n          o = this._mercatorZfromZoom(e),\n          s = this._mercatorZfromZoom(this._maxZoom),\n          r = Math.max(o - i, s);\n        this._setZoom(this._zoomFromMercatorZ(r));\n      }\n      get padding() {\n        return this._edgeInsets.toJSON();\n      }\n      set padding(e) {\n        this._edgeInsets.equals(e) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, e, 1), this._calcMatrices());\n      }\n      computeZoomRelativeTo(t) {\n        const i = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t.toAltitude()));\n        let o;\n        o = t.z < this._camera.position[2] ? [i.x, i.y, i.z] : [t.x, t.y, t.z];\n        const s = e.ad.vec3.length(e.ad.vec3.sub([], this._camera.position, o));\n        return e.ay(this._zoomFromMercatorZ(s), this._minZoom, this._maxZoom);\n      }\n      setFreeCameraOptions(t) {\n        if (!this.height) return;\n        if (!t.position && !t.orientation) return;\n        this._updateCameraState();\n        let i = !1;\n        if (t.orientation && !e.ad.quat.exactEquals(t.orientation, this._camera.orientation) && (i = this._setCameraOrientation(t.orientation)), t.position) {\n          const o = [t.position.x, t.position.y, t.position.z];\n          e.ad.vec3.exactEquals(o, this._camera.position) || (this._setCameraPosition(o), i = !0);\n        }\n        i && (this._updateStateFromCamera(), this.recenterOnTerrain());\n      }\n      getFreeCameraOptions() {\n        this._updateCameraState();\n        const t = this._camera.position,\n          i = new Wi();\n        return i.position = new e.ac(t[0], t[1], t[2]), i.orientation = this._camera.orientation, i._elevation = this.elevation, i._renderWorldCopies = this.renderWorldCopies, i;\n      }\n      _setCameraOrientation(t) {\n        if (!e.ad.quat.length(t)) return !1;\n        e.ad.quat.normalize(t, t);\n        const i = e.ad.vec3.transformQuat([], [0, 0, -1], t),\n          o = e.ad.vec3.transformQuat([], [0, -1, 0], t);\n        if (o[2] < 0) return !1;\n        const s = Zi(i, o);\n        return !!s && (this._camera.orientation = s, !0);\n      }\n      _setCameraPosition(t) {\n        const i = this.zoomScale(this.minZoom) * this.tileSize,\n          o = this.zoomScale(this.maxZoom) * this.tileSize,\n          s = this.cameraToCenterDistance;\n        t[2] = e.ay(t[2], s / o, s / i), this._camera.position = t;\n      }\n      get centerPoint() {\n        return this._edgeInsets.getCenter(this.width, this.height);\n      }\n      get fovAboveCenter() {\n        return this._fov * (.5 + this.centerOffset.y / this.height);\n      }\n      isPaddingEqual(e) {\n        return this._edgeInsets.equals(e);\n      }\n      interpolatePadding(e, t, i) {\n        this._unmodified = !1, this._edgeInsets.interpolate(e, t, i), this._constrain(), this._calcMatrices();\n      }\n      coveringZoomLevel(e) {\n        const t = (e.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e.tileSize));\n        return Math.max(0, t);\n      }\n      getVisibleUnwrappedCoordinates(t) {\n        const i = [new e.bQ(0, t)];\n        if (this.renderWorldCopies) {\n          const o = this.pointCoordinate(new e.P(0, 0)),\n            s = this.pointCoordinate(new e.P(this.width, 0)),\n            r = this.pointCoordinate(new e.P(this.width, this.height)),\n            n = this.pointCoordinate(new e.P(0, this.height)),\n            a = Math.floor(Math.min(o.x, s.x, r.x, n.x)),\n            l = Math.floor(Math.max(o.x, s.x, r.x, n.x)),\n            c = 1;\n          for (let o = a - c; o <= l + c; o++) 0 !== o && i.push(new e.bQ(o, t));\n        }\n        return i;\n      }\n      isLODDisabled(e) {\n        return (!e || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;\n      }\n      extendTileCover(t, i, o) {\n        let s = [];\n        const r = void 0 !== o,\n          n = !r;\n        if (n && this.zoom < i) return s;\n        if (r && 0 === o[0] && 0 === o[1]) return s;\n        const a = new Set(),\n          l = (t, i, o, r, n) => {\n            const l = e.c5(i, t, o, r, n);\n            a.has(l) || (s.push(new e.aH(t, i, o, r, n)), a.add(l));\n          };\n        for (let e = 0; e < t.length; e++) {\n          const s = t[e];\n          if (n && s.canonical.z !== i) continue;\n          const a = s.canonical,\n            c = s.overscaledZ,\n            h = s.wrap,\n            d = 1 << a.z,\n            u = a.x + 1 < d,\n            _ = a.x > 0,\n            p = a.y + 1 < d,\n            f = a.y > 0,\n            m = s.wrap - (_ ? 0 : 1),\n            g = s.wrap + (u ? 0 : 1),\n            v = _ ? a.x - 1 : d - 1,\n            y = u ? a.x + 1 : 0;\n          if (r) o[0] < 0 ? (l(c, g, a.z, y, a.y), o[1] < 0 && p && (l(c, h, a.z, a.x, a.y + 1), l(c, g, a.z, y, a.y + 1)), o[1] > 0 && f && (l(c, h, a.z, a.x, a.y - 1), l(c, g, a.z, y, a.y - 1))) : o[0] > 0 ? (l(c, m, a.z, v, a.y), o[1] < 0 && p && (l(c, h, a.z, a.x, a.y + 1), l(c, m, a.z, v, a.y + 1)), o[1] > 0 && f && (l(c, h, a.z, a.x, a.y - 1), l(c, m, a.z, v, a.y - 1))) : o[1] < 0 && p ? l(c, h, a.z, a.x, a.y + 1) : f && l(c, h, a.z, a.x, a.y - 1);else {\n            const e = s.visibleQuadrants;\n            1 & e && (l(c, m, a.z, v, a.y), f && (l(c, h, a.z, a.x, a.y - 1), l(c, m, a.z, v, a.y - 1))), 2 & e && (l(c, g, a.z, y, a.y), f && (l(c, h, a.z, a.x, a.y - 1), l(c, g, a.z, y, a.y - 1))), 4 & e && (l(c, m, a.z, v, a.y), p && (l(c, h, a.z, a.x, a.y + 1), l(c, m, a.z, v, a.y + 1))), 8 & e && (l(c, g, a.z, y, a.y), p && (l(c, h, a.z, a.x, a.y + 1), l(c, g, a.z, y, a.y + 1)));\n          }\n        }\n        const c = [];\n        for (const e of s) s.some(t => e.isChildOf(t)) || c.push(e);\n        if (s = c.filter(e => !t.some(t => !!(e.overscaledZ < i && t.isChildOf(e)) || e.equals(t) || e.isChildOf(t))), n) {\n          const e = 1 << i,\n            t = \"globe\" === this.projection.name ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()),\n            o = [e * t.x, e * t.y],\n            r = 4,\n            n = r * r;\n          s = s.filter(e => {\n            const t = e.canonical.x + .5 - o[0],\n              i = e.canonical.y + .5 - o[1];\n            return t * t + i * i < n;\n          });\n        }\n        return s;\n      }\n      coveringTiles(t) {\n        let i = this.coveringZoomLevel(t);\n        const o = i,\n          s = this.elevation && this.elevation.exaggeration(),\n          r = s && !t.isTerrainDEM,\n          n = \"mercator\" === this.projection.name;\n        if (void 0 !== t.minzoom && i < t.minzoom) return [];\n        void 0 !== t.maxzoom && i > t.maxzoom && (i = t.maxzoom);\n        const a = this.locationCoordinate(this.center),\n          l = this.center.lat,\n          c = 1 << i,\n          h = [c * a.x, c * a.y, 0],\n          d = \"globe\" === this.projection.name,\n          u = !d,\n          _ = e.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i, u),\n          p = d ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()),\n          f = c * e.bH(1, this.center.lat),\n          m = this._camera.position[2] / e.bH(1, this.center.lat),\n          g = [c * p.x, c * p.y, m * (u ? 1 : f)],\n          v = d || s,\n          y = this.cameraToCenterDistance / t.tileSize * (t.roundZoom ? 1 : .502),\n          x = this.isLODDisabled(!0) ? i : 0;\n        let b;\n        if (this._elevation && t.isTerrainDEM) b = 1e4 * this._elevation.exaggeration();else if (this._elevation) {\n          const e = this._elevation.getMinMaxForVisibleTiles();\n          b = e ? e.max : this._centerAltitude;\n        } else b = this._centerAltitude;\n        const w = t.isTerrainDEM ? -b : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0,\n          T = this.projection.isReprojectedInTileSpace ? e.bS(this) : 1,\n          E = t => {\n            const i = 1 / 4e4,\n              o = new e.ac(t.x + i, t.y, t.z),\n              s = new e.ac(t.x, t.y + i, t.z),\n              r = t.toLngLat(),\n              n = o.toLngLat(),\n              a = s.toLngLat(),\n              l = this.locationCoordinate(r),\n              c = this.locationCoordinate(n),\n              h = this.locationCoordinate(a),\n              d = Math.hypot(c.x - l.x, c.y - l.y),\n              u = Math.hypot(h.x - l.x, h.y - l.y);\n            return Math.sqrt(d * u) * T / i;\n          },\n          S = t => {\n            const i = b,\n              o = w;\n            return {\n              aabb: e.bV(this, c, 0, 0, 0, t, o, i, this.projection),\n              zoom: 0,\n              x: 0,\n              y: 0,\n              minZ: o,\n              maxZ: i,\n              wrap: t,\n              fullyVisible: !1\n            };\n          },\n          C = [];\n        let I = [];\n        const R = i,\n          D = t.reparseOverscaled ? o : i,\n          A = (m - this._centerAltitude) * f,\n          L = e => {\n            if (!this._elevation || !e.tileID || !n) return;\n            const t = this._elevation.getMinMaxForTile(e.tileID),\n              i = e.aabb;\n            t ? (i.min[2] = t.min, i.max[2] = t.max, i.center[2] = (i.min[2] + i.max[2]) / 2) : (e.shouldSplit = P(e), e.shouldSplit || (i.min[2] = i.max[2] = i.center[2] = this._centerAltitude));\n          },\n          M = (e, t) => {\n            if (.707 * t < e) return 1;\n            const i = t / e;\n            return i / (1.4144271570014144 + (Math.pow(1.1, i - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);\n          },\n          P = t => {\n            if (t.zoom < x) return !0;\n            if (t.zoom === R) return !1;\n            if (null != t.shouldSplit) return t.shouldSplit;\n            const i = t.aabb.distanceX(g),\n              s = t.aabb.distanceY(g);\n            let a = A,\n              c = 1;\n            if (d) {\n              a = t.aabb.distanceZ(g);\n              const i = Math.pow(2, t.zoom),\n                o = e.aT((t.y + 1) / i),\n                s = e.aT(t.y / i),\n                r = Math.min(Math.max(l, o), s),\n                n = e.ca(r) / e.ca(l);\n              if (c = r === l ? 1 / Math.max(1, this._mercatorScaleRatio - .3) : Math.min(1, n / this._mercatorScaleRatio), this.zoom <= e.c6 && t.zoom === R - 1 && n >= .9) return !0;\n            } else if (r && (a = t.aabb.distanceZ(g) * f), this.projection.isReprojectedInTileSpace && o <= 5) {\n              const i = Math.pow(2, t.zoom),\n                o = E(new e.ac((t.x + .5) / i, (t.y + .5) / i));\n              c = o > .85 ? 1 : o;\n            }\n            if (!n) {\n              const e = Math.sqrt(i * i + s * s + a * a);\n              let o = (1 << R - t.zoom) * y * c;\n              return o *= M(Math.max(a, A), e), e < o;\n            }\n            let u = Number.MAX_VALUE,\n              _ = 0;\n            const p = t.aabb.getCorners(),\n              m = [];\n            for (const t of p) {\n              e.ad.vec3.sub(m, t, g), d || (r ? m[2] *= f : m[2] = A);\n              const i = e.ad.vec3.dot(m, this._camera.forward());\n              i < u && (u = i, _ = Math.abs(m[2]));\n            }\n            let v = (1 << R - t.zoom) * y * c;\n            if (v *= M(Math.max(_, A), u), u < v) return !0;\n            const b = t.aabb.closestPoint(h);\n            return b[0] === h[0] && b[1] === h[1];\n          };\n        if (this.renderWorldCopies) for (let e = 1; e <= 3; e++) C.push(S(-e)), C.push(S(e));\n        for (C.push(S(0)); C.length > 0;) {\n          const o = C.pop(),\n            s = o.x,\n            a = o.y;\n          let l = o.fullyVisible;\n          const u = () => \"globe\" === this.projection.name && (0 === o.y || o.y === (1 << o.zoom) - 1);\n          if (!l) {\n            let t = v ? o.aabb.intersects(_) : o.aabb.intersectsFlat(_);\n            if (0 === t && u()) {\n              const i = new e.bT(o.zoom, s, a);\n              t = e.bU(this, c, i, !0).intersects(_);\n            }\n            if (0 === t) continue;\n            l = 2 === t;\n          }\n          if (o.zoom !== R && P(o)) for (let t = 0; t < 4; t++) {\n            const i = (s << 1) + t % 2,\n              h = (a << 1) + (t >> 1),\n              u = {\n                aabb: n ? o.aabb.quadrant(t) : e.bV(this, c, o.zoom + 1, i, h, o.wrap, o.minZ, o.maxZ, this.projection),\n                zoom: o.zoom + 1,\n                x: i,\n                y: h,\n                wrap: o.wrap,\n                fullyVisible: l,\n                tileID: void 0,\n                shouldSplit: void 0,\n                minZ: o.minZ,\n                maxZ: o.maxZ\n              };\n            r && !d && (u.tileID = new e.aH(o.zoom + 1 === R ? D : o.zoom + 1, o.wrap, o.zoom + 1, i, h), L(u)), C.push(u);\n          } else {\n            const r = o.zoom === R ? D : o.zoom;\n            if (t.minzoom && t.minzoom > r) continue;\n            let n = 0;\n            if (!l) {\n              let i = v ? o.aabb.intersectsPrecise(_) : o.aabb.intersectsPreciseFlat(_);\n              if (0 === i && u()) {\n                const t = new e.bT(o.zoom, s, a);\n                i = e.bU(this, c, t, !0).intersectsPrecise(_);\n              }\n              if (0 === i) continue;\n              if (t.calculateQuadrantVisibility) if (_.containsPoint(o.aabb.center)) n = 15;else for (let e = 0; e < 4; e++) 0 !== o.aabb.quadrant(e).intersects(_) && (n |= 1 << e);\n            }\n            const d = h[0] - (.5 + s + (o.wrap << o.zoom)) * (1 << i - o.zoom),\n              p = h[1] - .5 - a,\n              f = o.tileID ? o.tileID : new e.aH(r, o.wrap, o.zoom, s, a);\n            t.calculateQuadrantVisibility && (f.visibleQuadrants = n), I.push({\n              tileID: f,\n              distanceSq: d * d + p * p\n            });\n          }\n        }\n        if (this.fogCullDistSq) {\n          const i = this.fogCullDistSq,\n            o = this.horizonLineFromTop();\n          I = I.filter(s => {\n            const r = [0, 0, 0, 1],\n              n = [e.ai, e.ai, 0, 1],\n              a = this.calculateFogTileMatrix(s.tileID.toUnwrapped());\n            e.ad.vec4.transformMat4(r, r, a), e.ad.vec4.transformMat4(n, n, a);\n            const l = e.ad.vec4.min([], r, n),\n              c = e.ad.vec4.max([], r, n),\n              h = e.bW(l, c);\n            if (0 === h) return !0;\n            let d = !1;\n            const u = this._elevation;\n            if (u && h > i && 0 !== o) {\n              const i = this.calculateProjMatrix(s.tileID.toUnwrapped());\n              let r;\n              t.isTerrainDEM || (r = u.getMinMaxForTile(s.tileID)), r || (r = {\n                min: w,\n                max: b\n              });\n              const n = e.c7(this.rotation),\n                a = [n[0] * e.ai, n[1] * e.ai, r.max];\n              e.ad.vec3.transformMat4(a, a, i), d = (1 - a[1]) * this.height * .5 < o;\n            }\n            return h < i || d;\n          });\n        }\n        return I.sort((e, t) => e.distanceSq - t.distanceSq).map(e => e.tileID);\n      }\n      resize(e, t) {\n        this.width = e, this.height = t, this.pixelsToGLUnits = [2 / e, -2 / t], this._constrain(), this._calcMatrices();\n      }\n      get unmodified() {\n        return this._unmodified;\n      }\n      zoomScale(e) {\n        return Math.pow(2, e);\n      }\n      scaleZoom(e) {\n        return Math.log(e) / Math.LN2;\n      }\n      project(t) {\n        const i = e.ay(t.lat, -e.bX, e.bX),\n          o = this.projection.project(t.lng, i);\n        return new e.P(o.x * this.worldSize, o.y * this.worldSize);\n      }\n      unproject(e) {\n        return this.projection.unproject(e.x / this.worldSize, e.y / this.worldSize);\n      }\n      get point() {\n        return this.project(this.center);\n      }\n      get pointMerc() {\n        return this.point._div(this.worldSize);\n      }\n      get pixelsPerMeterRatio() {\n        return this.pixelsPerMeter / e.bH(1, this.center.lat) / this.worldSize;\n      }\n      setLocationAtPoint(t, i) {\n        let o, s;\n        const r = this.centerPoint;\n        if (\"globe\" === this.projection.name) {\n          const e = this.worldSize;\n          o = (i.x - r.x) / e, s = (i.y - r.y) / e;\n        } else {\n          const e = this.pointCoordinate(i),\n            t = this.pointCoordinate(r);\n          o = e.x - t.x, s = e.y - t.y;\n        }\n        const n = this.locationCoordinate(t);\n        this.setLocation(new e.ac(n.x - o, n.y - s));\n      }\n      setLocation(e) {\n        this.center = this.coordinateLocation(e), this.projection.wrap && (this.center = this.center.wrap());\n      }\n      locationPoint(e, t) {\n        return this.projection.locationPoint(this, e, t);\n      }\n      locationPoint3D(e, t) {\n        return this.projection.locationPoint(this, e, t, !0);\n      }\n      pointLocation(e) {\n        return this.coordinateLocation(this.pointCoordinate(e));\n      }\n      pointLocation3D(e, t) {\n        return this.coordinateLocation(this.pointCoordinate3D(e, t));\n      }\n      locationCoordinate(t, i) {\n        const o = i ? e.bH(i, t.lat) : void 0,\n          s = this.projection.project(t.lng, t.lat);\n        return new e.ac(s.x, s.y, o);\n      }\n      coordinateLocation(e) {\n        return this.projection.unproject(e.x, e.y);\n      }\n      pointRayIntersection(t, i) {\n        const o = null != i ? i : this._centerAltitude,\n          s = [t.x, t.y, 0, 1],\n          r = [t.x, t.y, 1, 1];\n        e.ad.vec4.transformMat4(s, s, this.pixelMatrixInverse), e.ad.vec4.transformMat4(r, r, this.pixelMatrixInverse);\n        const n = r[3];\n        e.ad.vec4.scale(s, s, 1 / s[3]), e.ad.vec4.scale(r, r, 1 / n);\n        const a = s[2],\n          l = r[2];\n        return {\n          p0: s,\n          p1: r,\n          t: a === l ? 0 : (o - a) / (l - a)\n        };\n      }\n      screenPointToMercatorRay(t) {\n        const i = [t.x, t.y, 0, 1],\n          o = [t.x, t.y, 1, 1];\n        return e.ad.vec4.transformMat4(i, i, this.pixelMatrixInverse), e.ad.vec4.transformMat4(o, o, this.pixelMatrixInverse), e.ad.vec4.scale(i, i, 1 / i[3]), e.ad.vec4.scale(o, o, 1 / o[3]), i[2] = e.bH(i[2], this._center.lat) * this.worldSize, o[2] = e.bH(o[2], this._center.lat) * this.worldSize, e.ad.vec4.scale(i, i, 1 / this.worldSize), e.ad.vec4.scale(o, o, 1 / this.worldSize), new e.as([i[0], i[1], i[2]], e.ad.vec3.normalize([], e.ad.vec3.sub([], o, i)));\n      }\n      rayIntersectionCoordinate(t) {\n        const {\n            p0: i,\n            p1: o,\n            t: s\n          } = t,\n          r = e.bH(i[2], this._center.lat),\n          n = e.bH(o[2], this._center.lat);\n        return new e.ac(e.ah(i[0], o[0], s) / this.worldSize, e.ah(i[1], o[1], s) / this.worldSize, e.ah(r, n, s));\n      }\n      pointCoordinate(e, t = this._centerAltitude) {\n        return this.projection.pointCoordinate(this, e.x, e.y, t);\n      }\n      pointCoordinate3D(t, i) {\n        if (!this.elevation) return this.pointCoordinate(t, i);\n        let o = this.projection.pointCoordinate3D(this, t.x, t.y);\n        if (o) return new e.ac(o[0], o[1], o[2]);\n        let s = 0,\n          r = this.horizonLineFromTop();\n        if (t.y > r) return this.pointCoordinate(t, i);\n        const n = .02 * r,\n          a = t.clone();\n        for (let t = 0; t < 10 && r - s > n; t++) {\n          a.y = e.ah(s, r, .66);\n          const t = this.projection.pointCoordinate3D(this, a.x, a.y);\n          t ? (r = a.y, o = t) : s = a.y;\n        }\n        return o ? new e.ac(o[0], o[1], o[2]) : this.pointCoordinate(t);\n      }\n      isPointAboveHorizon(e) {\n        return this.projection.isPointAboveHorizon(this, e);\n      }\n      isPointOnSurface(t) {\n        if (t.y < 0 || t.y > this.height || t.x < 0 || t.x > this.width) return !1;\n        if (this.elevation || this.zoom >= e.bY) return !this.isPointAboveHorizon(t);\n        const i = this.pointCoordinate(t);\n        return i.y >= 0 && i.y <= 1;\n      }\n      _coordinatePoint(t, i) {\n        const o = i && this.elevation ? this.elevation.getAtPointOrZero(t, this._centerAltitude) : this._centerAltitude,\n          s = [t.x * this.worldSize, t.y * this.worldSize, o + t.toAltitude(), 1];\n        return e.ad.vec4.transformMat4(s, s, this.pixelMatrix), s[3] > 0 ? new e.P(s[0] / s[3], s[1] / s[3]) : new e.P(Number.MAX_VALUE, Number.MAX_VALUE);\n      }\n      _getBoundsNonRectangular() {\n        const {\n            top: t,\n            left: i\n          } = this._edgeInsets,\n          o = this.height - this._edgeInsets.bottom,\n          s = this.width - this._edgeInsets.right,\n          r = this.pointLocation3D(new e.P(i, t)),\n          n = this.pointLocation3D(new e.P(s, t)),\n          a = this.pointLocation3D(new e.P(s, o)),\n          l = this.pointLocation3D(new e.P(i, o));\n        let c = Math.min(r.lng, n.lng, a.lng, l.lng),\n          h = Math.max(r.lng, n.lng, a.lng, l.lng),\n          d = Math.min(r.lat, n.lat, a.lat, l.lat),\n          u = Math.max(r.lat, n.lat, a.lat, l.lat);\n        const _ = Math.pow(2, -this.zoom) / 16 * 270,\n          p = \"globe\" === this.projection.name ? 1 : 4,\n          f = (t, i, o, s, r) => {\n            const n = (t + o) / 2,\n              a = (i + s) / 2,\n              l = new e.P(n, a),\n              {\n                lng: m,\n                lat: g\n              } = this.pointLocation3D(l),\n              v = Math.max(0, c - m, d - g, m - h, g - u);\n            c = Math.min(c, m), h = Math.max(h, m), d = Math.min(d, g), u = Math.max(u, g), (r < p || v > _) && (f(t, i, n, a, r + 1), f(n, a, o, s, r + 1));\n          };\n        if (f(i, t, s, t, 1), f(s, t, s, o, 1), f(s, o, i, o, 1), f(i, o, i, t, 1), \"globe\" === this.projection.name) {\n          const [t, i] = e.bZ(this);\n          t ? (u = 90, h = 180, c = -180) : i && (d = -90, h = 180, c = -180);\n        }\n        return new e.aB(new e.bO(c, d), new e.bO(h, u));\n      }\n      _getBoundsRectangular(t, i) {\n        const {\n            top: o,\n            left: s\n          } = this._edgeInsets,\n          r = this.height - this._edgeInsets.bottom,\n          n = this.width - this._edgeInsets.right,\n          a = new e.P(s, o),\n          l = new e.P(n, o),\n          c = new e.P(n, r),\n          h = new e.P(s, r);\n        let d = this.pointCoordinate(a, t),\n          u = this.pointCoordinate(l, t);\n        const _ = this.pointCoordinate(c, i),\n          p = this.pointCoordinate(h, i),\n          f = (e, t) => (t.y - e.y) / (t.x - e.x);\n        return d.y > 1 && u.y >= 0 ? d = new e.ac((1 - p.y) / f(p, d) + p.x, 1) : d.y < 0 && u.y <= 1 && (d = new e.ac(-p.y / f(p, d) + p.x, 0)), u.y > 1 && d.y >= 0 ? u = new e.ac((1 - _.y) / f(_, u) + _.x, 1) : u.y < 0 && d.y <= 1 && (u = new e.ac(-_.y / f(_, u) + _.x, 0)), new e.aB().extend(this.coordinateLocation(d)).extend(this.coordinateLocation(u)).extend(this.coordinateLocation(p)).extend(this.coordinateLocation(_));\n      }\n      _getBoundsRectangularTerrain() {\n        const e = this.elevation;\n        if (!e.visibleDemTiles.length || e.isUsingMockSource()) return this._getBoundsRectangular(0, 0);\n        const t = e.visibleDemTiles.reduce((e, t) => {\n          if (t.dem) {\n            const i = t.dem.tree;\n            e.min = Math.min(e.min, i.minimums[0]), e.max = Math.max(e.max, i.maximums[0]);\n          }\n          return e;\n        }, {\n          min: Number.MAX_VALUE,\n          max: 0\n        });\n        return this._getBoundsRectangular(t.min * e.exaggeration(), t.max * e.exaggeration());\n      }\n      getBounds() {\n        return \"mercator\" === this.projection.name || \"equirectangular\" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();\n      }\n      horizonLineFromTop(e = !0) {\n        const t = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, .1)) - this.centerOffset.y,\n          i = this.height / 2 - t * (1 - this._horizonShift);\n        return e ? Math.max(0, i) : i;\n      }\n      getMaxBounds() {\n        return this.maxBounds;\n      }\n      setMaxBounds(t) {\n        this.maxBounds = t, this.minLat = -e.bX, this.maxLat = e.bX, this.minLng = -180, this.maxLng = 180, t && (this.minLat = t.getSouth(), this.maxLat = t.getNorth(), this.minLng = t.getWest(), this.maxLng = t.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.av(this.minLng) * this.tileSize, this.worldMaxX = e.av(this.maxLng) * this.tileSize, this.worldMinY = e.aC(this.maxLat) * this.tileSize, this.worldMaxY = e.aC(this.minLat) * this.tileSize, this._constrain();\n      }\n      calculatePosMatrix(e, t) {\n        return this.projection.createTileMatrix(this, t, e);\n      }\n      calculateDistanceTileData(t) {\n        const i = t.key,\n          o = this._distanceTileDataCache;\n        if (o[i]) return o[i];\n        const s = t.canonical,\n          r = 1 / this.height,\n          n = this.cameraWorldSize,\n          a = n / this.zoomScale(s.z),\n          l = (s.x + Math.pow(2, s.z) * t.wrap) * a,\n          c = s.y * a,\n          h = this.point;\n        h.x *= n / this.worldSize, h.y *= n / this.worldSize;\n        const d = this.angle,\n          u = Math.sin(-d),\n          _ = -Math.cos(-d);\n        return o[i] = {\n          bearing: [u, _],\n          center: [(h.x - l) * r, (h.y - c) * r],\n          scale: a / e.ai * r\n        }, o[i];\n      }\n      calculateFogTileMatrix(t) {\n        const i = t.key,\n          o = this._fogTileMatrixCache;\n        if (o[i]) return o[i];\n        const s = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t);\n        return e.ad.mat4.multiply(s, this.worldToFogMatrix, s), o[i] = new Float32Array(s), o[i];\n      }\n      calculateProjMatrix(t, i = !1, o = !1) {\n        const s = t.key;\n        let r;\n        if (r = o ? this._expandedProjMatrixCache : i ? this._alignedProjMatrixCache : this._projMatrixCache, r[s]) return r[s];\n        const n = this.calculatePosMatrix(t, this.worldSize);\n        let a;\n        return a = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : o ? this.expandedFarZProjMatrix : i ? this.alignedProjMatrix : this.projMatrix, e.ad.mat4.multiply(n, a, n), r[s] = new Float32Array(n), r[s];\n      }\n      calculatePixelsToTileUnitsMatrix(t) {\n        const i = t.tileID.key,\n          o = this._pixelsToTileUnitsCache;\n        if (o[i]) return o[i];\n        const s = e.b_(t, this);\n        return o[i] = s, o[i];\n      }\n      customLayerMatrix() {\n        return this.mercatorMatrix.slice();\n      }\n      globeToMercatorMatrix() {\n        if (\"globe\" === this.projection.name) {\n          const t = 1 / this.worldSize,\n            i = e.ad.mat4.fromScaling([], [t, t, t]);\n          return e.ad.mat4.multiply(i, i, this.globeMatrix), i;\n        }\n      }\n      recenterOnTerrain() {\n        if (!this._elevation || \"globe\" === this.projection.name) return;\n        const t = this._elevation;\n        this._updateCameraState();\n        const i = e.bH(1, this._center.lat) * this.worldSize,\n          o = this._computeCameraPosition(i),\n          s = this._camera.forward(),\n          r = e.bH(1, this._center.lat);\n        o[2] /= r, s[2] /= r, e.ad.vec3.normalize(s, s);\n        const n = t.raycast(o, s, t.exaggeration());\n        if (n) {\n          const t = e.ad.vec3.scaleAndAdd([], o, s, n),\n            i = new e.ac(t[0], t[1], e.bH(t[2], e.aT(t[1]))),\n            a = (i.z + e.ad.vec3.length([i.x - o[0], i.y - o[1], i.z - o[2] * r])) * this._pixelsPerMercatorPixel;\n          this._seaLevelZoom = this._zoomFromMercatorZ(a), this._centerAltitude = i.toAltitude(), this._center = this.coordinateLocation(i), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();\n        }\n      }\n      _constrainCamera(t = !1) {\n        if (!this._elevation) return;\n        const i = this._elevation,\n          o = e.bH(1, this._center.lat) * this.worldSize,\n          s = this._computeCameraPosition(o),\n          r = i.getAtPointOrZero(new e.ac(...s)),\n          n = this.pixelsPerMeter / this.worldSize * r,\n          a = this._minimumHeightOverTerrain(),\n          l = s[2] - n;\n        if (l <= a) if (l < 0 || t) {\n          const t = this.locationCoordinate(this._center, this._centerAltitude),\n            i = [s[0], s[1], t.z - s[2]],\n            o = e.ad.vec3.length(i);\n          i[2] -= (a - l) / this._pixelsPerMercatorPixel;\n          const r = e.ad.vec3.length(i);\n          if (0 === r) return;\n          e.ad.vec3.scale(i, i, o / r * this._pixelsPerMercatorPixel), this._camera.position = [s[0], s[1], t.z * this._pixelsPerMercatorPixel - i[2]], this._updateStateFromCamera();\n        } else this._isCameraConstrained = !0;\n      }\n      _constrain() {\n        if (!this.center || !this.width || !this.height || this._constraining) return;\n        this._constraining = !0;\n        const t = \"globe\" === this.projection.name || this.mercatorFromTransition;\n        if (this.projection.isReprojectedInTileSpace || t) {\n          const i = this.center;\n          return i.lat = e.ay(i.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t) && (i.lng = e.ay(i.lng, this.minLng, this.maxLng)), this.center = i, void (this._constraining = !1);\n        }\n        const i = this._unmodified,\n          {\n            x: o,\n            y: s\n          } = this.point;\n        let r = 0,\n          n = o,\n          a = s;\n        const l = this.width / 2,\n          c = this.height / 2,\n          h = this.worldMinY * this.scale,\n          d = this.worldMaxY * this.scale;\n        if (s - c < h && (a = h + c), s + c > d && (a = d - c), d - h < this.height && (r = Math.max(r, this.height / (d - h)), a = (d + h) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {\n          const e = this.worldMinX * this.scale,\n            t = this.worldMaxX * this.scale,\n            i = this.worldSize / 2 - (e + t) / 2;\n          n = (o + i + this.worldSize) % this.worldSize - i, n - l < e && (n = e + l), n + l > t && (n = t - l), t - e < this.width && (r = Math.max(r, this.width / (t - e)), n = (t + e) / 2);\n        }\n        n === o && a === s || this._allowWorldUnderZoom || (this.center = this.unproject(new e.P(n, a))), r && !this._allowWorldUnderZoom && (this.zoom += this.scaleZoom(r)), this._constrainCamera(), this._unmodified = i, this._constraining = !1;\n      }\n      _minZoomForBounds() {\n        let e = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));\n        return this.maxBounds && (e = Math.max(e, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e;\n      }\n      _maxCameraBoundsDistance() {\n        return this._mercatorZfromZoom(this._minZoomForBounds());\n      }\n      _calcMatrices() {\n        if (!this.height) return;\n        const t = this.centerOffset,\n          i = \"globe\" === this.projection.name,\n          o = this.pixelsPerMeter;\n        \"globe\" === this.projection.name && (this._mercatorScaleRatio = e.bH(1, this.center.lat) / e.bH(1, e.c8));\n        const s = e.b$(this.projection, this.zoom, this.width, this.height, 1024);\n        this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, s), this.cameraToCenterDistance = .5 / Math.tan(.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;\n        const r = \"meters\" === this.projection.zAxisUnit ? o : 1,\n          n = this._camera.getWorldToCamera(this.worldSize, r);\n        let a;\n        const l = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);\n        if (l[8] = 2 * -t.x / this.width, l[9] = 2 * t.y / this.height, this.isOrthographic) {\n          let i = .5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(.5 * this._fov),\n            o = i * this.aspect,\n            s = -o,\n            r = -i;\n          o -= t.x, s -= t.x, i += t.y, r += t.y, a = this._camera.getCameraToClipOrthographic(s, o, r, i, this._nearZ, this._farZ), ((t, i, o, s) => {\n            for (let r = 0; r < 16; r++) t[r] = e.ah(i[r], o[r], s);\n          })(a, a, l, e.c9(this.pitch >= Yi ? 1 : this.pitch / Yi));\n        } else a = l;\n        const c = e.ad.mat4.mul([], l, n);\n        let h = e.ad.mat4.mul([], a, n);\n        if (this.projection.isReprojectedInTileSpace) {\n          const t = this.locationCoordinate(this.center),\n            i = e.ad.mat4.identity([]);\n          e.ad.mat4.translate(i, i, [t.x * this.worldSize, t.y * this.worldSize, 0]), e.ad.mat4.multiply(i, i, e.c0(this)), e.ad.mat4.translate(i, i, [-t.x * this.worldSize, -t.y * this.worldSize, 0]), e.ad.mat4.multiply(h, h, i), e.ad.mat4.multiply(c, c, i), this.inverseAdjustmentMatrix = e.c1(this);\n        } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];\n        if (this.mercatorMatrix = e.ad.mat4.scale([], h, [this.worldSize, this.worldSize, this.worldSize / r, 1]), this.projMatrix = h, this.invProjMatrix = e.ad.mat4.invert(new Float64Array(16), this.projMatrix), i) {\n          const i = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);\n          i[8] = 2 * -t.x / this.width, i[9] = 2 * t.y / this.height, this.expandedFarZProjMatrix = e.ad.mat4.mul([], i, n);\n        } else this.expandedFarZProjMatrix = this.projMatrix;\n        const d = e.ad.mat4.invert([], a);\n        this.frustumCorners = e.c2.fromInvProjectionMatrix(d, this.horizonLineFromTop(), this.height), this.cameraFrustum = e.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !i);\n        const u = new Float32Array(16);\n        e.ad.mat4.identity(u), e.ad.mat4.scale(u, u, [1, -1, 1]), e.ad.mat4.rotateX(u, u, this._pitch), e.ad.mat4.rotateZ(u, u, this.angle);\n        const _ = e.ad.mat4.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);\n        this.starsProjMatrix = e.ad.mat4.clone(_);\n        const p = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;\n        _[8] = 2 * -t.x / this.width, _[9] = 2 * (t.y + p) / this.height, this.skyboxMatrix = e.ad.mat4.multiply(u, _, u);\n        const f = this.point,\n          m = f.x,\n          g = f.y,\n          v = this.width % 2 / 2,\n          y = this.height % 2 / 2,\n          x = Math.cos(this.angle),\n          b = Math.sin(this.angle),\n          w = m - Math.round(m) + x * v + b * y,\n          T = g - Math.round(g) + x * y + b * v,\n          E = new Float64Array(h);\n        if (e.ad.mat4.translate(E, E, [w > .5 ? w - 1 : w, T > .5 ? T - 1 : T, 0]), this.alignedProjMatrix = E, h = e.ad.mat4.create(), e.ad.mat4.scale(h, h, [this.width / 2, -this.height / 2, 1]), e.ad.mat4.translate(h, h, [1, -1, 0]), this.labelPlaneMatrix = h, h = e.ad.mat4.create(), e.ad.mat4.scale(h, h, [1, -1, 1]), e.ad.mat4.translate(h, h, [-1, -1, 0]), e.ad.mat4.scale(h, h, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = h, this.pixelMatrix = e.ad.mat4.multiply(new Float64Array(16), this.labelPlaneMatrix, c), this._calcFogMatrices(), this._distanceTileDataCache = {}, h = e.ad.mat4.invert(new Float64Array(16), this.pixelMatrix), !h) throw new Error(\"failed to invert matrix\");\n        if (this.pixelMatrixInverse = h, \"globe\" === this.projection.name || this.mercatorFromTransition) {\n          this.globeMatrix = e.c3(this);\n          const t = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];\n          this.globeCenterInViewSpace = e.ad.vec3.transformMat4(t, t, n), this.globeRadius = this.worldSize / 2 / Math.PI - 1;\n        } else this.globeMatrix = h;\n        this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};\n      }\n      _calcFogMatrices() {\n        this._fogTileMatrixCache = {};\n        const t = this.cameraWorldSizeForFog,\n          i = this.cameraPixelsPerMeter,\n          o = this._camera.position,\n          s = 1 / this.height / this._pixelsPerMercatorPixel,\n          r = [t, t, i];\n        e.ad.vec3.scale(r, r, s), e.ad.vec3.scale(o, o, -1), e.ad.vec3.multiply(o, o, r);\n        const n = e.ad.mat4.create();\n        e.ad.mat4.translate(n, n, o), e.ad.mat4.scale(n, n, r), this.mercatorFogMatrix = n, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t, i, s);\n      }\n      _computeCameraPosition(e) {\n        const t = (e = e || this.pixelsPerMeter) / this.pixelsPerMeter,\n          i = this._camera.forward(),\n          o = this.point,\n          s = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t - e / this.worldSize * this._centerAltitude;\n        return [o.x / this.worldSize - i[0] * s, o.y / this.worldSize - i[1] * s, e / this.worldSize * this._centerAltitude - i[2] * s];\n      }\n      _updateCameraState() {\n        this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());\n      }\n      _translateCameraConstrained(t) {\n        const i = this._maxCameraBoundsDistance() * Math.cos(this._pitch),\n          o = this._camera.position[2],\n          s = t[2];\n        let r = 1;\n        this.projection.wrap && (this.center = this.center.wrap()), s > 0 && (r = Math.min((i - o) / s, 1)), this._camera.position = e.ad.vec3.scaleAndAdd([], this._camera.position, t, r), this._updateStateFromCamera();\n      }\n      _updateStateFromCamera() {\n        const t = this._camera.position,\n          i = this._camera.forward(),\n          {\n            pitch: o,\n            bearing: s\n          } = this._camera.getPitchBearing(),\n          r = e.bH(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel,\n          n = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.ak(this._maxPitch)),\n          a = Math.max((t[2] - r) / Math.cos(o), n),\n          l = this._zoomFromMercatorZ(a);\n        e.ad.vec3.scaleAndAdd(t, t, i, a), this._pitch = e.ay(o, e.ak(this.minPitch), e.ak(this.maxPitch)), this.angle = e.bF(s, -Math.PI, Math.PI), this._setZoom(e.ay(l, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.ac(t[0], t[1], t[2])), this._unmodified = !1, this._constrain(), this._calcMatrices();\n      }\n      _worldSizeFromZoom(e) {\n        return Math.pow(2, e) * this.tileSize;\n      }\n      _mercatorZfromZoom(e) {\n        return this.cameraToCenterDistance / this._worldSizeFromZoom(e);\n      }\n      _minimumHeightOverTerrain() {\n        const e = Math.min(null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;\n        return this._mercatorZfromZoom(e);\n      }\n      _zoomFromMercatorZ(e) {\n        return this.scaleZoom(this.cameraToCenterDistance / (e * this.tileSize));\n      }\n      zoomFromMercatorZAdjusted(t) {\n        let i = 0,\n          o = e.bY,\n          s = 0,\n          r = 1 / 0;\n        for (; o - i > 1e-6 && o > i;) {\n          const e = i + .5 * (o - i),\n            n = this.tileSize * Math.pow(2, e),\n            a = this.getCameraToCenterDistance(this.projection, e, n),\n            l = this.scaleZoom(a / (t * this.tileSize)),\n            c = Math.abs(e - l);\n          c < r && (r = c, s = e), e < l ? i = e : o = e;\n        }\n        return s;\n      }\n      _terrainEnabled() {\n        return !(!this._elevation || !this.projection.supportsTerrain && (e.w(\"Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain.\"), 1));\n      }\n      anyCornerOffEdge(t, i) {\n        const o = Math.min(t.x, i.x),\n          s = Math.max(t.x, i.x),\n          r = Math.min(t.y, i.y),\n          n = Math.max(t.y, i.y);\n        if (r < this.horizonLineFromTop(!1)) return !0;\n        if (\"mercator\" !== this.projection.name) return !1;\n        const a = [new e.P(o, r), new e.P(s, n), new e.P(o, n), new e.P(s, r)],\n          l = this.renderWorldCopies ? -3 : 0,\n          c = this.renderWorldCopies ? 4 : 1;\n        for (const e of a) {\n          const t = this.pointRayIntersection(e);\n          if (t.t < 0) return !0;\n          const i = this.rayIntersectionCoordinate(t);\n          if (i.x < l || i.y < 0 || i.x > c || i.y > 1) return !0;\n        }\n        return !1;\n      }\n      isHorizonVisible() {\n        return this.pitch + e.c4(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.P(0, 0), new e.P(this.width, this.height));\n      }\n      zoomDeltaToMovement(t, i) {\n        const o = e.ad.vec3.length(e.ad.vec3.sub([], this._camera.position, t)),\n          s = this._zoomFromMercatorZ(o) + i;\n        return o - this._mercatorZfromZoom(s);\n      }\n      getCameraPoint() {\n        if (\"globe\" === this.projection.name) {\n          const t = function ([t, i, o], s) {\n            const r = [t, i, o, 1];\n            e.ad.vec4.transformMat4(r, r, s);\n            const n = r[3] = Math.max(r[3], 1e-6);\n            return r[0] /= n, r[1] /= n, r[2] /= n, r;\n          }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);\n          return new e.P(t[0], t[1]);\n        }\n        {\n          const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);\n          return this.centerPoint.add(new e.P(0, t));\n        }\n      }\n      getCameraToCenterDistance(t, i = this.zoom, o = this.worldSize) {\n        const s = e.b$(t, i, this.width, this.height, 1024),\n          r = t.pixelSpaceConversion(this.center.lat, o, s);\n        let n = .5 / Math.tan(.5 * this._fov) * this.height * r;\n        return this.isOrthographic && (n = e.ah(1, n, e.c9(this.pitch >= Yi ? 1 : this.pitch / Yi))), n;\n      }\n      getWorldToCameraMatrix() {\n        const t = this._camera.getWorldToCamera(this.worldSize, \"meters\" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);\n        return \"globe\" === this.projection.name && e.ad.mat4.multiply(t, t, this.globeMatrix), t;\n      }\n      getFrustum(t) {\n        return e.bR.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t, \"meters\" === this.projection.zAxisUnit);\n      }\n    }\n    const Qi = (t, i) => {\n        if (i > 0 && t.terrain && e.w(\"Cutoff is currently disabled on terrain\"), i <= 0 || t.terrain) return {\n          shouldRenderCutoff: !1,\n          uniformValues: {\n            u_cutoff_params: [0, 0, 0, 1]\n          }\n        };\n        const o = t.transform,\n          s = Math.max(Math.abs(o._zoom - (t.minCutoffZoom - 1)), 1),\n          r = o.isLODDisabled(!1) ? e.ae(60, 45, o.pitch) : e.ae(30, 15, o.pitch),\n          n = o._farZ - o._nearZ,\n          a = i * o.height,\n          l = ((1 - (c = r)) * o.cameraToCenterDistance + c * (o._farZ + a)) * s;\n        var c;\n        return {\n          shouldRenderCutoff: r < 1,\n          uniformValues: {\n            u_cutoff_params: [o._nearZ, o._farZ, (l - o._nearZ) / n, (l - a - o._nearZ) / n]\n          }\n        };\n      },\n      eo = {\n        cascadeCount: 2,\n        normalOffset: 3,\n        shadowMapResolution: 2048\n      };\n    class to {\n      constructor(e, t) {\n        this.aabb = e, this.lastCascade = t;\n      }\n    }\n    class io {\n      add(e, t) {\n        const i = this.receivers[e.key];\n        void 0 !== i ? (i.aabb.min[0] = Math.min(i.aabb.min[0], t.min[0]), i.aabb.min[1] = Math.min(i.aabb.min[1], t.min[1]), i.aabb.min[2] = Math.min(i.aabb.min[2], t.min[2]), i.aabb.max[0] = Math.max(i.aabb.max[0], t.max[0]), i.aabb.max[1] = Math.max(i.aabb.max[1], t.max[1]), i.aabb.max[2] = Math.max(i.aabb.max[2], t.max[2])) : this.receivers[e.key] = new to(t, null);\n      }\n      clear() {\n        this.receivers = {};\n      }\n      get(e) {\n        return this.receivers[e.key];\n      }\n      computeRequiredCascades(t, i, o) {\n        const s = e.ce.fromPoints(t.points);\n        let r = 0;\n        for (const t in this.receivers) {\n          const n = this.receivers[t];\n          if (!n) continue;\n          if (!s.intersectsAabb(n.aabb)) continue;\n          n.aabb.min = s.closestPoint(n.aabb.min), n.aabb.max = s.closestPoint(n.aabb.max);\n          const a = n.aabb.getCorners();\n          for (let t = 0; t < o.length; t++) {\n            let s = !0;\n            for (const r of a) {\n              const n = [r[0] * i, r[1] * i, r[2]];\n              if (e.ad.vec3.transformMat4(n, n, o[t].matrix), n[0] < -1 || n[0] > 1 || n[1] < -1 || n[1] > 1) {\n                s = !1;\n                break;\n              }\n            }\n            if (n.lastCascade = t, r = Math.max(r, t), s) break;\n          }\n        }\n        return r + 1;\n      }\n    }\n    class oo {\n      constructor(e) {\n        this.painter = e, this._enabled = !1, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new io(), this._depthMode = new Bi(e.context.gl.LEQUAL, Bi.ReadWrite, [0, 1]), this._uniformValues = {\n          u_light_matrix_0: new Float32Array(16),\n          u_light_matrix_1: new Float32Array(16),\n          u_shadow_intensity: 0,\n          u_fade_range: [0, 0],\n          u_shadow_normal_offset: [1, 1, 1],\n          u_shadow_texel_size: 1,\n          u_shadow_map_resolution: 1,\n          u_shadow_direction: [0, 0, 1],\n          u_shadow_bias: [36e-5, .0012, .012],\n          u_shadowmap_0: 0,\n          u_shadowmap_1: 0\n        }, this._forceDisable = !1, this.useNormalOffset = !1, e.tp.registerParameter(this, [\"Shadows\"], \"_forceDisable\", {\n          label: \"forceDisable\"\n        }, () => {\n          this.painter.style.map.triggerRepaint();\n        }), e.tp.registerParameter(eo, [\"Shadows\"], \"cascadeCount\", {\n          min: 1,\n          max: 2,\n          step: 1\n        }), e.tp.registerParameter(eo, [\"Shadows\"], \"normalOffset\", {\n          min: 0,\n          max: 10,\n          step: .05\n        }), e.tp.registerParameter(eo, [\"Shadows\"], \"shadowMapResolution\", {\n          min: 32,\n          max: 2048,\n          step: 32\n        }), e.tp.registerBinding(this, [\"Shadows\"], \"_numCascadesToRender\", {\n          readonly: !0,\n          label: \"numCascadesToRender\"\n        });\n      }\n      destroy() {\n        for (const e of this._cascades) e.texture.destroy(), e.framebuffer.destroy();\n        this._cascades = [];\n      }\n      updateShadowParameters(t, i) {\n        const o = this.painter;\n        if (this._enabled = !1, this._shadowLayerCount = 0, this._receivers.clear(), !i || !i.properties) return;\n        const s = i.properties.get(\"shadow-intensity\");\n        if (!i.shadowsEnabled() || s <= 0) return;\n        if (this._shadowLayerCount = o.style.order.reduce((e, i) => {\n          const s = o.style._mergedLayers[i];\n          return e + (s.hasShadowPass() && !s.isHidden(t.zoom) ? 1 : 0);\n        }, 0), this._enabled = this._shadowLayerCount > 0, !this.enabled) return;\n        const r = o.context,\n          n = eo.shadowMapResolution,\n          a = eo.shadowMapResolution;\n        if (0 === this._cascades.length || eo.shadowMapResolution !== this._cascades[0].texture.size[0]) {\n          this._cascades = [];\n          for (let t = 0; t < eo.cascadeCount; ++t) {\n            const t = o._shadowMapDebug,\n              i = r.gl,\n              s = r.createFramebuffer(n, a, t, \"texture\"),\n              l = new e.T(r, {\n                width: n,\n                height: a,\n                data: null\n              }, i.DEPTH_COMPONENT16);\n            if (s.depthAttachment.set(l.texture), t) {\n              const t = new e.T(r, {\n                width: n,\n                height: a,\n                data: null\n              }, i.RGBA8);\n              s.colorAttachment.set(t.texture);\n            }\n            this._cascades.push({\n              framebuffer: s,\n              texture: l,\n              matrix: [],\n              far: 0,\n              boundingSphereRadius: 0,\n              frustum: new e.bR(),\n              scale: 0\n            });\n          }\n        }\n        this.shadowDirection = ro(i);\n        let l = 0;\n        if (t.elevation) {\n          const e = t.elevation,\n            i = [1e4, -1e4];\n          e.visibleDemTiles.filter(e => e.dem).forEach(e => {\n            const t = e.dem.tree;\n            i[0] = Math.min(i[0], t.minimums[0]), i[1] = Math.max(i[1], t.maximums[0]);\n          }), 1e4 !== i[0] && (l = (i[1] - i[0]) * e.exaggeration());\n        }\n        const c = 1.5 * t.cameraToCenterDistance,\n          h = 3 * c,\n          d = new Float64Array(16);\n        for (let i = 0; i < this._cascades.length; ++i) {\n          const o = this._cascades[i];\n          let s = t.height / 50,\n            r = 1;\n          1 === eo.cascadeCount ? r = h : 0 === i ? r = c : (s = c, r = h);\n          const [n, a] = ao(t, this.shadowDirection, s, r, eo.shadowMapResolution, l);\n          o.scale = t.scale, o.matrix = n, o.boundingSphereRadius = a, e.ad.mat4.invert(d, o.matrix), o.frustum = e.bR.fromInvProjectionMatrix(d, 1, 0, !0), o.far = r;\n        }\n        const u = this._cascades.length - 1;\n        this._uniformValues.u_fade_range = [.75 * this._cascades[u].far, this._cascades[u].far], this._uniformValues.u_shadow_intensity = s, this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]], this._uniformValues.u_shadow_texel_size = 1 / eo.shadowMapResolution, this._uniformValues.u_shadow_map_resolution = eo.shadowMapResolution, this._uniformValues.u_shadowmap_0 = Xi.ShadowMap0, this._uniformValues.u_shadowmap_1 = Xi.ShadowMap0 + 1, this._groundShadowTiles = o.transform.coveringTiles({\n          tileSize: 512,\n          renderWorldCopies: !0\n        });\n        const _ = o.transform.elevation;\n        for (const e of this._groundShadowTiles) {\n          let t = {\n            min: 0,\n            max: 0\n          };\n          if (_) {\n            const i = _.getMinMaxForTile(e);\n            i && (t = i);\n          }\n          this.addShadowReceiver(e.toUnwrapped(), t.min, t.max);\n        }\n      }\n      get enabled() {\n        return this._enabled && !this._forceDisable;\n      }\n      set enabled(e) {\n        this._enabled = e;\n      }\n      drawShadowPass(t, i) {\n        if (!this.enabled) return;\n        const o = this.painter,\n          s = o.context;\n        this._numCascadesToRender = this._receivers.computeRequiredCascades(o.transform.getFrustum(0), o.transform.worldSize, this._cascades), s.viewport.set([0, 0, eo.shadowMapResolution, eo.shadowMapResolution]);\n        for (let r = 0; r < this._numCascadesToRender; ++r) {\n          o.currentShadowCascade = r, s.bindFramebuffer.set(this._cascades[r].framebuffer.framebuffer), s.clear({\n            color: e.al.white,\n            depth: 1\n          });\n          for (const e of t.order) {\n            const s = t._mergedLayers[e];\n            if (!s.hasShadowPass() || s.isHidden(o.transform.zoom)) continue;\n            const r = t.getLayerSourceCache(s),\n              n = r ? i[r.id] : void 0;\n            (\"model\" === s.type || n && n.length) && o.renderLayer(o, r, s, n);\n          }\n        }\n        o.currentShadowCascade = 0;\n      }\n      drawGroundShadows() {\n        if (!this.enabled) return;\n        const e = this.painter,\n          t = e.style,\n          i = e.context,\n          o = t.directionalLight,\n          s = t.ambientLight;\n        if (!o || !s) return;\n        const r = [],\n          n = Qi(e, e.longestCutoffRange);\n        n.shouldRenderCutoff && r.push(\"RENDER_CUTOFF\"), r.push(\"RENDER_SHADOWS\", \"DEPTH_TEXTURE\"), this.useNormalOffset && r.push(\"NORMAL_OFFSET\");\n        const a = no(t, o, s),\n          l = new Bi(i.gl.LEQUAL, Bi.ReadOnly, e.depthRangeFor3D);\n        for (const t of this._groundShadowTiles) {\n          const o = t.toUnwrapped(),\n            s = e.isTileAffectedByFog(t),\n            c = e.getOrCreateProgram(\"groundShadow\", {\n              defines: r,\n              overrideFog: s\n            });\n          this.setupShadows(o, c), e.uploadCommonUniforms(i, c, o, null, n);\n          const h = {\n            u_matrix: e.transform.calculateProjMatrix(o),\n            u_ground_shadow_factor: a\n          };\n          c.draw(e, i.gl.TRIANGLES, l, Ui.disabled, ki.multiply, ji.disabled, h, \"ground_shadow\", e.tileExtentBuffer, e.quadTriangleIndexBuffer, e.tileExtentSegments, null, e.transform.zoom, null, null);\n        }\n      }\n      getShadowPassColorMode() {\n        return this.painter._shadowMapDebug ? ki.unblended : ki.disabled;\n      }\n      getShadowPassDepthMode() {\n        return this._depthMode;\n      }\n      getShadowCastingLayerCount() {\n        return this._shadowLayerCount;\n      }\n      calculateShadowPassMatrixFromTile(t) {\n        const i = this.painter.transform,\n          o = i.calculatePosMatrix(t, i.worldSize);\n        return e.ad.mat4.multiply(o, this._cascades[this.painter.currentShadowCascade].matrix, o), Float32Array.from(o);\n      }\n      calculateShadowPassMatrixFromMatrix(t) {\n        return e.ad.mat4.multiply(t, this._cascades[this.painter.currentShadowCascade].matrix, t), Float32Array.from(t);\n      }\n      setupShadows(t, i, o, s = 0) {\n        if (!this.enabled) return;\n        const r = this.painter.transform,\n          n = this.painter.context,\n          a = n.gl,\n          l = this._uniformValues,\n          c = new Float64Array(16),\n          h = r.calculatePosMatrix(t, r.worldSize);\n        for (let t = 0; t < this._cascades.length; t++) e.ad.mat4.multiply(c, this._cascades[t].matrix, h), l[0 === t ? \"u_light_matrix_0\" : \"u_light_matrix_1\"] = Float32Array.from(c), n.activeTexture.set(a.TEXTURE0 + Xi.ShadowMap0 + t), this._cascades[t].texture.bind(a.NEAREST, a.CLAMP_TO_EDGE);\n        if (this.useNormalOffset = !!o, this.useNormalOffset) {\n          const i = e.cd(t.canonical),\n            n = 2 / r.tileSize * e.ai / eo.shadowMapResolution,\n            a = n * this._cascades[0].boundingSphereRadius,\n            c = n * this._cascades[this._cascades.length - 1].boundingSphereRadius,\n            h = (\"vector-tile\" === o ? 1 : 3) / Math.pow(2, s - t.canonical.z - (1 - r.zoom + Math.floor(r.zoom)));\n          l.u_shadow_normal_offset = [i, a * h, c * h], l.u_shadow_bias = [6e-5, .0012, .012];\n        } else l.u_shadow_bias = [36e-5, .0012, .012];\n        i.setShadowUniformValues(n, l);\n      }\n      setupShadowsFromMatrix(t, i, o = !1) {\n        if (!this.enabled) return;\n        const s = this.painter.context,\n          r = s.gl,\n          n = this._uniformValues,\n          a = new Float64Array(16);\n        for (let i = 0; i < eo.cascadeCount; i++) e.ad.mat4.multiply(a, this._cascades[i].matrix, t), n[0 === i ? \"u_light_matrix_0\" : \"u_light_matrix_1\"] = Float32Array.from(a), s.activeTexture.set(r.TEXTURE0 + Xi.ShadowMap0 + i), this._cascades[i].texture.bind(r.NEAREST, r.CLAMP_TO_EDGE);\n        if (this.useNormalOffset = o, o) {\n          const e = eo.normalOffset;\n          n.u_shadow_normal_offset = [1, e, e], n.u_shadow_bias = [6e-5, .0012, .012];\n        } else n.u_shadow_bias = [36e-5, .0012, .012];\n        i.setShadowUniformValues(s, n);\n      }\n      getShadowUniformValues() {\n        return this._uniformValues;\n      }\n      getCurrentCascadeFrustum() {\n        return this._cascades[this.painter.currentShadowCascade].frustum;\n      }\n      computeSimplifiedTileShadowVolume(t, i, o, s) {\n        if (s[2] >= 0) return {};\n        const r = function (t, i, o) {\n            const s = o / (1 << t.canonical.z);\n            return new e.ce([t.canonical.x * s + t.wrap * o, t.canonical.y * s + t.wrap * o, 0], [(t.canonical.x + 1) * s + t.wrap * o, (t.canonical.y + 1) * s + t.wrap * o, i]);\n          }(t, i, o).getCorners(),\n          n = i / -s[2];\n        s[0] < 0 ? (e.ad.vec3.add(r[0], r[0], [s[0] * n, 0, 0]), e.ad.vec3.add(r[3], r[3], [s[0] * n, 0, 0])) : s[0] > 0 && (e.ad.vec3.add(r[1], r[1], [s[0] * n, 0, 0]), e.ad.vec3.add(r[2], r[2], [s[0] * n, 0, 0])), s[1] < 0 ? (e.ad.vec3.add(r[0], r[0], [0, s[1] * n, 0]), e.ad.vec3.add(r[1], r[1], [0, s[1] * n, 0])) : s[1] > 0 && (e.ad.vec3.add(r[2], r[2], [0, s[1] * n, 0]), e.ad.vec3.add(r[3], r[3], [0, s[1] * n, 0]));\n        const a = {};\n        return a.vertices = r, a.planes = [so(r[1], r[0], r[4]), so(r[2], r[1], r[5]), so(r[3], r[2], r[6]), so(r[0], r[3], r[7])], a;\n      }\n      addShadowReceiver(t, i, o) {\n        this._receivers.add(t, e.ce.fromTileIdAndHeight(t, i, o));\n      }\n      getMaxCascadeForTile(e) {\n        const t = this._receivers.get(e);\n        return t && t.lastCascade ? t.lastCascade : 0;\n      }\n    }\n    function so(t, i, o) {\n      const s = e.ad.vec3.sub([], o, i),\n        r = e.ad.vec3.sub([], t, i),\n        n = e.ad.vec3.cross([], s, r),\n        a = e.ad.vec3.length(n);\n      return 0 === a ? [0, 0, 1, 0] : (e.ad.vec3.scale(n, n, 1 / a), [n[0], n[1], n[2], -e.ad.vec3.dot(n, i)]);\n    }\n    function ro(t) {\n      const i = t.properties.get(\"direction\"),\n        o = e.cc(i.x, i.y, i.z);\n      o[2] = e.ay(o[2], 0, 75);\n      const s = e.cf([o[0], o[1], o[2]]);\n      return e.ad.vec3.fromValues(s.x, s.y, s.z);\n    }\n    function no(t, i, o) {\n      const s = \"none\" === i.properties.get(\"color-use-theme\"),\n        r = i.properties.get(\"color\"),\n        n = i.properties.get(\"intensity\"),\n        a = i.properties.get(\"direction\"),\n        l = [a.x, a.y, a.z],\n        c = \"none\" === o.properties.get(\"color-use-theme\"),\n        h = o.properties.get(\"color\"),\n        d = o.properties.get(\"intensity\"),\n        u = Math.max(e.ad.vec3.dot([0, 0, 1], l), 0),\n        _ = [0, 0, 0];\n      e.ad.vec3.scale(_, h.toRenderColor(c ? null : t.getLut(i.scope)).toArray01Linear().slice(0, 3), d);\n      const p = [0, 0, 0];\n      return e.ad.vec3.scale(p, r.toRenderColor(s ? null : t.getLut(o.scope)).toArray01Linear().slice(0, 3), u * n), e.cg([_[0] > 0 ? _[0] / (_[0] + p[0]) : 0, _[1] > 0 ? _[1] / (_[1] + p[1]) : 0, _[2] > 0 ? _[2] / (_[2] + p[2]) : 0]);\n    }\n    function ao(t, i, o, s, r, n) {\n      const a = t.zoom,\n        l = t.scale,\n        c = t.worldSize,\n        h = 1 / c,\n        d = t.aspect,\n        u = Math.sqrt(1 + d * d) * Math.tan(.5 * t.fovX),\n        _ = u * u,\n        p = s - o,\n        f = s + o;\n      let m, g;\n      _ > p / f ? (m = s, g = s * u) : (m = .5 * f * (1 + _), g = .5 * Math.sqrt(p * p + 2 * (s * s + o * o) * _ + f * f * _ * _));\n      const v = t.projection.pixelsPerMeter(t.center.lat, c),\n        y = t._camera.getCameraToWorldMercator(),\n        x = [0, 0, -m * h];\n      e.ad.vec3.transformMat4(x, x, y);\n      let b = g * h;\n      const w = t._edgeInsets;\n      if (!(0 === w.left && 0 === w.top && 0 === w.right && 0 === w.bottom || w.left === w.right && w.top === w.bottom)) {\n        const i = t._camera.getWorldToCamera(t.worldSize, \"meters\" === t.projection.zAxisUnit ? v : 1),\n          r = t._camera.getCameraToClipPerspective(t._fov, t.width / t.height, o, s);\n        r[8] = 2 * -t.centerOffset.x / t.width, r[9] = 2 * t.centerOffset.y / t.height;\n        const n = new Float64Array(16);\n        e.ad.mat4.mul(n, r, i);\n        const h = new Float64Array(16);\n        e.ad.mat4.invert(h, n);\n        const d = e.bR.fromInvProjectionMatrix(h, c, a, !0);\n        for (const i of d.points) {\n          const o = ((T = i)[0] /= l, T[1] /= l, T[2] = e.bH(T[2], t._center.lat), T);\n          b = Math.max(b, e.ad.vec3.len(e.ad.vec3.subtract([], x, o)));\n        }\n      }\n      var T;\n      b *= r / (r - 1);\n      const E = Math.acos(i[2]),\n        S = Math.atan2(-i[0], -i[1]),\n        C = new $i();\n      C.position = x, C.setPitchBearing(E, S);\n      const I = C.getWorldToCamera(c, v),\n        R = b * c,\n        D = Math.min(t._mercatorZfromZoom(17) * c * -2, -2 * R),\n        A = C.getCameraToClipOrthographic(-R, R, -R, R, D, (R + n * v) / i[2]),\n        L = new Float64Array(16);\n      e.ad.mat4.multiply(L, A, I);\n      const M = e.ad.vec3.fromValues(Math.floor(1e6 * x[0]) / 1e6 * c, Math.floor(1e6 * x[1]) / 1e6 * c, 0),\n        P = .5 * r,\n        z = [0, 0, 0];\n      e.ad.vec3.transformMat4(z, M, L), e.ad.vec3.scale(z, z, P);\n      const O = [Math.floor(z[0]), Math.floor(z[1]), Math.floor(z[2])],\n        F = [0, 0, 0];\n      e.ad.vec3.sub(F, z, O), e.ad.vec3.scale(F, F, -1 / P);\n      const k = new Float64Array(16);\n      return e.ad.mat4.identity(k), e.ad.mat4.translate(k, k, F), e.ad.mat4.multiply(L, k, L), [L, R];\n    }\n    class lo extends e.E {\n      constructor(e) {\n        super(), this.requestManager = e, this.models = {\n          \"\": {}\n        }, this.modelUris = {\n          \"\": {}\n        }, this.numModelsLoading = {};\n      }\n      loadModel(t, i) {\n        return e.aN(this.requestManager.transformRequest(i, e.R.Model).url).then(i => {\n          if (!i) return;\n          const o = e.aO(i),\n            s = new e.aP(t, void 0, void 0, o);\n          return s.computeBoundsAndApplyParent(), s;\n        }).catch(o => {\n          if (o && 404 === o.status) return null;\n          this.fire(new e.z(new Error(`Could not load model ${t} from ${i}: ${o.message}`)));\n        });\n      }\n      load(t, i, o = {\n        keepNumReferences: !1\n      }) {\n        this.models[i] || (this.models[i] = {});\n        const s = Object.keys(t);\n        this.numModelsLoading[i] = (this.numModelsLoading[i] || 0) + s.length;\n        const r = [];\n        for (const e of s) r.push(this.loadModel(e, t[e]));\n        Promise.allSettled(r).then(t => {\n          for (let e = 0; e < t.length; e++) {\n            const {\n              status: r,\n              value: n\n            } = t[e];\n            if (\"fulfilled\" === r && n) {\n              const t = this.models[i][s[e]];\n              this.models[i][s[e]] = {\n                model: n,\n                numReferences: o.keepNumReferences && t ? t.numReferences : 1\n              };\n            }\n          }\n          this.numModelsLoading[i] -= s.length, this.fire(new e.A(\"data\", {\n            dataType: \"style\"\n          }));\n        }).catch(t => {\n          this.fire(new e.z(new Error(`Could not load models: ${t.message}`)));\n        });\n      }\n      isLoaded() {\n        for (const e in this.numModelsLoading) if (this.numModelsLoading[e] > 0) return !1;\n        return !0;\n      }\n      hasModel(e, t) {\n        return !!this.getModel(e, t);\n      }\n      getModel(e, t) {\n        return this.models[t] || (this.models[t] = {}), this.models[t][e] ? this.models[t][e].model : void 0;\n      }\n      addModel(e, t, i) {\n        this.models[i] || (this.models[i] = {}), this.modelUris[i] || (this.modelUris[i] = {}), this.hasModel(e, i) && this.models[i][e].numReferences++, this.modelUris[i][e] = this.requestManager.normalizeModelURL(t), this.load({\n          [e]: this.modelUris[i][e]\n        }, i);\n      }\n      addModels(e, t) {\n        this.models[t] || (this.models[t] = {}), this.modelUris[t] || (this.modelUris[t] = {});\n        const i = this.modelUris[t];\n        for (const o in e) this.models[t][o] = {}, i[o] = this.requestManager.normalizeModelURL(e[o]);\n        this.load(i, t, {\n          keepNumReferences: !0\n        });\n      }\n      reloadModels(e) {\n        this.load(this.modelUris[e], e);\n      }\n      addModelsFromBucket(e, t) {\n        this.models[t] || (this.models[t] = {}), this.modelUris[t] || (this.modelUris[t] = {});\n        const i = {};\n        for (const o of e) this.hasModel(o, t) ? this.models[t][o].numReferences++ : (this.modelUris[t][o] = this.requestManager.normalizeModelURL(o), i[o] = this.modelUris[t][o]);\n        this.load(i, t);\n      }\n      removeModel(e, t) {\n        if (this.models[t] && this.models[t][e] && (this.models[t][e].numReferences--, 0 === this.models[t][e].numReferences)) {\n          const i = this.models[t][e].model;\n          delete this.models[t][e], delete this.modelUris[t][e], i.destroy();\n        }\n      }\n      listModels(e) {\n        return this.models[e] || (this.models[e] = {}), Object.keys(this.models[e]);\n      }\n      upload(e, t) {\n        this.models[t] || (this.models[t] = {});\n        for (const i in this.models[t]) this.models[t][i].model && this.models[t][i].model.upload(e.context);\n      }\n    }\n    const co = new e.a7({\n        data: new e.a8(e.a5.colorTheme.data)\n      }),\n      ho = {\n        \"mbx-indoor-active-floorplans\": {\n          default: [\"literal\", []]\n        },\n        \"mbx-indoor-underground\": {\n          default: [\"literal\", !1]\n        },\n        \"mbx-indoor-loaded-levels\": {\n          default: [\"literal\", []]\n        },\n        \"mbx-indoor-level-height\": {\n          default: [\"literal\", {}]\n        },\n        \"mbx-indoor-level-base\": {\n          default: [\"literal\", {}]\n        },\n        \"mbx-indoor-level-selected\": {\n          default: [\"literal\", {}]\n        },\n        \"mbx-indoor-level-overlapped\": {\n          default: [\"literal\", {}]\n        }\n      };\n    function uo(e) {\n      return e = e || {}, Object.assign(e, ho);\n    }\n    class _o extends e.E {\n      constructor(t) {\n        super(), this.mergeFloors = !0, this._scope = void 0, this._queryFeatureSetId = void 0, this._buildingEntryFeatureSetId = void 0, this._selectedFloorplan = void 0, this._indoorData = void 0, this._selectedLevel = void 0, this._floorplanStates = {}, e.aQ([\"_onLoad\", \"_onMove\", \"_checkFloorplanVisible\"], this), this._map = t, this._checkFloorplanVisible(!0), this._map.on(\"load\", this._onLoad), this._map.on(\"move\", this._onMove);\n      }\n      destroy() {\n        this._map.indoor.off(\"load\", this._onLoad), this._map.indoor.off(\"move\", this._onMove), this._map = void 0;\n      }\n      _onLoad() {\n        this._map.style.forEachFragmentStyle(t => {\n          t.stylesheet.indoor && (this._queryFeatureSetId ? this.fire(new e.z(new Error(\"Multiple indoor map styles detected, simultaneous usage is not allowed currently.\"))) : (this._queryFeatureSetId = t.stylesheet.indoor.floorplanFeaturesetId, this._buildingEntryFeatureSetId = t.stylesheet.indoor.buildingFeaturesetId, this._scope = t.scope));\n        }), this._queryFeatureSetId && this._buildingEntryFeatureSetId && this._map.addInteraction(\"mbx-indoor-buildingclick\", {\n          type: \"click\",\n          target: {\n            featuresetId: this._buildingEntryFeatureSetId,\n            importId: this._scope\n          },\n          handler: e => (e.feature && e.feature.properties.floorplan && this.selectFloorplan(e.feature.properties.floorplan), !0)\n        }), this._checkFloorplanVisible(!0);\n      }\n      _onMove() {\n        this._checkFloorplanVisible(!1);\n      }\n      _checkFloorplanVisible(t) {\n        if (!this._queryFeatureSetId) return;\n        if (!this._map.isStyleLoaded()) return;\n        if (this._map.transform.zoom < 13) return;\n        this._indoorData && !function (e, t) {\n          const [i, o] = e,\n            {\n              center: s,\n              radius: r\n            } = t,\n            [n, a] = s,\n            l = Math.abs(i - n);\n          return Math.sqrt((l > 180 ? 360 - l : l) ** 2 + (o - a) ** 2) <= r;\n        }([this._map.getCenter().lng, this._map.getCenter().lat], this._indoorData.circumCircle) && (this._indoorData = void 0, this._selectedFloorplan = void 0, this._map.setConfigProperty(this._scope, \"mbx-indoor-underground\", !1), this._map.setConfigProperty(this._scope, \"mbx-indoor-active-floorplans\", [\"literal\", []]), this.fire(new e.A(\"floorplangone\")));\n        const i = {\n            target: {\n              featuresetId: this._queryFeatureSetId,\n              importId: this._scope\n            }\n          },\n          o = new e.P(this._map.transform.width / 2, this._map.transform.height / 2),\n          s = [new e.P(0, 0), new e.P(this._map.transform.width, this._map.transform.height)],\n          r = this._map.queryRenderedFeatures(t ? s : o, i);\n        r.length > 0 && (this._selectedFloorplan && r[0].properties.id === this._selectedFloorplan.properties.id || (this._selectedFloorplan = r[0], this._floorplanSelected(!1)));\n      }\n      _floorplanSelected(t) {\n        this._indoorData = JSON.parse(this._selectedFloorplan.properties[\"indoor-data\"]), this._indoorData.id = this._selectedFloorplan.properties.id, this._indoorData.circumCircle = function (e) {\n          const [[t, i], [o, s]] = e,\n            r = (o - t + 360) % 360,\n            n = r > 180 ? 360 - r : r;\n          return {\n            center: [(t + n / 2 + 360) % 360, (i + s) / 2],\n            radius: Math.sqrt(n ** 2 + (s - i) ** 2) / 2\n          };\n        }(this._indoorData.extent), this._floorplanStates[this._indoorData.id] || (this._floorplanStates[this._indoorData.id] = {});\n        const i = this._floorplanStates[this._indoorData.id].selectedBuilding,\n          o = this._floorplanStates[this._indoorData.id].selectedLevel;\n        let s;\n        if (this._map.setConfigProperty(this._scope, \"mbx-indoor-active-floorplans\", this._indoorData.floorplanIDs), this._selectedLevel) for (const e of this._indoorData.levels) e.id === this._selectedLevel.id && (s = e.id);\n        if (this.fire(new e.A(\"floorplanselected\", {\n          buildings: this._indoorData.buildings,\n          levels: this._indoorData.levels,\n          selectedLevelId: s\n        })), i) {\n          const e = this._indoorData.buildings.find(e => e.id === i);\n          this._buildingSelected(e, !1);\n        } else this._indoorData.buildings.length > 0 && this._buildingSelected(this._indoorData.buildings[0], !1);\n        if (o) {\n          const e = this._indoorData.levels.find(e => e.id === o);\n          this._updateLevels(e, t);\n        } else t && this._indoorData[\"default-levels\"].length > 0 && this.selectLevel(this._indoorData[\"default-levels\"][0]);\n      }\n      _buildingSelected(t, i) {\n        i && t && t.extent && this._map.fitBounds(t.extent, {\n          pitch: this._map.getPitch(),\n          bearing: this._map.getBearing()\n        }), this._floorplanStates[this._indoorData.id].selectedBuilding = t ? t.id : void 0;\n        const o = this._indoorData.levels.filter(e => t.levels.includes(e.id));\n        this.fire(new e.A(\"buildingselected\", {\n          buildingId: t.id,\n          levels: o\n        }));\n      }\n      _levelSelected(t) {\n        if (\"overview\" === t) this._updateLevels(void 0, !0);else {\n          const e = this._indoorData.levels.find(e => e.id === t);\n          this._updateLevels(e, !0);\n        }\n        this.fire(new e.A(\"levelselected\", {\n          levelId: \"overview\" === t ? void 0 : t\n        }));\n      }\n      _updateLevels(e, t) {\n        if (!e) return this._map.setConfigProperty(this._scope, \"mbx-indoor-loaded-levels\", [\"literal\", []]), this._map.setConfigProperty(this._scope, \"mbx-indoor-underground\", !1), this._floorplanStates[this._indoorData.id].selectedLevel = void 0, void (t && this._indoorData.extent && this._map.fitBounds(this._indoorData.extent, {\n          pitch: this._map.getPitch(),\n          bearing: this._map.getBearing()\n        }));\n        function i(e) {\n          const t = e.indexOf(\"/floor/\");\n          if (-1 === t) return e;\n          const i = t + 7,\n            o = e.indexOf(\"/\", i);\n          return -1 === o ? e.slice(i) : e.slice(i, o);\n        }\n        this._selectedLevel = e, this._floorplanStates[this._indoorData.id].selectedLevel = e ? e.id : void 0;\n        const o = [],\n          s = {},\n          r = {},\n          n = {},\n          a = {};\n        for (const t of this._indoorData.levels) if (o.push(t.id), s[t.id] = t.height, r[t.id] = t.base, e) {\n          if (this.mergeFloors) {\n            const o = i(e.id),\n              s = i(t.id);\n            n[t.id] = s === o ? \"true\" : \"false\";\n          } else n[t.id] = t.id === e.id ? \"true\" : \"false\";\n          a[t.id] = t.base < e.base ? \"true\" : \"false\";\n        } else a[t.id] = !0;\n        if (this._map.setConfigProperty(this._scope, \"mbx-indoor-loaded-levels\", [\"literal\", o]), this._map.setConfigProperty(this._scope, \"mbx-indoor-level-height\", [\"literal\", s]), this._map.setConfigProperty(this._scope, \"mbx-indoor-level-base\", [\"literal\", r]), this._map.setConfigProperty(this._scope, \"mbx-indoor-level-selected\", [\"literal\", n]), this._map.setConfigProperty(this._scope, \"mbx-indoor-level-overlapped\", [\"literal\", a]), e && (this._map.setConfigProperty(this._scope, \"mbx-indoor-underground\", !!e.isUnderground), t && e.extent)) {\n          const t = this._map.cameraForBounds(e.extent, {\n              pitch: this._map.getPitch(),\n              bearing: this._map.getBearing()\n            }),\n            i = this._map.getZoom(),\n            o = t.zoom ? Math.abs(i - t.zoom) : 0;\n          this._map.fitBounds(e.extent, o >= 1 ? {\n            pitch: this._map.getPitch(),\n            bearing: this._map.getBearing()\n          } : {\n            pitch: this._map.getPitch(),\n            bearing: this._map.getBearing(),\n            zoom: i\n          });\n        }\n      }\n      selectFloorplan(t) {\n        const i = {\n            target: {\n              featuresetId: this._queryFeatureSetId,\n              importId: this._scope\n            }\n          },\n          o = [new e.P(0, 0), new e.P(this._map.transform.width, this._map.transform.height)],\n          s = this._map.queryRenderedFeatures(o, i);\n        if (s.length > 0) for (const e of s) if (JSON.parse(e.properties[\"indoor-data\"]).floorplanIDs.includes(t)) {\n          this._selectedFloorplan = e, this._floorplanSelected(!0);\n          break;\n        }\n      }\n      selectBuilding(e) {\n        const t = this._indoorData.buildings.find(t => t.id === e);\n        this._buildingSelected(t, !0);\n      }\n      selectLevel(e) {\n        this._levelSelected(e);\n      }\n    }\n    function po(t) {\n      if (!t.metadata || !t.metadata.content_area) return;\n      const i = e.q.devicePixelRatio,\n        {\n          left: o,\n          top: s,\n          width: r,\n          height: n\n        } = t.metadata.content_area,\n        a = o * i,\n        l = s * i;\n      return [a, l, a + r * i, l + n * i];\n    }\n    function fo(t) {\n      if (t) return t.map(([t, i]) => [t * e.q.devicePixelRatio, i * e.q.devicePixelRatio]);\n    }\n    class mo {\n      constructor(e, t) {\n        this.id = e, this.style = t;\n      }\n      addIcons(t) {\n        const i = new Map();\n        for (const [o, s] of t.entries()) {\n          const t = e.I.from({\n            name: o,\n            iconsetId: this.id\n          });\n          i.set(t, s);\n        }\n        this.style.addImages(i);\n      }\n    }\n    const go = (e, t) => Ae(e, t && t.filter(e => \"source.canvas\" !== e.identifier)),\n      vo = e.aA(Mt, [\"addLayer\", \"removeLayer\", \"setLights\", \"setPaintProperty\", \"setLayoutProperty\", \"setSlot\", \"setFilter\", \"addSource\", \"removeSource\", \"setLayerZoomRange\", \"setLight\", \"setTransition\", \"setGeoJSONSourceData\", \"setTerrain\", \"setFog\", \"setSnow\", \"setRain\", \"setProjection\", \"setCamera\", \"addImport\", \"removeImport\", \"updateImport\"]),\n      yo = e.aA(Mt, [\"setCenter\", \"setZoom\", \"setBearing\", \"setPitch\"]),\n      xo = new Set([\"background\", \"sky\", \"slot\", \"custom\"]),\n      bo = {\n        version: 8,\n        layers: [],\n        sources: {}\n      },\n      wo = {\n        duration: 300,\n        delay: 0\n      };\n    class To extends e.E {\n      constructor(t, i = {}) {\n        super(), this.map = t, this.scope = i.scope || \"\", this.globalId = null, this.fragments = [], this.importDepth = i.importDepth || 0, this.importsCache = i.importsCache || new Map(), this.resolvedImports = i.resolvedImports || new Set(), this.transition = e.l({}, wo), this._buildingIndex = new Dt(this), this.crossTileSymbolIndex = new Oi(), this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._clipLayerPresent = !1, this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this._changes = i.styleChanges || new G(), this.dispatcher = i.dispatcher ? i.dispatcher : new e.D(e.cj(), this), i.imageManager ? this.imageManager = i.imageManager : (this.imageManager = new q(this.map._spriteFormat), this.imageManager.setEventedParent(this)), this.imageManager.createScope(this.scope), this.glyphManager = i.glyphManager ? i.glyphManager : new e.ck(t._requestManager, i.localFontFamily ? e.cl.all : i.localIdeographFontFamily ? e.cl.ideographs : e.cl.none, i.localFontFamily || i.localIdeographFontFamily), i.modelManager ? this.modelManager = i.modelManager : (this.modelManager = new lo(t._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = !1, this._precompileDone = !1, this._shouldPrecompile = !1, this._availableImages = [], this._order = [], this._markersNeedUpdate = !1, this.options = i.configOptions ? i.configOptions : new Map(), this._configDependentLayers = i.configDependentLayers ? i.configDependentLayers : new Set(), this._config = i.config, this._styleColorTheme = {\n          lut: null,\n          lutLoading: !1,\n          lutLoadingCorrelationID: 0,\n          colorTheme: null,\n          colorThemeOverride: i.colorThemeOverride\n        }, this._styleColorThemeForScope = {}, this._initialConfig = i.initialConfig, this.dispatcher.broadcast(\"setReferrer\", e.cm());\n        const o = this;\n        this._rtlTextPluginCallback = To.registerForPluginStateChange(t => {\n          o.dispatcher.broadcast(\"syncRTLPluginState\", {\n            pluginStatus: t.pluginStatus,\n            pluginURL: t.pluginURL\n          }, (t, i) => {\n            if (e.cn(t), i && i.every(e => e)) for (const e in o._sourceCaches) {\n              const t = o._sourceCaches[e],\n                i = t.getSource().type;\n              \"vector\" !== i && \"geojson\" !== i || t.reload();\n            }\n          });\n        }), this.on(\"data\", e => {\n          if (\"source\" !== e.dataType || \"metadata\" !== e.sourceDataType) return;\n          const t = this.getOwnSource(e.sourceId);\n          if (t && t.vectorLayerIds) for (const e in this._layers) {\n            const i = this._layers[e];\n            i.source === t.id && this._validateLayer(i);\n          }\n        });\n      }\n      load(e) {\n        return e ? (\"string\" == typeof e ? this.loadURL(e) : this.loadJSON(e), this) : this;\n      }\n      _getGlobalId(t) {\n        if (!t) return null;\n        if (\"string\" == typeof t) {\n          if (e.f(t)) return t;\n          const i = e.co(t);\n          if (!i.startsWith(\"http\")) try {\n            return new URL(i, location.href).toString();\n          } catch (e) {\n            return i;\n          }\n          return i;\n        }\n        return `json://${e.cp(JSON.stringify(t))}`;\n      }\n      _diffStyle(t, i, o) {\n        this.globalId = this._getGlobalId(t);\n        const s = (e, t) => {\n          try {\n            t(null, this.setState(e, o));\n          } catch (e) {\n            t(e, !1);\n          }\n        };\n        if (\"string\" == typeof t) {\n          const o = this.map._requestManager.normalizeStyleURL(t),\n            r = this.map._requestManager.transformRequest(o, e.R.Style);\n          e.n(r, (t, o) => {\n            t ? this.fire(new e.z(t)) : o && s(o, i);\n          });\n        } else \"object\" == typeof t && s(t, i);\n      }\n      loadURL(t, i = {}) {\n        this.fire(new e.A(\"dataloading\", {\n          dataType: \"style\"\n        }));\n        const o = \"boolean\" == typeof i.validate ? i.validate : !e.f(t);\n        this.globalId = this._getGlobalId(t), t = this.map._requestManager.normalizeStyleURL(t, i.accessToken), this.resolvedImports.add(t);\n        const s = this.importsCache.get(t);\n        if (s) return this._load(s, o);\n        const r = this.map._requestManager.transformRequest(t, e.R.Style);\n        this._request = e.n(r, (i, s) => {\n          if (this._request = null, i) this.fire(new e.z(i));else if (s) return this.importsCache.set(t, s), this._load(s, o);\n        });\n      }\n      loadJSON(t, i = {}) {\n        this.fire(new e.A(\"dataloading\", {\n          dataType: \"style\"\n        })), this.globalId = this._getGlobalId(t), this._request = e.q.frame(() => {\n          this._request = null, this._load(t, !1 !== i.validate);\n        });\n      }\n      loadEmpty() {\n        this.fire(new e.A(\"dataloading\", {\n          dataType: \"style\"\n        })), this._load(bo, !1);\n      }\n      _loadImports(t, i, o) {\n        if (this.importDepth >= 4) return e.w(\"Style doesn't support nesting deeper than 5\"), Promise.resolve();\n        const s = [];\n        for (const e of t) {\n          const t = this._createFragmentStyle(e),\n            r = new Promise(e => {\n              t.once(\"style.import.load\", e), t.once(\"error\", e);\n            }).then(() => this.mergeAll());\n          if (s.push(r), this.resolvedImports.has(e.url)) {\n            t.loadEmpty();\n            continue;\n          }\n          const n = e.data || this.importsCache.get(e.url);\n          n ? (t.loadJSON(n, {\n            validate: i\n          }), this._isInternalStyle(n) && (t.globalId = null)) : e.url ? t.loadURL(e.url, {\n            validate: i\n          }) : t.loadEmpty();\n          const a = {\n            style: t,\n            id: e.id,\n            config: e.config\n          };\n          if (o) {\n            const e = this.fragments.findIndex(({\n              id: e\n            }) => e === o);\n            this.fragments = this.fragments.slice(0, e).concat(a).concat(this.fragments.slice(e));\n          } else this.fragments.push(a);\n        }\n        return Promise.allSettled(s);\n      }\n      getImportGlobalIds(e = this, t = new Set()) {\n        for (const i of e.fragments) i.style.globalId && t.add(i.style.globalId), this.getImportGlobalIds(i.style, t);\n        return [...t.values()];\n      }\n      _createFragmentStyle(t) {\n        const i = this.scope ? e.C(t.id, this.scope) : t.id;\n        let o;\n        const s = this._initialConfig && this._initialConfig[i];\n        (t.config || s) && (o = e.l({}, t.config, s));\n        const r = new To(this.map, {\n          scope: i,\n          styleChanges: this._changes,\n          importDepth: this.importDepth + 1,\n          importsCache: this.importsCache,\n          resolvedImports: new Set(this.resolvedImports),\n          dispatcher: this.dispatcher,\n          imageManager: this.imageManager,\n          glyphManager: this.glyphManager,\n          modelManager: this.modelManager,\n          config: o,\n          configOptions: this.options,\n          colorThemeOverride: t[\"color-theme\"],\n          configDependentLayers: this._configDependentLayers\n        });\n        return r.setEventedParent(this.map, {\n          style: r\n        }), r;\n      }\n      _reloadImports() {\n        this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast(\"setLayers\", {\n          layers: this._serializeLayers(this._order),\n          scope: this.scope,\n          options: this.options\n        }), this._shouldPrecompile = this.map._precompilePrograms && this.isRootStyle();\n      }\n      _isInternalStyle(e) {\n        return this.isRootStyle() && (e.fragment || !!e.schema && !1 !== e.fragment);\n      }\n      _load(t, i) {\n        const o = t.indoor ? uo(t.schema) : t.schema;\n        if (this._isInternalStyle(t)) {\n          const o = e.l({}, bo, {\n            imports: [{\n              id: \"basemap\",\n              data: t,\n              url: \"\"\n            }]\n          });\n          return void this._load(o, i);\n        }\n        if (this.updateConfig(this._config, o), i && go(this, me(t))) return;\n        this._loaded = !0, this.stylesheet = e.cq(t);\n        const s = () => {\n          for (const e in t.sources) this.addSource(e, t.sources[e], {\n            validate: !1,\n            isInitialLoad: !0\n          });\n          if (t.iconsets) for (const e in t.iconsets) this.addIconset(e, t.iconsets[e]);\n          t.sprite ? this._loadIconset(t.sprite) : (this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast(\"spriteLoaded\", {\n            scope: this.scope,\n            isLoaded: !0\n          })), this.setGlyphsUrl(t.glyphs);\n          const o = Lt(this.stylesheet.layers);\n          if (this._order = o.map(e => e.id), this.stylesheet.light && e.w(\"The `light` root property is deprecated, prefer using `lights` with `flat` light type instead.\"), this.stylesheet.lights) if (1 === this.stylesheet.lights.length && \"flat\" === this.stylesheet.lights[0].type) {\n            const e = this.stylesheet.lights[0];\n            this.light = new Me(e.properties, e.id);\n          } else this.setLights(this.stylesheet.lights);\n          this.light || (this.light = new Me(this.stylesheet.light)), this._layers = {};\n          for (const t of o) {\n            const i = e.cv(t, this.scope, this._styleColorTheme.lut, this.options);\n            0 !== i.configDependencies.size && this._configDependentLayers.add(i.fqid), i.setEventedParent(this, {\n              layer: {\n                id: i.id\n              }\n            }), this._layers[i.id] = i;\n            const o = this.getOwnLayerSourceCache(i),\n              s = !!this.directionalLight && this.directionalLight.shadowsEnabled();\n            o && i.canCastShadows() && s && (o.castsShadows = !0);\n          }\n          this.stylesheet.featuresets && this.setFeaturesetSelectors(this.stylesheet.featuresets), this.stylesheet.models && this.modelManager.addModels(this.stylesheet.models, this.scope);\n          const s = this.stylesheet.terrain;\n          s && (this.checkCanvasFingerprintNoise(), this.disableElevatedTerrain || this.terrainSetForDrapingOnly() || this._createTerrain(s, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.snow && this._createSnow(this.stylesheet.snow), this.stylesheet.rain && this._createRain(this.stylesheet.rain), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new e.A(\"data\", {\n            dataType: \"style\"\n          }));\n          const r = this.isRootStyle();\n          t.imports ? this._loadImports(t.imports, i).then(() => {\n            this._reloadImports(), this.fire(new e.A(r ? \"style.load\" : \"style.import.load\"));\n          }) : (this._reloadImports(), this.fire(new e.A(r ? \"style.load\" : \"style.import.load\")));\n        };\n        this._styleColorTheme.colorTheme = this.stylesheet[\"color-theme\"];\n        const r = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;\n        if (r) {\n          const t = this._evaluateColorThemeData(r);\n          this._loadColorTheme(t).then(() => {\n            s();\n          }).catch(t => {\n            e.w(`Couldn't load color theme from the stylesheet: ${t}`), s();\n          });\n        } else this._styleColorTheme.lut = null, s();\n      }\n      isRootStyle() {\n        return 0 === this.importDepth;\n      }\n      mergeAll() {\n        let t, i, o, s, r, n, a, l, c, h;\n        const d = {};\n        this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle(e => {\n          if (e.stylesheet) {\n            if (null != e.light && (t = e.light), e.stylesheet.lights) for (const t of e.stylesheet.lights) \"ambient\" === t.type && null != e.ambientLight && (i = e.ambientLight), \"directional\" === t.type && null != e.directionalLight && (o = e.directionalLight);\n            s = this._prioritizeTerrain(s, e.terrain, e.stylesheet.terrain), e.stylesheet.fog && null != e.fog && (r = e.fog), e.stylesheet.snow && null != e.snow && (n = e.snow), e.stylesheet.rain && null != e.rain && (a = e.rain), null != e.stylesheet.camera && (h = e.stylesheet.camera), null != e.stylesheet.projection && (l = e.stylesheet.projection), null != e.stylesheet.transition && (c = e.stylesheet.transition), d[e.scope] = e._styleColorTheme;\n          }\n        }), this.light = t, this.ambientLight = i, this.directionalLight = o, this.fog = r, this.snow = n, this.rain = a, this._styleColorThemeForScope = d, null === s ? delete this.terrain : this.terrain = s, this.camera = h || {\n          \"camera-projection\": \"perspective\"\n        }, this.projection = l || {\n          name: \"mercator\"\n        }, this.transition = e.l({}, wo, c), this.mergeSources(), this.mergeLayers();\n      }\n      forEachFragmentStyle(e) {\n        const t = i => {\n          for (const e of i.fragments) t(e.style);\n          e(i);\n        };\n        t(this);\n      }\n      _prioritizeTerrain(e, t, i) {\n        const o = e && 0 === e.drapeRenderMode;\n        return null === i ? t && 0 === t.drapeRenderMode ? t : o ? e : null : null != t && (!e || o || t && 1 === t.drapeRenderMode) ? t : e;\n      }\n      mergeTerrain() {\n        let e;\n        this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle(t => {\n          e = this._prioritizeTerrain(e, t.terrain, t.stylesheet.terrain);\n        }), null === e ? delete this.terrain : this.terrain = e;\n      }\n      mergeProjection() {\n        let e;\n        this.forEachFragmentStyle(t => {\n          null != t.stylesheet.projection && (e = t.stylesheet.projection);\n        }), this.projection = e || {\n          name: \"mercator\"\n        };\n      }\n      mergeSources() {\n        const t = {},\n          i = {},\n          o = {};\n        this.forEachFragmentStyle(s => {\n          for (const i in s._sourceCaches) {\n            const o = e.C(i, s.scope);\n            t[o] = s._sourceCaches[i];\n          }\n          for (const t in s._otherSourceCaches) {\n            const o = e.C(t, s.scope);\n            i[o] = s._otherSourceCaches[t];\n          }\n          for (const t in s._symbolSourceCaches) {\n            const i = e.C(t, s.scope);\n            o[i] = s._symbolSourceCaches[t];\n          }\n        }), this._mergedSourceCaches = t, this._mergedOtherSourceCaches = i, this._mergedSymbolSourceCaches = o;\n      }\n      mergeLayers() {\n        const t = {},\n          i = [],\n          o = {};\n        this._mergedSlots = [], this._has3DLayers = !1, this._hasCircleLayers = !1, this._hasSymbolLayers = !1, this.forEachFragmentStyle(o => {\n          for (const s of o._order) {\n            const r = o._layers[s];\n            if (\"slot\" === r.type) {\n              const i = e.cr(s);\n              if (t[i]) continue;\n              t[i] = [];\n            }\n            r.slot && t[r.slot] ? t[r.slot].push(r) : i.push(r);\n          }\n        }), this._mergedOrder = [];\n        const s = (i = []) => {\n          for (const r of i) if (\"slot\" === r.type) {\n            const i = e.cr(r.id);\n            t[i] && s(t[i]), this._mergedSlots.push(i);\n          } else {\n            const t = e.C(r.id, r.scope);\n            this._mergedOrder.push(t), o[t] = r, r.is3D(!!this.terrain) && (this._has3DLayers = !0), \"circle\" === r.type && (this._hasCircleLayers = !0), \"symbol\" === r.type && (this._hasSymbolLayers = !0), \"clip\" === r.type && (this._clipLayerPresent = !0);\n          }\n        };\n        s(i), this._mergedOrder.sort((e, t) => {\n          const i = o[e],\n            s = o[t];\n          return i.hasInitialOcclusionOpacityProperties ? s.is3D(!!this.terrain) ? 1 : 0 : i.is3D(!!this.terrain) && s.hasInitialOcclusionOpacityProperties ? -1 : 0;\n        }), this._mergedLayers = o, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged();\n      }\n      terrainSetForDrapingOnly() {\n        return !!this.terrain && 0 === this.terrain.drapeRenderMode;\n      }\n      getCamera() {\n        return this.stylesheet.camera;\n      }\n      setCamera(t) {\n        return this.stylesheet.camera = e.l({}, this.stylesheet.camera, t), this.camera = this.stylesheet.camera, this;\n      }\n      _evaluateColorThemeData(t) {\n        return t.data ? function (t, i, o) {\n          const s = e.l({}, i);\n          for (const t of Object.keys(e.a5.colorTheme)) void 0 === s[t] && (s[t] = e.a5.colorTheme[t].default);\n          const r = new e.a6(co, t, new Map(o));\n          return r.setTransitionOrValue(s, o), r.untransitioned().possiblyEvaluate(new e.aa(0));\n        }(this.scope, t, this.options).get(\"data\") : null;\n      }\n      _loadColorTheme(t) {\n        this._styleColorTheme.lutLoading = !0, this._styleColorTheme.lutLoadingCorrelationID += 1;\n        const i = this._styleColorTheme.lutLoadingCorrelationID;\n        return new Promise((o, s) => {\n          const r = \"data:image/png;base64,\";\n          if (!t || 0 === t.length) return this._styleColorTheme.lut = null, this._styleColorTheme.lutLoading = !1, void o();\n          let n = t;\n          n.startsWith(r) || (n = r + n);\n          const a = e.I.from(\"mapbox-reserved-lut\"),\n            l = new Image();\n          l.src = n, l.onerror = () => {\n            this._styleColorTheme.lutLoading = !1, s(new Error(\"Failed to load image data\"));\n          }, l.onload = () => {\n            if (this._styleColorTheme.lutLoadingCorrelationID !== i) return void o();\n            this._styleColorTheme.lutLoading = !1;\n            const {\n              width: r,\n              height: n,\n              data: c\n            } = e.q.getImageData(l);\n            if (n > 32) return void s(new Error(\"The height of the image must be less than or equal to 32 pixels.\"));\n            if (r !== n * n) return void s(new Error(\"The width of the image must be equal to the height squared.\"));\n            this.getImage(a) && this.removeImage(a), this.addImage(a, {\n              data: new e.r({\n                width: r,\n                height: n\n              }, c),\n              pixelRatio: 1,\n              sdf: !1,\n              usvg: !1,\n              version: 0\n            });\n            const h = this.imageManager.getImage(a, this.scope);\n            h ? (this._styleColorTheme.lut = {\n              image: h.data,\n              data: t\n            }, o()) : s(new Error(\"Missing LUT image.\"));\n          };\n        });\n      }\n      getLut(e) {\n        const t = this._styleColorThemeForScope[e];\n        return t ? t.lut : null;\n      }\n      setProjection(e) {\n        e ? this.stylesheet.projection = e : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();\n      }\n      applyProjectionUpdate() {\n        this._loaded && (this.dispatcher.broadcast(\"setProjection\", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0));\n      }\n      _updateMapProjection() {\n        this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));\n      }\n      _loadSprite(t) {\n        this._spriteRequest = function (t, i, o) {\n          let s, r, n;\n          const a = e.q.devicePixelRatio > 1 ? \"@2x\" : \"\";\n          let l = e.n(i.transformRequest(i.normalizeSpriteURL(t, a, \".json\"), e.R.SpriteJSON), (e, t) => {\n              l = null, n || (n = e, s = t, h());\n            }),\n            c = e.o(i.transformRequest(i.normalizeSpriteURL(t, a, \".png\"), e.R.SpriteImage), (e, t) => {\n              c = null, n || (n = e, r = t, h());\n            });\n          function h() {\n            if (n) o(n);else if (s && r) {\n              const t = e.q.getImageData(r),\n                i = {};\n              for (const o in s) {\n                const {\n                    width: r,\n                    height: n,\n                    x: a,\n                    y: l,\n                    sdf: c,\n                    pixelRatio: h,\n                    stretchX: d,\n                    stretchY: u,\n                    content: _\n                  } = s[o],\n                  p = new e.r({\n                    width: r,\n                    height: n\n                  });\n                e.r.copy(t, p, {\n                  x: a,\n                  y: l\n                }, {\n                  x: 0,\n                  y: 0\n                }, {\n                  width: r,\n                  height: n\n                }, null), i[o] = {\n                  data: p,\n                  pixelRatio: h,\n                  sdf: c,\n                  stretchX: d,\n                  stretchY: u,\n                  content: _,\n                  usvg: !1\n                };\n              }\n              o(null, i);\n            }\n          }\n          return {\n            cancel() {\n              l && (l.cancel(), l = null), c && (c.cancel(), c = null);\n            }\n          };\n        }(t, this.map._requestManager, (t, i) => {\n          if (this._spriteRequest = null, t) this.fire(new e.z(t));else if (i) {\n            const t = new Map();\n            for (const o in i) t.set(e.I.from(o), i[o]);\n            this.addImages(t);\n          }\n          this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast(\"spriteLoaded\", {\n            scope: this.scope,\n            isLoaded: !0\n          }), this.fire(new e.A(\"data\", {\n            dataType: \"style\"\n          }));\n        });\n      }\n      addIconset(t, i) {\n        if (\"sprite\" === i.type) return void this._loadSprite(i.url);\n        const o = this.getOwnSource(i.source);\n        if (!o) return void this.fire(new e.z(new Error(`Source \"${i.source}\" as specified by iconset \"${t}\" does not exist and cannot be used as an iconset source`)));\n        if (\"raster-array\" !== o.type) return void this.fire(new e.z(new Error(`Source \"${i.source}\" as specified by iconset \"${t}\" is not a \"raster-array\" source and cannot be used as an iconset source`)));\n        this.imageManager.createIconset(this.scope, t);\n        const s = new mo(t, this);\n        o.addIconset(t, s);\n      }\n      _loadIconset(t) {\n        if (!e.f(t) && \"icon_set\" !== this.map._spriteFormat || \"raster\" === this.map._spriteFormat) return void this._loadSprite(t);\n        const i = \"auto\" === this.map._spriteFormat;\n        var o, s;\n        this._spriteRequest = (s = (o, s) => {\n          if (this._spriteRequest = null, o) i ? this._loadSprite(t) : this.fire(new e.z(o));else if (s) {\n            const t = new Map();\n            for (const i in s) t.set(e.I.from(i), s[i]);\n            this.addImages(t);\n          }\n          this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast(\"spriteLoaded\", {\n            scope: this.scope,\n            isLoaded: !0\n          }), this.fire(new e.A(\"data\", {\n            dataType: \"style\"\n          }));\n        }, e.bj((o = this.map._requestManager).transformRequest(o.normalizeIconsetURL(t), e.R.Iconset), (t, i) => {\n          if (t) return void s(t);\n          const o = {},\n            r = e.ch(new e.bi(i));\n          for (const t of r.icons) {\n            const i = {\n              version: 1,\n              pixelRatio: e.q.devicePixelRatio,\n              content: po(t),\n              stretchX: t.metadata ? fo(t.metadata.stretch_x_areas) : void 0,\n              stretchY: t.metadata ? fo(t.metadata.stretch_y_areas) : void 0,\n              sdf: !1,\n              usvg: !0,\n              icon: t\n            };\n            o[t.name] = i;\n          }\n          s(null, o);\n        }));\n      }\n      _validateLayer(t) {\n        const i = this.getOwnSource(t.source);\n        if (!i) return;\n        const o = t.sourceLayer;\n        o && (\"geojson\" === i.type || i.vectorLayerIds && -1 === i.vectorLayerIds.indexOf(o)) && this.fire(new e.z(new Error(`Source layer \"${o}\" does not exist on source \"${i.id}\" as specified by style layer \"${t.id}\"`)));\n      }\n      loaded() {\n        if (!this._loaded) return !1;\n        if (Object.keys(this._changes.getUpdatedSourceCaches()).length) return !1;\n        for (const e in this._sourceCaches) if (!this._sourceCaches[e].loaded()) return !1;\n        if (!this.imageManager.isLoaded()) return !1;\n        if (this.imageManager.hasPatternsInFlight()) return !1;\n        if (!this.modelManager.isLoaded()) return !1;\n        if (this._styleColorTheme.lutLoading) return !1;\n        for (const {\n          style: e\n        } of this.fragments) if (!e.loaded()) return !1;\n        return !0;\n      }\n      _serializeImports() {\n        if (this.stylesheet.imports) return this.stylesheet.imports.map((e, t) => {\n          const i = this.fragments[t];\n          return i && i.style && (e.data = i.style.serialize()), e;\n        });\n      }\n      _serializeSources() {\n        const e = {};\n        for (const t in this._sourceCaches) {\n          const i = this._sourceCaches[t].getSource();\n          e[i.id] || (e[i.id] = i.serialize());\n        }\n        return e;\n      }\n      _serializeLayers(e) {\n        const t = [];\n        for (const i of e) {\n          const e = this._layers[i];\n          e && \"custom\" !== e.type && t.push(e.serialize());\n        }\n        return t;\n      }\n      hasLightTransitions() {\n        return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());\n      }\n      hasFogTransition() {\n        return !!this.fog && this.fog.hasTransition();\n      }\n      hasSnowTransition() {\n        return !!this.snow && this.snow.hasTransition();\n      }\n      hasRainTransition() {\n        return !!this.rain && this.rain.hasTransition();\n      }\n      hasTransitions() {\n        if (this.hasLightTransitions()) return !0;\n        if (this.hasFogTransition()) return !0;\n        if (this.hasSnowTransition()) return !0;\n        if (this.hasRainTransition()) return !0;\n        for (const e in this._sourceCaches) if (this._sourceCaches[e].hasTransition()) return !0;\n        for (const e in this._layers) if (this._layers[e].hasTransition()) return !0;\n        return !1;\n      }\n      get order() {\n        return this.terrain ? this._drapedFirstOrder : this._mergedOrder;\n      }\n      _getOrder(e) {\n        return e ? this.order : this._mergedOrder;\n      }\n      isLayerDraped(e) {\n        return !!this.terrain && e.isDraped(this.getLayerSourceCache(e));\n      }\n      _checkLoaded() {\n        if (!this._loaded) throw new Error(\"Style is not done loading\");\n      }\n      _checkLayer(t) {\n        const i = this.getOwnLayer(t);\n        if (i) return i;\n        this.fire(new e.z(new Error(`The layer '${t}' does not exist in the map's style.`)));\n      }\n      _checkSource(t) {\n        const i = this.getOwnSource(t);\n        if (i) return i;\n        this.fire(new e.z(new Error(`The source '${t}' does not exist in the map's style.`)));\n      }\n      precompilePrograms(e, t) {\n        const i = this.map.painter;\n        if (i) for (let o = e.minzoom || 0; o < (e.maxzoom || 25.5); o++) {\n          const o = e.getProgramIds();\n          if (o) for (const s of o) {\n            const o = e.getDefaultProgramParams(s, t.zoom, this._styleColorTheme.lut);\n            o && (i.style = this, this.fog && (i._fogVisible = !0, o.overrideFog = !0, i.getOrCreateProgram(s, o)), i._fogVisible = !1, o.overrideFog = !1, i.getOrCreateProgram(s, o), (this.stylesheet.terrain || this.stylesheet.projection && \"globe\" === this.stylesheet.projection.name) && (o.overrideRtt = !0, i.getOrCreateProgram(s, o)));\n          }\n        }\n      }\n      update(t) {\n        if (!this._loaded) return;\n        this.ambientLight && this.ambientLight.recalculate(t), this.directionalLight && this.directionalLight.recalculate(t);\n        const i = this.calculateLightsBrightness();\n        t.brightness = i || 0, i !== this._brightness && (this._brightness = i, this.dispatcher.broadcast(\"setBrightness\", i));\n        const o = this._changes.isDirty();\n        let s = !1;\n        if (this._changes.isDirty()) {\n          const e = this._changes.getLayerUpdatesByScope();\n          for (const t in e) {\n            const {\n              updatedIds: i,\n              removedIds: o\n            } = e[t];\n            (i || o) && (this._updateWorkerLayers(t, i, o), s = !0);\n          }\n          this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t), this.light && this.light.updateTransitions(t), this.ambientLight && this.ambientLight.updateTransitions(t), this.directionalLight && this.directionalLight.updateTransitions(t), this.fog && this.fog.updateTransitions(t), this.snow && this.snow.updateTransitions(t), this.rain && this.rain.updateTransitions(t), this._changes.reset();\n        }\n        const r = {};\n        for (const e in this._mergedSourceCaches) {\n          const t = this._mergedSourceCaches[e];\n          r[e] = t.used, t.used = !1, t.tileCoverLift = 0;\n        }\n        for (const e of this._mergedOrder) {\n          const i = this._mergedLayers[e];\n          if (i.recalculate(t, this._availableImages), !i.isHidden(t.zoom)) {\n            const e = this.getLayerSourceCache(i);\n            e && (e.used = !0, e.tileCoverLift = Math.max(e.tileCoverLift, i.tileCoverLift()));\n          }\n          !this._precompileDone && this._shouldPrecompile && (\"requestIdleCallback\" in window ? requestIdleCallback(() => {\n            this.precompilePrograms(i, t);\n          }) : this.precompilePrograms(i, t));\n        }\n        for (const e in this._mergedSourceCaches) {\n          const t = this._mergedSourceCaches[e];\n          if (!t) continue;\n          const i = t._source;\n          \"raster-array\" === i.type && i.iconsets && (t.used = !0);\n        }\n        this._shouldPrecompile && (this._precompileDone = !0), this.terrain && s && this.mergeLayers();\n        for (const t in r) {\n          const i = this._mergedSourceCaches[t];\n          r[t] !== i.used && i.getSource().fire(new e.A(\"data\", {\n            sourceDataType: \"visibility\",\n            dataType: \"source\",\n            sourceId: i.getSource().id\n          }));\n        }\n        this.light && this.light.recalculate(t), this.terrain && this.terrain.recalculate(t), this.fog && this.fog.recalculate(t), this.snow && this.snow.recalculate(t), this.rain && this.rain.recalculate(t), this.z = t.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = !1), this.imageManager.clearUpdatedImages(this.scope), o && this.fire(new e.A(\"data\", {\n          dataType: \"style\"\n        }));\n      }\n      _updateTilesForChangedImages() {\n        const e = this._changes.getUpdatedImages();\n        if (e.length) {\n          for (const t in this._mergedSourceCaches) this._mergedSourceCaches[t].reloadTilesForDependencies([\"icons\", \"patterns\"], e);\n          this._changes.resetUpdatedImages();\n        }\n      }\n      _updateWorkerLayers(e, t, i) {\n        const o = this.getFragmentStyle(e);\n        o && this.dispatcher.broadcast(\"updateLayers\", {\n          layers: t ? o._serializeLayers(t) : [],\n          scope: e,\n          removedIds: i || [],\n          options: o.options\n        });\n      }\n      setState(t, i) {\n        if (this._checkLoaded(), go(this, me(t))) return !1;\n        (t = e.cq(t)).layers = Lt(t.layers);\n        const o = function (t, i) {\n          if (!t) return [{\n            command: Mt.setStyle,\n            args: [i]\n          }];\n          let o = [];\n          try {\n            if (!e.bn(t.version, i.version)) return [{\n              command: Mt.setStyle,\n              args: [i]\n            }];\n            if (e.bn(t.center, i.center) || o.push({\n              command: Mt.setCenter,\n              args: [i.center]\n            }), e.bn(t.zoom, i.zoom) || o.push({\n              command: Mt.setZoom,\n              args: [i.zoom]\n            }), e.bn(t.bearing, i.bearing) || o.push({\n              command: Mt.setBearing,\n              args: [i.bearing]\n            }), e.bn(t.pitch, i.pitch) || o.push({\n              command: Mt.setPitch,\n              args: [i.pitch]\n            }), e.bn(t.sprite, i.sprite) || o.push({\n              command: Mt.setSprite,\n              args: [i.sprite]\n            }), e.bn(t.glyphs, i.glyphs) || o.push({\n              command: Mt.setGlyphs,\n              args: [i.glyphs]\n            }), e.bn(t.imports, i.imports) || function (t = [], i = [], o) {\n              i = i || [];\n              const s = (t = t || []).map(Bt),\n                r = i.map(Bt),\n                n = t.reduce(Nt, {}),\n                a = i.reduce(Nt, {}),\n                l = s.slice();\n              let c, h, d, u;\n              for (c = 0, h = 0; c < s.length; c++) d = s[c], a.hasOwnProperty(d) ? h++ : (o.push({\n                command: Mt.removeImport,\n                args: [d]\n              }), l.splice(l.indexOf(d, h), 1));\n              for (c = 0, h = 0; c < r.length; c++) d = r[r.length - 1 - c], l[l.length - 1 - c] !== d && (n.hasOwnProperty(d) ? (o.push({\n                command: Mt.removeImport,\n                args: [d]\n              }), l.splice(l.lastIndexOf(d, l.length - h), 1)) : h++, u = l[l.length - c], o.push({\n                command: Mt.addImport,\n                args: [a[d], u]\n              }), l.splice(l.length - c, 0, d));\n              for (const t of i) {\n                const i = n[t.id];\n                i && !e.bn(i, t) && o.push({\n                  command: Mt.updateImport,\n                  args: [t.id, t]\n                });\n              }\n            }(t.imports, i.imports, o), e.bn(t.transition, i.transition) || o.push({\n              command: Mt.setTransition,\n              args: [i.transition]\n            }), e.bn(t.light, i.light) || o.push({\n              command: Mt.setLight,\n              args: [i.light]\n            }), e.bn(t.fog, i.fog) || o.push({\n              command: Mt.setFog,\n              args: [i.fog]\n            }), e.bn(t.snow, i.snow) || o.push({\n              command: Mt.setSnow,\n              args: [i.snow]\n            }), e.bn(t.rain, i.rain) || o.push({\n              command: Mt.setRain,\n              args: [i.rain]\n            }), e.bn(t.projection, i.projection) || o.push({\n              command: Mt.setProjection,\n              args: [i.projection]\n            }), e.bn(t.lights, i.lights) || o.push({\n              command: Mt.setLights,\n              args: [i.lights]\n            }), e.bn(t.camera, i.camera) || o.push({\n              command: Mt.setCamera,\n              args: [i.camera]\n            }), !e.bn(t[\"color-theme\"], i[\"color-theme\"])) return [{\n              command: Mt.setStyle,\n              args: [i]\n            }];\n            const s = {},\n              r = [];\n            !function (t, i, o, s) {\n              let r;\n              for (r in i = i || {}, t = t || {}) t.hasOwnProperty(r) && (i.hasOwnProperty(r) || zt(r, o, s));\n              for (r in i) {\n                if (!i.hasOwnProperty(r)) continue;\n                const n = i[r];\n                t.hasOwnProperty(r) ? e.bn(t[r], n) || (\"geojson\" === t[r].type && \"geojson\" === n.type && Ft(t, i, r) ? o.push({\n                  command: Mt.setGeoJSONSourceData,\n                  args: [r, n.data]\n                }) : Ot(r, i, o, s)) : Pt(r, i, o);\n              }\n            }(t.sources, i.sources, r, s);\n            const n = [];\n            t.layers && t.layers.forEach(e => {\n              e.source && s[e.source] ? o.push({\n                command: Mt.removeLayer,\n                args: [e.id]\n              }) : n.push(e);\n            });\n            let a = t.terrain;\n            a && s[a.source] && (o.push({\n              command: Mt.setTerrain,\n              args: [void 0]\n            }), a = void 0), o = o.concat(r), e.bn(a, i.terrain) || o.push({\n              command: Mt.setTerrain,\n              args: [i.terrain]\n            }), function (t, i, o) {\n              i = i || [];\n              const s = (t = t || []).map(Bt),\n                r = i.map(Bt),\n                n = t.reduce(Nt, {}),\n                a = i.reduce(Nt, {}),\n                l = s.slice(),\n                c = Object.create(null);\n              let h, d, u, _, p, f, m;\n              for (h = 0, d = 0; h < s.length; h++) u = s[h], a.hasOwnProperty(u) ? d++ : (o.push({\n                command: Mt.removeLayer,\n                args: [u]\n              }), l.splice(l.indexOf(u, d), 1));\n              for (h = 0, d = 0; h < r.length; h++) u = r[r.length - 1 - h], l[l.length - 1 - h] !== u && (n.hasOwnProperty(u) ? (o.push({\n                command: Mt.removeLayer,\n                args: [u]\n              }), l.splice(l.lastIndexOf(u, l.length - d), 1)) : d++, f = l[l.length - h], o.push({\n                command: Mt.addLayer,\n                args: [a[u], f]\n              }), l.splice(l.length - h, 0, u), c[u] = !0);\n              for (h = 0; h < r.length; h++) if (u = r[h], _ = n[u], p = a[u], !c[u] && !e.bn(_, p)) if (e.bn(_.source, p.source) && e.bn(_[\"source-layer\"], p[\"source-layer\"]) && e.bn(_.type, p.type)) {\n                for (m in kt(_.layout, p.layout, o, u, null, Mt.setLayoutProperty), kt(_.paint, p.paint, o, u, null, Mt.setPaintProperty), e.bn(_.slot, p.slot) || o.push({\n                  command: Mt.setSlot,\n                  args: [u, p.slot]\n                }), e.bn(_.filter, p.filter) || o.push({\n                  command: Mt.setFilter,\n                  args: [u, p.filter]\n                }), e.bn(_.minzoom, p.minzoom) && e.bn(_.maxzoom, p.maxzoom) || o.push({\n                  command: Mt.setLayerZoomRange,\n                  args: [u, p.minzoom, p.maxzoom]\n                }), _) _.hasOwnProperty(m) && \"layout\" !== m && \"paint\" !== m && \"filter\" !== m && \"metadata\" !== m && \"minzoom\" !== m && \"maxzoom\" !== m && \"slot\" !== m && (0 === m.indexOf(\"paint.\") ? kt(_[m], p[m], o, u, m.slice(6), Mt.setPaintProperty) : e.bn(_[m], p[m]) || o.push({\n                  command: Mt.setLayerProperty,\n                  args: [u, m, p[m]]\n                }));\n                for (m in p) p.hasOwnProperty(m) && !_.hasOwnProperty(m) && \"layout\" !== m && \"paint\" !== m && \"filter\" !== m && \"metadata\" !== m && \"minzoom\" !== m && \"maxzoom\" !== m && \"slot\" !== m && (0 === m.indexOf(\"paint.\") ? kt(_[m], p[m], o, u, m.slice(6), Mt.setPaintProperty) : e.bn(_[m], p[m]) || o.push({\n                  command: Mt.setLayerProperty,\n                  args: [u, m, p[m]]\n                }));\n              } else o.push({\n                command: Mt.removeLayer,\n                args: [u]\n              }), f = l[l.lastIndexOf(u) + 1], o.push({\n                command: Mt.addLayer,\n                args: [p, f]\n              });\n            }(n, i.layers, o);\n          } catch (e) {\n            console.warn(\"Unable to compute style diff:\", e), o = [{\n              command: Mt.setStyle,\n              args: [i]\n            }];\n          }\n          return o;\n        }(this.serialize(), t).filter(e => !(e.command in yo));\n        if (0 === o.length) return !1;\n        const s = o.filter(e => !(e.command in vo));\n        if (s.length > 0) throw new Error(`Unimplemented: ${s.map(e => e.command).join(\", \")}.`);\n        const r = [];\n        return o.forEach(e => {\n          r.push(this[e.command].apply(this, e.args));\n        }), i && Promise.all(r).then(i), this.stylesheet = t, this.mergeAll(), this.dispatcher.broadcast(\"setLayers\", {\n          layers: this._serializeLayers(this._order),\n          scope: this.scope,\n          options: this.options\n        }), !0;\n      }\n      _updateWorkerImages() {\n        this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast(\"setImages\", {\n          scope: this.scope,\n          images: this._availableImages\n        });\n      }\n      addImages(t) {\n        for (const [i, o] of t.entries()) {\n          if (this.getImage(i) && !i.iconsetId) return this.fire(new e.z(new Error(`An image with the name \"${i.name}\" already exists.`)));\n          this.imageManager.addImage(i, this.scope, o), this._changes.updateImage(i);\n        }\n        return this._updateWorkerImages(), this.fire(new e.A(\"data\", {\n          dataType: \"style\"\n        })), this;\n      }\n      addImage(t, i) {\n        return this.getImage(t) && !t.iconsetId ? this.fire(new e.z(new Error(`An image with the name \"${t.name}\" already exists.`))) : (this.imageManager.addImage(t, this.scope, i), this._changes.updateImage(t), this._updateWorkerImages(), this.fire(new e.A(\"data\", {\n          dataType: \"style\"\n        })), this);\n      }\n      updateImage(t, i, o = !1) {\n        this.imageManager.updateImage(t, this.scope, i), o && (this._changes.updateImage(t), this._updateWorkerImages(), this.fire(new e.A(\"data\", {\n          dataType: \"style\"\n        })));\n      }\n      getImage(e) {\n        return this.imageManager.getImage(e, this.scope);\n      }\n      removeImage(t) {\n        return this.getImage(t) ? (this.imageManager.removeImage(t, this.scope), this._changes.updateImage(t), this._updateWorkerImages(), this.fire(new e.A(\"data\", {\n          dataType: \"style\"\n        })), this) : this.fire(new e.z(new Error(\"No image with this name exists.\")));\n      }\n      listImages() {\n        return this._checkLoaded(), this._availableImages.slice();\n      }\n      addModel(e, t, i = {}) {\n        return this._checkLoaded(), this._validate(Re, `models.${e}`, t, null, i) || (this.modelManager.addModel(e, t, this.scope), this._changes.setDirty()), this;\n      }\n      hasModel(e) {\n        return this.modelManager.hasModel(e, this.scope);\n      }\n      removeModel(t) {\n        return this.hasModel(t) ? (this.modelManager.removeModel(t, this.scope), this) : this.fire(new e.z(new Error(\"No model with this ID exists.\")));\n      }\n      listModels() {\n        return this._checkLoaded(), this.modelManager.listModels(this.scope);\n      }\n      addSource(t, i, o = {}) {\n        if (this._checkLoaded(), void 0 !== this.getOwnSource(t)) throw new Error(`There is already a source with ID \"${t}\".`);\n        if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(\", \")}.`);\n        if ([\"vector\", \"raster\", \"geojson\", \"video\", \"image\"].indexOf(i.type) >= 0 && this._validate(ge, `sources.${t}`, i, null, o)) return;\n        this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);\n        const s = rt(t, i, this.dispatcher, this);\n        s.scope = this.scope, s.setEventedParent(this, () => ({\n          isSourceLoaded: this._isSourceCacheLoaded(s.id),\n          source: s.serialize(),\n          sourceId: s.id\n        }));\n        const r = t => {\n          const i = (t ? \"symbol:\" : \"other:\") + s.id,\n            o = e.C(i, this.scope),\n            r = this._sourceCaches[i] = new St(o, s, t);\n          (t ? this._symbolSourceCaches : this._otherSourceCaches)[s.id] = r, r.onAdd(this.map);\n        };\n        r(!1), \"vector\" !== i.type && \"geojson\" !== i.type || r(!0), s.onAdd && s.onAdd(this.map), o.isInitialLoad || (this.mergeSources(), this._changes.setDirty());\n      }\n      removeSource(t) {\n        this._checkLoaded();\n        const i = this.getOwnSource(t);\n        if (!i) throw new Error(\"There is no source with this ID\");\n        for (const i in this._layers) if (this._layers[i].source === t) return this.fire(new e.z(new Error(`Source \"${t}\" cannot be removed while layer \"${i}\" is using it.`)));\n        if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t) return this.fire(new e.z(new Error(`Source \"${t}\" cannot be removed while terrain is using it.`)));\n        const o = this.getOwnSourceCaches(t);\n        for (const t of o) {\n          const i = e.cr(t.id);\n          delete this._sourceCaches[i], this._changes.discardSourceCacheUpdate(t.id), t.fire(new e.A(\"data\", {\n            sourceDataType: \"metadata\",\n            dataType: \"source\",\n            sourceId: t.getSource().id\n          })), t.setEventedParent(null), t.clearTiles();\n        }\n        return delete this._otherSourceCaches[t], delete this._symbolSourceCaches[t], this.mergeSources(), i.setEventedParent(null), i.onRemove && i.onRemove(this.map), this._changes.setDirty(), this;\n      }\n      setGeoJSONSourceData(e, t) {\n        this._checkLoaded(), this.getOwnSource(e).setData(t), this._changes.setDirty();\n      }\n      getOwnSource(e) {\n        const t = this.getOwnSourceCache(e);\n        return t && t.getSource();\n      }\n      getOwnSources() {\n        const e = [];\n        for (const t in this._otherSourceCaches) {\n          const i = this.getOwnSourceCache(t);\n          i && e.push(i.getSource());\n        }\n        return e;\n      }\n      areTilesLoaded() {\n        const e = this._mergedSourceCaches;\n        for (const t in e) {\n          const i = e[t]._tiles;\n          for (const e in i) {\n            const t = i[e];\n            if (\"loaded\" !== t.state && \"errored\" !== t.state) return !1;\n          }\n        }\n        return !0;\n      }\n      setLights(t) {\n        if (this._checkLoaded(), !t) return delete this.ambientLight, void delete this.directionalLight;\n        const i = this._getTransitionParameters();\n        for (const o of t) {\n          if (this._validate(ye, \"lights\", o)) return;\n          switch (o.type) {\n            case \"ambient\":\n              if (this.ambientLight) {\n                const e = this.ambientLight;\n                e.set(o), e.updateTransitions(i);\n              } else this.ambientLight = new $e(o, qe || (qe = new e.a7({\n                color: new e.a8(e.a5.properties_light_ambient.color),\n                \"color-use-theme\": new e.a8({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-constant\"\n                }),\n                intensity: new e.a8(e.a5.properties_light_ambient.intensity)\n              })), this.scope, this.options);\n              break;\n            case \"directional\":\n              if (this.directionalLight) {\n                const e = this.directionalLight;\n                e.set(o), e.updateTransitions(i);\n              } else this.directionalLight = new $e(o, He || (He = new e.a7({\n                direction: new e.am(e.a5.properties_light_directional.direction),\n                color: new e.a8(e.a5.properties_light_directional.color),\n                \"color-use-theme\": new e.a8({\n                  type: \"string\",\n                  default: \"default\",\n                  \"property-type\": \"data-constant\"\n                }),\n                intensity: new e.a8(e.a5.properties_light_directional.intensity),\n                \"cast-shadows\": new e.a8(e.a5.properties_light_directional[\"cast-shadows\"]),\n                \"shadow-quality\": new e.a8(e.a5.properties_light_directional[\"shadow-quality\"]),\n                \"shadow-intensity\": new e.a8(e.a5.properties_light_directional[\"shadow-intensity\"])\n              })), this.scope, this.options);\n          }\n        }\n        const o = new e.aa(this.z || 0, i);\n        this.ambientLight && this.ambientLight.recalculate(o), this.directionalLight && this.directionalLight.recalculate(o), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast(\"setBrightness\", this._brightness);\n      }\n      calculateLightsBrightness() {\n        const t = this.directionalLight,\n          i = this.ambientLight;\n        if (!t || !i) return;\n        const o = e => .2126 * (e[0] <= .03928 ? e[0] / 12.92 : Math.pow((e[0] + .055) / 1.055, 2.4)) + .7152 * (e[1] <= .03928 ? e[1] / 12.92 : Math.pow((e[1] + .055) / 1.055, 2.4)) + .0722 * (e[2] <= .03928 ? e[2] / 12.92 : Math.pow((e[2] + .055) / 1.055, 2.4)),\n          s = t.properties.get(\"color\").toRenderColor(null).toArray01(),\n          r = t.properties.get(\"intensity\"),\n          n = t.properties.get(\"direction\"),\n          a = 1 - e.cc(n.x, n.y, n.z)[2] / 90,\n          l = o(s) * r * a,\n          c = i.properties.get(\"color\").toRenderColor(null).toArray01(),\n          h = i.properties.get(\"intensity\"),\n          d = o(c) * h;\n        return Number(((l + d) / 2).toFixed(6));\n      }\n      getBrightness() {\n        return this._brightness;\n      }\n      getLights() {\n        if (!this.enable3dLights()) return null;\n        const e = [];\n        return this.directionalLight && e.push(this.directionalLight.get()), this.ambientLight && e.push(this.ambientLight.get()), e;\n      }\n      enable3dLights() {\n        return !!this.ambientLight && !!this.directionalLight;\n      }\n      getFragmentStyle(t) {\n        if (!t) return this;\n        if (e.cs(t)) {\n          const i = e.ct(t),\n            o = this.fragments.find(({\n              id: e\n            }) => e === i);\n          if (!o) throw new Error(`Style import '${t}' not found`);\n          const s = e.cr(t);\n          return o.style.getFragmentStyle(s);\n        }\n        {\n          const e = this.fragments.find(({\n            id: e\n          }) => e === t);\n          return e ? e.style : void 0;\n        }\n      }\n      setFeaturesetSelectors(t) {\n        if (!t) return;\n        const i = {},\n          o = (e, t = \"\") => `${e}::${t}`;\n        this._featuresetSelectors = {};\n        for (const s in t) {\n          const r = this._featuresetSelectors[s] = [];\n          for (const n of t[s].selectors) {\n            if (n.featureNamespace) {\n              const t = this.getOwnLayer(n.layer);\n              if (!t) {\n                e.w(`Layer is undefined for selector: ${n.layer}`);\n                continue;\n              }\n              const r = o(t.source, t.sourceLayer);\n              if (r in i && i[r] !== n.featureNamespace) {\n                e.w(`\"featureNamespace ${n.featureNamespace} of featureset ${s}'s selector is not associated to the same source, skip this selector`);\n                continue;\n              }\n              i[r] = n.featureNamespace;\n            }\n            let t;\n            if (n.properties) for (const i in n.properties) {\n              const o = e.X(n.properties[i]);\n              \"success\" === o.result && (t = t || {}, t[i] = o.value);\n            }\n            r.push({\n              layerId: n.layer,\n              namespace: n.featureNamespace,\n              properties: t,\n              uniqueFeatureID: n._uniqueFeatureID\n            });\n          }\n        }\n      }\n      getFeaturesetDescriptors(e) {\n        const t = this.getFragmentStyle(e);\n        if (!t || !t.stylesheet.featuresets) return [];\n        const i = [];\n        for (const e in t.stylesheet.featuresets) i.push({\n          featuresetId: e,\n          importId: t.scope ? t.scope : void 0\n        });\n        return i;\n      }\n      getFeaturesetLayers(t, i) {\n        const o = this.getFragmentStyle(i),\n          s = o.stylesheet.featuresets;\n        if (!s || !s[t]) return this.fire(new e.z(new Error(`The featureset '${t}' does not exist in the map's style and cannot be queried.`))), [];\n        const r = [];\n        for (const e of s[t].selectors) {\n          const t = o.getOwnLayer(e.layer);\n          t && r.push(t);\n        }\n        return r;\n      }\n      getConfigProperty(t, i) {\n        const o = this.getFragmentStyle(t);\n        if (!o) return null;\n        const s = e.C(i, o.scope),\n          r = o.options.get(s),\n          n = r ? r.value || r.default : null;\n        return n ? n.serialize() : null;\n      }\n      setConfigProperty(t, i, o) {\n        const s = this.getFragmentStyle(t);\n        if (!s) return;\n        const r = s.stylesheet.indoor ? uo(s.stylesheet.schema) : s.stylesheet.schema;\n        if (!r || !r[i]) return;\n        const n = e.X(o);\n        if (\"success\" !== n.result) return void go(this, n.value);\n        const a = n.value.expression,\n          l = e.C(i, s.scope),\n          c = s.options.get(l);\n        if (!c) return;\n        let h;\n        const {\n            minValue: d,\n            maxValue: u,\n            stepValue: _,\n            type: p,\n            values: f\n          } = r[i],\n          m = e.X(r[i].default);\n        \"success\" === m.result && (h = m.value.expression), h ? (this.options.set(l, Object.assign({}, c, {\n          value: a,\n          default: h,\n          minValue: d,\n          maxValue: u,\n          stepValue: _,\n          type: p,\n          values: f\n        })), this.updateConfigDependencies(i)) : this.fire(new e.z(new Error(`No schema defined for the config option \"${i}\" in the \"${t}\" fragment.`)));\n      }\n      getConfig(t) {\n        const i = this.getFragmentStyle(t);\n        if (!i) return null;\n        const o = i.stylesheet.schema;\n        if (!o) return null;\n        const s = {};\n        for (const t in o) {\n          const o = e.C(t, i.scope),\n            r = i.options.get(o),\n            n = r ? r.value || r.default : null;\n          s[t] = n ? n.serialize() : null;\n        }\n        return s;\n      }\n      setConfig(e, t) {\n        const i = this.getFragmentStyle(e);\n        i && (i.updateConfig(t, i.stylesheet.schema), this.updateConfigDependencies());\n      }\n      getSchema(e) {\n        const t = this.getFragmentStyle(e);\n        return t ? t.stylesheet.schema : null;\n      }\n      setSchema(e, t) {\n        const i = this.getFragmentStyle(e);\n        i && (i.stylesheet.schema = t, i.updateConfig(i._config, t), this.updateConfigDependencies());\n      }\n      updateConfig(t, i) {\n        if (this._config = t, t || i) if (i) for (const o in i) {\n          let s, r;\n          const n = e.X(i[o].default);\n          if (\"success\" === n.result && (s = n.value.expression), t && void 0 !== t[o]) {\n            const i = e.X(t[o]);\n            \"success\" === i.result && (r = i.value.expression);\n          }\n          const {\n            minValue: a,\n            maxValue: l,\n            stepValue: c,\n            type: h,\n            values: d\n          } = i[o];\n          if (s) {\n            const t = e.C(o, this.scope);\n            this.options.set(t, {\n              default: s,\n              value: r,\n              minValue: a,\n              maxValue: l,\n              stepValue: c,\n              type: h,\n              values: d\n            });\n          } else this.fire(new e.z(new Error(`No schema defined for config option \"${o}\".`)));\n        } else this.fire(new e.z(new Error(\"Attempting to set config for a style without schema.\")));\n      }\n      updateConfigDependencies(e) {\n        for (const t of this._configDependentLayers) {\n          const i = this.getLayer(t);\n          if (i) {\n            if (e && !i.configDependencies.has(e)) continue;\n            i.possiblyEvaluateVisibility(), this._updateLayer(i);\n          }\n        }\n        this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this.snow && this.snow.updateConfig(this.options), this.rain && this.rain.updateConfig(this.options), this.forEachFragmentStyle(e => {\n          const t = e._styleColorTheme.colorThemeOverride ? e._styleColorTheme.colorThemeOverride : e._styleColorTheme.colorTheme;\n          if (t) {\n            const i = e._evaluateColorThemeData(t);\n            (!e._styleColorTheme.lut && \"\" !== i || e._styleColorTheme.lut && i !== e._styleColorTheme.lut.data) && e.setColorTheme(t);\n          }\n        }), this._changes.setDirty();\n      }\n      addLayer(t, i, o = {}) {\n        this._checkLoaded();\n        const s = t.id;\n        if (this._layers[s]) return void this.fire(new e.z(new Error(`Layer with id \"${s}\" already exists on this map`)));\n        let r;\n        if (\"custom\" === t.type) {\n          if (go(this, e.cu(t))) return;\n          r = e.cv(t, this.scope, this._styleColorTheme.lut, this.options);\n        } else {\n          if (\"object\" == typeof t.source && (this.addSource(s, t.source), t = e.cq(t), t = e.l(t, {\n            source: s\n          })), this._validate(Ee, `layers.${s}`, t, {\n            arrayIndex: -1\n          }, o)) return;\n          r = e.cv(t, this.scope, this._styleColorTheme.lut, this.options), this._validateLayer(r), r.setEventedParent(this, {\n            layer: {\n              id: s\n            }\n          });\n        }\n        0 !== r.configDependencies.size && this._configDependentLayers.add(r.fqid);\n        let n = this._order.length;\n        if (i) {\n          const t = this._order.indexOf(i);\n          if (-1 === t) return void this.fire(new e.z(new Error(`Layer with id \"${i}\" does not exist on this map.`)));\n          r.slot === this._layers[i].slot ? n = t : e.w(`Layer with id \"${i}\" has a different slot. Layers can only be rearranged within the same slot.`);\n        }\n        this._order.splice(n, 0, s), this._layerOrderChanged = !0, this._layers[s] = r;\n        const a = this.getOwnLayerSourceCache(r),\n          l = !!this.directionalLight && this.directionalLight.shadowsEnabled();\n        a && r.canCastShadows() && l && (a.castsShadows = !0);\n        const c = this._changes.getRemovedLayer(r);\n        if (c && r.source && a && \"custom\" !== r.type) {\n          this._changes.discardLayerRemoval(r);\n          const t = e.C(r.source, r.scope);\n          c.type !== r.type ? this._changes.updateSourceCache(t, \"clear\") : (this._changes.updateSourceCache(t, \"reload\"), a.pause());\n        }\n        this._updateLayer(r), r.onAdd && r.onAdd(this.map), r.scope = this.scope, this.mergeLayers();\n      }\n      moveLayer(t, i) {\n        this._checkLoaded();\n        const o = this._checkLayer(t);\n        if (!o) return;\n        if (t === i) return;\n        const s = this._order.indexOf(t);\n        this._order.splice(s, 1);\n        let r = this._order.length;\n        if (i) {\n          const t = this._order.indexOf(i);\n          if (-1 === t) return void this.fire(new e.z(new Error(`Layer with id \"${i}\" does not exist on this map.`)));\n          o.slot === this._layers[i].slot ? r = t : e.w(`Layer with id \"${i}\" has a different slot. Layers can only be rearranged within the same slot.`);\n        }\n        this._order.splice(r, 0, t), this._changes.setDirty(), this._layerOrderChanged = !0, this.mergeLayers();\n      }\n      removeLayer(e) {\n        this._checkLoaded();\n        const t = this._checkLayer(e);\n        if (!t) return;\n        t.setEventedParent(null);\n        const i = this._order.indexOf(e);\n        this._order.splice(i, 1), delete this._layers[e], this._changes.setDirty(), this._layerOrderChanged = !0, this._configDependentLayers.delete(t.fqid), this._changes.removeLayer(t);\n        const o = this.getOwnLayerSourceCache(t);\n        if (o && o.castsShadows) {\n          let e = !1;\n          for (const i in this._layers) if (this._layers[i].source === t.source && this._layers[i].canCastShadows()) {\n            e = !0;\n            break;\n          }\n          o.castsShadows = e;\n        }\n        t.onRemove && t.onRemove(this.map), this.mergeLayers();\n      }\n      getOwnLayer(e) {\n        return this._layers[e];\n      }\n      hasLayer(e) {\n        return e in this._mergedLayers;\n      }\n      hasLayerType(e) {\n        for (const t in this._layers) if (this._layers[t].type === e) return !0;\n        return !1;\n      }\n      setLayerZoomRange(e, t, i) {\n        this._checkLoaded();\n        const o = this._checkLayer(e);\n        o && (o.minzoom === t && o.maxzoom === i || (null != t && (o.minzoom = t), null != i && (o.maxzoom = i), this._updateLayer(o)));\n      }\n      getSlots() {\n        return this._checkLoaded(), this._mergedSlots;\n      }\n      setSlot(e, t) {\n        this._checkLoaded();\n        const i = this._checkLayer(e);\n        i && i.slot !== t && (i.slot = t, this._updateLayer(i));\n      }\n      setFilter(t, i, o = {}) {\n        this._checkLoaded();\n        const s = this._checkLayer(t);\n        if (s && !e.bn(s.filter, i)) return null == i ? (s.filter = void 0, void this._updateLayer(s)) : void (this._validate(Se, `layers.${s.id}.filter`, i, {\n          layerType: s.type\n        }, o) || (s.filter = e.cq(i), this._updateLayer(s)));\n      }\n      getFilter(t) {\n        const i = this._checkLayer(t);\n        if (i) return e.cq(i.filter);\n      }\n      setLayoutProperty(t, i, o, s = {}) {\n        this._checkLoaded();\n        const r = this._checkLayer(t);\n        if (r && !e.bn(r.getLayoutProperty(i), o)) {\n          if (null != o && (!s || !1 !== s.validate) && go(r, Ie.call(me, {\n            key: `layers.${t}.layout.${i}`,\n            layerType: r.type,\n            objectKey: i,\n            value: o,\n            styleSpec: e.a5,\n            style: {\n              glyphs: !0,\n              sprite: !0\n            }\n          }))) return;\n          r.setLayoutProperty(i, o), 0 !== r.configDependencies.size && this._configDependentLayers.add(r.fqid), this._updateLayer(r);\n        }\n      }\n      getLayoutProperty(e, t) {\n        const i = this._checkLayer(e);\n        if (i) return i.getLayoutProperty(t);\n      }\n      setPaintProperty(t, i, o, s = {}) {\n        this._checkLoaded();\n        const r = this._checkLayer(t);\n        if (!r) return;\n        if (e.bn(r.getPaintProperty(i), o)) return;\n        if (null != o && (!s || !1 !== s.validate) && go(r, Ce.call(me, {\n          key: `layers.${t}.paint.${i}`,\n          layerType: r.type,\n          objectKey: i,\n          value: o,\n          styleSpec: e.a5\n        }))) return;\n        const n = r.setPaintProperty(i, o);\n        0 !== r.configDependencies.size && this._configDependentLayers.add(r.fqid), n && this._updateLayer(r), this._changes.updatePaintProperties(r);\n      }\n      getPaintProperty(e, t) {\n        const i = this._checkLayer(e);\n        if (i) return i.getPaintProperty(t);\n      }\n      setFeatureState(t, i) {\n        if (this._checkLoaded(), \"target\" in t) {\n          if (\"featuresetId\" in t.target) {\n            const {\n                featuresetId: e,\n                importId: o\n              } = t.target,\n              s = this.getFragmentStyle(o),\n              r = s.getFeaturesetLayers(e);\n            for (const {\n              source: e,\n              sourceLayer: o\n            } of r) s.setFeatureState({\n              id: t.id,\n              source: e,\n              sourceLayer: o\n            }, i);\n          } else if (\"layerId\" in t.target) {\n            const {\n                layerId: e\n              } = t.target,\n              o = this.getLayer(e);\n            this.setFeatureState({\n              id: t.id,\n              source: o.source,\n              sourceLayer: o.sourceLayer\n            }, i);\n          }\n          return;\n        }\n        const o = t.source,\n          s = t.sourceLayer,\n          r = this._checkSource(o);\n        if (!r) return;\n        const n = r.type;\n        if (\"geojson\" === n && s) return void this.fire(new e.z(new Error(\"GeoJSON sources cannot have a sourceLayer parameter.\")));\n        if (\"vector\" === n && !s) return void this.fire(new e.z(new Error(\"The sourceLayer parameter must be provided for vector source types.\")));\n        void 0 === t.id && this.fire(new e.z(new Error(\"The feature id parameter must be provided.\")));\n        const a = this.getOwnSourceCaches(o);\n        for (const e of a) e.setFeatureState(s, t.id, i);\n      }\n      removeFeatureState(t, i) {\n        if (this._checkLoaded(), \"target\" in t) {\n          if (\"featuresetId\" in t.target) {\n            const {\n                featuresetId: e,\n                importId: o\n              } = t.target,\n              s = this.getFragmentStyle(o),\n              r = s.getFeaturesetLayers(e);\n            for (const {\n              source: e,\n              sourceLayer: o\n            } of r) s.removeFeatureState({\n              id: t.id,\n              source: e,\n              sourceLayer: o\n            }, i);\n          } else if (\"layerId\" in t.target) {\n            const {\n                layerId: e\n              } = t.target,\n              o = this.getLayer(e);\n            this.removeFeatureState({\n              id: t.id,\n              source: o.source,\n              sourceLayer: o.sourceLayer\n            }, i);\n          }\n          return;\n        }\n        const o = t.source,\n          s = this._checkSource(o);\n        if (!s) return;\n        const r = s.type,\n          n = \"vector\" === r ? t.sourceLayer : void 0;\n        if (\"vector\" === r && !n) return void this.fire(new e.z(new Error(\"The sourceLayer parameter must be provided for vector source types.\")));\n        if (i && \"string\" != typeof t.id && \"number\" != typeof t.id) return void this.fire(new e.z(new Error(\"A feature id is required to remove its specific state property.\")));\n        const a = this.getOwnSourceCaches(o);\n        for (const e of a) e.removeFeatureState(n, t.id, i);\n      }\n      getFeatureState(t) {\n        if (this._checkLoaded(), \"target\" in t) {\n          let i;\n          if (\"featuresetId\" in t.target) {\n            const {\n                featuresetId: o,\n                importId: s\n              } = t.target,\n              r = this.getFragmentStyle(s),\n              n = r.getFeaturesetLayers(o);\n            for (const {\n              source: o,\n              sourceLayer: s\n            } of n) {\n              const n = r.getFeatureState({\n                id: t.id,\n                source: o,\n                sourceLayer: s\n              });\n              if (n && !i) i = n;else if (!e.bn(i, n)) return void this.fire(new e.z(new Error(\"The same feature id exists in multiple sources in the featureset, but their feature states are not consistent through the sources.\")));\n            }\n          } else if (\"layerId\" in t.target) {\n            const {\n                layerId: e\n              } = t.target,\n              o = this.getLayer(e);\n            i = this.getFeatureState({\n              id: t.id,\n              source: o.source,\n              sourceLayer: o.sourceLayer\n            });\n          }\n          return i;\n        }\n        const i = t.source,\n          o = t.sourceLayer,\n          s = this._checkSource(i);\n        if (s) {\n          if (\"vector\" !== s.type || o) return void 0 === t.id && this.fire(new e.z(new Error(\"The feature id parameter must be provided.\"))), this.getOwnSourceCaches(i)[0].getFeatureState(o, t.id);\n          this.fire(new e.z(new Error(\"The sourceLayer parameter must be provided for vector source types.\")));\n        }\n      }\n      setTransition(t) {\n        return this.stylesheet.transition = e.l({}, this.stylesheet.transition, t), this.transition = this.stylesheet.transition, this;\n      }\n      getTransition() {\n        return e.l({}, this.stylesheet.transition);\n      }\n      serialize() {\n        this._checkLoaded();\n        const t = this.getTerrain(),\n          i = t && this.terrain && this.terrain.scope === this.scope ? t : this.stylesheet.terrain;\n        return e.cw({\n          version: this.stylesheet.version,\n          name: this.stylesheet.name,\n          metadata: this.stylesheet.metadata,\n          fragment: this.stylesheet.fragment,\n          iconsets: this.stylesheet.iconsets,\n          imports: this._serializeImports(),\n          schema: this.stylesheet.schema,\n          camera: this.stylesheet.camera,\n          light: this.stylesheet.light,\n          lights: this.stylesheet.lights,\n          terrain: i,\n          fog: this.stylesheet.fog,\n          snow: this.stylesheet.snow,\n          rain: this.stylesheet.rain,\n          center: this.stylesheet.center,\n          \"color-theme\": this.stylesheet[\"color-theme\"],\n          zoom: this.stylesheet.zoom,\n          bearing: this.stylesheet.bearing,\n          pitch: this.stylesheet.pitch,\n          sprite: this.stylesheet.sprite,\n          glyphs: this.stylesheet.glyphs,\n          transition: this.stylesheet.transition,\n          projection: this.stylesheet.projection,\n          sources: this._serializeSources(),\n          layers: this._serializeLayers(this._order)\n        }, e => void 0 !== e);\n      }\n      _updateFilteredLayers(e) {\n        for (const t of Object.values(this._mergedLayers)) e(t) && this._updateLayer(t);\n      }\n      _updateLayer(t) {\n        this._changes.updateLayer(t);\n        const i = this.getLayerSourceCache(t),\n          o = e.C(t.source, t.scope),\n          s = this._changes.getUpdatedSourceCaches();\n        t.source && !s[o] && i && \"raster\" !== i.getSource().type && (this._changes.updateSourceCache(o, \"reload\"), i.pause()), t.invalidateCompiledFilter();\n      }\n      _flattenAndSortRenderedFeatures(e) {\n        const t = e => this._mergedLayers[e].is3D(!!this.terrain),\n          i = this.order,\n          o = {},\n          s = [];\n        for (let r = i.length - 1; r >= 0; r--) {\n          const n = i[r];\n          if (t(n)) {\n            o[n] = r;\n            for (const t of e) {\n              const e = t[n];\n              if (e) for (const t of e) s.push(t);\n            }\n          }\n        }\n        s.sort((e, t) => t.intersectionZ - e.intersectionZ);\n        const r = [];\n        for (let n = i.length - 1; n >= 0; n--) {\n          const a = i[n];\n          if (t(a)) for (let e = s.length - 1; e >= 0; e--) {\n            const t = s[e].feature;\n            if (t.layer && o[t.layer.id] < n) break;\n            r.push(t), s.pop();\n          } else for (const t of e) {\n            const e = t[a];\n            if (e) for (const t of e) r.push(t.feature);\n          }\n        }\n        return r;\n      }\n      queryRenderedFeatures(t, i, o) {\n        let s;\n        i && !Array.isArray(i) && i.filter && (this._validate(Se, \"queryRenderedFeatures.filter\", i.filter, null, i), s = e.a_(i.filter));\n        const r = {},\n          n = e => {\n            if (xo.has(e.type)) return;\n            const t = this.getOwnLayerSourceCache(e),\n              i = r[t.id] = r[t.id] || {\n                sourceCache: t,\n                layers: {},\n                has3DLayers: !1\n              };\n            e.is3D(!!this.terrain) && (i.has3DLayers = !0), i.layers[e.fqid] = i.layers[e.fqid] || {\n              styleLayer: e,\n              targets: []\n            }, i.layers[e.fqid].targets.push({\n              filter: s\n            });\n          };\n        if (i && i.layers) {\n          if (!Array.isArray(i.layers)) return this.fire(new e.z(new Error(\"parameters.layers must be an Array.\"))), [];\n          for (const t of i.layers) {\n            const i = this._layers[t];\n            if (!i) return this.fire(new e.z(new Error(`The layer '${t}' does not exist in the map's style and cannot be queried for features.`))), [];\n            n(i);\n          }\n        } else for (const e in this._layers) n(this._layers[e]);\n        const a = this._queryRenderedFeatures(t, r, o),\n          l = this._flattenAndSortRenderedFeatures(a),\n          c = [];\n        for (const t of l) e.ct(t.layer.id) === this.scope && c.push(t);\n        return c;\n      }\n      queryRenderedFeatureset(t, i, o) {\n        let s;\n        i && !Array.isArray(i) && i.filter && (this._validate(Se, \"queryRenderedFeatures.filter\", i.filter, null, i), s = e.a_(i.filter));\n        const r = \"mock\",\n          n = [];\n        if (i && i.target) n.push(Object.assign({}, i, {\n          targetId: r,\n          filter: s\n        }));else {\n          const e = this.getFeaturesetDescriptors();\n          for (const t of e) n.push({\n            targetId: r,\n            filter: s,\n            target: t\n          });\n          for (const {\n            style: e\n          } of this.fragments) {\n            const t = e.getFeaturesetDescriptors();\n            for (const e of t) n.push({\n              targetId: r,\n              filter: s,\n              target: e\n            });\n          }\n        }\n        const a = this.queryRenderedTargets(t, n, o),\n          l = [],\n          c = new Set();\n        for (const t of a) for (const i of t.variants[r]) at(i, t, c) || l.push(new e.cx(t, i));\n        return l;\n      }\n      queryRenderedTargets(t, i, o) {\n        const s = {},\n          r = (e, t, i, o) => {\n            const r = s[t.id] = s[t.id] || {\n              sourceCache: t,\n              layers: {},\n              has3DLayers: !1\n            };\n            if (r.layers[e.fqid] = r.layers[e.fqid] || {\n              styleLayer: e,\n              targets: []\n            }, e.is3D(!!this.terrain) && (r.has3DLayers = !0), !o) return i.uniqueFeatureID = !1, void r.layers[e.fqid].targets.push(i);\n            r.layers[e.fqid].targets.push(Object.assign({}, i, {\n              namespace: o.namespace,\n              properties: o.properties,\n              uniqueFeatureID: o.uniqueFeatureID\n            }));\n          };\n        for (const t of i) if (\"featuresetId\" in t.target) {\n          const {\n              featuresetId: i,\n              importId: o\n            } = t.target,\n            s = this.getFragmentStyle(o);\n          if (!s || !s._featuresetSelectors) continue;\n          const n = s._featuresetSelectors[i];\n          if (!n) {\n            this.fire(new e.z(new Error(`The featureset '${i}' does not exist in the map's style and cannot be queried for features.`)));\n            continue;\n          }\n          for (const e of n) {\n            const i = s.getOwnLayer(e.layerId);\n            i && !xo.has(i.type) && r(i, s.getOwnLayerSourceCache(i), t, e);\n          }\n        } else if (\"layerId\" in t.target) {\n          const {\n              layerId: e\n            } = t.target,\n            i = this.getLayer(e);\n          if (!i || xo.has(i.type)) continue;\n          r(i, this.getLayerSourceCache(i), t);\n        }\n        const n = this._queryRenderedFeatures(t, s, o);\n        return this._flattenAndSortRenderedFeatures(n);\n      }\n      _queryRenderedFeatures(e, t, i) {\n        const o = [],\n          s = !!this.map._showQueryGeometry,\n          r = Xe.createFromScreenPoints(e, i);\n        for (const e in t) {\n          const n = lt(r, t[e], this._availableImages, i, s);\n          Object.keys(n).length && o.push(n);\n        }\n        if (this.placement) for (const e in t) {\n          if (!t[e].sourceCache._onlySymbols) continue;\n          const i = ct(r.screenGeometry, t[e], this._availableImages, this.placement.collisionIndex, this.placement.retainedQueryData);\n          Object.keys(i).length && o.push(i);\n        }\n        return o;\n      }\n      querySourceFeatures(e, t) {\n        const i = t && t.filter;\n        i && this._validate(Se, \"querySourceFeatures.filter\", i, null, t);\n        let o = [];\n        const s = this.getOwnSourceCaches(e);\n        for (const e of s) o = o.concat(ht(e, t));\n        return o;\n      }\n      addSourceType(e, t, i) {\n        return To.getSourceType(e) ? i(new Error(`A source type called \"${e}\" already exists.`)) : (To.setSourceType(e, t), t.workerSourceURL ? void this.dispatcher.broadcast(\"loadWorkerSource\", {\n          name: e,\n          url: t.workerSourceURL\n        }, i) : i(null, null));\n      }\n      getFlatLight() {\n        return this.light.getLight();\n      }\n      setFlatLight(t, i, o = {}) {\n        this._checkLoaded();\n        const s = this.light.getLight();\n        let r = !1;\n        for (const i in t) if (!e.bn(t[i], s[i])) {\n          r = !0;\n          break;\n        }\n        if (!r) return;\n        const n = this._getTransitionParameters();\n        this.light.setLight(t, i, o), this.light.updateTransitions(n);\n      }\n      getTerrain() {\n        return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;\n      }\n      setTerrainForDraping() {\n        this.setTerrain({\n          source: \"\",\n          exaggeration: 0\n        }, 0);\n      }\n      checkCanvasFingerprintNoise() {\n        void 0 === this.disableElevatedTerrain && (this.disableElevatedTerrain = e.q.hasCanvasFingerprintNoise(), this.disableElevatedTerrain && e.w(\"Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode).\"));\n      }\n      setTerrain(t, i = 1) {\n        if (this._checkLoaded(), !t) return this.terrainSetForDrapingOnly() || (delete this.terrain, this.map.transform.projection.requiresDraping && this.setTerrainForDraping()), 0 === i && delete this.terrain, null === t ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);\n        this.checkCanvasFingerprintNoise();\n        let o = t;\n        const s = null == t.source;\n        if (1 === i) {\n          if (this.disableElevatedTerrain) return;\n          if (\"object\" == typeof o.source) {\n            const t = \"terrain-dem-src\";\n            this.addSource(t, o.source), o = e.cq(o), o = e.l(o, {\n              source: t\n            });\n          }\n          const t = e.l({}, o),\n            i = {};\n          if (this.terrain && s) {\n            t.source = this.terrain.get().source;\n            const e = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;\n            e && (i.style = e.serialize());\n          }\n          if (this._validate(xe, \"terrain\", t, i)) return;\n        }\n        if (!this.terrain || this.terrain.scope !== this.scope && !s || this.terrain && i !== this.terrain.drapeRenderMode) {\n          if (!o) return;\n          this._createTerrain(o, i), this.fire(new e.A(\"data\", {\n            dataType: \"style\"\n          }));\n        } else {\n          const i = this.terrain,\n            s = i.get();\n          for (const t of Object.keys(e.a5.terrain)) !o.hasOwnProperty(t) && e.a5.terrain[t].default && (o[t] = e.a5.terrain[t].default);\n          for (const o in t) if (!e.bn(t[o], s[o])) {\n            i.set(t, this.options), this.stylesheet.terrain = t;\n            const o = this._getTransitionParameters({\n              duration: 0\n            });\n            i.updateTransitions(o), this.fire(new e.A(\"data\", {\n              dataType: \"style\"\n            }));\n            break;\n          }\n        }\n        this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = !0;\n      }\n      _createFog(e) {\n        const t = this.fog = new Ve(e, this.map.transform, this.scope, this.options);\n        this.stylesheet.fog = t.get();\n        const i = this._getTransitionParameters({\n          duration: 0\n        });\n        t.updateTransitions(i);\n      }\n      _createSnow(e) {\n        const t = this.snow = new Ze(e, this.map.transform, this.scope, this.options);\n        this.stylesheet.snow = t.get();\n        const i = this._getTransitionParameters({\n          duration: 0\n        });\n        t.updateTransitions(i);\n      }\n      _createRain(e) {\n        const t = this.rain = new We(e, this.map.transform, this.scope, this.options);\n        this.stylesheet.rain = t.get();\n        const i = this._getTransitionParameters({\n          duration: 0\n        });\n        t.updateTransitions(i);\n      }\n      _updateMarkersOpacity() {\n        0 !== this.map._markers.length && this.map._requestDomTask(() => {\n          for (const e of this.map._markers) e._evaluateOpacity();\n        });\n      }\n      getFog() {\n        return this.fog ? this.fog.get() : null;\n      }\n      setFog(t) {\n        if (this._checkLoaded(), !t) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);\n        if (this.fog) {\n          const i = this.fog;\n          if (!e.bn(i.get(), t)) {\n            i.set(t, this.options), this.stylesheet.fog = i.get();\n            const e = this._getTransitionParameters({\n              duration: 0\n            });\n            i.updateTransitions(e);\n          }\n        } else this._createFog(t);\n        this._markersNeedUpdate = !0;\n      }\n      getSnow() {\n        return this.snow ? this.snow.get() : null;\n      }\n      setSnow(t) {\n        if (this._checkLoaded(), !t) return delete this.snow, void delete this.stylesheet.snow;\n        if (this.snow) {\n          const i = this.snow;\n          if (!e.bn(i.get(), t)) {\n            i.set(t, this.options), this.stylesheet.snow = i.get();\n            const e = this._getTransitionParameters({\n              duration: 0\n            });\n            i.updateTransitions(e);\n          }\n        } else this._createSnow(t);\n        this._markersNeedUpdate = !0;\n      }\n      getRain() {\n        return this.rain ? this.rain.get() : null;\n      }\n      setRain(t) {\n        if (this._checkLoaded(), !t) return delete this.rain, void delete this.stylesheet.rain;\n        if (this.rain) {\n          const i = this.rain;\n          if (!e.bn(i.get(), t)) {\n            i.set(t, this.options), this.stylesheet.rain = i.get();\n            const e = this._getTransitionParameters({\n              duration: 0\n            });\n            i.updateTransitions(e);\n          }\n        } else this._createRain(t);\n        this._markersNeedUpdate = !0;\n      }\n      _reloadColorTheme() {\n        const t = () => {\n            for (const e in this._layers) this._layers[e].lut = this._styleColorTheme.lut;\n            for (const e in this._sourceCaches) this._sourceCaches[e].clearTiles();\n          },\n          i = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;\n        if (!i) return this._styleColorTheme.lut = null, void t();\n        const o = this._evaluateColorThemeData(i);\n        this._loadColorTheme(o).then(() => {\n          this.fire(new e.A(\"colorthemeset\")), t();\n        }).catch(t => {\n          e.w(`Couldn't set color theme: ${t}`);\n        });\n      }\n      setColorTheme(t) {\n        this._checkLoaded(), this._styleColorTheme.colorThemeOverride && e.w(\"Note: setColorTheme is called on a style with a color-theme override, the passed color-theme won't be visible.\"), this._styleColorTheme.colorTheme = t, this._reloadColorTheme();\n      }\n      setImportColorTheme(e, t) {\n        const i = this.getFragmentStyle(e);\n        i && (i._styleColorTheme.colorThemeOverride = t, i._reloadColorTheme());\n      }\n      _getTransitionParameters(t) {\n        return {\n          now: e.q.now(),\n          transition: e.l(this.transition, t)\n        };\n      }\n      updateDrapeFirstLayers() {\n        if (!this.terrain) return;\n        const e = [],\n          t = [];\n        for (const i of this._mergedOrder) this.isLayerDraped(this._mergedLayers[i]) ? e.push(i) : t.push(i);\n        this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e), this._drapedFirstOrder.push(...t);\n      }\n      _createTerrain(e, t) {\n        const i = this.terrain = new Pe(e, t, this.scope, this.options);\n        1 === t && (this.stylesheet.terrain = e), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();\n        const o = this._getTransitionParameters({\n          duration: 0\n        });\n        i.updateTransitions(o);\n      }\n      _force3DLayerUpdate() {\n        for (const e in this._layers) {\n          const t = this._layers[e];\n          \"fill-extrusion\" === t.type && this._updateLayer(t);\n        }\n      }\n      _forceSymbolLayerUpdate() {\n        for (const e in this._layers) {\n          const t = this._layers[e];\n          \"symbol\" === t.type && this._updateLayer(t);\n        }\n      }\n      _validate(t, i, o, s, r = {}) {\n        if (r && !1 === r.validate) return !1;\n        const n = e.l({}, this.serialize());\n        return go(this, t.call(me, e.l({\n          key: i,\n          style: n,\n          value: o,\n          styleSpec: e.a5\n        }, s)));\n      }\n      _remove() {\n        this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.cy.off(\"pluginStateChange\", this._rtlTextPluginCallback);\n        for (const e in this._mergedLayers) this._mergedLayers[e].setEventedParent(null);\n        for (const e in this._mergedSourceCaches) this._mergedSourceCaches[e].clearTiles(), this._mergedSourceCaches[e].setEventedParent(null);\n        this.setEventedParent(null), delete this.fog, delete this.snow, delete this.rain, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.modelManager.setEventedParent(null), this.dispatcher.remove());\n      }\n      clearSource(e) {\n        const t = this.getSourceCaches(e);\n        for (const e of t) e.clearTiles();\n      }\n      clearSources() {\n        for (const e in this._mergedSourceCaches) this._mergedSourceCaches[e].clearTiles();\n      }\n      reloadSource(e) {\n        const t = this.getSourceCaches(e);\n        for (const e of t) e.resume(), e.reload();\n      }\n      reloadSources() {\n        for (const e of this.getSources()) e.reload && e.reload();\n      }\n      reloadModels() {\n        this.modelManager.reloadModels(\"\"), this.forEachFragmentStyle(e => {\n          e.modelManager.reloadModels(e.scope);\n        });\n      }\n      updateSources(e) {\n        let t;\n        this.directionalLight && (t = ro(this.directionalLight));\n        for (const i in this._mergedSourceCaches) this._mergedSourceCaches[i].update(e, void 0, void 0, t);\n      }\n      _generateCollisionBoxes() {\n        for (const e in this._sourceCaches) {\n          const t = this._sourceCaches[e];\n          t.resume(), t.reload();\n        }\n      }\n      _updatePlacement(t, i, o, s, r, n, a = !1) {\n        let l = !1,\n          c = !1;\n        const h = {},\n          d = {};\n        for (const t of this._mergedOrder) {\n          const o = this._mergedLayers[t];\n          if (\"symbol\" !== o.type) continue;\n          const s = e.C(o.source, o.scope);\n          let r = h[s];\n          if (!r) {\n            const e = this.getLayerSourceCache(o);\n            if (!e) continue;\n            const t = e.getRenderableIds(!0).map(t => e.getTileByID(t));\n            d[s] = t.slice(), r = h[s] = t.sort((e, t) => t.tileID.overscaledZ - e.tileID.overscaledZ || (e.tileID.isLessThan(t.tileID) ? -1 : 1));\n          }\n          const n = this.crossTileSymbolIndex.addLayer(o, r, i.center.lng, i.projection);\n          l = l || n;\n        }\n        if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), a = a || this._layerOrderChanged || 0 === s, this._layerOrderChanged && this.fire(new e.A(\"neworder\")), (a || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.q.now(), i.zoom)) && (this.pauseablePlacement = new Ai(i, this._mergedOrder, a, o, s, r, this.placement, this.fog && i.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, h, d, this.map.painter.scaleFactor), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.q.now()), c = !0), l && this.pauseablePlacement.placement.setStale()), c || l) {\n          this._buildingIndex.onNewFrame(i.zoom);\n          for (let t = 0; t < this._mergedOrder.length; t++) {\n            const i = this._mergedLayers[this._mergedOrder[t]];\n            if (\"symbol\" !== i.type) continue;\n            const o = this.isLayerClipped(i);\n            this.placement.updateLayerOpacities(i, h[e.C(i.source, i.scope)], t, o ? n : null);\n          }\n        }\n        return {\n          needsRerender: !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.q.now())\n        };\n      }\n      _releaseSymbolFadeTiles() {\n        for (const e in this._sourceCaches) this._sourceCaches[e].releaseSymbolFadeTiles();\n      }\n      addImport(t, i) {\n        this._checkLoaded();\n        const o = this.stylesheet.imports = this.stylesheet.imports || [];\n        if (-1 !== o.findIndex(({\n          id: e\n        }) => e === t.id)) return void this.fire(new e.z(new Error(`Import with id '${t.id}' already exists in the map's style.`)));\n        if (!i) return o.push(t), this._loadImports([t], !0);\n        const s = o.findIndex(({\n          id: e\n        }) => e === i);\n        return -1 === s && this.fire(new e.z(new Error(`Import with id \"${i}\" does not exist on this map.`))), this.stylesheet.imports = o.slice(0, s).concat(t).concat(o.slice(s)), this._loadImports([t], !0, i);\n      }\n      updateImport(t, i) {\n        this._checkLoaded();\n        const o = this.stylesheet.imports || [],\n          s = this.getImportIndex(t);\n        return -1 === s ? this : \"string\" == typeof i ? (this.setImportUrl(t, i), this) : (i.url && i.url !== o[s].url && this.setImportUrl(t, i.url), e.bn(i.config, o[s].config) || this.setImportConfig(t, i.config, i.data.schema), e.bn(i.data, o[s].data) || this.setImportData(t, i.data), this);\n      }\n      moveImport(e, t) {\n        this._checkLoaded();\n        let i = this.stylesheet.imports || [];\n        const o = this.getImportIndex(e);\n        if (-1 === o) return this;\n        const s = this.getImportIndex(t);\n        if (-1 === s) return this;\n        const r = i[o],\n          n = this.fragments[o];\n        return i = i.filter(({\n          id: t\n        }) => t !== e), this.fragments = this.fragments.filter(({\n          id: t\n        }) => t !== e), this.stylesheet.imports = i.slice(0, s).concat(r).concat(i.slice(s)), this.fragments = this.fragments.slice(0, s).concat(n).concat(this.fragments.slice(s)), this.mergeLayers(), this;\n      }\n      setImportUrl(e, t) {\n        this._checkLoaded();\n        const i = this.stylesheet.imports || [],\n          o = this.getImportIndex(e);\n        if (-1 === o) return this;\n        i[o].url = t;\n        const s = this.fragments[o];\n        return s.style = this._createFragmentStyle(i[o]), s.style.on(\"style.import.load\", () => this.mergeAll()), s.style.loadURL(t), this;\n      }\n      setImportData(e, t) {\n        this._checkLoaded();\n        const i = this.getImportIndex(e),\n          o = this.stylesheet.imports || [];\n        return -1 === i ? this : t ? (this.fragments[i].style.setState(t), this._reloadImports(), this) : (delete o[i].data, this.setImportUrl(e, o[i].url));\n      }\n      setImportConfig(e, t, i) {\n        this._checkLoaded();\n        const o = this.getImportIndex(e),\n          s = this.stylesheet.imports || [];\n        if (-1 === o) return this;\n        t ? s[o].config = t : delete s[o].config;\n        const r = this.fragments[o];\n        i && r.style.stylesheet && (r.style.stylesheet.schema = i);\n        const n = r.style.stylesheet && r.style.stylesheet.schema;\n        return r.config = t, r.style.updateConfig(t, n), this.updateConfigDependencies(), this;\n      }\n      removeImport(e) {\n        this._checkLoaded();\n        const t = this.stylesheet.imports || [],\n          i = this.getImportIndex(e);\n        -1 !== i && (t.splice(i, 1), this.fragments[i].style._remove(), this.fragments.splice(i, 1), this._reloadImports());\n      }\n      getImportIndex(t) {\n        const i = (this.stylesheet.imports || []).findIndex(e => e.id === t);\n        return -1 === i && this.fire(new e.z(new Error(`Import '${t}' does not exist in the map's style and cannot be updated.`))), i;\n      }\n      getLayer(e) {\n        return this._mergedLayers[e];\n      }\n      getSources() {\n        const e = [];\n        for (const t in this._mergedOtherSourceCaches) {\n          const i = this._mergedOtherSourceCaches[t];\n          i && e.push(i.getSource());\n        }\n        return e;\n      }\n      getSource(e, t) {\n        const i = this.getSourceCache(e, t);\n        return i && i.getSource();\n      }\n      getLayerSource(e) {\n        const t = this.getLayerSourceCache(e);\n        return t && t.getSource();\n      }\n      getSourceCache(t, i) {\n        const o = e.C(t, i);\n        return this._mergedOtherSourceCaches[o];\n      }\n      getLayerSourceCache(t) {\n        const i = e.C(t.source, t.scope);\n        return \"symbol\" === t.type ? this._mergedSymbolSourceCaches[i] : this._mergedOtherSourceCaches[i];\n      }\n      getSourceCaches(e) {\n        if (null == e) return Object.values(this._mergedSourceCaches);\n        const t = [];\n        return this._mergedOtherSourceCaches[e] && t.push(this._mergedOtherSourceCaches[e]), this._mergedSymbolSourceCaches[e] && t.push(this._mergedSymbolSourceCaches[e]), t;\n      }\n      updateSourceCaches() {\n        const e = this._changes.getUpdatedSourceCaches();\n        for (const t in e) {\n          const i = e[t];\n          \"reload\" === i ? this.reloadSource(t) : \"clear\" === i && this.clearSource(t);\n        }\n      }\n      updateLayers(e) {\n        const t = this._changes.getUpdatedPaintProperties();\n        for (const i of t) {\n          const t = this.getLayer(i);\n          t && t.updateTransitions(e);\n        }\n      }\n      getGlyphsUrl() {\n        return this.stylesheet.glyphs;\n      }\n      setGlyphsUrl(e) {\n        this.stylesheet.glyphs = e, this.glyphManager.setURL(e, this.scope);\n      }\n      getImages(t, i, o) {\n        this.imageManager.getImages(i.images, i.scope, o), this._updateTilesForChangedImages();\n        const s = t => {\n            if (t) {\n              const o = i.images.map(t => e.I.toString(t));\n              t.setDependencies(i.tileID.key, i.type, o);\n            }\n          },\n          r = e.C(i.source, i.scope);\n        s(this._mergedOtherSourceCaches[r]), s(this._mergedSymbolSourceCaches[r]);\n      }\n      rasterizeImages(e, t, i) {\n        this.imageManager.rasterizeImages(t, i);\n      }\n      getGlyphs(e, t, i) {\n        this.glyphManager.getGlyphs(t.stacks, t.scope, i);\n      }\n      getResource(t, i, o) {\n        return e.cz(i, o);\n      }\n      getOwnSourceCache(e) {\n        return this._otherSourceCaches[e];\n      }\n      getOwnLayerSourceCache(e) {\n        return \"symbol\" === e.type ? this._symbolSourceCaches[e.source] : this._otherSourceCaches[e.source];\n      }\n      getOwnSourceCaches(e) {\n        const t = [];\n        return this._otherSourceCaches[e] && t.push(this._otherSourceCaches[e]), this._symbolSourceCaches[e] && t.push(this._symbolSourceCaches[e]), t;\n      }\n      _isSourceCacheLoaded(t) {\n        const i = this.getOwnSourceCaches(t);\n        return 0 === i.length ? (this.fire(new e.z(new Error(`There is no source with ID '${t}'`))), !1) : i.every(e => e.loaded());\n      }\n      has3DLayers() {\n        return this._has3DLayers;\n      }\n      hasSymbolLayers() {\n        return this._hasSymbolLayers;\n      }\n      hasCircleLayers() {\n        return this._hasCircleLayers;\n      }\n      isLayerClipped(e, t) {\n        if (!this._clipLayerPresent && \"fill-extrusion\" !== e.type) return !1;\n        const i = \"fill-extrusion\" === e.type && \"building\" === e.sourceLayer;\n        if (e.is3D(!!this.terrain)) {\n          if (i || t && \"batched-model\" === t.type) return !0;\n          if (\"model\" === e.type) return !0;\n        } else if (\"symbol\" === e.type) return !0;\n        return !1;\n      }\n      _clearWorkerCaches() {\n        this.dispatcher.broadcast(\"clearCaches\");\n      }\n      destroy() {\n        this._clearWorkerCaches(), this.fragments.forEach(e => {\n          e.style._remove();\n        }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);\n      }\n    }\n    To.getSourceType = function (e) {\n      return st[e];\n    }, To.setSourceType = function (e, t) {\n      st[e] = t;\n    }, To.registerForPluginStateChange = e.ci;\n    var Eo = \"\\n#define EPSILON 0.0000001\\n#define PI 3.141592653589793\\n#ifdef RENDER_CUTOFF\\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\\n#endif\",\n      So = \"\\nout vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)\\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\\n#ifdef INDICATOR_CUTOUT\\nuniform vec3 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\\n#endif\\nvec4 applyCutout(vec4 color,float height) {\\n#ifdef INDICATOR_CUTOUT\\nfloat verticalFadeRange=u_indicator_cutout_centers.z*0.25;float holeMinOpacity=mix(1.0,u_indicator_cutout_params.x,smoothstep(u_indicator_cutout_centers.z,u_indicator_cutout_centers.z+verticalFadeRange,height));float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\\n#else\\nreturn color;\\n#endif\\n}\\n#ifdef DEBUG_WIREFRAME\\n#define HANDLE_WIREFRAME_DEBUG \\\\\\nglFragColor=vec4(0.7,0.0,0.0,0.7); \\\\\\ngl_FragDepth=gl_FragCoord.z-0.0001;\\n#else\\n#define HANDLE_WIREFRAME_DEBUG\\n#endif\\n#ifdef RENDER_CUTOFF\\nuniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;\\n#endif\\nvec4 textureLodCustom(sampler2D image,highp vec2 pos,highp vec2 lod_coord) {highp vec2 size=vec2(textureSize(image,0));highp vec2 dx=dFdx(lod_coord.xy*size);highp vec2 dy=dFdy(lod_coord.xy*size);highp float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));highp float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}\",\n      Co = \"\\n#define EXTENT 8192.0\\n#define RAD_TO_DEG 180.0/PI\\n#define DEG_TO_RAD PI/180.0\\n#define GLOBE_RADIUS EXTENT/PI/2.0\\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\\n#ifndef PROJECTED_POS_ON_VIEWPORT\\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\\n#else\\nreturn vec3(0.0);\\n#endif\\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\\n#endif\\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const vec2 units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (units_to_pixels*pos+offset)/pattern_size;}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {return get_pattern_pos(pixel_coord_upper,pixel_coord_lower,pattern_size,vec2(tile_units_to_pixels),pos);}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}\\n#ifdef RENDER_CUTOFF\\nuniform vec4 u_cutoff_params;out float v_cutoff_opacity;\\n#endif\\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}\",\n      Io = \"in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}\",\n      Ro = \"\\n#define ELEVATION_SCALE 7.0\\n#define ELEVATION_OFFSET 450.0\\n#ifdef PROJECTION_GLOBE_VIEW\\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\\n#else\\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\\n#endif\\n#ifdef TERRAIN\\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {\\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\\n#else\\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\\n#endif\\n}float prevElevation(vec2 apos) {\\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\\n#else\\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\\n#endif\\n}\\n#ifdef TERRAIN_VERTEX_MORPHING\\nfloat elevation(vec2 apos) {\\n#ifdef ZERO_EXAGGERATION\\nreturn 0.0;\\n#endif\\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\\n#else\\nfloat elevation(vec2 apos) {\\n#ifdef ZERO_EXAGGERATION\\nreturn 0.0;\\n#endif\\nreturn currentElevation(apos);}\\n#endif\\nvec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\\n#else\\nfloat elevation(vec2 pos) { return 0.0; }\\n#endif\\n#ifdef DEPTH_OCCLUSION\\nuniform highp sampler2D u_depth;uniform highp vec2 u_depth_size_inv;uniform highp vec2 u_depth_range_unpack;uniform highp float u_occluder_half_size;uniform highp float u_occlusion_depth_offset;\\n#ifdef DEPTH_D24\\nfloat unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}\\n#else\\nhighp float unpack_depth_rgba(vec4 rgba_depth)\\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\\n#endif\\nbool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;\\n#ifdef DEPTH_D24\\nfloat depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);\\n#else\\nfloat depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));\\n#endif\\nreturn coord.z+u_occlusion_depth_offset > depth;}highp vec4 getCornerDepths(vec2 coord) {highp vec3 df=vec3(u_occluder_half_size*u_depth_size_inv,0.0);highp vec2 uv=0.5*coord.xy+0.5;\\n#ifdef DEPTH_D24\\nhighp vec4 depth=vec4(\\ntexture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r\\n);depth=unpack_depth4(depth);\\n#else\\nhighp vec4 depth=vec4(\\nunpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))\\n);\\n#endif\\nreturn depth;}highp float occlusionFadeMultiSample(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec2 uv=0.5*coord.xy+0.5;int NX=3;int NY=4;highp vec2 df=u_occluder_half_size*u_depth_size_inv;highp vec2 oneStep=2.0*u_occluder_half_size*u_depth_size_inv/vec2(NX-1,NY-1);highp float res=0.0;for (int y=0; y < NY;++y) {for (int x=0; x < NX;++x) {\\n#ifdef DEPTH_D24\\nhighp float depth=unpack_depth(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)).r);\\n#else\\nhighp float depth=unpack_depth_rgba(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)));\\n#endif\\nres+=1.0-clamp(300.0*(coord.z+u_occlusion_depth_offset-depth),0.0,1.0);}}res=clamp(2.0*res/float(NX*NY)-0.5,0.0,1.0);return res;}highp float occlusionFade(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec4 depth=getCornerDepths(coord.xy);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z+u_occlusion_depth_offset)-depth),0.0,1.0));}\\n#else\\nbool isOccluded(vec4 frag) { return false; }highp float occlusionFade(vec4 frag) { return 1.0; }highp float occlusionFadeMultiSample(vec4 frag) { return 1.0; }\\n#endif//DEPTH_OCCLUSION\",\n      Do = \"#ifdef FOG\\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\\n#endif\",\n      Ao = \"#ifdef FOG\\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {return color;}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\\n#endif\",\n      Lo = \"#ifdef RASTER_ARRAY\\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)\\n);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)\\n);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}\\n#endif\",\n      Mo = \"#ifdef RASTER_ARRAY\\nuniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}\\n#endif\\nuniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}\",\n      Po = \"#ifdef RENDER_SHADOWS\\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {vec3 transformed_normal=vec3(-normal.xy,normal.z);float NDotL=dot(normalize(transformed_normal),u_shadow_direction);float dotScale=min(1.0-NDotL,1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\\n#endif//RENDER_SHADOWS\",\n      zo = \"#ifdef RENDER_SHADOWS\\n#ifdef DEPTH_TEXTURE\\nuniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;\\n#else\\nuniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;\\n#endif\\nuniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;\\n#ifdef DEPTH_TEXTURE\\nshadow_depth=texture(u_shadowmap_1,uv).r;\\n#else\\nshadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;\\n#endif\\nreturn step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;\\n#ifdef DEPTH_TEXTURE\\nshadow_depth=texture(u_shadowmap_0,uv).r;\\n#else\\nshadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;\\n#endif\\nreturn step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;\\n#ifdef TEXTURE_GATHER\\nhighp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));\\n#else\\nhighp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(\\nshadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)\\n);\\n#endif\\nvec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return clamp(mix(lerpx.x,lerpx.y,f.y),0.0,1.0);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {\\n#ifdef SHADOWS_SINGLE_CASCADE\\nlight_view_pos0.xyz/=light_view_pos0.w;vec2 abs_bounds=abs(light_view_pos0.xy);if (abs_bounds.x >=1.0 || abs_bounds.y >=1.0) {return 0.0;}light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);\\n#else\\nlight_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return clamp(mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth)),0.0,1.0);\\n#endif\\n}highp float calculate_shadow_bias(float NDotL) {\\n#ifdef NORMAL_OFFSET\\nreturn 0.5*u_shadow_bias.x;\\n#else\\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\\n#endif\\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}highp vec2 compute_receiver_plane_depth_bias(highp vec3 pos_dx,highp vec3 pos_dy)\\n{highp vec2 biasUV=vec2(\\npos_dy.y*pos_dx.z-pos_dx.y*pos_dy.z,pos_dx.x*pos_dy.z-pos_dy.x*pos_dx.z);biasUV*=1.0/((pos_dx.x*pos_dy.y)-(pos_dx.y*pos_dy.x));return biasUV;}float shadowed_light_factor_plane_bias(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {highp vec3 light_view_pos0_xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;highp vec3 light_view_pos0_ddx=dFdx(light_view_pos0_xyz);highp vec3 light_view_pos0_ddy=dFdy(light_view_pos0_xyz);highp vec2 plane_depth_bias=compute_receiver_plane_depth_bias(light_view_pos0_ddx,light_view_pos0_ddy);highp float bias=dot(vec2(u_shadow_texel_size,u_shadow_texel_size),plane_depth_bias)+0.0001;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\\n#endif\";\n    const Oo = [];\n    Vo(Eo, Oo), Vo(Co, Oo), Vo(So, Oo);\n    const Fo = {\n        \"_prelude_fog.vertex.glsl\": Do,\n        \"_prelude_terrain.vertex.glsl\": Ro,\n        \"_prelude_shadow.vertex.glsl\": Po,\n        \"_prelude_fog.fragment.glsl\": Ao,\n        \"_prelude_shadow.fragment.glsl\": zo,\n        \"_prelude_lighting.glsl\": \"\\n#ifdef LIGHTING_3D_MODE\\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\\n#endif//LIGHTING_3D_MODE\",\n        \"_prelude_raster_array.glsl\": Lo,\n        \"_prelude_raster_particle.glsl\": Mo\n      },\n      ko = {};\n    Go(\"\", Ro), Go(Ao, Do), Go(zo, Po), Go(Lo, \"\"), Go(Mo, \"\");\n    const Bo = Go(So, Co),\n      No = Eo;\n    var Uo = {\n      background: Go('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform vec4 u_color;uniform float u_opacity;\\n#ifdef LIGHTING_3D_MODE\\nin vec4 v_color;\\n#endif\\nvoid main() {vec4 out_color;\\n#ifdef LIGHTING_3D_MODE\\nout_color=v_color;\\n#else\\nout_color=u_color;\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nglFragColor=out_color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nin vec2 a_pos;uniform mat4 u_matrix;\\n#ifdef LIGHTING_3D_MODE\\nuniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;\\n#endif\\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\\n#ifdef LIGHTING_3D_MODE\\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      backgroundPattern: Go('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in highp vec2 v_pos;void main() {highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nglFragColor=out_color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec2 u_pattern_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_pattern_units_to_pixels,a_pos);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      circle: Go('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nin vec3 v_data;in float v_visibility;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump float radius\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp vec4 stroke_color\\n#pragma mapbox: define mediump float stroke_width\\n#pragma mapbox: define lowp float stroke_opacity\\nuniform float u_emissive_strength;void main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump float radius\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp vec4 stroke_color\\n#pragma mapbox: initialize mediump float stroke_width\\n#pragma mapbox: initialize lowp float stroke_opacity\\nvec2 extrude=v_data.xy;float blur_positive=blur < 0.0 ? 0.0 : 1.0;lowp float antialiasblur=v_data.z;float extrude_length=length(extrude)+antialiasblur*(1.0-blur_positive);float antialiased_blur=-max(abs(blur),antialiasblur);float antialiase_blur_opacity=smoothstep(0.0,antialiasblur,extrude_length-1.0);float opacity_t=blur_positive==1.0 ? \\nsmoothstep(0.0,-antialiased_blur,1.0-extrude_length) : \\nsmoothstep(antialiased_blur,0.0,extrude_length-1.0)-antialiase_blur_opacity;float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#endif\\n#ifdef FOG\\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\\n#endif\\nglFragColor=out_color*(v_visibility*opacity_t);\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\n}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_terrain.vertex.glsl\"\\n#define NUM_VISIBILITY_RINGS 2\\n#define INV_SQRT2 0.70710678\\n#define ELEVATION_BIAS 0.0001\\n#define NUM_SAMPLES_PER_RING 16\\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\\n#endif\\n#ifdef ELEVATED_ROADS\\nin float a_circle_z_offset;\\n#endif\\nout vec3 v_data;out float v_visibility;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump float radius\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp vec4 stroke_color\\n#pragma mapbox: define mediump float stroke_width\\n#pragma mapbox: define lowp float stroke_opacity\\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\\n#if defined(TERRAIN)\\nreturn elevation(pos)+ELEVATION_BIAS;\\n#else\\nreturn 0.0;\\n#endif\\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\\n#ifdef PITCH_WITH_MAP\\n#ifdef PROJECTION_GLOBE_VIEW\\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\\n#else\\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\\n#endif\\n#else\\nreturn projected_center+vec4(sample_offset,0,0);\\n#endif\\n}float get_sample_step() {\\n#ifdef PITCH_WITH_MAP\\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\\n#else\\nreturn PI/float(NUM_SAMPLES_PER_RING);\\n#endif\\n}void main(void) {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump float radius\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp vec4 stroke_color\\n#pragma mapbox: initialize mediump float stroke_width\\n#pragma mapbox: initialize lowp float stroke_opacity\\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\\n#else \\nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\\n#endif\\n#ifdef ELEVATED_ROADS\\nworld_center.z+=a_circle_z_offset+ELEVATION_BIAS;\\n#endif\\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\\n#ifdef PITCH_WITH_MAP\\n#ifdef SCALE_WITH_MAP\\nview_scale=1.0;\\n#else\\nview_scale=projected_center.w/u_camera_to_center_distance;\\n#endif\\n#else\\n#ifdef SCALE_WITH_MAP\\nview_scale=u_camera_to_center_distance;\\n#else\\nview_scale=projected_center.w;\\n#endif\\n#endif\\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\\n#ifdef TERRAIN\\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\\n#ifdef PITCH_WITH_MAP\\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\\n#else\\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\\n#endif\\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\\n#else\\nvisibility=1.0;\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nvisibility=1.0;\\n#endif\\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\\n#ifdef FOG\\nv_fog_pos=fog_position(world_center.xyz);\\n#endif\\n}'),\n      clippingMask: Go(\"void main() {glFragColor=vec4(1.0);}\", \"in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}\"),\n      heatmap: Go('#include \"_prelude_fog.fragment.glsl\"\\nuniform highp float u_intensity;in vec2 v_extrude;\\n#pragma mapbox: define highp float weight\\n#define GAUSS_COEF 0.3989422804014327\\nvoid main() {\\n#pragma mapbox: initialize highp float weight\\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);\\n#ifdef FOG\\nif (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\\n#endif\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_terrain.vertex.glsl\"\\n#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\\n#endif\\nout vec2 v_extrude;\\n#pragma mapbox: define highp float weight\\n#pragma mapbox: define mediump float radius\\nconst highp float ZERO=1.0/255.0/16.0;\\n#define GAUSS_COEF 0.3989422804014327\\nvoid main(void) {\\n#pragma mapbox: initialize highp float weight\\n#pragma mapbox: initialize mediump float radius\\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\\n#else\\npos=vec3(tilePos+extrude,elevation(tilePos));\\n#endif\\ngl_Position=u_matrix*vec4(pos,1);\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n}'),\n      heatmapTexture: Go(\"uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(0.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}\", \"in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}\"),\n      collisionBox: Go(\"in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}\", '#include \"_prelude_terrain.vertex.glsl\"\\nin vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in vec2 a_elevation_from_sea;in float a_size_scale;in vec2 a_padding;in float a_auto_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {float feature_elevation=a_elevation_from_sea.x+a_auto_z_offset;float terrain_elevation=(a_elevation_from_sea.y==1.0 ? 0.0 : elevation(a_anchor_pos));vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(feature_elevation+terrain_elevation),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}'),\n      collisionCircle: Go(\"in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}\", \"in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}\"),\n      debug: Go(\"uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}\", '#include \"_prelude_terrain.vertex.glsl\"\\nin vec2 a_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_pos_3;\\n#endif\\nout vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\\n#ifdef PROJECTION_GLOBE_VIEW\\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\\n#else\\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\\n#endif\\n}'),\n      elevatedStructuresDepth: Go(\"void main() {\\n#ifndef DEPTH_TEXTURE\\nglFragColor=vec4(0.);\\n#endif\\n}\", \"in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform float u_depth_bias;void main() {gl_Position=u_matrix*vec4(a_pos,a_height,1);gl_Position.z=gl_Position.z+u_depth_bias;}\"),\n      elevatedStructuresDepthReconstruct: Go(\"#ifdef DEPTH_RECONSTRUCTION\\nin float v_height;\\n#endif\\nvoid main() {\\n#ifdef DEPTH_RECONSTRUCTION\\nif (v_height >=0.0)\\ndiscard;\\n#endif\\nglFragColor=vec4(1.0,0.0,0.0,1.0);}\", \"in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform vec3 u_camera_pos;uniform highp float u_depth_bias;uniform lowp float u_height_scale;uniform lowp float u_reset_depth;\\n#ifdef DEPTH_RECONSTRUCTION\\nout float v_height;\\n#endif\\nvoid main() {vec3 vpos=vec3(a_pos,a_height*u_height_scale);\\n#ifdef DEPTH_RECONSTRUCTION\\nif (u_camera_pos.z > vpos.z) {vpos-=(u_camera_pos-vpos)*(vpos.z/(u_camera_pos.z-vpos.z));}v_height=a_height;\\n#endif\\ngl_Position=u_matrix*vec4(vpos,1);gl_Position.z=u_reset_depth==1.0 ? gl_Position.w : gl_Position.z+u_depth_bias;}\"),\n      elevatedStructures: Go('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\nin vec3 v_normal;in float v_height;\\n#ifdef RENDER_SHADOWS\\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth;\\n#endif\\nvoid main() {vec3 color=vec3(241.0/255.0,236.0/255.0,225.0/255.0);\\n#ifdef LIGHTING_3D_MODE\\nvec3 normal=normalize(v_normal);\\n#ifdef RENDER_SHADOWS\\nfloat shadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,v_depth);color.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\\n#else\\ncolor=apply_lighting(color,normal);\\n#endif\\nif (v_height < 0.0) {float penetration=max(v_height+7.5,0.0);float occlusion=1.0-1.0/PI*acos(1.0-penetration/4.0);color=color*(1.0-pow(occlusion,2.0)*0.3);}\\n#endif\\n#ifdef FOG\\ncolor=fog_apply(color,v_fog_pos);\\n#endif\\nvec4 out_color=vec4(color,1.0);\\n#ifdef INDICATOR_CUTOUT\\nout_color=applyCutout(out_color,v_height);\\n#endif\\nglFragColor=out_color;HANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\nin vec2 a_pos;in float a_height;in vec3 a_pos_normal_3;uniform mat4 u_matrix;out vec3 v_normal;out float v_height;\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth;\\n#endif\\nvoid main() {v_normal=a_pos_normal_3/16384.0;v_height=a_height;vec3 pos=vec3(a_pos,a_height);gl_Position=u_matrix*vec4(pos,1);\\n#ifdef RENDER_SHADOWS\\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\\n#ifdef NORMAL_OFFSET\\nvec3 offset=shadow_normal_offset(v_normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      fill: Go('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float opacity\\nuniform float u_emissive_strength;\\n#ifdef RENDER_SHADOWS\\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nin highp float v_z_offset;\\n#endif\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float opacity\\nvec4 out_color=color;\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#ifdef RENDER_SHADOWS\\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\\n#endif\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nout_color*=opacity;\\n#ifdef INDICATOR_CUTOUT\\nif (v_z_offset >=0.0) {out_color=applyCutout(out_color,v_z_offset);}\\n#endif\\nglFragColor=out_color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\nin vec2 a_pos;\\n#ifdef ELEVATED_ROADS\\nin float a_road_z_offset;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nout highp float v_z_offset;\\n#endif\\nuniform mat4 u_matrix;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp float z_offset\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp float z_offset\\n#ifdef ELEVATED_ROADS\\nz_offset+=a_road_z_offset;\\n#endif\\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);\\n#ifdef RENDER_SHADOWS\\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\\n#ifdef NORMAL_OFFSET\\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nv_z_offset=z_offset;\\n#endif\\n}'),\n      fillOutline: Go('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\nin highp vec2 v_pos;uniform float u_emissive_strength;\\n#ifdef RENDER_SHADOWS\\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\\n#endif\\n#pragma mapbox: define highp vec4 outline_color\\n#pragma mapbox: define lowp float opacity\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 outline_color\\n#pragma mapbox: initialize lowp float opacity\\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#ifdef RENDER_SHADOWS\\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\\n#endif\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nglFragColor=out_color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\nin vec2 a_pos;\\n#ifdef ELEVATED_ROADS\\nin float a_road_z_offset;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\\n#endif\\nuniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;\\n#pragma mapbox: define highp vec4 outline_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define highp float z_offset\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 outline_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize highp float z_offset\\n#ifdef ELEVATED_ROADS\\nz_offset+=a_road_z_offset;\\n#endif\\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\\n#ifdef RENDER_SHADOWS\\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\\n#ifdef NORMAL_OFFSET\\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      fillOutlinePattern: Go('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\nuniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_emissive_strength;\\n#ifdef RENDER_SHADOWS\\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\\n#endif\\nin highp vec2 v_pos;in highp vec2 v_pos_world;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#ifdef RENDER_SHADOWS\\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\\n#endif\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nglFragColor=out_color*(alpha*opacity);\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\\n#ifdef ELEVATED_ROADS\\nin float a_road_z_offset;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\\n#endif\\nout highp vec2 v_pos;out highp vec2 v_pos_world;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern\\n#pragma mapbox: define lowp float pixel_ratio\\n#pragma mapbox: define highp float z_offset\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern\\n#pragma mapbox: initialize lowp float pixel_ratio\\n#pragma mapbox: initialize highp float z_offset\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;\\n#ifdef ELEVATED_ROADS\\nz_offset+=a_road_z_offset;\\n#endif\\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\\n#ifdef RENDER_SHADOWS\\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\\n#ifdef NORMAL_OFFSET\\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      fillPattern: Go('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\nuniform vec2 u_texsize;uniform sampler2D u_image;in highp vec2 v_pos;uniform float u_emissive_strength;\\n#ifdef RENDER_SHADOWS\\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\\n#endif\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#ifdef RENDER_SHADOWS\\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\\n#endif\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nglFragColor=out_color*opacity;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\\n#ifdef ELEVATED_ROADS\\nin float a_road_z_offset;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\\n#endif\\nout highp vec2 v_pos;\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp vec4 pattern\\n#pragma mapbox: define lowp float pixel_ratio\\n#pragma mapbox: define highp float z_offset\\nvoid main() {\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump vec4 pattern\\n#pragma mapbox: initialize lowp float pixel_ratio\\n#pragma mapbox: initialize highp float z_offset\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;\\n#ifdef ELEVATED_ROADS\\nz_offset+=a_road_z_offset;\\n#endif\\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\\n#ifdef RENDER_SHADOWS\\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\\n#ifdef NORMAL_OFFSET\\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      fillExtrusion: Go('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nin vec4 v_color;in vec4 v_flat;\\n#ifdef RENDER_SHADOWS\\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\\n#endif\\nuniform lowp float u_opacity;\\n#ifdef FAUX_AO\\nuniform lowp vec2 u_ao;in vec2 v_ao;\\n#endif\\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\\nin vec4 v_roof_color;\\n#endif\\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\\nin highp vec3 v_normal;\\n#endif\\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\\nin float v_flood_radius;in float v_has_floodlight;\\n#endif\\nin float v_height;\\n#pragma mapbox: define highp float emissive_strength\\nvoid main() {\\n#pragma mapbox: initialize highp float emissive_strength\\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\\nvec3 normal=normalize(v_normal);\\n#endif\\nfloat z;vec4 color=v_color;\\n#ifdef ZERO_ROOF_RADIUS\\nz=float(normal.z > 0.00001);\\n#ifdef LIGHTING_3D_MODE\\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\\n#else\\ncolor=mix(v_color,v_roof_color,z);\\n#endif\\n#endif\\nfloat h=max(0.0,v_height);float ao_shade=1.0;\\n#ifdef FAUX_AO\\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\\n#ifdef ZERO_ROOF_RADIUS\\nconcave*=(1.0-z);\\n#endif\\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\\n#ifdef LIGHTING_3D_MODE\\n#ifdef FLOOD_LIGHT\\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\\n#else\\ncolor.rgb*=ao_shade;\\n#endif\\n#else\\ncolor.rgb*=ao_shade;\\n#endif\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nfloat flood_radiance=0.0;\\n#ifdef FLOOD_LIGHT\\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\\n#endif\\n#ifdef RENDER_SHADOWS\\n#ifdef FLOOD_LIGHT\\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\\n#else\\nfloat shadowed_lighting_factor;\\n#ifdef RENDER_CUTOFF\\nshadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}\\n#else\\nshadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);\\n#endif\\ncolor.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\\n#endif\\n#else\\ncolor.rgb=apply_lighting(color.rgb,normal);\\n#ifdef FLOOD_LIGHT\\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\\n#endif\\n#endif\\ncolor.rgb=mix(color.rgb,v_flat.rgb,emissive_strength);color*=u_opacity;\\n#endif\\n#ifdef FOG\\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\\n#endif\\n#ifdef INDICATOR_CUTOUT\\ncolor=applyCutout(color,h);\\n#endif\\nglFragColor=color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_terrain.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;uniform float u_width_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\\n#ifdef RENDER_WALL_MODE\\nin vec3 a_join_normal_inside;\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\\n#endif\\n#ifdef TERRAIN\\nuniform int u_height_type;uniform int u_base_type;\\n#endif\\nuniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;\\n#endif\\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\\nout vec4 v_roof_color;\\n#endif\\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\\nout highp vec3 v_normal;\\n#endif\\n#ifdef FAUX_AO\\nuniform lowp vec2 u_ao;out vec2 v_ao;\\n#endif\\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\\nout float v_flood_radius;out float v_has_floodlight;\\n#endif\\nout float v_height;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}\\n#pragma mapbox: define highp float base\\n#pragma mapbox: define highp float height\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define highp float flood_light_wall_radius\\n#pragma mapbox: define highp float line_width\\n#pragma mapbox: define highp float emissive_strength\\nvoid main() {\\n#pragma mapbox: initialize highp float base\\n#pragma mapbox: initialize highp float height\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize highp float flood_light_wall_radius\\n#pragma mapbox: initialize highp float line_width\\n#pragma mapbox: initialize highp float emissive_strength\\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\\nv_normal=normal;\\n#endif\\nbase=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\\n#if defined(HAS_CENTROID) || defined(TERRAIN)\\ncentroid_pos=a_centroid_pos;\\n#endif\\nfloat ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;\\n#ifdef TERRAIN\\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\\n#else\\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\\n#endif\\nfloat cutoff=1.0;vec3 scaled_pos=pos;\\n#ifdef RENDER_CUTOFF\\nvec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);cutoff=cutoff_opacity(u_cutoff_params,ground.z);if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);\\n#endif\\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0) || (color.a==0.0));\\n#ifdef RENDER_WALL_MODE\\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);scaled_pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;scaled_pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\\n#endif\\ngl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;\\n#ifdef RENDER_SHADOWS\\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\\n#ifdef NORMAL_OFFSET\\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);\\n#endif\\nfloat NdotL=0.0;float colorvalue=0.0;\\n#ifndef LIGHTING_3D_MODE\\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\\n#endif\\n#ifdef FAUX_AO\\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\\n#ifdef TERRAIN\\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\\n#endif\\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\\n#ifdef PROJECTION_GLOBE_VIEW\\ntop_height+=u_height_lift;\\n#endif\\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\\n#endif\\n#ifdef LIGHTING_3D_MODE\\n#ifdef FLOOD_LIGHT\\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\\n#endif\\nv_color=vec4(color.rgb,1.0);float ndotl=calculate_NdotL(normal);v_flat.rgb=sRGBToLinear(color.rgb);v_flat.rgb=v_flat.rgb*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);v_flat=vec4(linearTosRGB(v_flat.rgb),1.0);\\n#else\\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\\n#endif\\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n}'),\n      fillExtrusionDepth: Go(\"in highp float v_depth;void main() {\\n#ifndef DEPTH_TEXTURE\\nglFragColor=pack_depth(v_depth);\\n#endif\\n}\", '#include \"_prelude_terrain.vertex.glsl\"\\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_width_scale;uniform float u_vertical_scale;\\n#ifdef TERRAIN\\nuniform int u_height_type;uniform int u_base_type;\\n#endif\\nin vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\\n#ifdef RENDER_WALL_MODE\\nin vec3 a_join_normal_inside;\\n#endif\\n#pragma mapbox: define highp float base\\n#pragma mapbox: define highp float height\\n#pragma mapbox: define highp float line_width\\n#pragma mapbox: define highp vec4 color\\nout highp float v_depth;void main() {\\n#pragma mapbox: initialize highp float base\\n#pragma mapbox: initialize highp float height\\n#pragma mapbox: initialize highp float line_width\\n#pragma mapbox: initialize highp vec4 color\\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\\n#if defined(HAS_CENTROID) || defined(TERRAIN)\\ncentroid_pos=a_centroid_pos;\\n#endif\\nvec3 pos;\\n#ifdef TERRAIN\\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;float ele=elevation(pos_nx.xy);float c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);float h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\\n#else\\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\\n#endif\\n#ifdef RENDER_WALL_MODE\\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\\n#endif\\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}'),\n      fillExtrusionPattern: Go('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform vec2 u_texsize;uniform sampler2D u_image;\\n#ifdef FAUX_AO\\nuniform lowp vec2 u_ao;in vec3 v_ao;\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nin vec3 v_normal;\\n#endif\\nin highp vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;\\n#pragma mapbox: define highp float base\\n#pragma mapbox: define highp float height\\n#pragma mapbox: define mediump vec4 pattern\\n#pragma mapbox: define highp float pixel_ratio\\nvoid main() {\\n#pragma mapbox: initialize highp float base\\n#pragma mapbox: initialize highp float height\\n#pragma mapbox: initialize mediump vec4 pattern\\n#pragma mapbox: initialize highp float pixel_ratio\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\\n#else\\nout_color=out_color*v_lighting;\\n#endif\\n#ifdef FAUX_AO\\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nout_color=applyCutout(out_color,height);\\n#endif\\nglFragColor=out_color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_terrain.vertex.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_width_scale;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\\n#ifdef RENDER_WALL_MODE\\nin vec3 a_join_normal_inside;\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\\n#endif\\n#ifdef TERRAIN\\nuniform int u_height_type;uniform int u_base_type;\\n#endif\\nout highp vec2 v_pos;out vec4 v_lighting;\\n#ifdef FAUX_AO\\nuniform lowp vec2 u_ao;out vec3 v_ao;\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nout vec3 v_normal;\\n#endif\\n#pragma mapbox: define highp float base\\n#pragma mapbox: define highp float height\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define mediump vec4 pattern\\n#pragma mapbox: define highp float pixel_ratio\\n#pragma mapbox: define highp float line_width\\nvoid main() {\\n#pragma mapbox: initialize highp float base\\n#pragma mapbox: initialize highp float height\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize mediump vec4 pattern\\n#pragma mapbox: initialize highp float pixel_ratio\\n#pragma mapbox: initialize highp float line_width\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\\n#if defined(HAS_CENTROID) || defined(TERRAIN)\\ncentroid_pos=a_centroid_pos;\\n#endif\\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\\n#ifdef TERRAIN\\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;p=vec3(pos_nx.xy,h);\\n#else\\np=vec3(pos_nx.xy,z);\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\\n#endif\\n#ifdef RENDER_WALL_MODE\\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);p.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;p.xy-=a_join_normal_inside.z*wall_offset*0.5;\\n#endif\\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\\n? pos_nx.xy\\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\\n#ifdef LIGHTING_3D_MODE\\nNdotL=calculate_NdotL(normal);\\n#else\\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\\n#endif\\nif (normal.y !=0.0) {float r=0.84;\\n#ifndef LIGHTING_3D_MODE\\nr=mix(0.7,0.98,1.0-u_lightintensity);\\n#endif\\nNdotL*=(\\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\\n#ifdef FAUX_AO\\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\\n#ifdef TERRAIN\\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\\n#endif\\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\\n#ifdef PROJECTION_GLOBE_VIEW\\ntop_height+=u_height_lift;\\n#endif\\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nv_normal=normal;\\n#else\\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\\n#endif \\n#ifdef FOG\\nv_fog_pos=fog_position(p);\\n#endif\\n}'),\n      groundShadow: Go('#include \"_prelude_shadow.fragment.glsl\"\\nprecision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\\n#ifdef FOG\\nin float v_fog_opacity;\\n#endif\\nvoid main() {float light=shadowed_light_factor_plane_bias(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\\n#ifdef RENDER_CUTOFF\\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));\\n#endif\\n#ifdef FOG\\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0),0.0).r);\\n#endif\\nglFragColor=vec4(shadow,1.0);}', '#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\\n#ifdef FOG\\nout float v_fog_opacity;\\n#endif\\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\\n#endif\\n}'),\n      fillExtrusionGroundEffect: Go(\"uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\\n#ifdef SDF_SUBPASS\\nin highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\\n#ifdef FOG\\nin highp float v_fog;\\n#endif\\n#endif\\nvoid main() {\\n#ifdef CLEAR_SUBPASS\\nvec4 color=vec4(1.0);\\n#ifdef CLEAR_FROM_TEXTURE\\ncolor=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\\n#endif\\nglFragColor=color;\\n#else\\n#ifdef SDF_SUBPASS\\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\\n#ifdef FOG\\nfog=v_fog;\\n#endif\\n#ifdef RENDER_CUTOFF\\nfog*=v_cutoff_opacity;\\n#endif\\nglFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\\n#else\\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\\n#ifdef OVERDRAW_INSPECTOR\\ncolor=vec4(1.0);\\n#endif\\nglFragColor=color;\\n#endif\\nHANDLE_WIREFRAME_DEBUG;\\n#endif\\n}\", '#include \"_prelude_fog.vertex.glsl\"\\nin highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;\\n#ifdef SDF_SUBPASS\\nout highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;\\n#ifdef FOG\\nout highp float v_fog;\\n#endif\\n#endif\\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp float u_dynamic_offset;uniform highp vec2 u_ao;\\n#pragma mapbox: define highp float flood_light_ground_radius\\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\\n#pragma mapbox: initialize highp float flood_light_ground_radius\\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(u_dynamic_offset,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\\n#ifdef SDF_SUBPASS\\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\\n#endif\\n#endif\\nfloat hidden_by_landmark=0.0;\\n#ifdef HAS_CENTROID\\nhidden_by_landmark=a_hidden_by_landmark;\\n#endif\\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\\n#ifdef RENDER_CUTOFF\\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\\n#endif\\n}'),\n      hillshadePrepare: Go(\"precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\\n)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(\\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}\", \"uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}\"),\n      hillshade: Go('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;\\n#ifdef LIGHTING_3D_MODE\\nglFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);\\n#endif\\n#ifdef FOG\\nglFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));\\n#endif\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n}'),\n      line: Go('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\nuniform lowp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_floor_width_scale;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec3 v_uv;\\n#ifdef ELEVATED_ROADS\\nin highp float v_road_z_offset;\\n#endif\\n#ifdef RENDER_LINE_DASH\\nuniform sampler2D u_dash_image;in vec2 v_tex;\\n#endif\\n#ifdef RENDER_LINE_GRADIENT\\nuniform sampler2D u_gradient_image;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nin highp float v_z_offset;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\\n#endif\\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float floorwidth\\n#pragma mapbox: define lowp vec4 dash\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float border_width\\n#pragma mapbox: define lowp vec4 border_color\\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float floorwidth\\n#pragma mapbox: initialize lowp vec4 dash\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float border_width\\n#pragma mapbox: initialize lowp vec4 border_color\\nfloat dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\\n#ifdef RENDER_LINE_DASH\\nfloat sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;float scaled_floorwidth=(floorwidth*u_floor_width_scale);alpha*=linearstep(0.5-sdfgamma/scaled_floorwidth,0.5+sdfgamma/scaled_floorwidth,sdfdist);\\n#endif\\nhighp vec4 out_color;\\n#ifdef RENDER_LINE_GRADIENT\\nout_color=texture(u_gradient_image,v_uv.xy);\\n#else\\nout_color=color;\\n#endif\\nfloat trim_alpha=1.0;\\n#ifdef RENDER_LINE_TRIM_OFFSET\\nhighp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);out_color=mix(out_color,u_trim_color,transition_factor);trim_alpha=1.0-transition_factor;}\\n#endif\\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\\n#ifdef RENDER_LINE_BORDER\\nfloat edgeBlur=((border_width*u_width_scale)+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color=mix(border_color*trim_alpha,out_color,smoothAlpha);}}\\n#endif\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\\n#ifdef RENDER_SHADOWS\\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\\n#ifdef ELEVATED_ROADS\\nout_color.rgb*=mix(v_road_z_offset > 0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\\n#else\\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\\n#endif\\n#endif\\n#endif\\n#ifdef FOG\\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\\n#endif\\nout_color*=(alpha*opacity);\\n#ifdef INDICATOR_CUTOUT\\nout_color=applyCutout(out_color,v_z_offset);\\n#endif\\nglFragColor=out_color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\n#include \"_prelude_terrain.vertex.glsl\"\\n#define EXTRUDE_SCALE 0.015873016\\nin vec2 a_pos_normal;in vec4 a_data;\\n#if defined(ELEVATED) || defined(ELEVATED_ROADS) || defined(VARIABLE_LINE_WIDTH)\\nin vec3 a_z_offset_width;\\n#endif\\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\\nin highp vec3 a_packed;\\n#endif\\n#ifdef RENDER_LINE_DASH\\nin float a_linesofar;\\n#endif\\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;uniform float u_width_scale;uniform highp float u_floor_width_scale;\\n#ifdef ELEVATED\\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\\n#ifdef ELEVATION_REFERENCE_SEA\\nreturn 0.0;\\n#else\\nreturn elevation(apos);\\n#endif\\n}\\n#endif\\nout vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec3 v_uv;\\n#ifdef ELEVATED_ROADS\\nout highp float v_road_z_offset;\\n#endif\\n#ifdef RENDER_LINE_DASH\\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;\\n#endif\\n#ifdef RENDER_LINE_GRADIENT\\nuniform float u_image_height;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nout highp float v_z_offset;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\\n#endif\\n#pragma mapbox: define highp vec4 color\\n#pragma mapbox: define lowp float floorwidth\\n#pragma mapbox: define lowp vec4 dash\\n#pragma mapbox: define lowp float blur\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define lowp float offset\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define lowp float border_width\\n#pragma mapbox: define lowp vec4 border_color\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 color\\n#pragma mapbox: initialize lowp float floorwidth\\n#pragma mapbox: initialize lowp vec4 dash\\n#pragma mapbox: initialize lowp float blur\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize lowp float offset\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize lowp float border_width\\n#pragma mapbox: initialize lowp vec4 border_color\\nfloat a_z_offset;\\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\\na_z_offset=a_z_offset_width.x;\\n#endif\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth;\\n#ifdef VARIABLE_LINE_WIDTH\\nfloat left=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);halfwidth=(u_width_scale*(left==1.0 ? a_z_offset_width.y : a_z_offset_width.z))/2.0;\\n#else\\nhalfwidth=(u_width_scale*width)/2.0;\\n#endif\\noffset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\\n#ifdef ELEVATED_ROADS\\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;\\n#else\\n#ifdef ELEVATED\\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\\n#ifdef CROSS_SLOPE_VERTICAL\\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\\n#else\\n#ifdef CROSS_SLOPE_HORIZONTAL\\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\\n#else\\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\\n#endif\\n#endif\\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\\n#else\\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\\n#endif\\n#endif\\n#ifdef ELEVATED_ROADS\\n#ifdef RENDER_SHADOWS\\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\\n#ifdef NORMAL_OFFSET\\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\\n#endif\\n#endif\\n#ifndef RENDER_TO_TEXTURE\\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=max(length(projected_extrude_xy/gl_Position.w*u_units_to_pixels),0.001);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\\n#else\\nv_gamma_scale=1.0;\\n#endif\\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\\nhighp float a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float line_progress=a_packed[2];\\n#ifdef RENDER_LINE_GRADIENT\\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec3(a_uv_x,a_split_index*texel_height-half_texel_height,line_progress);\\n#else\\nv_uv=vec3(a_uv_x,0.0,line_progress);\\n#endif\\n#endif\\n#ifdef RENDER_LINE_DASH\\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/(floorwidth*u_floor_width_scale),(-normal.y*height+dash.x+0.5)/u_texsize.y);\\n#endif\\nv_width2=vec2(outset,inset);\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nv_z_offset=a_z_offset;\\n#endif\\n}'),\n      linePattern: Go('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\nuniform highp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;\\n#ifdef RENDER_LINE_TRIM_OFFSET\\nin highp vec3 v_uv;\\n#endif\\n#ifdef ELEVATED_ROADS\\nin highp float v_road_z_offset;\\n#endif\\n#ifdef LINE_JOIN_NONE\\nin vec2 v_pattern_data;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nin highp float v_z_offset;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\\n#endif\\nuniform float u_emissive_strength;\\n#pragma mapbox: define mediump vec4 pattern\\n#pragma mapbox: define mediump float pixel_ratio\\n#pragma mapbox: define mediump float blur\\n#pragma mapbox: define mediump float opacity\\nvoid main() {\\n#pragma mapbox: initialize mediump vec4 pattern\\n#pragma mapbox: initialize mediump float pixel_ratio\\n#pragma mapbox: initialize mediump float blur\\n#pragma mapbox: initialize mediump float opacity\\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;highp float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;highp float x=mod(pattern_x,1.0);highp float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;highp vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));highp vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);\\n#ifdef RENDER_LINE_TRIM_OFFSET\\nhighp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);color=mix(color,color.a*u_trim_color,transition_factor);}\\n#endif\\n#ifdef LINE_JOIN_NONE\\nhighp float pattern_len=pattern_size/aspect;highp float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);highp float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;highp float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}\\n#endif\\n#ifdef LIGHTING_3D_MODE\\ncolor=apply_lighting_with_emission_ground(color,u_emissive_strength);\\n#ifdef RENDER_SHADOWS\\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\\n#ifdef ELEVATED_ROADS\\ncolor.rgb*=mix(v_road_z_offset > 0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\\n#else\\ncolor.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\\n#endif\\n#endif\\n#endif\\n#ifdef FOG\\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\\n#endif\\ncolor*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}\\n#ifdef INDICATOR_CUTOUT\\ncolor=applyCutout(color,v_z_offset);\\n#endif\\nglFragColor=color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\n#include \"_prelude_terrain.vertex.glsl\"\\n#define scale 0.015873016\\nin vec2 a_pos_normal;in vec4 a_data;\\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\\nin vec3 a_z_offset_width;\\n#endif\\n#ifdef RENDER_LINE_TRIM_OFFSET\\nin highp vec3 a_packed;\\n#endif\\nin highp float a_linesofar;\\n#ifdef LINE_JOIN_NONE\\nin highp vec3 a_pattern_data;out vec2 v_pattern_data;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nout highp float v_z_offset;\\n#endif\\nuniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;uniform float u_width_scale;uniform float u_floor_width_scale;\\n#ifdef ELEVATED\\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\\n#ifdef ELEVATION_REFERENCE_SEA\\nreturn 0.0;\\n#else\\nreturn elevation(apos);\\n#endif\\n}\\n#endif\\nout vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;\\n#ifdef RENDER_LINE_TRIM_OFFSET\\nout highp vec3 v_uv;\\n#endif\\n#ifdef ELEVATED_ROADS\\nout highp float v_road_z_offset;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\\n#endif\\n#pragma mapbox: define mediump float blur\\n#pragma mapbox: define mediump float opacity\\n#pragma mapbox: define mediump float offset\\n#pragma mapbox: define mediump float gapwidth\\n#pragma mapbox: define mediump float width\\n#pragma mapbox: define mediump float floorwidth\\n#pragma mapbox: define mediump vec4 pattern\\n#pragma mapbox: define mediump float pixel_ratio\\nvoid main() {\\n#pragma mapbox: initialize mediump float blur\\n#pragma mapbox: initialize mediump float opacity\\n#pragma mapbox: initialize mediump float offset\\n#pragma mapbox: initialize mediump float gapwidth\\n#pragma mapbox: initialize mediump float width\\n#pragma mapbox: initialize mediump float floorwidth\\n#pragma mapbox: initialize mediump vec4 pattern\\n#pragma mapbox: initialize mediump float pixel_ratio\\nfloat a_z_offset;\\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\\na_z_offset=a_z_offset_width.x;\\n#endif\\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=(u_width_scale*width)/2.0;offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\\n#ifdef ELEVATED_ROADS\\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;\\n#else\\n#ifdef ELEVATED\\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\\n#ifdef CROSS_SLOPE_VERTICAL\\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\\n#else\\n#ifdef CROSS_SLOPE_HORIZONTAL\\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\\n#else\\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\\n#endif\\n#endif\\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\\n#else\\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\\n#endif\\n#endif\\n#ifdef ELEVATED_ROADS\\n#ifdef RENDER_SHADOWS\\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\\n#ifdef NORMAL_OFFSET\\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\\n#endif\\n#endif\\n#ifndef RENDER_TO_TEXTURE\\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\\n#else\\nv_gamma_scale=1.0;\\n#endif\\n#ifdef RENDER_LINE_TRIM_OFFSET\\nhighp float a_uv_x=a_packed[0];highp float line_progress=a_packed[2];v_uv=vec3(a_uv_x,0.0,line_progress);\\n#endif\\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=(floorwidth*u_floor_width_scale);\\n#ifdef LINE_JOIN_NONE\\nv_width=(floorwidth*u_floor_width_scale)+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(pos);\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nv_z_offset=a_z_offset;\\n#endif\\n}'),\n      raster: Go('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\n#include \"_prelude_raster_array.glsl\"\\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;\\n#ifdef PROJECTION_GLOBE_VIEW\\nin float v_split_fade;\\n#endif\\nuniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;\\n#ifndef RASTER_ARRAY\\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;\\n#endif\\n#ifdef RASTER_COLOR\\nuniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;\\n#endif\\nvoid main() {vec4 color0,color1,color;vec2 value;\\n#ifdef RASTER_COLOR\\n#ifdef RASTER_ARRAY\\n#ifdef RASTER_ARRAY_LINEAR\\nvalue=mix(\\nraTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\\n);\\n#else\\nvalue=mix(\\nraTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\\n);\\n#endif\\nif (value.y > 0.0) value.x/=value.y;\\n#else\\ncolor=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);\\n#endif\\ncolor=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;\\n#else\\ncolor0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);\\n#endif\\ncolor.a*=u_opacity;\\n#ifdef GLOBE_POLES\\ncolor.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);\\n#endif\\nvec3 rgb=color.rgb;rgb=vec3(\\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;\\n#endif\\n#ifdef FOG\\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\\n#endif\\nglFragColor=vec4(out_color*color.a,color.a);\\n#ifdef PROJECTION_GLOBE_VIEW\\nglFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));\\n#endif\\n#ifdef RENDER_CUTOFF\\nglFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);\\n#endif\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\\n#ifdef GLOBE_POLES\\nin vec3 a_globe_pos;in vec2 a_uv;\\n#else\\nin vec2 a_pos;in vec2 a_texture_pos;\\n#endif\\nout vec2 v_pos0;out vec2 v_pos1;out float v_depth;\\n#ifdef PROJECTION_GLOBE_VIEW\\nout float v_split_fade;\\n#endif\\nvoid main() {vec2 uv;\\n#ifdef GLOBE_POLES\\nvec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;\\n#ifdef FOG\\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\\n#endif\\n#else\\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    \\nv_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\\n#ifdef FOG\\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\\n#endif\\n#else\\ngl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n#endif\\n#endif\\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;\\n#ifdef RENDER_CUTOFF\\nv_depth=gl_Position.z;\\n#endif\\n}'),\n      rasterParticle: Go('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;\\n#endif\\n#ifdef FOG\\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\\n#endif\\nglFragColor=vec4(out_color*color.a,color.a);\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\\nin vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\\n#ifdef FOG\\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\\n#endif\\n#else\\nuv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\\n#ifdef FOG\\nv_fog_pos=fog_position(a_pos);\\n#endif\\n#endif\\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}'),\n      rasterParticleDraw: Go(\"uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}\", '#include \"_prelude_raster_particle.glsl\"\\nin float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(\\nmod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}'),\n      rasterParticleTexture: Go(\"uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}\", \"in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}\"),\n      rasterParticleUpdate: Go('#include \"_prelude_raster_particle.glsl\"\\nuniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(\\nlinearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)\\n);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}', \"in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}\"),\n      symbol: Go('#include \"_prelude_lighting.glsl\"\\n#define SDF_PX 8.0\\n#define SDF 1.0\\n#define ICON 0.0\\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;uniform lowp float u_scale_factor;\\n#ifdef ICON_TRANSITION\\nuniform float u_icon_transition;\\n#endif\\n#ifdef COLOR_ADJUSTMENT\\nuniform mat4 u_color_adj_mat;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nin highp float v_z_offset;\\n#endif\\nin vec2 v_tex_a;\\n#ifdef ICON_TRANSITION\\nin vec2 v_tex_b;\\n#endif\\nin float v_draw_halo;in vec3 v_gamma_scale_size_fade_opacity;\\n#ifdef RENDER_TEXT_AND_SYMBOL\\nin float is_sdf;in vec2 v_tex_a_icon;\\n#endif\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\n#pragma mapbox: define lowp float emissive_strength\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\n#pragma mapbox: initialize lowp float emissive_strength\\nvec4 out_color;float fade_opacity=v_gamma_scale_size_fade_opacity[2];\\n#ifdef RENDER_TEXT_AND_SYMBOL\\nif (is_sdf==ICON) {vec2 tex_icon=v_tex_a_icon;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nreturn;}\\n#endif\\n#ifdef RENDER_SDF\\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_gamma_scale_size_fade_opacity.x;float size=v_gamma_scale_size_fade_opacity.y;float fontScale=u_is_text ? size/24.0 : size;out_color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {out_color=halo_color;gamma=(halo_blur*u_scale_factor*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width*u_scale_factor/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,v_tex_a).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);out_color*=alpha;\\n#else\\n#ifdef ICON_TRANSITION\\nvec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);\\n#else\\nout_color=texture(u_texture,v_tex_a);\\n#endif\\n#ifdef COLOR_ADJUSTMENT\\nout_color=u_color_adj_mat*out_color;\\n#endif\\n#endif\\nout_color*=opacity*fade_opacity;\\n#ifdef LIGHTING_3D_MODE\\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nout_color=applyCutout(out_color,v_z_offset);\\n#endif\\nglFragColor=out_color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_terrain.vertex.glsl\"\\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\\n#ifdef Z_OFFSET\\nin float a_auto_z_offset;\\n#endif\\n#ifdef PROJECTION_GLOBE_VIEW\\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\\n#endif\\n#ifdef ICON_TRANSITION\\nin vec2 a_texb;\\n#endif\\n#ifdef OCCLUSION_QUERIES\\nin float a_occlusion_query_opacity;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nout highp float v_z_offset;\\n#endif\\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_elevation_from_sea;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\\n#ifdef PROJECTION_GLOBE_VIEW\\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\\n#endif\\nout vec2 v_tex_a;\\n#ifdef ICON_TRANSITION\\nout vec2 v_tex_b;\\n#endif\\nout float v_draw_halo;out vec3 v_gamma_scale_size_fade_opacity;\\n#ifdef RENDER_TEXT_AND_SYMBOL\\nout float is_sdf;out vec2 v_tex_a_icon;\\n#endif\\n#pragma mapbox: define highp vec4 fill_color\\n#pragma mapbox: define highp vec4 halo_color\\n#pragma mapbox: define lowp float opacity\\n#pragma mapbox: define lowp float halo_width\\n#pragma mapbox: define lowp float halo_blur\\n#pragma mapbox: define lowp float emissive_strength\\n#pragma mapbox: define lowp float occlusion_opacity\\n#pragma mapbox: define lowp float z_offset\\nvoid main() {\\n#pragma mapbox: initialize highp vec4 fill_color\\n#pragma mapbox: initialize highp vec4 halo_color\\n#pragma mapbox: initialize lowp float opacity\\n#pragma mapbox: initialize lowp float halo_width\\n#pragma mapbox: initialize lowp float halo_blur\\n#pragma mapbox: initialize lowp float emissive_strength\\n#pragma mapbox: initialize lowp float occlusion_opacity\\n#pragma mapbox: initialize lowp float z_offset\\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=u_elevation_from_sea ? z_offset : z_offset+elevation(tile_anchor);\\n#ifdef Z_OFFSET\\ne+=a_auto_z_offset;\\n#endif\\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;\\n#ifdef PROJECTION_GLOBE_VIEW\\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\\n#else\\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\\n#endif\\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\\ncamera_to_anchor_distance/u_camera_to_center_distance :\\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;\\n#else\\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;\\n#endif\\nvec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\\n#ifdef PROJECTION_GLOBE_VIEW\\n#ifdef PROJECTED_POS_ON_VIEWPORT\\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xyz+h,1.0);\\n#else\\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz,mercator_pos,u_zoom_transition)+h;projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);    \\n#endif\\n#else\\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\\n#endif\\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\\n#ifdef TERRAIN\\n#ifdef PITCH_WITH_MAP_TERRAIN\\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\\n#endif\\n#endif\\n#ifdef Z_OFFSET\\nz+=u_pitch_with_map ? a_auto_z_offset+(u_elevation_from_sea ? z_offset : z_offset) : 0.0;\\n#else\\nz+=u_pitch_with_map ? (u_elevation_from_sea ? z_offset : z_offset) : 0.0;\\n#endif\\nfloat occlusion_fade=globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));\\n#ifdef DEPTH_OCCLUSION\\nfloat depth_occlusion=occlusionFadeMultiSample(projected_point);float depth_occlusion_multplier=mix(occlusion_opacity,1.0,depth_occlusion);out_fade_opacity*=depth_occlusion_multplier;\\n#endif\\n#ifdef OCCLUSION_QUERIES\\nfloat occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;\\n#endif\\nfloat alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);\\n#ifdef PROJECTION_GLOBE_VIEW\\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);\\n#else\\ngl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);\\n#endif\\nfloat gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_gamma_scale_size_fade_opacity=vec3(gamma_scale,size,out_fade_opacity);v_tex_a=a_tex/u_texsize;\\n#ifdef RENDER_TEXT_AND_SYMBOL\\nis_sdf=a_size[0]-2.0*a_size_min;v_tex_a_icon=a_tex/u_texsize_icon;\\n#endif\\n#ifdef ICON_TRANSITION\\nv_tex_b=a_texb/u_texsize;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nv_z_offset=e;\\n#endif\\n}'),\n      terrainRaster: Go('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform sampler2D u_image0;in vec2 v_pos0;\\n#ifdef FOG\\nin float v_fog_opacity;\\n#endif\\n#ifdef RENDER_SHADOWS\\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\\n#endif\\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;\\n#ifdef LIGHTING_3D_MODE\\nconst vec3 normal=vec3(0.0,0.0,1.0);\\n#ifdef RENDER_SHADOWS\\nfloat cutoffOpacity=1.0;\\n#ifdef RENDER_CUTOFF\\ncutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);\\n#endif\\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\\nvec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\\n#else\\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\\n#endif\\n#else\\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\\ncolor.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;\\n#endif\\n#endif\\n#else\\ncolor=image_color;\\n#endif\\n#ifdef FOG\\n#ifdef ZERO_EXAGGERATION\\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\\n#else\\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\\n#endif\\n#endif\\nglFragColor=color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_terrain.vertex.glsl\"\\nuniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;\\n#ifdef FOG\\nout float v_fog_opacity;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;\\n#endif\\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\\n#ifdef FOG\\n#ifdef ZERO_EXAGGERATION\\nv_fog_pos=fog_position(decodedPos);\\n#else\\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\\n#endif\\n#endif\\n#ifdef RENDER_SHADOWS\\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);\\n#endif\\n}'),\n      terrainDepth: Go(\"precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}\", '#include \"_prelude_terrain.vertex.glsl\"\\nuniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}'),\n      skybox: Go('#include \"_prelude_fog.fragment.glsl\"\\nin lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;\\n#ifdef FOG\\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\\n#endif\\nsky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\n}', Io),\n      skyboxGradient: Go('#include \"_prelude_fog.fragment.glsl\"\\nin highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));\\n#ifdef FOG\\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\\n#endif\\ncolor*=u_opacity;glFragColor=color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\n}', Io),\n      skyboxCapture: Go(\"\\nin highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;\\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\\n#define MIE_G                   0.76\\n#define DENSITY_HEIGHT_SCALE_R  8000.0\\n#define DENSITY_HEIGHT_SCALE_M  1200.0\\n#define PLANET_RADIUS           6360e3\\n#define ATMOSPHERE_RADIUS       6420e3\\n#define SAMPLE_STEPS            10\\n#define DENSITY_STEPS           4\\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}\", \"in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}\"),\n      globeRaster: Go('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;\\n#ifndef FOG\\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\\n#endif\\nvoid main() {vec4 color;\\n#ifdef CUSTOM_ANTIALIASING\\nhighp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;highp float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);highp float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);\\n#ifdef LIGHTING_3D_MODE\\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\\nraster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(clamp(raster.rgb,vec3(0),vec3(1))*antialias,antialias);\\n#else\\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\\n#endif\\n#else\\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\\n#endif\\n#else\\ncolor=texture(u_image0,v_pos0);\\n#ifdef LIGHTING_3D_MODE\\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\\ncolor=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;\\n#else\\ncolor=apply_lighting_ground(color);\\n#endif\\n#endif\\n#endif\\n#ifdef FOG\\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\\n#endif\\ncolor*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_terrain.vertex.glsl\"\\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\\n#ifdef GLOBE_POLES\\nin vec3 a_globe_pos;in vec2 a_uv;\\n#else\\nin vec2 a_pos;\\n#endif\\nout vec2 v_pos0;void main() {\\n#ifdef GLOBE_POLES\\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\\n#else\\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\\n#endif\\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\\n#ifdef GLOBE_POLES\\nvec3 up_vector=globe_derived_up_vector;\\n#else\\nvec3 up_vector=elevationVector(tile_pos);\\n#endif\\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\\n#ifndef GLOBE_POLES\\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\\n#endif\\n#ifdef GLOBE_POLES\\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\\n#else\\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\\n#endif\\ngl_Position=u_proj_matrix*interpolated_pos;\\n#ifdef FOG\\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\\n#endif\\n}'),\n      globeAtmosphere: Go('#include \"_prelude_fog.fragment.glsl\"\\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\\n#ifdef PROJECTION_GLOBE_VIEW\\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\\n#ifdef ALPHA_PASS\\nglFragColor=vec4(0,0,0,0);return;\\n#else\\n#ifdef NATIVE\\nglFragColor=vec4(1,1,1,1);\\n#else\\nglFragColor=vec4(0,0,0,1);\\n#endif\\nreturn;\\n#endif\\n}\\n#endif\\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\\n#ifdef PROJECTION_GLOBE_VIEW\\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\\n#else\\nhorizon_angle=horizon_angle_mercator;\\n#endif\\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\\n#ifdef ALPHA_PASS\\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);\\n#else\\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;glFragColor=vec4(c*t,t);\\n#endif\\n}', \"in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}\"),\n      model: Go('#include \"_prelude_fog.fragment.glsl\"\\n#include \"_prelude_shadow.fragment.glsl\"\\n#include \"_prelude_lighting.glsl\"\\nuniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;\\n#ifdef RENDER_SHADOWS\\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;\\n#endif\\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\\nuniform vec4 u_occlusionTextureTransform;\\n#endif\\n#pragma mapbox: define-attribute highp vec3 normal_3f\\n#pragma mapbox: define-attribute highp vec3 color_3f\\n#pragma mapbox: define-attribute highp vec4 color_4f\\n#pragma mapbox: define-attribute highp vec2 uv_2f\\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\\n#pragma mapbox: initialize-attribute highp vec3 color_3f\\n#pragma mapbox: initialize-attribute highp vec4 color_4f\\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\\n#ifdef HAS_ATTRIBUTE_a_pbr\\nin lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;\\n#endif\\n#ifdef HAS_TEXTURE_u_baseColorTexture\\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\\n#endif\\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\\nuniform sampler2D u_metallicRoughnessTexture;\\n#endif\\n#ifdef HAS_TEXTURE_u_occlusionTexture\\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\\n#endif\\n#ifdef HAS_TEXTURE_u_normalTexture\\nuniform sampler2D u_normalTexture;\\n#endif\\n#ifdef HAS_TEXTURE_u_emissionTexture\\nuniform sampler2D u_emissionTexture;\\n#endif\\n#ifdef APPLY_LUT_ON_GPU\\nuniform highp sampler3D u_lutTexture;\\n#endif\\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\\nin highp float v_depth;uniform highp sampler2D u_depthTexture;uniform highp vec2 u_inv_depth_size;uniform highp vec2 u_depth_range_unpack;\\n#ifdef DEPTH_D24\\nhighp float unpack_depth(highp float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}\\n#else\\nhighp float unpack_depth_rgba(highp vec4 rgba_depth)\\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\\n#endif\\nbool isOccluded() {highp vec2 coord=gl_FragCoord.xy*u_inv_depth_size;\\n#ifdef DEPTH_D24\\nhighp float depth=unpack_depth(texture(u_depthTexture,coord).r);\\n#else\\nhighp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));\\n#endif\\nreturn v_depth > depth+0.0005;}\\n#endif\\n#define saturate(_x) clamp(_x,0.,1.)\\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\\n{\\n#ifdef LIGHTING_3D_MODE\\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\\n#ifdef RENDER_SHADOWS\\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\\n#else\\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\\n#endif\\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\\n#else\\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\\n#endif\\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\\n#ifdef HAS_ATTRIBUTE_a_color_3f\\nalbedo*=vec4(color_3f,1.0);\\n#endif\\n#ifdef HAS_ATTRIBUTE_a_pbr\\n#else\\n#ifdef HAS_ATTRIBUTE_a_color_4f\\nalbedo*=color_4f;\\n#endif\\n#endif\\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\\nvec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\\n#endif\\nif(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}\\n#endif\\nvec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);\\n#ifdef APPLY_LUT_ON_GPU\\ncolor=applyLUT(u_lutTexture,color);\\n#endif\\nreturn color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\\n#ifdef HAS_TEXTURE_u_normalTexture\\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\\n#else\\nreturn mat3(1.0);\\n#endif\\n}highp vec3 getNormal(){highp vec3 n;\\n#ifdef HAS_ATTRIBUTE_a_normal_3f\\nn=normalize(normal_3f);\\n#else\\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;\\n#endif\\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\\nvec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\\n#endif\\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\\n#ifdef HAS_ATTRIBUTE_a_pbr\\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\\n#endif\\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \\nvec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\\n#endif\\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\\n{\\n#ifdef LIGHTING_3D_MODE\\nreturn mat.diffuseColor;\\n#else\\nreturn mat.diffuseColor/PI;\\n#endif\\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\\n{vec3 env_light=vec3(0.65,0.65,0.65);\\n#ifdef LIGHTING_3D_MODE\\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\\n#endif\\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\\n#ifdef RENDER_SHADOWS\\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\\n#else\\nlighting_factor=NdotL;\\n#endif\\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\\n#if !defined(LIGHTING_3D_MODE)\\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\\n#endif\\ncolor*=intensityFactor;return color;}void main() {\\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\\nif (isOccluded()) {discard;}\\n#endif\\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\\n#ifdef LIGHTING_3D_MODE\\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\\n#endif\\nvec4 finalColor;\\n#ifdef DIFFUSE_SHADED\\nvec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);\\n#ifdef HAS_TEXTURE_u_occlusionTexture\\nfloat ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\\n#endif\\nfinalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;\\n#else\\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;\\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\\nvec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;\\n#else\\nvec2 uv=uv_2f;\\n#endif\\nao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;\\n#endif\\nvec4 emissive=u_emissiveFactor;\\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\\nemissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);\\n#endif\\n#ifdef APPLY_LUT_ON_GPU\\nfloat emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;\\n#endif\\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\\n#ifdef HAS_ATTRIBUTE_a_pbr\\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;\\n#ifdef APPLY_LUT_ON_GPU\\ncolor_mix=applyLUT(u_lutTexture,color_mix);\\n#endif\\ncolor=mix(color,color_mix,min(1.0,resEmission));\\n#ifdef HAS_ATTRIBUTE_a_color_4f\\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\\n#endif\\n#endif\\nvec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\\n#endif\\n#ifdef FOG\\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\\n#endif\\n#ifdef RENDER_CUTOFF\\nfinalColor*=v_cutoff_opacity;\\n#endif\\n#ifdef INDICATOR_CUTOUT\\nfinalColor=applyCutout(finalColor,v_position_height.w);\\n#endif\\nglFragColor=finalColor;\\n#ifdef OVERDRAW_INSPECTOR\\nglFragColor=vec4(1.0);\\n#endif\\nHANDLE_WIREFRAME_DEBUG;}', '#include \"_prelude_fog.vertex.glsl\"\\n#include \"_prelude_shadow.vertex.glsl\"\\nin vec3 a_pos_3f;\\n#pragma mapbox: define-attribute highp vec3 normal_3f\\n#pragma mapbox: define-attribute highp vec2 uv_2f\\n#pragma mapbox: define-attribute highp vec3 color_3f\\n#pragma mapbox: define-attribute highp vec4 color_4f\\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\\nuniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\\n#ifdef INSTANCED_ARRAYS\\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\\n#else\\nuniform highp mat4 u_normal_matrix;\\n#endif\\n#ifdef RENDER_SHADOWS\\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;\\n#endif\\nout vec4 v_position_height;out lowp vec4 v_color_mix;\\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\\nout highp float v_depth;\\n#endif\\n#ifdef HAS_ATTRIBUTE_a_pbr\\nout lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;\\n#endif\\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\\n#pragma mapbox: initialize-attribute highp vec3 color_3f\\n#pragma mapbox: initialize-attribute highp vec4 color_4f\\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\\nhighp mat4 normal_matrix;\\n#ifdef INSTANCED_ARRAYS\\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\\n#else\\nnormal_matrix=u_normal_matrix;\\n#endif\\nvec3 local_pos;mat3 rs;\\n#ifdef MODEL_POSITION_ON_GPU\\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\\n#else\\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\\n#endif\\nv_position_height.w=a_pos_3f.z;\\n#ifdef HAS_ATTRIBUTE_a_pbr\\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\\n#endif\\n#ifdef FOG\\nv_fog_pos=fog_position(local_pos);\\n#endif\\n#ifdef RENDER_CUTOFF\\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\\n#endif\\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\\nv_depth=gl_Position.z/gl_Position.w;\\n#endif\\n#ifdef HAS_ATTRIBUTE_a_normal_3f\\n#ifdef MODEL_POSITION_ON_GPU\\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\\n#else\\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\\n#endif\\n#endif\\n#ifdef HAS_ATTRIBUTE_a_pbr\\n#ifdef HAS_ATTRIBUTE_a_color_4f\\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\\n#endif\\n#endif\\n#ifdef RENDER_SHADOWS\\nvec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);\\n#ifdef NORMAL_OFFSET\\n#ifdef HAS_ATTRIBUTE_a_normal_3f\\n#ifdef MODEL_POSITION_ON_GPU\\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\\n#else\\nvec3 offset=shadow_normal_offset_model(normal_3f);shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\\n#endif\\n#endif\\n#endif\\nv_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;\\n#endif\\n}'),\n      modelDepth: Go(\"in highp float v_depth;void main() {\\n#ifndef DEPTH_TEXTURE\\nglFragColor=pack_depth(v_depth);\\n#endif\\n}\", \"in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;\\n#ifdef MODEL_POSITION_ON_GPU\\n#ifdef INSTANCED_ARRAYS\\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\\n#else\\nuniform highp mat4 u_instance;\\n#endif\\nuniform highp mat4 u_node_matrix;\\n#endif\\nvoid main() {\\n#ifdef MODEL_POSITION_ON_GPU\\nhighp mat4 instance;\\n#ifdef INSTANCED_ARRAYS\\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\\n#else\\ninstance=u_instance;\\n#endif\\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);\\n#else\\ngl_Position=u_matrix*vec4(a_pos_3f,1);\\n#endif\\nv_depth=gl_Position.z/gl_Position.w;}\"),\n      stars: Go(\"in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)\\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}\", \"\\nin vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}\"),\n      snowParticle: Go(\"in highp vec2 uv;in highp float alphaMultiplier;uniform vec4 u_particleColor;uniform vec2 u_simpleShapeParameters;void main() {float t=clamp((length(uv)-u_simpleShapeParameters.x)/(1.0-u_simpleShapeParameters.x),0.0,1.0);float alpha=1.0-pow(t,pow(10.0,u_simpleShapeParameters.y));alpha*=alphaMultiplier;alpha*=u_particleColor.a;vec3 color=u_particleColor.rgb*alpha;glFragColor=vec4(color,alpha) ;HANDLE_WIREFRAME_DEBUG;}\", \"\\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_snowParticleData;in highp vec4 a_snowParticleDataHorizontalOscillation;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform vec2 u_screenSize;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \\nuniform float u_velocity;uniform vec3 u_direction;uniform float u_horizontalOscillationRadius; \\nuniform float u_horizontalOscillationRate; \\nuniform float u_billboardSize;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;out highp vec2 uv;out highp float alphaMultiplier;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos.xyz*=halfBoxSize;pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_snowParticleData.z;float coneAngleHeadingRad=a_snowParticleData.w*radians(360.0);vec3 localZ=normalize(u_direction);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 direction;direction.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.z=cos(coneAnglePichRad);direction=normalize(direction);vec3 simPosLocal=vec3(0,0,0);float velocityScale=(1.0+3.0*a_snowParticleData.y)*u_velocity;simPosLocal+=direction*velocityScale*u_time;float horizontalOscillationRadius=u_horizontalOscillationRadius*a_snowParticleDataHorizontalOscillation.x;float horizontalOscillationAngle=u_horizontalOscillationRate*u_time*(-1.0+2.0*a_snowParticleDataHorizontalOscillation.y);simPosLocal.xy+=horizontalOscillationRadius*vec2(cos(horizontalOscillationAngle),sin(horizontalOscillationAngle));vec3 simPos=localX*simPosLocal.x+\\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);float clipZ=-u_cam_pos.z+pos.z;vec4 posView=u_modelview*vec4(pos,1.0);float size=u_billboardSize;alphaMultiplier=1.0;vec4 posScreen=u_projection*posView;posScreen/=posScreen.w;posScreen.xy=vec2(0.5)+posScreen.xy*0.5;posScreen.xy*=u_screenSize;vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=u_screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-posScreen.xy)/(0.5*u_screenSize));screenDist+=a_snowParticleData.x*u_thinningParticleOffset;float scaleFactorMode=0.0;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);if (a_snowParticleData.x < u_thinningAffectedRatio) {scaleFactorMode=1.0-thinningFadeRatio;alphaMultiplier=thinningFadeRatio;}}vec4 posScreen1=u_projection*vec4(posView.x-size,posView.yzw);posScreen1/=posScreen1.w;vec4 posScreen2=u_projection*vec4(posView.x+size,posView.yzw);posScreen2/=posScreen2.w;posScreen1.xy=vec2(0.5)+posScreen1.xy*0.5;posScreen1.xy*=u_screenSize;posScreen2.xy=vec2(0.5)+posScreen2.xy*0.5;posScreen2.xy*=u_screenSize;float screenLength=length(posScreen1.xy-posScreen2.xy);float screenEpsilon=3.0;float scaleFactor=1.0;if (screenLength < screenEpsilon) {scaleFactor=screenEpsilon/max(screenLength,0.01);scaleFactor=mix(scaleFactor,1.0,scaleFactorMode);}float screenEpsilon2=15.0;if (screenLength > screenEpsilon2) {scaleFactor=screenEpsilon2/max(screenLength,0.01);}size*=scaleFactor;vec2 right=size*vec2(1,0);vec2 up=size*vec2(0,1);posView.xy+=right*a_uv.x;posView.xy+=up*a_uv.y;uv=a_uv;gl_Position=u_projection*posView;}\"),\n      rainParticle: Go(\"in highp vec2 uv;in highp float particleRandomValue;uniform sampler2D u_texScreen;uniform float u_distortionStrength;uniform vec4 u_color;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;uniform float u_shapeDirectionalPower;uniform float u_mode;void main() {vec2 st=uv*0.5+vec2(0.5);vec2 uvm=uv;uvm.y=-1.0+2.0*pow(st.y,u_shapeDirectionalPower);float shape=clamp(1.0-length(uvm),0.0,1.0);float alpha=abs(shape)*u_color.a;vec2 screenSize=vec2(textureSize(u_texScreen,0));vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-gl_FragCoord.xy)/(0.5*screenSize));screenDist+=(0.5+0.5*particleRandomValue)*u_thinningParticleOffset;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;float thinningAlpha=1.0;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);thinningAlpha*=thinningFadeRatio;}vec2 offsetXY=normalize(uvm)*abs(shape);vec2 stScreen=(gl_FragCoord.xy+offsetXY*u_distortionStrength*thinningAlpha)/screenSize;vec3 colorScreen=texture(u_texScreen,stScreen).rgb;alpha*=thinningAlpha;glFragColor=mix(vec4(colorScreen,1.0),vec4(u_color.rgb*alpha,alpha),u_mode);HANDLE_WIREFRAME_DEBUG;}\", \"\\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_rainParticleData;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \\nuniform float u_velocity; \\nuniform vec2 u_rainDropletSize;uniform vec3 u_rainDirection;out highp vec2 uv;out highp float particleRandomValue;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos*=halfBoxSize; \\npos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_rainParticleData.z;float coneAngleHeadingRad=a_rainParticleData.w*radians(360.0);vec3 localZ=normalize(u_rainDirection);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 directionLocal;directionLocal.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.z=cos(coneAnglePichRad);directionLocal=normalize(directionLocal);vec3 directionWorld=localX*directionLocal.x+localY*directionLocal.y+localZ*directionLocal.z;float velocityScale=(1.0+3.0*a_rainParticleData.y)*u_velocity;vec3 simPosLocal=vec3(0,0,0);simPosLocal+=directionLocal*velocityScale*u_time;vec3 simPos=localX*simPosLocal.x+\\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);vec4 posView=u_modelview*vec4(pos,1.0);vec3 directionView=normalize((u_modelview*vec4(directionWorld,0.0)).xyz);vec3 side=cross(directionView,normalize(posView.xyz));posView.xyz+=side*a_uv.x*u_rainDropletSize.x;posView.xyz+=directionView*a_uv.y*u_rainDropletSize.y;uv=a_uv;particleRandomValue=a_rainParticleData.x;gl_Position=u_projection*posView;}\"),\n      vignette: Go(\"uniform vec3 u_vignetteShape;uniform vec4 u_vignetteColor;in vec2 st;void main() {float screenDist=length(st);float alpha=clamp((screenDist-u_vignetteShape.x)/u_vignetteShape.y,0.0,1.0);alpha=pow(alpha,u_vignetteShape.z)*u_vignetteColor.a;vec3 color=u_vignetteColor.rgb;glFragColor=vec4(color*alpha,alpha) ;}\", \"in vec2 a_pos_2f;out vec2 st;void main() {st=a_pos_2f;gl_Position=vec4(a_pos_2f,0,1);}\"),\n      occlusion: Go(\"uniform vec4 u_color;void main() {glFragColor=u_color;}\", '#include \"_prelude_terrain.vertex.glsl\"\\nin highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;\\n#ifdef TERRAIN\\nfloat e=elevation(world_pos.xy);world_pos.z+=e;\\n#endif\\nvec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}')\n    };\n    function Vo(e, t) {\n      const i = e.replace(/\\s*\\/\\/[^\\n]*\\n/g, \"\\n\").split(\"\\n\");\n      for (let e of i) if (e = e.trim(), \"#\" === e[0] && e.includes(\"if\") && !e.includes(\"endif\")) {\n        e = e.replace(\"#\", \"\").replace(/ifdef|ifndef|elif|if/g, \"\").replace(/!|defined|\\(|\\)|\\|\\||&&/g, \"\").replace(/\\s+/g, \" \").trim();\n        const i = e.split(\" \");\n        for (const e of i) t.includes(e) || t.push(e);\n      }\n    }\n    function Go(e, t) {\n      const i = /#include\\s+\"([^\"]+)\"/g,\n        o = /#pragma mapbox: ([\\w\\-]+) ([\\w]+) ([\\w]+) ([\\w]+)/g;\n      let s = t.match(/(attribute(\\S*)|(^\\s*|;)in) (highp |mediump |lowp )?([\\w]+) ([\\w]+)/gm);\n      s && (s = s.map(e => {\n        const t = e.split(\" \");\n        return t[t.length - 1];\n      }), s = [...new Set(s)]);\n      const r = {},\n        n = [],\n        a = [];\n      if (e = e.replace(i, (e, t) => (a.push(t), \"\")), (t = t.replace(i, (e, t) => (n.push(t), \"\"))).includes(\"flat out\")) return void console.error('The usage of \"flat\" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');\n      let l = [...Oo];\n      Vo(e, l), Vo(t, l);\n      for (const e of [...n, ...a]) Fo[e] || console.error(`Undefined include: ${e}`), ko[e] || (ko[e] = [], Vo(Fo[e], ko[e])), l = [...l, ...ko[e]];\n      return {\n        fragmentSource: e = e.replace(o, (e, t, i, o, s) => (r[s] = !0, \"define\" === t ? `\\n#ifndef HAS_UNIFORM_u_${s}\\nin ${i} ${o} ${s};\\n#else\\nuniform ${i} ${o} u_${s};\\n#endif\\n` : \"initialize\" === t ? `\\n#ifdef HAS_UNIFORM_u_${s}\\n    ${i} ${o} ${s} = u_${s};\\n#endif\\n` : \"define-attribute\" === t ? `\\n#ifdef HAS_ATTRIBUTE_a_${s}\\n    in ${i} ${o} ${s};\\n#endif\\n` : \"initialize-attribute\" === t ? \"\" : void 0)),\n        vertexSource: t = t.replace(o, (e, t, i, o, s) => {\n          const n = \"float\" === o ? \"vec2\" : o,\n            a = s.match(/color/) ? \"color\" : n;\n          return \"define-attribute-vertex-shader-only\" === t ? `\\n#ifdef HAS_ATTRIBUTE_a_${s}\\nin ${i} ${o} a_${s};\\n#endif\\n` : r[s] ? \"define\" === t ? `\\n#ifndef HAS_UNIFORM_u_${s}\\nuniform lowp float u_${s}_t;\\nin ${i} ${n} a_${s};\\nout ${i} ${o} ${s};\\n#else\\nuniform ${i} ${o} u_${s};\\n#endif\\n` : \"initialize\" === t ? \"vec4\" === a ? `\\n#ifndef HAS_UNIFORM_u_${s}\\n    ${s} = a_${s};\\n#else\\n    ${i} ${o} ${s} = u_${s};\\n#endif\\n` : `\\n#ifndef HAS_UNIFORM_u_${s}\\n    ${s} = unpack_mix_${a}(a_${s}, u_${s}_t);\\n#else\\n    ${i} ${o} ${s} = u_${s};\\n#endif\\n` : \"define-attribute\" === t ? `\\n#ifdef HAS_ATTRIBUTE_a_${s}\\n    in ${i} ${o} a_${s};\\n    out ${i} ${o} ${s};\\n#endif\\n` : \"initialize-attribute\" === t ? `\\n#ifdef HAS_ATTRIBUTE_a_${s}\\n    ${s} = a_${s};\\n#endif\\n` : void 0 : \"define\" === t ? `\\n#ifndef HAS_UNIFORM_u_${s}\\nuniform lowp float u_${s}_t;\\nin ${i} ${n} a_${s};\\n#else\\nuniform ${i} ${o} u_${s};\\n#endif\\n` : \"define-instanced\" === t ? \"mat4\" === a ? `\\n#ifdef INSTANCED_ARRAYS\\nin vec4 a_${s}0;\\nin vec4 a_${s}1;\\nin vec4 a_${s}2;\\nin vec4 a_${s}3;\\n#else\\nuniform ${i} ${o} u_${s};\\n#endif\\n` : `\\n#ifdef INSTANCED_ARRAYS\\nin ${i} ${n} a_${s};\\n#else\\nuniform ${i} ${o} u_${s};\\n#endif\\n` : \"initialize-attribute-custom\" === t ? `\\n#ifdef HAS_ATTRIBUTE_a_${s}\\n    ${i} ${o} ${s} = a_${s};\\n#endif\\n` : \"vec4\" === a ? `\\n#ifndef HAS_UNIFORM_u_${s}\\n    ${i} ${o} ${s} = a_${s};\\n#else\\n    ${i} ${o} ${s} = u_${s};\\n#endif\\n` : `\\n#ifndef HAS_UNIFORM_u_${s}\\n    ${i} ${o} ${s} = unpack_mix_${a}(a_${s}, u_${s}_t);\\n#else\\n    ${i} ${o} ${s} = u_${s};\\n#endif\\n`;\n        }),\n        staticAttributes: s,\n        usedDefines: l,\n        vertexIncludes: n,\n        fragmentIncludes: a\n      };\n    }\n    class jo {\n      constructor() {\n        this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;\n      }\n      bind(e, t, i, o, s, r, n, a) {\n        this.context = e;\n        let l = this.boundPaintVertexBuffers.length !== o.length;\n        for (let e = 0; !l && e < o.length; e++) this.boundPaintVertexBuffers[e] !== o[e] && (l = !0);\n        let c = this.boundDynamicVertexBuffers.length !== n.length;\n        for (let e = 0; !c && e < n.length; e++) this.boundDynamicVertexBuffers[e] !== n[e] && (c = !0);\n        if (!this.vao || this.boundProgram !== t || this.boundLayoutVertexBuffer !== i || l || c || this.boundIndexBuffer !== s || this.boundVertexOffset !== r) this.freshBind(t, i, o, s, r, n, a);else {\n          e.bindVertexArrayOES.set(this.vao);\n          for (const i of n) i && (i.bind(), a && i.instanceCount && i.setVertexAttribDivisor(e.gl, t, a));\n          s && s.dynamicDraw && s.bind();\n        }\n      }\n      freshBind(e, t, i, o, s, r, n) {\n        const a = e.numAttributes,\n          l = this.context,\n          c = l.gl;\n        this.vao && this.destroy(), this.vao = l.gl.createVertexArray(), l.bindVertexArrayOES.set(this.vao), this.boundProgram = e, this.boundLayoutVertexBuffer = t, this.boundPaintVertexBuffers = i, this.boundIndexBuffer = o, this.boundVertexOffset = s, this.boundDynamicVertexBuffers = r, t.enableAttributes(c, e), t.bind(), t.setVertexAttribPointers(c, e, s);\n        for (const t of i) t.enableAttributes(c, e), t.bind(), t.setVertexAttribPointers(c, e, s);\n        for (const t of r) t && (t.enableAttributes(c, e), t.bind(), t.setVertexAttribPointers(c, e, s), n && t.instanceCount && t.setVertexAttribDivisor(c, e, n));\n        o && o.bind(), l.currentNumAttributes = a;\n      }\n      destroy() {\n        this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);\n      }\n    }\n    function qo(t, i) {\n      const o = Math.pow(2, i.canonical.z),\n        s = i.canonical.y;\n      return [new e.ac(0, s / o).toLngLat().lat, new e.ac(0, (s + 1) / o).toLngLat().lat];\n    }\n    function Ho(t, i, o, s, r, n, a) {\n      const l = t.context,\n        c = l.gl,\n        h = o.hillshadeFBO;\n      if (!h) return;\n      t.prepareDrawTile();\n      const d = t.isTileAffectedByFog(i),\n        u = t.getOrCreateProgram(\"hillshade\", {\n          overrideFog: d\n        });\n      l.activeTexture.set(c.TEXTURE0), c.bindTexture(c.TEXTURE_2D, h.colorAttachment.get());\n      const _ = ((t, i, o, s) => {\n        const r = o.paint.get(\"hillshade-shadow-color\"),\n          n = \"none\" === o.paint.get(\"hillshade-shadow-color-use-theme\").constantOr(\"default\"),\n          a = o.paint.get(\"hillshade-highlight-color\"),\n          l = \"none\" === o.paint.get(\"hillshade-highlight-color-use-theme\").constantOr(\"default\"),\n          c = o.paint.get(\"hillshade-accent-color\"),\n          h = \"none\" === o.paint.get(\"hillshade-accent-color-use-theme\").constantOr(\"default\"),\n          d = o.paint.get(\"hillshade-emissive-strength\");\n        let u = e.ak(o.paint.get(\"hillshade-illumination-direction\"));\n        if (\"viewport\" === o.paint.get(\"hillshade-illumination-anchor\")) u -= t.transform.angle;else if (t.style && t.style.enable3dLights() && t.style.directionalLight) {\n          const i = t.style.directionalLight.properties.get(\"direction\"),\n            o = e.cc(i.x, i.y, i.z);\n          u = e.ak(o[1]);\n        }\n        const _ = !t.options.moving;\n        return {\n          u_matrix: s || t.transform.calculateProjMatrix(i.tileID.toUnwrapped(), _),\n          u_image: 0,\n          u_latrange: qo(0, i.tileID),\n          u_light: [o.paint.get(\"hillshade-exaggeration\"), u],\n          u_shadow: r.toRenderColor(n ? null : o.lut),\n          u_highlight: a.toRenderColor(l ? null : o.lut),\n          u_emissive_strength: d,\n          u_accent: c.toRenderColor(h ? null : o.lut)\n        };\n      })(t, o, s, t.terrain ? i.projMatrix : null);\n      t.uploadCommonUniforms(l, u, i.toUnwrapped());\n      const {\n        tileBoundsBuffer: p,\n        tileBoundsIndexBuffer: f,\n        tileBoundsSegments: m\n      } = t.getTileBoundsBuffers(o);\n      u.draw(t, c.TRIANGLES, r, n, a, ji.disabled, _, s.id, p, f, m);\n    }\n    function Zo(t, i, o) {\n      if (!i.needsDEMTextureUpload) return;\n      const s = t.context,\n        r = s.gl;\n      s.pixelStoreUnpackPremultiplyAlpha.set(!1), i.demTexture = i.demTexture || t.getTileTexture(o.stride);\n      const n = o.getPixels();\n      i.demTexture ? i.demTexture.update(n, {\n        premultiply: !1\n      }) : i.demTexture = new e.T(s, n, r.R32F, {\n        premultiply: !1\n      }), i.needsDEMTextureUpload = !1;\n    }\n    function Wo(t, i, o) {\n      const s = t.context,\n        r = s.gl;\n      if (!i.dem) return;\n      const n = i.dem;\n      if (s.activeTexture.set(r.TEXTURE1), Zo(t, i, n), !i.demTexture) return;\n      i.demTexture.bind(r.NEAREST, r.CLAMP_TO_EDGE);\n      const a = n.dim;\n      s.activeTexture.set(r.TEXTURE0);\n      let l = i.hillshadeFBO;\n      if (!l) {\n        const t = new e.T(s, {\n          width: a,\n          height: a,\n          data: null\n        }, r.RGBA8);\n        t.bind(r.LINEAR, r.CLAMP_TO_EDGE), l = i.hillshadeFBO = s.createFramebuffer(a, a, !0, \"renderbuffer\"), l.colorAttachment.set(t.texture);\n      }\n      s.bindFramebuffer.set(l.framebuffer), s.viewport.set([0, 0, a, a]);\n      const {\n          tileBoundsBuffer: c,\n          tileBoundsIndexBuffer: h,\n          tileBoundsSegments: d\n        } = t.getMercatorTileBoundsBuffers(),\n        u = [];\n      t.linearFloatFilteringSupported() && u.push(\"TERRAIN_DEM_FLOAT_FORMAT\"), t.getOrCreateProgram(\"hillshadePrepare\", {\n        defines: u\n      }).draw(t, r.TRIANGLES, Bi.disabled, Ui.disabled, ki.unblended, ji.disabled, ((t, i) => {\n        const o = i.stride,\n          s = e.ad.mat4.create();\n        return e.ad.mat4.ortho(s, 0, e.ai, -e.ai, 0, 0, 1), e.ad.mat4.translate(s, s, [0, -e.ai, 0]), {\n          u_matrix: s,\n          u_image: 1,\n          u_dimension: [o, o],\n          u_zoom: t.overscaledZ\n        };\n      })(i.tileID, n), o.id, c, h, d), i.needsHillshadePrepare = !1;\n    }\n    class $o {\n      constructor(e) {\n        this.gl = e.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;\n      }\n      get() {\n        return this.current;\n      }\n      set(e) {}\n      getDefault() {\n        return this.default;\n      }\n      setDefault() {\n        this.set(this.default);\n      }\n    }\n    class Xo extends $o {\n      getDefault() {\n        return e.al.transparent;\n      }\n      set(e) {\n        const t = this.current;\n        (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);\n      }\n    }\n    class Ko extends $o {\n      getDefault() {\n        return 1;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.clearDepth(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class Yo extends $o {\n      getDefault() {\n        return 0;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.clearStencil(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class Jo extends $o {\n      getDefault() {\n        return [!0, !0, !0, !0];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);\n      }\n    }\n    class Qo extends $o {\n      getDefault() {\n        return !0;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.depthMask(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class es extends $o {\n      getDefault() {\n        return 255;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.stencilMask(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class ts extends $o {\n      getDefault() {\n        return {\n          func: this.gl.ALWAYS,\n          ref: 0,\n          mask: 255\n        };\n      }\n      set(e) {\n        const t = this.current;\n        (e.func !== t.func || e.ref !== t.ref || e.mask !== t.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask), this.current = e, this.dirty = !1);\n      }\n    }\n    class is extends $o {\n      getDefault() {\n        const e = this.gl;\n        return [e.KEEP, e.KEEP, e.KEEP];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]), this.current = e, this.dirty = !1);\n      }\n    }\n    class os extends $o {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.current = e, this.dirty = !1;\n      }\n    }\n    class ss extends $o {\n      getDefault() {\n        return [0, 1];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]), this.current = e, this.dirty = !1);\n      }\n    }\n    class rs extends $o {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.DEPTH_TEST) : t.disable(t.DEPTH_TEST), this.current = e, this.dirty = !1;\n      }\n    }\n    class ns extends $o {\n      getDefault() {\n        return this.gl.LESS;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.depthFunc(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class as extends $o {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.BLEND) : t.disable(t.BLEND), this.current = e, this.dirty = !1;\n      }\n    }\n    class ls extends $o {\n      getDefault() {\n        const e = this.gl;\n        return [e.ONE, e.ZERO, e.ONE, e.ZERO];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.blendFuncSeparate(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);\n      }\n    }\n    class cs extends $o {\n      getDefault() {\n        return e.al.transparent;\n      }\n      set(e) {\n        const t = this.current;\n        (e.r !== t.r || e.g !== t.g || e.b !== t.b || e.a !== t.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a), this.current = e, this.dirty = !1);\n      }\n    }\n    class hs extends $o {\n      getDefault() {\n        return this.gl.FUNC_ADD;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.blendEquationSeparate(e, e), this.current = e, this.dirty = !1);\n      }\n    }\n    class ds extends $o {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        e ? t.enable(t.CULL_FACE) : t.disable(t.CULL_FACE), this.current = e, this.dirty = !1;\n      }\n    }\n    class us extends $o {\n      getDefault() {\n        return this.gl.BACK;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.cullFace(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class _s extends $o {\n      getDefault() {\n        return this.gl.CCW;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.frontFace(e), this.current = e, this.dirty = !1);\n      }\n    }\n    let ps = class extends $o {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.useProgram(e), this.current = e, this.dirty = !1);\n      }\n    };\n    class fs extends $o {\n      getDefault() {\n        return this.gl.TEXTURE0;\n      }\n      set(e) {\n        (e !== this.current || this.dirty) && (this.gl.activeTexture(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class ms extends $o {\n      getDefault() {\n        const e = this.gl;\n        return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight];\n      }\n      set(e) {\n        const t = this.current;\n        (e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]), this.current = e, this.dirty = !1);\n      }\n    }\n    class gs extends $o {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindFramebuffer(t.FRAMEBUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class vs extends $o {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindRenderbuffer(t.RENDERBUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class ys extends $o {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindTexture(t.TEXTURE_2D, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class xs extends $o {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.bindBuffer(t.ARRAY_BUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class bs extends $o {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        const t = this.gl;\n        t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class ws extends $o {\n      getDefault() {\n        return null;\n      }\n      set(e) {\n        this.gl && (e !== this.current || this.dirty) && (this.gl.bindVertexArray(e), this.current = e, this.dirty = !1);\n      }\n    }\n    class Ts extends $o {\n      getDefault() {\n        return 4;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.pixelStorei(t.UNPACK_ALIGNMENT, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class Es extends $o {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class Ss extends $o {\n      getDefault() {\n        return !1;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        const t = this.gl;\n        t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class Cs extends $o {\n      constructor(e, t) {\n        super(e), this.context = e, this.parent = t;\n      }\n      getDefault() {\n        return null;\n      }\n    }\n    class Is extends Cs {\n      setDirty() {\n        this.dirty = !0;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        this.context.bindFramebuffer.set(this.parent);\n        const t = this.gl;\n        t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;\n      }\n    }\n    class Rs extends Cs {\n      attachment() {\n        return this.gl.DEPTH_ATTACHMENT;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        this.context.bindFramebuffer.set(this.parent);\n        const t = this.gl;\n        t.framebufferRenderbuffer(t.FRAMEBUFFER, this.attachment(), t.RENDERBUFFER, e), this.current = e, this.dirty = !1;\n      }\n    }\n    class Ds extends Cs {\n      attachment() {\n        return this.gl.DEPTH_ATTACHMENT;\n      }\n      set(e) {\n        if (e === this.current && !this.dirty) return;\n        this.context.bindFramebuffer.set(this.parent);\n        const t = this.gl;\n        t.framebufferTexture2D(t.FRAMEBUFFER, this.attachment(), t.TEXTURE_2D, e, 0), this.current = e, this.dirty = !1;\n      }\n    }\n    class As extends Rs {\n      attachment() {\n        return this.gl.DEPTH_STENCIL_ATTACHMENT;\n      }\n    }\n    const Ls = (e, t, i) => ({\n        u_matrix: e,\n        u_image0: 0,\n        u_skirt_height: t,\n        u_ground_shadow_factor: i\n      }),\n      Ms = (e, t, i, o, s, r, n, a, l, c, h, d, u, _, p, f) => ({\n        u_proj_matrix: Float32Array.from(e),\n        u_globe_matrix: t,\n        u_normalize_matrix: Float32Array.from(o),\n        u_merc_matrix: i,\n        u_zoom_transition: s,\n        u_merc_center: r,\n        u_image0: 0,\n        u_frustum_tl: n,\n        u_frustum_tr: a,\n        u_frustum_br: l,\n        u_frustum_bl: c,\n        u_globe_pos: h,\n        u_globe_radius: d,\n        u_viewport: u,\n        u_grid_matrix: f ? Float32Array.from(f) : new Float32Array(9),\n        u_skirt_height: _,\n        u_far_z_cutoff: p\n      });\n    function Ps(e, t) {\n      return null != e && null != t && !(!e.hasData() || !t.hasData()) && null != e.demTexture && null != t.demTexture && e.tileID.key !== t.tileID.key;\n    }\n    const zs = new class {\n        constructor() {\n          this.operations = {};\n        }\n        newMorphing(e, t, i, o, s) {\n          if (e in this.operations) {\n            const t = this.operations[e];\n            t.to.tileID.key !== i.tileID.key && (t.queued = i);\n          } else this.operations[e] = {\n            startTime: o,\n            phase: 0,\n            duration: s,\n            from: t,\n            to: i,\n            queued: null\n          };\n        }\n        getMorphValuesForProxy(e) {\n          if (!(e in this.operations)) return null;\n          const t = this.operations[e];\n          return {\n            from: t.from,\n            to: t.to,\n            phase: t.phase\n          };\n        }\n        update(e) {\n          for (const t in this.operations) {\n            const i = this.operations[t];\n            for (i.phase = (e - i.startTime) / i.duration; i.phase >= 1 || !this._validOp(i);) if (!this._nextOp(i, e)) {\n              delete this.operations[t];\n              break;\n            }\n          }\n        }\n        _nextOp(e, t) {\n          return !!e.queued && (e.from = e.to, e.to = e.queued, e.queued = null, e.phase = 0, e.startTime = t, !0);\n        }\n        _validOp(e) {\n          return e.from.hasData() && e.to.hasData();\n        }\n      }(),\n      Os = {\n        0: null,\n        1: \"TERRAIN_VERTEX_MORPHING\"\n      };\n    function Fs(e, t, i) {\n      if (0 === t) return 0;\n      const o = t < 1 && 514 === i ? .25 / t : 1;\n      return 6 * Math.pow(1.5, 22 - e) * Math.max(t, 1) * o;\n    }\n    function ks(e, t) {\n      const i = 1 << e.z;\n      return !t && (0 === e.x || e.x === i - 1) || 0 === e.y || e.y === i - 1;\n    }\n    const Bs = e => ({\n      u_matrix: e\n    });\n    function Ns(t, i, o, s, r) {\n      if (r > 0) {\n        const n = e.q.now(),\n          a = (n - t.timeAdded) / r,\n          l = i ? (n - i.timeAdded) / r : -1,\n          c = o.getSource(),\n          h = s.coveringZoomLevel({\n            tileSize: c.tileSize,\n            roundZoom: c.roundZoom\n          }),\n          d = !i || Math.abs(i.tileID.overscaledZ - h) > Math.abs(t.tileID.overscaledZ - h),\n          u = d && t.refreshedUponExpiration ? 1 : e.ay(d ? a : 1 - l, 0, 1);\n        return t.refreshedUponExpiration && a >= 1 && (t.refreshedUponExpiration = !1), i ? {\n          opacity: 1,\n          mix: 1 - u\n        } : {\n          opacity: u,\n          mix: 0\n        };\n      }\n      return {\n        opacity: 1,\n        mix: 0\n      };\n    }\n    class Us extends St {\n      constructor(t) {\n        const i = {\n            type: \"raster-dem\",\n            maxzoom: t.transform.maxZoom\n          },\n          o = new e.D(e.cj(), null),\n          s = rt(\"mock-dem\", i, o, t.style);\n        super(\"mock-dem\", s, !1), s.setEventedParent(this), this._sourceLoaded = !0;\n      }\n      _loadTile(e, t) {\n        e.state = \"loaded\", t(null);\n      }\n    }\n    class Vs extends St {\n      constructor(t) {\n        const i = rt(\"proxy\", {\n          type: \"geojson\",\n          maxzoom: t.transform.maxZoom\n        }, new e.D(e.cj(), null), t.style);\n        super(\"proxy\", i, !1), i.setEventedParent(this), this.map = this.getSource().map = t, this.used = this._sourceLoaded = !0, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};\n      }\n      update(e, t, i) {\n        if (e.freezeTileCoverage) return;\n        this.transform = e;\n        const o = e.coveringTiles({\n          tileSize: this._source.tileSize,\n          minzoom: this._source.minzoom,\n          maxzoom: this._source.maxzoom,\n          roundZoom: this._source.roundZoom,\n          reparseOverscaled: this._source.reparseOverscaled\n        }).reduce((t, i) => {\n          if (t[i.key] = \"\", !this._tiles[i.key]) {\n            const t = new bt(i, this._source.tileSize * i.overscaleFactor(), e.tileZoom);\n            t.state = \"loaded\", this._tiles[i.key] = t;\n          }\n          return t;\n        }, {});\n        for (const e in this._tiles) e in o || (this.freeFBO(e), this._tiles[e].unloadVectorData(), delete this._tiles[e]);\n      }\n      freeFBO(e) {\n        const t = this.proxyCachedFBO[e];\n        if (void 0 !== t) {\n          const i = Object.values(t);\n          this.renderCachePool.push(...i), delete this.proxyCachedFBO[e];\n        }\n      }\n      deallocRenderCache() {\n        this.renderCache.forEach(e => e.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};\n      }\n    }\n    class Gs extends e.aH {\n      constructor(e, t, i) {\n        super(e.overscaledZ, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y), this.proxyTileKey = t, this.projMatrix = i;\n      }\n    }\n    class js extends e.cK {\n      constructor(t, i) {\n        super(), this._debugParams = {\n          sortTilesHiZFirst: !0,\n          disableRenderCache: !1\n        }, t.tp.registerParameter(this._debugParams, [\"Terrain\"], \"sortTilesHiZFirst\", {}, () => {\n          this._style.map.triggerRepaint();\n        }), t.tp.registerParameter(this._debugParams, [\"Terrain\"], \"disableRenderCache\", {}, () => {\n          this._style.map.triggerRepaint();\n        }), t.tp.registerButton([\"Terrain\"], \"Invalidate Render Cache\", () => {\n          this.invalidateRenderCache = !0, this._style.map.triggerRepaint();\n        }), this.painter = t, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};\n        const [o, s, r] = function (t) {\n            const i = new e.b5(),\n              o = new e.aV(),\n              s = 131;\n            i.reserve(17161), o.reserve(33800);\n            const r = e.ai / 128,\n              n = e.ai + r / 2,\n              a = n + r;\n            for (let t = -r; t < a; t += r) for (let o = -r; o < a; o += r) {\n              const s = o < 0 || o > n || t < 0 || t > n ? 24575 : 0,\n                r = e.ay(Math.round(o), 0, e.ai),\n                a = e.ay(Math.round(t), 0, e.ai);\n              i.emplaceBack(r + s, a);\n            }\n            const l = (e, t) => {\n              const i = t * s + e;\n              o.emplaceBack(i + 1, i, i + s), o.emplaceBack(i + s, i + s + 1, i + 1);\n            };\n            for (let e = 1; e < 129; e++) for (let t = 1; t < 129; t++) l(t, e);\n            return [0, 129].forEach(e => {\n              for (let t = 0; t < 130; t++) l(t, e), l(e, t);\n            }), [i, o, 32768];\n          }(),\n          n = t.context;\n        this.gridBuffer = n.createVertexBuffer(o, e.b7.members), this.gridIndexBuffer = n.createIndexBuffer(s), this.gridSegments = e.b8.simpleSegment(0, 0, o.length, s.length), this.gridNoSkirtSegments = e.b8.simpleSegment(0, 0, o.length, r), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Vs(i.map), this.orthoMatrix = e.ad.mat4.create(), e.ad.mat4.ortho(this.orthoMatrix, \"globe\" === this.painter.transform.projection.name ? .015 : 0, e.ai, 0, e.ai, 0, 1);\n        const a = n.gl;\n        this._overlapStencilMode = new Ui({\n          func: a.GEQUAL,\n          mask: 255\n        }, 0, 255, a.KEEP, a.KEEP, a.REPLACE), this._previousZoom = t.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i, this._useVertexMorphing = !0, this._exaggeration = 1, this._mockSourceCache = new Us(i.map), this._pendingGroundEffectLayers = [];\n      }\n      set style(e) {\n        e.on(\"data\", this._onStyleDataEvent.bind(this)), this._style = e, this._style.map.on(\"moveend\", () => {\n          this._clearLineLayersFromRenderCache();\n        });\n      }\n      update(t, i, o) {\n        if (t && t.terrain) {\n          this._style !== t && (this.style = t, this._evaluationZoom = void 0);\n          const s = t.terrain.properties,\n            r = 0 === t.terrain.drapeRenderMode,\n            n = t.terrain.isZoomDependent();\n          this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = e.q.now();\n          const a = t.terrain && t.terrain.scope,\n            l = s.get(\"source\"),\n            c = r ? this._mockSourceCache : t.getSourceCache(l, a);\n          if (!c) return void e.w(`Couldn't find terrain source \"${l}\".`);\n          if (this.sourceCache = c, this._attenuationRange = t.terrain.getAttenuationRange(), this._exaggeration = n ? this.calculateExaggeration(i) : s.get(\"exaggeration\"), !i.projection.requiresDraping && n && 0 === this._exaggeration) return void this._disable();\n          this.enabled = !0;\n          const h = () => {\n            this.sourceCache.used && e.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.\\nThis leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);\n            const t = this.getScaledDemTileSize();\n            this.sourceCache.update(i, t, !0), this.resetTileLookupCache(this.sourceCache.id);\n          };\n          this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = !0, h(), this._initializing = !0), h(), i.updateElevation(!0, o), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i), this._emptyDEMTextureDirty = !0, this._previousZoom = i.zoom;\n        } else this._disable();\n      }\n      calculateExaggeration(t) {\n        if (this._attenuationRange && t.zoom >= Math.ceil(this._attenuationRange[1])) return this._style.terrain.getExaggeration(t.zoom);\n        const i = this._previousCameraAltitude,\n          o = t.getFreeCameraOptions().position.z / t.pixelsPerMeter * t.worldSize;\n        this._previousCameraAltitude = o;\n        const s = null != i ? o - i : Number.MAX_VALUE;\n        if (Math.abs(s) < 2) return this._exaggeration;\n        const r = t.zoom,\n          n = this._style.terrain;\n        if (!this._previousUpdateTimestamp) return n.getExaggeration(r);\n        let a = r - this._previousZoom;\n        const l = this._previousUpdateTimestamp;\n        let c = r;\n        null != this._evaluationZoom && (c = this._evaluationZoom, Math.abs(r - c) > .5 && (a = .5 * (r - c + a)), a * s < 0 && (c += a)), this._evaluationZoom = c;\n        const h = n.getExaggeration(c),\n          d = h === n.getExaggeration(Math.max(0, c - .1));\n        if (d && Math.abs(h - this._exaggeration) < .01) return h;\n        let u = Math.min(.1, .00375 * (this._updateTimestamp - l));\n        return (d || h < .1 || Math.abs(a) < 1e-4) && (u = Math.min(.2, 4 * u)), e.ah(this._exaggeration, h, u);\n      }\n      resetTileLookupCache(e) {\n        this._findCoveringTileCache[e] = {};\n      }\n      attenuationRange() {\n        return this._attenuationRange;\n      }\n      getDemUpscale() {\n        return this.proxySourceCache.getSource().tileSize / 128;\n      }\n      getScaledDemTileSize() {\n        return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;\n      }\n      _onStyleDataEvent(e) {\n        e.coord && \"source\" === e.dataType ? this._clearRenderCacheForTile(e.sourceCacheId, e.coord) : \"style\" === e.dataType && (this.invalidateRenderCache = !0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);\n      }\n      _disable() {\n        if (this.enabled && (this.enabled = !1, this._emptyDEMTextureDirty = !0, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const e in this._style._mergedSourceCaches) this._style._mergedSourceCaches[e].usedForTerrain = !1;\n      }\n      destroy() {\n        this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this.pool.forEach(e => e.fb.destroy()), this.pool = [], this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();\n      }\n      _source() {\n        return this.enabled ? this.sourceCache : null;\n      }\n      isUsingMockSource() {\n        return this.sourceCache === this._mockSourceCache;\n      }\n      exaggeration() {\n        return this.enabled ? this._exaggeration : 0;\n      }\n      get visibleDemTiles() {\n        return this._visibleDemTiles;\n      }\n      get drapeBufferSize() {\n        const e = 2 * this.proxySourceCache.getSource().tileSize;\n        return [e, e];\n      }\n      set useVertexMorphing(e) {\n        this._useVertexMorphing = e;\n      }\n      updateTileBinding(t) {\n        if (!this.enabled) return;\n        this.prevTerrainTileForTile = this.terrainTileForTile;\n        const i = this.proxySourceCache,\n          o = this.painter.transform;\n        this._initializing && (this._initializing = 0 === o._centerAltitude && -1 === this.getAtPointOrZero(e.ac.fromLngLat(o.center), -1), this._emptyDEMTextureDirty = !this._initializing);\n        const s = this.proxyCoords = i.getIds().map(e => {\n          const t = i.getTileByID(e).tileID;\n          return t.projMatrix = o.calculateProjMatrix(t.toUnwrapped()), t;\n        });\n        !function (t, i) {\n          const o = i.transform.pointCoordinate(i.transform.getCameraPoint()),\n            s = new e.P(o.x, o.y);\n          t.sort((t, i) => {\n            if (i.overscaledZ - t.overscaledZ) return i.overscaledZ - t.overscaledZ;\n            const o = new e.P(t.canonical.x + (1 << t.canonical.z) * t.wrap, t.canonical.y),\n              r = new e.P(i.canonical.x + (1 << i.canonical.z) * i.wrap, i.canonical.y),\n              n = s.mult(1 << t.canonical.z);\n            return n.x -= .5, n.y -= .5, n.distSqr(o) - n.distSqr(r);\n          });\n        }(s, this.painter);\n        const r = this.proxyToSource || {};\n        this.proxyToSource = {}, s.forEach(e => {\n          this.proxyToSource[e.key] = {};\n        }), this.terrainTileForTile = {};\n        const n = this._style._mergedSourceCaches;\n        for (const e in n) {\n          const i = n[e];\n          if (!i.used) continue;\n          if (i !== this.sourceCache && this.resetTileLookupCache(i.id), this._setupProxiedCoordsForOrtho(i, t[e], r), i.usedForTerrain) continue;\n          const o = t[e];\n          i.getSource().reparseOverscaled && this._assignTerrainTiles(o);\n        }\n        this.proxiedCoords[i.id] = s.map(e => new Gs(e, e.key, this.orthoMatrix)), this._assignTerrainTiles(s), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(r), this.renderingToTexture = !1;\n        const a = {};\n        this._visibleDemTiles = [];\n        for (const e of this.proxyCoords) {\n          const t = this.terrainTileForTile[e.key];\n          if (!t) continue;\n          const i = t.tileID.key;\n          i in a || (this._visibleDemTiles.push(t), a[i] = i);\n        }\n      }\n      _assignTerrainTiles(e) {\n        this._initializing || e.forEach(e => {\n          if (this.terrainTileForTile[e.key]) return;\n          const t = this._findTileCoveringTileID(e, this.sourceCache);\n          t && (this.terrainTileForTile[e.key] = t);\n        });\n      }\n      _prepareDEMTextures() {\n        const e = this.painter.context,\n          t = e.gl;\n        for (const i in this.terrainTileForTile) {\n          const o = this.terrainTileForTile[i],\n            s = o.dem;\n          !s || o.demTexture && !o.needsDEMTextureUpload || (e.activeTexture.set(t.TEXTURE1), Zo(this.painter, o, s));\n        }\n      }\n      _prepareDemTileUniforms(e, t, i, o) {\n        if (!t || null == t.demTexture) return !1;\n        const s = e.tileID.canonical,\n          r = Math.pow(2, t.tileID.canonical.z - s.z),\n          n = o || \"\";\n        return i[`u_dem_tl${n}`] = [s.x * r % 1, s.y * r % 1], i[`u_dem_scale${n}`] = r, !0;\n      }\n      get emptyDEMTexture() {\n        return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();\n      }\n      _getLoadedAreaMinimum() {\n        if (!this.enabled) return 0;\n        let e = 0;\n        const t = this._visibleDemTiles.reduce((t, i) => {\n          if (!i.dem) return t;\n          const o = i.dem.tree.minimums[0];\n          return o > 0 && e++, t + o;\n        }, 0);\n        return e ? t / e : 0;\n      }\n      _updateEmptyDEMTexture() {\n        const t = this.painter.context,\n          i = t.gl;\n        t.activeTexture.set(i.TEXTURE2);\n        const o = this._getLoadedAreaMinimum(),\n          s = new e.cL({\n            width: 1,\n            height: 1\n          }, new Float32Array([o]));\n        this._emptyDEMTextureDirty = !1;\n        let r = this._emptyDEMTexture;\n        return r ? r.update(s, {\n          premultiply: !1\n        }) : r = this._emptyDEMTexture = new e.T(t, s, i.R32F, {\n          premultiply: !1\n        }), r;\n      }\n      setupElevationDraw(t, i, o) {\n        const s = this.painter.context,\n          r = s.gl,\n          n = {\n            u_dem: 2,\n            u_dem_prev: 4,\n            u_dem_tl: [0, 0],\n            u_dem_tl_prev: [0, 0],\n            u_dem_scale: 0,\n            u_dem_scale_prev: 0,\n            u_dem_size: 0,\n            u_dem_lerp: 1,\n            u_depth: 3,\n            u_depth_size_inv: [0, 0],\n            u_depth_range_unpack: [0, 1],\n            u_occluder_half_size: 16,\n            u_occlusion_depth_offset: -1e-4,\n            u_exaggeration: 0\n          };\n        n.u_exaggeration = this.exaggeration();\n        let a = null,\n          l = null,\n          c = 1;\n        if (o && o.morphing && this._useVertexMorphing) {\n          const e = o.morphing.srcDemTile,\n            i = o.morphing.dstDemTile;\n          c = o.morphing.phase, e && i && (this._prepareDemTileUniforms(t, e, n, \"_prev\") && (l = e), this._prepareDemTileUniforms(t, i, n) && (a = i));\n        }\n        const h = e => e && e.demTexture && this.painter.linearFloatFilteringSupported() ? r.LINEAR : r.NEAREST;\n        let d = null;\n        var u;\n        if (this.enabled ? l && a ? (d = a.demTexture, s.activeTexture.set(r.TEXTURE4), l.demTexture.bind(h(l), r.CLAMP_TO_EDGE), n.u_dem_lerp = c) : (a = this.terrainTileForTile[t.tileID.key], d = this._prepareDemTileUniforms(t, a, n) ? a.demTexture : this.emptyDEMTexture) : d = this.emptyDEMTexture, s.activeTexture.set(r.TEXTURE2), d && (n.u_dem_size = 1 === (u = d).size[0] ? 1 : u.size[0] - 2, d.bind(h(a), r.CLAMP_TO_EDGE)), this.painter.setupDepthForOcclusion(o && o.useDepthForOcclusion, i, n), o && o.useMeterToDem && a) {\n          const t = (1 << a.tileID.canonical.z) * e.bH(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;\n          n.u_meter_to_dem = t;\n        }\n        if (o && o.labelPlaneMatrixInv && (n.u_label_plane_matrix_inv = o.labelPlaneMatrixInv), i.setTerrainUniformValues(s, n), \"globe\" === this.painter.transform.projection.name) {\n          const e = this.globeUniformValues(this.painter.transform, t.tileID.canonical, o && o.useDenormalizedUpVectorScale);\n          i.setGlobeUniformValues(s, e);\n        }\n      }\n      globeUniformValues(t, i, o) {\n        const s = t.projection;\n        return {\n          u_tile_tl_up: s.upVector(i, 0, 0),\n          u_tile_tr_up: s.upVector(i, e.ai, 0),\n          u_tile_br_up: s.upVector(i, e.ai, e.ai),\n          u_tile_bl_up: s.upVector(i, 0, e.ai),\n          u_tile_up_scale: o ? e.cM(1) : s.upVectorScale(i, t.center.lat, t.worldSize).metersToTile\n        };\n      }\n      renderToBackBuffer(t) {\n        const i = this.painter,\n          o = this.painter.context;\n        0 !== t.length && (o.bindFramebuffer.set(null), o.viewport.set([0, 0, i.width, i.height]), i.gpuTimingDeferredRenderStart(), this.renderingToTexture = !1, function (t, i, o, s, r) {\n          if (\"globe\" === t.transform.projection.name) !function (t, i, o, s, r) {\n            const n = t.context,\n              a = n.gl;\n            let l, c;\n            const h = t.transform,\n              d = e.cD(t, n, h),\n              u = (e, i) => {\n                if (c === i) return;\n                const o = [Os[i], \"PROJECTION_GLOBE_VIEW\"];\n                d && o.push(\"CUSTOM_ANTIALIASING\");\n                const s = t.isTileAffectedByFog(e);\n                l = t.getOrCreateProgram(\"globeRaster\", {\n                  defines: o,\n                  overrideFog: s\n                }), c = i;\n              },\n              _ = t.colorModeForRenderPass(),\n              p = new Bi(a.LEQUAL, Bi.ReadWrite, t.depthRangeFor3D);\n            zs.update(r);\n            const f = e.cE(h),\n              m = [e.av(h.center.lng), e.aC(h.center.lat)],\n              g = t.globeSharedBuffers,\n              v = [h.width * e.q.devicePixelRatio, h.height * e.q.devicePixelRatio],\n              y = Float32Array.from(h.globeMatrix),\n              x = {\n                useDenormalizedUpVectorScale: !0\n              };\n            {\n              const h = t.transform,\n                d = Fs(h.zoom, i.exaggeration(), i.sourceCache._source.tileSize);\n              c = -1;\n              const b = a.TRIANGLES;\n              for (const c of s) {\n                const s = o.getTile(c),\n                  w = Ui.disabled,\n                  T = i.prevTerrainTileForTile[c.key],\n                  E = i.terrainTileForTile[c.key];\n                Ps(T, E) && zs.newMorphing(c.key, T, E, r, 250), n.activeTexture.set(a.TEXTURE0), s.texture && s.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);\n                const S = zs.getMorphValuesForProxy(c.key),\n                  C = S ? 1 : 0;\n                S && e.L(x, {\n                  morphing: {\n                    srcDemTile: S.from,\n                    dstDemTile: S.to,\n                    phase: e.cC(S.phase)\n                  }\n                });\n                const I = e.cF(c.canonical),\n                  R = e.cG(I.getCenter().lat),\n                  D = e.cH(c.canonical, I, R, h.worldSize / h._pixelsPerMercatorPixel),\n                  A = e.bc(e.cI(c.canonical)),\n                  L = Ms(h.expandedFarZProjMatrix, y, f, A, e.ag(h.zoom), m, h.frustumCorners.TL, h.frustumCorners.TR, h.frustumCorners.BR, h.frustumCorners.BL, h.globeCenterInViewSpace, h.globeRadius, v, d, h._farZ, D);\n                if (u(c, C), l && (i.setupElevationDraw(s, l, x), t.uploadCommonUniforms(n, l, c.toUnwrapped()), g)) {\n                  const [e, i, o] = g.getGridBuffers(R, 0 !== d);\n                  l.draw(t, b, p, w, _, ji.backCCW, L, \"globe_raster\", e, i, o);\n                }\n              }\n            }\n            if (g && (t.renderDefaultNorthPole || t.renderDefaultSouthPole)) {\n              const r = [\"GLOBE_POLES\", \"PROJECTION_GLOBE_VIEW\"];\n              d && r.push(\"CUSTOM_ANTIALIASING\"), l = t.getOrCreateProgram(\"globeRaster\", {\n                defines: r\n              });\n              for (const r of s) {\n                const {\n                    x: s,\n                    y: c,\n                    z: d\n                  } = r.canonical,\n                  u = 0 === c,\n                  f = c === (1 << d) - 1,\n                  [y, b, w, T] = g.getPoleBuffers(d, !1);\n                if (T && (u || f)) {\n                  const c = o.getTile(r);\n                  n.activeTexture.set(a.TEXTURE0), c.texture && c.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);\n                  let g = e.cJ(d, s, h);\n                  const E = e.bc(e.cI(r.canonical)),\n                    S = (e, i) => e.draw(t, a.TRIANGLES, p, Ui.disabled, _, ji.disabled, Ms(h.expandedFarZProjMatrix, g, g, E, 0, m, h.frustumCorners.TL, h.frustumCorners.TR, h.frustumCorners.BR, h.frustumCorners.BL, h.globeCenterInViewSpace, h.globeRadius, v, 0, h._farZ), \"globe_pole_raster\", i, w, T);\n                  i.setupElevationDraw(c, l, x), t.uploadCommonUniforms(n, l, r.toUnwrapped()), u && t.renderDefaultNorthPole && S(l, y), f && t.renderDefaultSouthPole && (g = e.ad.mat4.scale(e.ad.mat4.create(), g, [1, -1, 1]), S(l, b));\n                }\n              }\n            }\n          }(t, i, o, s, r);else {\n            const n = t.context,\n              a = n.gl;\n            let l, c;\n            const h = t.shadowRenderer,\n              d = Qi(t, t.longestCutoffRange),\n              u = e => {\n                if (c === e) return;\n                const i = [];\n                i.push(Os[e]), d.shouldRenderCutoff && i.push(\"RENDER_CUTOFF\"), h && (i.push(\"RENDER_SHADOWS\", \"DEPTH_TEXTURE\"), h.useNormalOffset && i.push(\"NORMAL_OFFSET\")), l = t.getOrCreateProgram(\"terrainRaster\", {\n                  defines: i\n                }), c = e;\n              },\n              _ = t.colorModeForRenderPass(),\n              p = new Bi(a.LEQUAL, Bi.ReadWrite, t.depthRangeFor3D);\n            zs.update(r);\n            const f = t.transform,\n              m = Fs(f.zoom, i.exaggeration(), i.sourceCache._source.tileSize);\n            let g = [0, 0, 0];\n            if (h) {\n              const e = t.style.directionalLight,\n                i = t.style.ambientLight;\n              e && i && (g = no(t.style, e, i));\n            }\n            {\n              c = -1;\n              const v = a.TRIANGLES,\n                [y, x] = [i.gridIndexBuffer, i.gridSegments];\n              for (const c of s) {\n                const s = o.getTile(c),\n                  b = Ui.disabled,\n                  w = i.prevTerrainTileForTile[c.key],\n                  T = i.terrainTileForTile[c.key];\n                Ps(w, T) && zs.newMorphing(c.key, w, T, r, 250), n.activeTexture.set(a.TEXTURE0), s.texture && s.texture.bind(a.LINEAR, a.CLAMP_TO_EDGE);\n                const E = zs.getMorphValuesForProxy(c.key),\n                  S = E ? 1 : 0;\n                let C;\n                E && (C = {\n                  morphing: {\n                    srcDemTile: E.from,\n                    dstDemTile: E.to,\n                    phase: e.cC(E.phase)\n                  }\n                });\n                const I = Ls(c.projMatrix, ks(c.canonical, f.renderWorldCopies) ? m / 10 : m, g);\n                if (u(S), !l) continue;\n                i.setupElevationDraw(s, l, C);\n                const R = c.toUnwrapped();\n                h && h.setupShadows(R, l), t.uploadCommonUniforms(n, l, R, null, d), l.draw(t, v, p, b, _, ji.backCCW, I, \"terrain_raster\", i.gridBuffer, y, x);\n              }\n            }\n          }\n        }(i, this, this.proxySourceCache, t, this._updateTimestamp), this.renderingToTexture = !0, i.gpuTimingDeferredRenderEnd(), t.splice(0, t.length));\n      }\n      renderBatch(t) {\n        if (0 === this._drapedRenderBatches.length) return t + 1;\n        this.renderingToTexture = !0;\n        const i = this.painter,\n          o = this.painter.context,\n          s = this.proxySourceCache,\n          r = this.proxiedCoords[s.id],\n          n = this._drapedRenderBatches.shift(),\n          a = i.style.order,\n          l = [];\n        let c = 0;\n        for (const h of r) {\n          const r = s.getTileByID(h.proxyTileKey),\n            d = s.proxyCachedFBO[h.key] ? s.proxyCachedFBO[h.key][t] : void 0,\n            u = void 0 !== d ? s.renderCache[d] : this.pool[c++],\n            _ = void 0 !== d;\n          if (r.texture = u.tex, _ && !u.dirty) {\n            l.push(r.tileID);\n            continue;\n          }\n          let p;\n          o.bindFramebuffer.set(u.fb.framebuffer), this.renderedToTile = !1, u.dirty && (o.clear({\n            color: e.al.transparent,\n            stencil: 0\n          }), u.dirty = !1);\n          for (let e = n.start; e <= n.end; ++e) {\n            const t = i.style._mergedLayers[a[e]];\n            if (t.isHidden(i.transform.zoom)) continue;\n            const s = i.style.getLayerSourceCache(t),\n              r = s ? this.proxyToSource[h.key][s.id] : [h];\n            if (!r) continue;\n            const n = r;\n            o.viewport.set([0, 0, u.fb.width, u.fb.height]), p !== (s ? s.id : null) && (this._setupStencil(u, r, t, s), p = s ? s.id : null), i.renderLayer(i, s, t, n);\n          }\n          if (0 === this._drapedRenderBatches.length) for (const e of this._pendingGroundEffectLayers) {\n            const t = i.style._mergedLayers[a[e]];\n            if (t.isHidden(i.transform.zoom)) continue;\n            const s = i.style.getLayerSourceCache(t),\n              r = s ? this.proxyToSource[h.key][s.id] : [h];\n            if (!r) continue;\n            const n = r;\n            o.viewport.set([0, 0, u.fb.width, u.fb.height]), p !== (s ? s.id : null) && (this._setupStencil(u, r, t, s), p = s ? s.id : null), i.renderLayer(i, s, t, n);\n          }\n          this.renderedToTile ? (u.dirty = !0, l.push(r.tileID)) : _ || --c, 5 === c && (c = 0, this.renderToBackBuffer(l));\n        }\n        return this.renderToBackBuffer(l), this.renderingToTexture = !1, o.bindFramebuffer.set(null), o.viewport.set([0, 0, i.width, i.height]), n.end + 1;\n      }\n      postRender() {}\n      isLayerOrderingCorrect(e) {\n        const t = e.order.length;\n        let i = -1,\n          o = t;\n        for (let s = 0; s < t; ++s) this._style.isLayerDraped(e._mergedLayers[e.order[s]]) ? i = Math.max(i, s) : o = Math.min(o, s);\n        return o > i;\n      }\n      getMinElevationBelowMSL() {\n        let e = 0;\n        return this._visibleDemTiles.filter(e => e.dem).forEach(t => {\n          e = Math.min(e, t.dem.tree.minimums[0]);\n        }), 0 === e ? e : (e - 30) * this._exaggeration;\n      }\n      raycast(e, t, i) {\n        if (!this._visibleDemTiles) return null;\n        const o = this._visibleDemTiles.filter(e => e.dem).map(o => {\n          const s = o.tileID,\n            r = 1 << s.overscaledZ,\n            {\n              x: n,\n              y: a\n            } = s.canonical,\n            l = n / r,\n            c = (n + 1) / r,\n            h = a / r,\n            d = (a + 1) / r;\n          return {\n            minx: l,\n            miny: h,\n            maxx: c,\n            maxy: d,\n            t: o.dem.tree.raycastRoot(l, h, c, d, e, t, i),\n            tile: o\n          };\n        });\n        o.sort((e, t) => (null !== e.t ? e.t : Number.MAX_VALUE) - (null !== t.t ? t.t : Number.MAX_VALUE));\n        for (const s of o) {\n          if (null == s.t) return null;\n          const o = s.tile.dem.tree.raycast(s.minx, s.miny, s.maxx, s.maxy, e, t, i);\n          if (null != o) return o;\n        }\n        return null;\n      }\n      _createFBO() {\n        const t = this.painter.context,\n          i = t.gl,\n          o = this.drapeBufferSize;\n        t.activeTexture.set(i.TEXTURE0);\n        const s = new e.T(t, {\n          width: o[0],\n          height: o[1],\n          data: null\n        }, i.RGBA8);\n        s.bind(i.LINEAR, i.CLAMP_TO_EDGE);\n        const r = t.createFramebuffer(o[0], o[1], !0, null);\n        return r.colorAttachment.set(s.texture), r.depthAttachment = new As(t, r.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t.createRenderbuffer(t.gl.DEPTH_STENCIL, o[0], o[1]), this._stencilRef = 0, r.depthAttachment.set(this._sharedDepthStencil), t.clear({\n          stencil: 0\n        })) : r.depthAttachment.set(this._sharedDepthStencil), t.extTextureFilterAnisotropic && i.texParameterf(i.TEXTURE_2D, t.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t.extTextureFilterAnisotropicMax), {\n          fb: r,\n          tex: s,\n          dirty: !1\n        };\n      }\n      _initFBOPool() {\n        for (; this.pool.length < Math.min(5, this.proxyCoords.length);) this.pool.push(this._createFBO());\n      }\n      _shouldDisableRenderCache() {\n        if (this._debugParams.disableRenderCache) return !0;\n        if (this._style.hasLightTransitions()) return !0;\n        for (const e in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[e].hasTransition()) return !0;\n        return this._style.order.some(e => {\n          const t = this._style._mergedLayers[e],\n            i = t.isHidden(this.painter.transform.zoom);\n          return \"hillshade\" === t.type || \"custom\" === t.type ? !i && t.shouldRedrape() : !i && t.hasTransition();\n        });\n      }\n      _clearLineLayersFromRenderCache() {\n        let t = !1;\n        for (const e of this._style.getSources()) if (e instanceof tt) {\n          t = !0;\n          break;\n        }\n        if (!t) return;\n        const i = {};\n        for (let t = 0; t < this._style.order.length; ++t) {\n          const o = this._style._mergedLayers[this._style.order[t]],\n            s = this._style.getLayerSourceCache(o);\n          if (s && !i[s.id] && !o.isHidden(this.painter.transform.zoom) && \"line\" === o.type && o.widthExpression() instanceof e.ab) {\n            i[s.id] = !0;\n            for (const e of this.proxyCoords) {\n              const t = this.proxyToSource[e.key][s.id];\n              if (t) for (const e of t) this._clearRenderCacheForTile(s.id, e);\n            }\n          }\n        }\n      }\n      _clearRasterLayersFromRenderCache() {\n        let e = !1;\n        for (const t in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[t]._source instanceof it) {\n          e = !0;\n          break;\n        }\n        if (!e) return;\n        const t = {};\n        for (let e = 0; e < this._style.order.length; ++e) {\n          const i = this._style._mergedLayers[this._style.order[e]],\n            o = this._style.getLayerSourceCache(i);\n          if (!o || t[o.id]) continue;\n          if (i.isHidden(this.painter.transform.zoom) || \"raster\" !== i.type) continue;\n          const s = i.paint.get(\"raster-fade-duration\");\n          for (const e of this.proxyCoords) {\n            const t = this.proxyToSource[e.key][o.id];\n            if (t) for (const e of t) {\n              const t = Ns(o.getTile(e), o.findLoadedParent(e, 0), o, this.painter.transform, s);\n              (1 !== t.opacity || 0 !== t.mix) && this._clearRenderCacheForTile(o.id, e);\n            }\n          }\n        }\n      }\n      _setupDrapedRenderBatches() {\n        this._style.updateDrapeFirstLayers();\n        const t = this._style.order,\n          i = t.length;\n        if (0 === i) return;\n        const o = [];\n        this._pendingGroundEffectLayers = [];\n        let s,\n          r = 0,\n          n = this._style._mergedLayers[t[r]];\n        for (; !this._style.isLayerDraped(n) && n.isHidden(this.painter.transform.zoom) && ++r < i;) n = this._style._mergedLayers[t[r]];\n        for (; r < i; ++r) {\n          const e = this._style._mergedLayers[t[r]];\n          e.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e) ? void 0 === s && (s = r) : (\"fill-extrusion\" === e.type && this._pendingGroundEffectLayers.push(r), void 0 !== s && (o.push({\n            start: s,\n            end: r - 1\n          }), s = void 0)));\n        }\n        if (void 0 !== s && o.push({\n          start: s,\n          end: r - 1\n        }), 0 !== o.length) {\n          const t = o[o.length - 1];\n          this._pendingGroundEffectLayers.every(e => e > t.end) || e.w(\"fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.\");\n        }\n        this._drapedRenderBatches = o;\n      }\n      _setupRenderCache(e) {\n        const t = this.proxySourceCache;\n        if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {\n          if (this.invalidateRenderCache = !1, t.renderCache.length > t.renderCachePool.length) {\n            const e = Object.values(t.proxyCachedFBO);\n            t.proxyCachedFBO = {};\n            for (let i = 0; i < e.length; ++i) {\n              const o = Object.values(e[i]);\n              t.renderCachePool.push(...o);\n            }\n          }\n          return;\n        }\n        this._clearRasterLayersFromRenderCache();\n        const i = this.proxyCoords,\n          o = this._tilesDirty;\n        for (let s = i.length - 1; s >= 0; s--) {\n          const r = i[s];\n          if (t.getTileByID(r.key), void 0 !== t.proxyCachedFBO[r.key]) {\n            const i = e[r.key],\n              s = this.proxyToSource[r.key];\n            let n = 0;\n            for (const e in s) {\n              const t = s[e],\n                r = i[e];\n              if (!r || r.length !== t.length || t.some((t, i) => t !== r[i] || o[e] && o[e].hasOwnProperty(t.key))) {\n                n = -1;\n                break;\n              }\n              ++n;\n            }\n            for (const e in t.proxyCachedFBO[r.key]) t.renderCache[t.proxyCachedFBO[r.key][e]].dirty = n < 0 || n !== Object.values(i).length;\n          }\n        }\n        const s = [...this._drapedRenderBatches];\n        s.sort((e, t) => t.end - t.start - (e.end - e.start));\n        for (const e of s) for (const o of i) {\n          if (t.proxyCachedFBO[o.key]) continue;\n          let i = t.renderCachePool.pop();\n          void 0 === i && t.renderCache.length < 50 && (i = t.renderCache.length, t.renderCache.push(this._createFBO())), void 0 !== i && (t.proxyCachedFBO[o.key] = {}, t.proxyCachedFBO[o.key][e.start] = i, t.renderCache[i].dirty = !0);\n        }\n        this._tilesDirty = {};\n      }\n      _setupStencil(e, t, i, o) {\n        if (!o || !this._sourceTilesOverlap[o.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));\n        const s = this.painter.context,\n          r = s.gl;\n        if (t.length <= 1) return void (this._overlapStencilType = !1);\n        let n;\n        if (i.isTileClipped()) n = t.length, this._overlapStencilMode.test = {\n          func: r.EQUAL,\n          mask: 255\n        }, this._overlapStencilType = \"Clip\";else {\n          if (!(t[0].overscaledZ > t[t.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);\n          n = 1, this._overlapStencilMode.test = {\n            func: r.GREATER,\n            mask: 255\n          }, this._overlapStencilType = \"Mask\";\n        }\n        this._stencilRef + n > 255 && (s.clear({\n          stencil: 0\n        }), this._stencilRef = 0), this._stencilRef += n, this._overlapStencilMode.ref = this._stencilRef, i.isTileClipped() && this._renderTileClippingMasks(t, this._overlapStencilMode.ref);\n      }\n      clipOrMaskOverlapStencilType() {\n        return \"Clip\" === this._overlapStencilType || \"Mask\" === this._overlapStencilType;\n      }\n      stencilModeForRTTOverlap(e) {\n        return this.renderingToTexture && this._overlapStencilType ? (\"Clip\" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e.key]), this._overlapStencilMode) : Ui.disabled;\n      }\n      _renderTileClippingMasks(e, t) {\n        const i = this.painter,\n          o = this.painter.context,\n          s = o.gl;\n        i._tileClippingMaskIDs = {}, o.setColorMode(ki.disabled), o.setDepthMode(Bi.disabled);\n        const r = i.getOrCreateProgram(\"clippingMask\");\n        for (const o of e) {\n          const e = i._tileClippingMaskIDs[o.key] = --t;\n          r.draw(i, s.TRIANGLES, Bi.disabled, new Ui({\n            func: s.ALWAYS,\n            mask: 0\n          }, e, 255, s.KEEP, s.KEEP, s.REPLACE), ki.disabled, ji.disabled, Bs(o.projMatrix), \"$clipping\", i.tileExtentBuffer, i.quadTriangleIndexBuffer, i.tileExtentSegments);\n        }\n      }\n      pointCoordinate(t) {\n        const i = this.painter.transform;\n        if (t.x < 0 || t.x > i.width || t.y < 0 || t.y > i.height) return null;\n        const o = [t.x, t.y, 1, 1];\n        e.ad.vec4.transformMat4(o, o, i.pixelMatrixInverse), e.ad.vec4.scale(o, o, 1 / o[3]), o[0] /= i.worldSize, o[1] /= i.worldSize;\n        const s = i._camera.position,\n          r = e.bH(1, i.center.lat),\n          n = [s[0], s[1], s[2] / r, 0],\n          a = e.ad.vec3.subtract([], o.slice(0, 3), n);\n        e.ad.vec3.normalize(a, a);\n        const l = this.raycast(n, a, this._exaggeration);\n        return null !== l && l ? (e.ad.vec3.scaleAndAdd(n, n, a, l), n[3] = n[2], n[2] *= r, n) : null;\n      }\n      _setupProxiedCoordsForOrtho(t, i, o) {\n        if (t.getSource() instanceof e.aK) return this._setupProxiedCoordsForImageSource(t, i, o);\n        this._findCoveringTileCache[t.id] = this._findCoveringTileCache[t.id] || {};\n        const s = this.proxiedCoords[t.id] = [],\n          r = this.proxyCoords;\n        for (let e = 0; e < r.length; e++) {\n          const i = r[e],\n            n = this._findTileCoveringTileID(i, t);\n          if (n) {\n            const e = this._createProxiedId(i, n, o[i.key] && o[i.key][t.id]);\n            s.push(e), this.proxyToSource[i.key][t.id] = [e];\n          }\n        }\n        let n = !1;\n        const a = new Set();\n        for (let e = 0; e < i.length; e++) {\n          const r = t.getTile(i[e]);\n          if (!r || !r.hasData()) continue;\n          const l = this._findTileCoveringTileID(r.tileID, this.proxySourceCache);\n          if (l && l.tileID.canonical.z !== r.tileID.canonical.z) {\n            const e = this.proxyToSource[l.tileID.key][t.id],\n              i = this._createProxiedId(l.tileID, r, o[l.tileID.key] && o[l.tileID.key][t.id]);\n            e ? e.splice(e.length - 1, 0, i) : this.proxyToSource[l.tileID.key][t.id] = [i];\n            const c = this.proxyToSource[l.tileID.key][t.id];\n            a.has(c) || a.add(c), s.push(i), n = !0;\n          }\n        }\n        if (this._sourceTilesOverlap[t.id] = n, n && this._debugParams.sortTilesHiZFirst) for (const e of a) e.sort((e, t) => t.overscaledZ - e.overscaledZ);\n      }\n      _setupProxiedCoordsForImageSource(t, i, o) {\n        if (!t.getSource().loaded()) return;\n        const s = this.proxiedCoords[t.id] = [],\n          r = this.proxyCoords,\n          n = t.getSource(),\n          a = n.tileID;\n        if (!a) return;\n        const l = new e.P(a.x, a.y)._div(1 << a.z),\n          c = n.coordinates.map(e.ac.fromLngLat).reduce((e, t) => (e.min.x = Math.min(e.min.x, t.x - l.x), e.min.y = Math.min(e.min.y, t.y - l.y), e.max.x = Math.max(e.max.x, t.x - l.x), e.max.y = Math.max(e.max.y, t.y - l.y), e), {\n            min: new e.P(Number.MAX_VALUE, Number.MAX_VALUE),\n            max: new e.P(-Number.MAX_VALUE, -Number.MAX_VALUE)\n          }),\n          h = (t, i) => {\n            const o = t.wrap + t.canonical.x / (1 << t.canonical.z),\n              s = t.canonical.y / (1 << t.canonical.z),\n              r = e.ai / (1 << t.canonical.z),\n              n = i.wrap + i.canonical.x / (1 << i.canonical.z),\n              a = i.canonical.y / (1 << i.canonical.z);\n            return o + r < n + c.min.x || o > n + c.max.x || s + r < a + c.min.y || s > a + c.max.y;\n          };\n        for (let e = 0; e < r.length; e++) {\n          const n = r[e];\n          for (let e = 0; e < i.length; e++) {\n            const r = t.getTile(i[e]);\n            if (!r || !r.hasData()) continue;\n            if (h(n, r.tileID)) continue;\n            const a = this._createProxiedId(n, r, o[n.key] && o[n.key][t.id]),\n              l = this.proxyToSource[n.key][t.id];\n            l ? l.push(a) : this.proxyToSource[n.key][t.id] = [a], s.push(a);\n          }\n        }\n      }\n      _createProxiedId(t, i, o) {\n        let s = this.orthoMatrix;\n        if (o) {\n          const e = o.find(e => e.key === i.tileID.key);\n          if (e) return e;\n        }\n        if (i.tileID.key !== t.key) {\n          const o = t.canonical.z - i.tileID.canonical.z;\n          let r, n, a;\n          s = e.ad.mat4.create();\n          const l = i.tileID.wrap - t.wrap << t.overscaledZ;\n          o > 0 ? (r = e.ai >> o, n = r * ((i.tileID.canonical.x << o) - t.canonical.x + l), a = r * ((i.tileID.canonical.y << o) - t.canonical.y)) : (r = e.ai << -o, n = e.ai * (i.tileID.canonical.x - (t.canonical.x + l << -o)), a = e.ai * (i.tileID.canonical.y - (t.canonical.y << -o))), e.ad.mat4.ortho(s, 0, r, 0, r, 0, 1), e.ad.mat4.translate(s, s, [n, a, 0]);\n        }\n        return new Gs(i.tileID, t.key, s);\n      }\n      _findTileCoveringTileID(t, i) {\n        let o = i.getTile(t);\n        if (o && o.hasData()) return o;\n        const s = this._findCoveringTileCache[i.id],\n          r = s[t.key];\n        if (o = r ? i.getTileByID(r) : null, o && o.hasData() || null === r) return o;\n        let n = o ? o.tileID : t,\n          a = n.overscaledZ;\n        const l = i.getSource().minzoom,\n          c = [];\n        if (!r) {\n          const s = i.getSource().maxzoom;\n          if (t.canonical.z >= s) {\n            const o = t.canonical.z - s;\n            i.getSource().reparseOverscaled ? (a = Math.max(t.canonical.z + 2, i.transform.tileZoom), n = new e.aH(a, t.wrap, s, t.canonical.x >> o, t.canonical.y >> o)) : 0 !== o && (a = s, n = new e.aH(a, t.wrap, s, t.canonical.x >> o, t.canonical.y >> o));\n          }\n          n.key !== t.key && (c.push(n.key), o = i.getTile(n));\n        }\n        const h = e => {\n          c.forEach(t => {\n            s[t] = e;\n          }), c.length = 0;\n        };\n        for (a -= 1; a >= l && (!o || !o.hasData()); a--) {\n          o && h(o.tileID.key);\n          const e = n.calculateScaledKey(a);\n          if (o = i.getTileByID(e), o && o.hasData()) break;\n          const t = s[e];\n          if (null === t) break;\n          void 0 === t ? c.push(e) : o = i.getTileByID(t);\n        }\n        return h(o ? o.tileID.key : null), o && o.hasData() ? o : null;\n      }\n      findDEMTileFor(e) {\n        return this.enabled ? this._findTileCoveringTileID(e, this.sourceCache) : null;\n      }\n      prepareDrawTile() {\n        this.renderedToTile = !0;\n      }\n      _clearRenderCacheForTile(e, t) {\n        let i = this._tilesDirty[e];\n        i || (i = this._tilesDirty[e] = {}), i[t.key] = !0;\n      }\n    }\n    function qs(t, i, o) {\n      const s = function (t, i, o) {\n          const s = e.ad.vec3.dot(i, t),\n            r = e.ad.vec3.dot(o, [.2126, .7152, .0722]),\n            n = (e, t, i) => (1 - i) * e + i * t,\n            a = n(1 - .3 * Math.min(r, 1), 1, Math.min(s + 1, 1));\n          return n(.92, 1, Math.asin(e.ay(i[2], -1, 1)) / Math.PI + .5) * a;\n        }(t, [0, 0, 1], i),\n        r = [0, 0, 0];\n      e.ad.vec3.scale(r, o.slice(0, 3), s);\n      const n = [0, 0, 0];\n      e.ad.vec3.scale(n, i.slice(0, 3), t[2]);\n      const a = [0, 0, 0];\n      return e.ad.vec3.add(a, r, n), e.cg(a);\n    }\n    const Hs = [\"fill\", \"fillOutline\", \"fillPattern\", \"line\", \"linePattern\", \"background\", \"backgroundPattern\", \"hillshade\", \"raster\"],\n      Zs = [\"stars\", \"rainParticle\", \"snowParticle\", \"fillExtrusion\", \"fillExtrusionGroundEffect\", \"elevatedStructures\", \"model\", \"symbol\"];\n    class Ws {\n      static cacheKey(e, t, i, o) {\n        let s = `${t}${o ? o.cacheKey : \"\"}`;\n        for (const t of i) e.usedDefines.includes(t) && (s += `/${t}`);\n        return s;\n      }\n      constructor(t, i, o, s, r, n) {\n        const a = t.gl;\n        this.program = a.createProgram(), this.configuration = s, this.name = i, this.fixedDefines = [...n];\n        const l = s ? s.getBinderAttributes() : [],\n          c = (o.staticAttributes || []).concat(l);\n        let h = s ? s.defines() : [];\n        h = h.concat(n.map(e => `#define ${e}`));\n        const d = \"#version 300 es\\n\";\n        let u = d + h.concat(\"precision mediump float;\", No, Bo.fragmentSource).join(\"\\n\");\n        for (const e of o.fragmentIncludes) u += `\\n${Fo[e]}`;\n        u += `\\n${o.fragmentSource}`;\n        let _ = d + h.concat(\"precision highp float;\", No, Bo.vertexSource).join(\"\\n\");\n        for (const e of o.vertexIncludes) _ += `\\n${Fo[e]}`;\n        this.forceManualRenderingForInstanceIDShaders = t.forceManualRenderingForInstanceIDShaders && -1 !== o.vertexSource.indexOf(\"gl_InstanceID\"), this.forceManualRenderingForInstanceIDShaders && (_ += \"\\nuniform int u_instanceID;\\n\"), _ += `\\n${o.vertexSource}`, this.forceManualRenderingForInstanceIDShaders && (_ = _.replaceAll(\"gl_InstanceID\", \"u_instanceID\"));\n        const p = a.createShader(a.FRAGMENT_SHADER);\n        if (a.isContextLost()) return void (this.failedToCreate = !0);\n        a.shaderSource(p, u), a.compileShader(p), a.attachShader(this.program, p);\n        const f = a.createShader(a.VERTEX_SHADER);\n        if (a.isContextLost()) this.failedToCreate = !0;else {\n          a.shaderSource(f, _), a.compileShader(f), a.attachShader(this.program, f), this.attributes = {}, this.numAttributes = c.length;\n          for (let e = 0; e < this.numAttributes; e++) if (c[e]) {\n            const t = c[e].startsWith(\"a_\") ? c[e] : `a_${c[e]}`;\n            a.bindAttribLocation(this.program, e, t), this.attributes[t] = e;\n          }\n          a.linkProgram(this.program), a.deleteShader(f), a.deleteShader(p), this.fixedUniforms = r(t), this.binderUniforms = s ? s.getUniforms(t) : [], this.forceManualRenderingForInstanceIDShaders && (this.instancingUniforms = (t => ({\n            u_instanceID: new e.bN(t)\n          }))(t)), (n.includes(\"TERRAIN\") || -1 !== i.indexOf(\"symbol\") || -1 !== i.indexOf(\"circle\")) && (this.terrainUniforms = (t => ({\n            u_dem: new e.bN(t),\n            u_dem_prev: new e.bN(t),\n            u_dem_tl: new e.bK(t),\n            u_dem_scale: new e.bM(t),\n            u_dem_tl_prev: new e.bK(t),\n            u_dem_scale_prev: new e.bM(t),\n            u_dem_size: new e.bM(t),\n            u_dem_lerp: new e.bM(t),\n            u_exaggeration: new e.bM(t),\n            u_depth: new e.bN(t),\n            u_depth_size_inv: new e.bK(t),\n            u_depth_range_unpack: new e.bK(t),\n            u_occluder_half_size: new e.bM(t),\n            u_occlusion_depth_offset: new e.bM(t),\n            u_meter_to_dem: new e.bM(t),\n            u_label_plane_matrix_inv: new e.bJ(t)\n          }))(t)), n.includes(\"GLOBE\") && (this.globeUniforms = (t => ({\n            u_tile_tl_up: new e.bL(t),\n            u_tile_tr_up: new e.bL(t),\n            u_tile_br_up: new e.bL(t),\n            u_tile_bl_up: new e.bL(t),\n            u_tile_up_scale: new e.bM(t)\n          }))(t)), n.includes(\"FOG\") && (this.fogUniforms = (t => ({\n            u_fog_matrix: new e.bJ(t),\n            u_fog_range: new e.bK(t),\n            u_fog_color: new e.cb(t),\n            u_fog_horizon_blend: new e.bM(t),\n            u_fog_vertical_limit: new e.bK(t),\n            u_fog_temporal_offset: new e.bM(t),\n            u_frustum_tl: new e.bL(t),\n            u_frustum_tr: new e.bL(t),\n            u_frustum_br: new e.bL(t),\n            u_frustum_bl: new e.bL(t),\n            u_globe_pos: new e.bL(t),\n            u_globe_radius: new e.bM(t),\n            u_globe_transition: new e.bM(t),\n            u_is_globe: new e.bN(t),\n            u_viewport: new e.bK(t)\n          }))(t)), n.includes(\"RENDER_CUTOFF\") && (this.cutoffUniforms = (t => ({\n            u_cutoff_params: new e.cb(t)\n          }))(t)), n.includes(\"LIGHTING_3D_MODE\") && (this.lightsUniforms = (t => ({\n            u_lighting_ambient_color: new e.bL(t),\n            u_lighting_directional_dir: new e.bL(t),\n            u_lighting_directional_color: new e.bL(t),\n            u_ground_radiance: new e.bL(t)\n          }))(t)), n.includes(\"RENDER_SHADOWS\") && (this.shadowUniforms = (t => ({\n            u_light_matrix_0: new e.bJ(t),\n            u_light_matrix_1: new e.bJ(t),\n            u_fade_range: new e.bK(t),\n            u_shadow_normal_offset: new e.bL(t),\n            u_shadow_intensity: new e.bM(t),\n            u_shadow_texel_size: new e.bM(t),\n            u_shadow_map_resolution: new e.bM(t),\n            u_shadow_direction: new e.bL(t),\n            u_shadow_bias: new e.bL(t),\n            u_shadowmap_0: new e.bN(t),\n            u_shadowmap_1: new e.bN(t)\n          }))(t));\n        }\n      }\n      setTerrainUniformValues(e, t) {\n        if (!this.terrainUniforms) return;\n        const i = this.terrainUniforms;\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n          for (const e in t) i[e] && i[e].set(this.program, e, t[e]);\n        }\n      }\n      setGlobeUniformValues(e, t) {\n        if (!this.globeUniforms) return;\n        const i = this.globeUniforms;\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n          for (const e in t) i[e] && i[e].set(this.program, e, t[e]);\n        }\n      }\n      setFogUniformValues(e, t) {\n        if (!this.fogUniforms) return;\n        const i = this.fogUniforms;\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n          for (const e in t) i[e].set(this.program, e, t[e]);\n        }\n      }\n      setCutoffUniformValues(e, t) {\n        if (!this.cutoffUniforms) return;\n        const i = this.cutoffUniforms;\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n          for (const e in t) i[e].set(this.program, e, t[e]);\n        }\n      }\n      setLightsUniformValues(e, t) {\n        if (!this.lightsUniforms) return;\n        const i = this.lightsUniforms;\n        if (!this.failedToCreate) {\n          e.program.set(this.program);\n          for (const e in t) i[e].set(this.program, e, t[e]);\n        }\n      }\n      setShadowUniformValues(e, t) {\n        if (this.failedToCreate || !this.shadowUniforms) return;\n        const i = this.shadowUniforms;\n        e.program.set(this.program);\n        for (const e in t) i[e].set(this.program, e, t[e]);\n      }\n      _drawDebugWireframe(t, i, o, s, r, n, a, l, c, h) {\n        const d = t.options.wireframe;\n        if (!1 === d.terrain && !1 === d.layers2D && !1 === d.layers3D) return;\n        const u = t.context;\n        if (!(() => !(!d.terrain || \"terrainRaster\" !== this.name && \"globeRaster\" !== this.name) || !(!d.layers2D || t._terrain && t._terrain.renderingToTexture || !Hs.includes(this.name)) || !(!d.layers3D || !Zs.includes(this.name)))()) return;\n        const _ = u.gl,\n          p = t.wireframeDebugCache.getLinesFromTrianglesBuffer(t.frameCounter, r, u);\n        if (!p) return;\n        const f = [...this.fixedDefines];\n        f.push(\"DEBUG_WIREFRAME\");\n        const m = t.getOrCreateProgram(this.name, {\n          config: this.configuration,\n          defines: f\n        });\n        u.program.set(m.program);\n        const g = (e, t, i) => {\n          if (t[e] && i[e]) for (const o in t[e]) i[e][o] && i[e][o].set(i.program, o, t[e][o].current);\n        };\n        c && c.setUniforms(m.program, u, m.binderUniforms, a, {\n          zoom: l\n        }), g(\"fixedUniforms\", this, m), g(\"terrainUniforms\", this, m), g(\"globeUniforms\", this, m), g(\"fogUniforms\", this, m), g(\"lightsUniforms\", this, m), g(\"shadowUniforms\", this, m), p.bind(), u.setColorMode(new ki([_.ONE, _.ONE_MINUS_SRC_ALPHA, _.ZERO, _.ONE], e.al.transparent, [!0, !0, !0, !1])), u.setDepthMode(new Bi(i.func === _.LESS ? _.LEQUAL : i.func, Bi.ReadOnly, i.range)), u.setStencilMode(Ui.disabled);\n        const v = 3 * n.primitiveLength * 2,\n          y = 3 * n.primitiveOffset * 2 * 2;\n        if (this.forceManualRenderingForInstanceIDShaders) {\n          const e = h || 1;\n          for (let t = 0; t < e; ++t) m.instancingUniforms.u_instanceID.set(this.program, \"u_instanceID\", t), _.drawElements(_.LINES, v, _.UNSIGNED_SHORT, y);\n        } else h && h > 1 ? _.drawElementsInstanced(_.LINES, v, _.UNSIGNED_SHORT, y, h) : _.drawElements(_.LINES, v, _.UNSIGNED_SHORT, y);\n        r.bind(), u.program.set(this.program), u.setDepthMode(i), u.setStencilMode(o), u.setColorMode(s);\n      }\n      checkUniforms(e, t, i) {\n        if (this.fixedDefines.includes(t)) for (const o of Object.keys(i)) if (!i[o].initialized) throw new Error(`Program '${this.name}', from draw '${e}': uniform ${o} not set but required by ${t} being defined`);\n      }\n      draw(e, t, i, o, s, r, n, a, l, c, h, d, u, _, p, f) {\n        const m = e.context,\n          g = m.gl;\n        if (this.failedToCreate) return;\n        m.program.set(this.program), m.setDepthMode(i), m.setStencilMode(o), m.setColorMode(s), m.setCullFace(r);\n        for (const e of Object.keys(this.fixedUniforms)) this.fixedUniforms[e].set(this.program, e, n[e]);\n        _ && _.setUniforms(this.program, m, this.binderUniforms, d, {\n          zoom: u\n        });\n        const v = {\n          [g.POINTS]: 1,\n          [g.LINES]: 2,\n          [g.TRIANGLES]: 3,\n          [g.LINE_STRIP]: 1\n        }[t];\n        this.checkUniforms(a, \"RENDER_SHADOWS\", this.shadowUniforms);\n        const y = f && f > 0 ? 1 : void 0;\n        for (const r of h.get()) {\n          const n = r.vaos || (r.vaos = {});\n          if ((n[a] || (n[a] = new jo())).bind(m, this, l, _ ? _.getPaintVertexBuffers() : [], c, r.vertexOffset, p || [], y), this.forceManualRenderingForInstanceIDShaders) {\n            const e = f || 1;\n            for (let i = 0; i < e; ++i) this.instancingUniforms.u_instanceID.set(this.program, \"u_instanceID\", i), c ? g.drawElements(t, r.primitiveLength * v, g.UNSIGNED_SHORT, r.primitiveOffset * v * 2) : g.drawArrays(t, r.vertexOffset, r.vertexLength);\n          } else f && f > 1 ? g.drawElementsInstanced(t, r.primitiveLength * v, g.UNSIGNED_SHORT, r.primitiveOffset * v * 2, f) : c ? g.drawElements(t, r.primitiveLength * v, g.UNSIGNED_SHORT, r.primitiveOffset * v * 2) : g.drawArrays(t, r.vertexOffset, r.vertexLength);\n          t === g.TRIANGLES && c && this._drawDebugWireframe(e, i, o, s, c, r, d, u, _, f);\n        }\n      }\n    }\n    function $s(t, i) {\n      const o = Math.pow(2, i.tileID.overscaledZ),\n        s = i.tileSize * Math.pow(2, t.transform.tileZoom) / o,\n        r = s * (i.tileID.canonical.x + i.tileID.wrap * o),\n        n = s * i.tileID.canonical.y;\n      return {\n        u_image: 0,\n        u_texsize: i.imageAtlasTexture ? i.imageAtlasTexture.size : [0, 0],\n        u_tile_units_to_pixels: 1 / e.at(i, 1, t.transform.tileZoom),\n        u_pixel_coord_upper: [r >> 16, n >> 16],\n        u_pixel_coord_lower: [65535 & r, 65535 & n]\n      };\n    }\n    const Xs = {\n        terrain: 0,\n        flat: 1\n      },\n      Ks = e.ad.mat4.create(),\n      Ys = (t, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v) => {\n        const y = i.style.light,\n          x = y.properties.get(\"position\"),\n          b = [x.x, x.y, x.z],\n          w = e.ad.mat3.create();\n        \"viewport\" === y.properties.get(\"anchor\") && (e.ad.mat3.fromRotation(w, -i.transform.angle), e.ad.vec3.transformMat3(b, b, w));\n        const T = y.properties.get(\"color\"),\n          E = i.transform,\n          S = {\n            u_matrix: t,\n            u_lightpos: b,\n            u_lightintensity: y.properties.get(\"intensity\"),\n            u_lightcolor: [T.r, T.g, T.b],\n            u_vertical_gradient: +o,\n            u_opacity: s,\n            u_tile_id: [0, 0, 0],\n            u_zoom_transition: 0,\n            u_inv_rot_matrix: Ks,\n            u_merc_center: [0, 0],\n            u_up_dir: [0, 0, 0],\n            u_height_lift: 0,\n            u_height_type: Xs[h],\n            u_base_type: Xs[d],\n            u_ao: r,\n            u_edge_radius: n,\n            u_width_scale: a,\n            u_flood_light_color: f,\n            u_vertical_scale: m,\n            u_flood_light_intensity: g,\n            u_ground_shadow_factor: v\n          };\n        return \"globe\" === E.projection.name && (S.u_tile_id = [l.canonical.x, l.canonical.y, 1 << l.canonical.z], S.u_zoom_transition = u, S.u_inv_rot_matrix = p, S.u_merc_center = _, S.u_up_dir = E.projection.upVector(new e.bT(0, 0, 0), _[0] * e.ai, _[1] * e.ai), S.u_height_lift = c), S;\n      },\n      Js = (e, t, i, o, s, r) => ({\n        u_matrix: e,\n        u_edge_radius: t,\n        u_width_scale: i,\n        u_vertical_scale: o,\n        u_height_type: Xs[s],\n        u_base_type: Xs[r]\n      }),\n      Qs = (t, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g) => {\n        const v = Ys(t, i, o, s, r, n, a, l, h, d, u, _, p, f, m, g, 1, [0, 0, 0]),\n          y = {\n            u_height_factor: -Math.pow(2, l.overscaledZ) / c.tileSize / 8\n          };\n        return e.l(v, $s(i, c), y);\n      },\n      er = (e, t) => ({\n        u_matrix: e,\n        u_emissive_strength: t\n      }),\n      tr = (t, i, o, s) => e.l(er(t, i), $s(o, s)),\n      ir = (e, t, i) => ({\n        u_matrix: e,\n        u_world: i,\n        u_emissive_strength: t\n      }),\n      or = (t, i, o, s, r) => e.l(tr(t, i, o, s), {\n        u_world: r\n      }),\n      sr = (e, t, i, o, s) => ({\n        u_matrix: e,\n        u_camera_pos: [t[0], t[1], t[2]],\n        u_depth_bias: i,\n        u_height_scale: o,\n        u_reset_depth: s\n      }),\n      rr = (t, i, o, s) => {\n        const r = e.ai / o.tileSize;\n        return {\n          u_matrix: t,\n          u_camera_to_center_distance: i.getCameraToCenterDistance(s),\n          u_extrude_scale: [i.pixelsToGLUnits[0] / r, i.pixelsToGLUnits[1] / r]\n        };\n      },\n      nr = (e, t, i = 1) => ({\n        u_matrix: e,\n        u_color: t.toRenderColor(null),\n        u_overlay: 0,\n        u_overlay_scale: i\n      }),\n      ar = e.ad.mat4.create(),\n      lr = (t, i, o, s, r, n, a) => {\n        const l = t.transform,\n          c = \"globe\" === l.projection.name,\n          h = c ? e.cO(l.zoom, i.canonical) * l._pixelsPerMercatorPixel : e.at(o, 1, n),\n          d = {\n            u_matrix: i.projMatrix,\n            u_extrude_scale: h,\n            u_intensity: a,\n            u_inv_rot_matrix: ar,\n            u_merc_center: [0, 0],\n            u_tile_id: [0, 0, 0],\n            u_zoom_transition: 0,\n            u_up_dir: [0, 0, 0]\n          };\n        if (c) {\n          d.u_inv_rot_matrix = s, d.u_merc_center = r, d.u_tile_id = [i.canonical.x, i.canonical.y, 1 << i.canonical.z], d.u_zoom_transition = e.ag(l.zoom);\n          const t = r[0] * e.ai,\n            o = r[1] * e.ai;\n          d.u_up_dir = l.projection.upVector(new e.bT(0, 0, 0), t, o);\n        }\n        return d;\n      };\n    function cr(e, [t, i, o, s], [r, n]) {\n      if (r === n) return [0, 0, 0, 0];\n      const a = 255 * (e - 1) / (e * (n - r));\n      return [t * a, i * a, o * a, s * a];\n    }\n    function hr(e, t, [i, o]) {\n      return i === o ? 0 : .5 / e + (t - i) * (e - 1) / (e * (o - i));\n    }\n    const dr = (t, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v, y, x, b) => ({\n      u_matrix: t,\n      u_normalize_matrix: i,\n      u_globe_matrix: o,\n      u_merc_matrix: s,\n      u_grid_matrix: r,\n      u_tl_parent: n,\n      u_scale_parent: h,\n      u_fade_t: d.mix,\n      u_opacity: d.opacity * u.paint.get(\"raster-opacity\"),\n      u_image0: 0,\n      u_image1: 1,\n      u_brightness_low: u.paint.get(\"raster-brightness-min\"),\n      u_brightness_high: u.paint.get(\"raster-brightness-max\"),\n      u_saturation_factor: e.cP(u.paint.get(\"raster-saturation\")),\n      u_contrast_factor: e.cQ(u.paint.get(\"raster-contrast\")),\n      u_spin_weights: ur(u.paint.get(\"raster-hue-rotate\")),\n      u_perspective_transform: _,\n      u_raster_elevation: p,\n      u_zoom_transition: a,\n      u_merc_center: l,\n      u_cutoff_params: c,\n      u_colorization_mix: cr(e.cR, m, v),\n      u_colorization_offset: hr(e.cR, g, v),\n      u_color_ramp: f,\n      u_texture_offset: [x / (y + 2 * x), y / (y + 2 * x)],\n      u_texture_res: [y + 2 * x, y + 2 * x],\n      u_emissive_strength: b\n    });\n    function ur(e) {\n      e *= Math.PI / 180;\n      const t = Math.sin(e),\n        i = Math.cos(e);\n      return [(2 * i + 1) / 3, (-Math.sqrt(3) * t - i + 1) / 3, (Math.sqrt(3) * t - i + 1) / 3];\n    }\n    const _r = .05,\n      pr = (e, t, i, o, s, r, n, a, l, c, h, d) => ({\n        u_matrix: e,\n        u_normalize_matrix: t,\n        u_globe_matrix: i,\n        u_merc_matrix: o,\n        u_grid_matrix: s,\n        u_tl_parent: r,\n        u_scale_parent: c,\n        u_fade_t: h.mix,\n        u_opacity: h.opacity,\n        u_image0: 0,\n        u_image1: 1,\n        u_raster_elevation: d,\n        u_zoom_transition: n,\n        u_merc_center: a,\n        u_cutoff_params: l\n      }),\n      fr = (e, t, i, o, s, r, n, a, l, c) => ({\n        u_particle_texture: e,\n        u_particle_texture_side_len: t,\n        u_tile_offset: i,\n        u_velocity: o,\n        u_color_ramp: r,\n        u_velocity_res: s,\n        u_max_speed: n,\n        u_uv_offset: a,\n        u_data_scale: [255 * l[0], 255 * l[1]],\n        u_data_offset: c,\n        u_particle_pos_scale: 1.1,\n        u_particle_pos_offset: [_r, _r]\n      }),\n      mr = (e, t, i, o, s, r, n, a, l, c) => ({\n        u_particle_texture: e,\n        u_particle_texture_side_len: t,\n        u_velocity: i,\n        u_velocity_res: o,\n        u_max_speed: s,\n        u_speed_factor: r,\n        u_reset_rate: n,\n        u_rand_seed: Math.random(),\n        u_uv_offset: a,\n        u_data_scale: [255 * l[0], 255 * l[1]],\n        u_data_offset: c,\n        u_particle_pos_scale: 1.1,\n        u_particle_pos_offset: [_r, _r]\n      }),\n      gr = e.ad.mat4.create(),\n      vr = (t, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v, y, x, b, w) => {\n        const T = r.transform,\n          E = {\n            u_is_size_zoom_constant: +(\"constant\" === t || \"source\" === t),\n            u_is_size_feature_constant: +(\"constant\" === t || \"camera\" === t),\n            u_size_t: i ? i.uSizeT : 0,\n            u_size: i ? i.uSize : 0,\n            u_camera_to_center_distance: T.getCameraToCenterDistance(y),\n            u_rotate_symbol: +o,\n            u_aspect_ratio: T.width / T.height,\n            u_fade_change: r.options.fadeDuration ? r.symbolFadeChange : 1,\n            u_matrix: n,\n            u_label_plane_matrix: a,\n            u_coord_matrix: l,\n            u_is_text: +h,\n            u_elevation_from_sea: c ? 1 : 0,\n            u_pitch_with_map: +s,\n            u_texsize: d,\n            u_texsize_icon: u,\n            u_texture: 0,\n            u_texture_icon: 1,\n            u_tile_id: [0, 0, 0],\n            u_zoom_transition: 0,\n            u_inv_rot_matrix: gr,\n            u_merc_center: [0, 0],\n            u_camera_forward: [0, 0, 0],\n            u_ecef_origin: [0, 0, 0],\n            u_tile_matrix: gr,\n            u_up_vector: [0, -1, 0],\n            u_color_adj_mat: x,\n            u_icon_transition: b || 0,\n            u_gamma_scale: s ? r.transform.getCameraToCenterDistance(y) * Math.cos(r.terrain ? 0 : r.transform._pitch) : 1,\n            u_device_pixel_ratio: e.q.devicePixelRatio,\n            u_is_halo: +_,\n            u_scale_factor: w || 1\n          };\n        return \"globe\" === y.name && (E.u_tile_id = [p.canonical.x, p.canonical.y, 1 << p.canonical.z], E.u_zoom_transition = f, E.u_inv_rot_matrix = g, E.u_merc_center = m, E.u_camera_forward = T._camera.forward(), E.u_ecef_origin = e.cS(T.globeMatrix, p.toUnwrapped()), E.u_tile_matrix = Float32Array.from(T.globeMatrix), E.u_up_vector = v), E;\n      },\n      yr = (e, t, i, o) => ({\n        u_matrix: e,\n        u_emissive_strength: t,\n        u_opacity: i,\n        u_color: o\n      }),\n      xr = (t, i, o, s, r, n, a, l, c) => e.l(function (t, i, o, s, r, n) {\n        const {\n            width: a,\n            height: l\n          } = s.imageManager.getPixelSize(i),\n          c = Math.pow(2, n.tileID.overscaledZ),\n          h = n.tileSize * Math.pow(2, s.transform.tileZoom) / c,\n          d = h * (n.tileID.canonical.x + n.tileID.wrap * c),\n          u = h * n.tileID.canonical.y;\n        return {\n          u_image: 0,\n          u_pattern_tl: o.tl,\n          u_pattern_br: o.br,\n          u_texsize: [a, l],\n          u_pattern_size: o.displaySize,\n          u_pattern_units_to_pixels: r ? [s.transform.width, -1 * s.transform.height] : [1 / e.at(n, 1, s.transform.tileZoom), 1 / e.at(n, 1, s.transform.tileZoom)],\n          u_pixel_coord_upper: [d >> 16, u >> 16],\n          u_pixel_coord_lower: [65535 & d, 65535 & u]\n        };\n      }(0, n, a, s, l, c), {\n        u_matrix: t,\n        u_emissive_strength: i,\n        u_opacity: o\n      }),\n      br = new Float32Array(e.ad.mat4.identity([])),\n      wr = (t, i, o, s, r, n, a, l, c, h, d, u, _, p = [0, 0, 0], f) => {\n        const m = r.style.light,\n          g = m.properties.get(\"position\"),\n          v = [-g.x, -g.y, g.z],\n          y = e.ad.mat3.create();\n        \"viewport\" === m.properties.get(\"anchor\") && (e.ad.mat3.fromRotation(y, -r.transform.angle), e.ad.vec3.transformMat3(v, v, y));\n        const x = \"MASK\" === d.alphaMode,\n          b = m.properties.get(\"color\").toRenderColor(null),\n          w = _.paint.get(\"model-ambient-occlusion-intensity\"),\n          T = _.paint.get(\"model-color\").constantOr(e.al.white).toRenderColor(null),\n          E = _.paint.get(\"model-color-mix-intensity\").constantOr(0);\n        return {\n          u_matrix: t,\n          u_lighting_matrix: i,\n          u_normal_matrix: o,\n          u_node_matrix: s || br,\n          u_lightpos: v,\n          u_lightintensity: m.properties.get(\"intensity\"),\n          u_lightcolor: [b.r, b.g, b.b],\n          u_camera_pos: p,\n          u_opacity: n,\n          u_baseTextureIsAlpha: 0,\n          u_alphaMask: +x,\n          u_alphaCutoff: d.alphaCutoff,\n          u_baseColorFactor: [a.r, a.g, a.b, a.a],\n          u_emissiveFactor: [l[0], l[1], l[2], 1],\n          u_metallicFactor: c,\n          u_roughnessFactor: h,\n          u_baseColorTexture: Xi.BaseColor,\n          u_metallicRoughnessTexture: Xi.MetallicRoughness,\n          u_normalTexture: Xi.Normal,\n          u_occlusionTexture: Xi.Occlusion,\n          u_emissionTexture: Xi.Emission,\n          u_lutTexture: Xi.LUT,\n          u_color_mix: [T.r, T.g, T.b, E],\n          u_aoIntensity: w,\n          u_emissive_strength: u,\n          u_occlusionTextureTransform: f || [0, 0, 0, 0]\n        };\n      },\n      Tr = (e, t = br, i = br) => ({\n        u_matrix: e,\n        u_instance: t,\n        u_node_matrix: i\n      }),\n      Er = {\n        fillExtrusion: t => ({\n          u_matrix: new e.bJ(t),\n          u_lightpos: new e.bL(t),\n          u_lightintensity: new e.bM(t),\n          u_lightcolor: new e.bL(t),\n          u_vertical_gradient: new e.bM(t),\n          u_opacity: new e.bM(t),\n          u_edge_radius: new e.bM(t),\n          u_width_scale: new e.bM(t),\n          u_ao: new e.bK(t),\n          u_height_type: new e.bN(t),\n          u_base_type: new e.bN(t),\n          u_tile_id: new e.bL(t),\n          u_zoom_transition: new e.bM(t),\n          u_inv_rot_matrix: new e.bJ(t),\n          u_merc_center: new e.bK(t),\n          u_up_dir: new e.bL(t),\n          u_height_lift: new e.bM(t),\n          u_flood_light_color: new e.bL(t),\n          u_vertical_scale: new e.bM(t),\n          u_flood_light_intensity: new e.bM(t),\n          u_ground_shadow_factor: new e.bL(t)\n        }),\n        fillExtrusionDepth: t => ({\n          u_matrix: new e.bJ(t),\n          u_edge_radius: new e.bM(t),\n          u_width_scale: new e.bM(t),\n          u_vertical_scale: new e.bM(t),\n          u_height_type: new e.bN(t),\n          u_base_type: new e.bN(t)\n        }),\n        fillExtrusionPattern: t => ({\n          u_matrix: new e.bJ(t),\n          u_lightpos: new e.bL(t),\n          u_lightintensity: new e.bM(t),\n          u_lightcolor: new e.bL(t),\n          u_vertical_gradient: new e.bM(t),\n          u_height_factor: new e.bM(t),\n          u_edge_radius: new e.bM(t),\n          u_width_scale: new e.bM(t),\n          u_ao: new e.bK(t),\n          u_height_type: new e.bN(t),\n          u_base_type: new e.bN(t),\n          u_tile_id: new e.bL(t),\n          u_zoom_transition: new e.bM(t),\n          u_inv_rot_matrix: new e.bJ(t),\n          u_merc_center: new e.bK(t),\n          u_up_dir: new e.bL(t),\n          u_height_lift: new e.bM(t),\n          u_image: new e.bN(t),\n          u_texsize: new e.bK(t),\n          u_pixel_coord_upper: new e.bK(t),\n          u_pixel_coord_lower: new e.bK(t),\n          u_tile_units_to_pixels: new e.bM(t),\n          u_opacity: new e.bM(t)\n        }),\n        fillExtrusionGroundEffect: t => ({\n          u_matrix: new e.bJ(t),\n          u_opacity: new e.bM(t),\n          u_ao_pass: new e.bM(t),\n          u_meter_to_tile: new e.bM(t),\n          u_ao: new e.bK(t),\n          u_flood_light_intensity: new e.bM(t),\n          u_flood_light_color: new e.bL(t),\n          u_attenuation: new e.bM(t),\n          u_edge_radius: new e.bM(t),\n          u_fb: new e.bN(t),\n          u_fb_size: new e.bM(t),\n          u_dynamic_offset: new e.bM(t)\n        }),\n        fill: t => ({\n          u_matrix: new e.bJ(t),\n          u_emissive_strength: new e.bM(t)\n        }),\n        fillPattern: t => ({\n          u_matrix: new e.bJ(t),\n          u_emissive_strength: new e.bM(t),\n          u_image: new e.bN(t),\n          u_texsize: new e.bK(t),\n          u_pixel_coord_upper: new e.bK(t),\n          u_pixel_coord_lower: new e.bK(t),\n          u_tile_units_to_pixels: new e.bM(t)\n        }),\n        fillOutline: t => ({\n          u_matrix: new e.bJ(t),\n          u_emissive_strength: new e.bM(t),\n          u_world: new e.bK(t)\n        }),\n        fillOutlinePattern: t => ({\n          u_matrix: new e.bJ(t),\n          u_emissive_strength: new e.bM(t),\n          u_world: new e.bK(t),\n          u_image: new e.bN(t),\n          u_texsize: new e.bK(t),\n          u_pixel_coord_upper: new e.bK(t),\n          u_pixel_coord_lower: new e.bK(t),\n          u_tile_units_to_pixels: new e.bM(t)\n        }),\n        elevatedStructures: t => ({\n          u_matrix: new e.bJ(t)\n        }),\n        elevatedStructuresDepthReconstruct: t => ({\n          u_matrix: new e.bJ(t),\n          u_camera_pos: new e.bL(t),\n          u_depth_bias: new e.bM(t),\n          u_height_scale: new e.bM(t),\n          u_reset_depth: new e.bM(t)\n        }),\n        circle: e.cT,\n        collisionBox: t => ({\n          u_matrix: new e.bJ(t),\n          u_camera_to_center_distance: new e.bM(t),\n          u_extrude_scale: new e.bK(t)\n        }),\n        collisionCircle: t => ({\n          u_matrix: new e.bJ(t),\n          u_inv_matrix: new e.bJ(t),\n          u_camera_to_center_distance: new e.bM(t),\n          u_viewport_size: new e.bK(t)\n        }),\n        debug: t => ({\n          u_color: new e.cA(t),\n          u_matrix: new e.bJ(t),\n          u_overlay: new e.bN(t),\n          u_overlay_scale: new e.bM(t)\n        }),\n        clippingMask: t => ({\n          u_matrix: new e.bJ(t)\n        }),\n        heatmap: t => ({\n          u_extrude_scale: new e.bM(t),\n          u_intensity: new e.bM(t),\n          u_matrix: new e.bJ(t),\n          u_inv_rot_matrix: new e.bJ(t),\n          u_merc_center: new e.bK(t),\n          u_tile_id: new e.bL(t),\n          u_zoom_transition: new e.bM(t),\n          u_up_dir: new e.bL(t)\n        }),\n        heatmapTexture: t => ({\n          u_image: new e.bN(t),\n          u_color_ramp: new e.bN(t),\n          u_opacity: new e.bM(t)\n        }),\n        hillshade: t => ({\n          u_matrix: new e.bJ(t),\n          u_image: new e.bN(t),\n          u_latrange: new e.bK(t),\n          u_light: new e.bK(t),\n          u_shadow: new e.cA(t),\n          u_highlight: new e.cA(t),\n          u_emissive_strength: new e.bM(t),\n          u_accent: new e.cA(t)\n        }),\n        hillshadePrepare: t => ({\n          u_matrix: new e.bJ(t),\n          u_image: new e.bN(t),\n          u_dimension: new e.bK(t),\n          u_zoom: new e.bM(t)\n        }),\n        line: e.cU,\n        linePattern: e.cV,\n        raster: t => ({\n          u_matrix: new e.bJ(t),\n          u_normalize_matrix: new e.bJ(t),\n          u_globe_matrix: new e.bJ(t),\n          u_merc_matrix: new e.bJ(t),\n          u_grid_matrix: new e.cB(t),\n          u_tl_parent: new e.bK(t),\n          u_scale_parent: new e.bM(t),\n          u_fade_t: new e.bM(t),\n          u_opacity: new e.bM(t),\n          u_image0: new e.bN(t),\n          u_image1: new e.bN(t),\n          u_brightness_low: new e.bM(t),\n          u_brightness_high: new e.bM(t),\n          u_saturation_factor: new e.bM(t),\n          u_contrast_factor: new e.bM(t),\n          u_spin_weights: new e.bL(t),\n          u_perspective_transform: new e.bK(t),\n          u_raster_elevation: new e.bM(t),\n          u_zoom_transition: new e.bM(t),\n          u_merc_center: new e.bK(t),\n          u_cutoff_params: new e.cb(t),\n          u_colorization_mix: new e.cb(t),\n          u_colorization_offset: new e.bM(t),\n          u_color_ramp: new e.bN(t),\n          u_texture_offset: new e.bK(t),\n          u_texture_res: new e.bK(t),\n          u_emissive_strength: new e.bM(t)\n        }),\n        rasterParticle: t => ({\n          u_matrix: new e.bJ(t),\n          u_normalize_matrix: new e.bJ(t),\n          u_globe_matrix: new e.bJ(t),\n          u_merc_matrix: new e.bJ(t),\n          u_grid_matrix: new e.cB(t),\n          u_tl_parent: new e.bK(t),\n          u_scale_parent: new e.bM(t),\n          u_fade_t: new e.bM(t),\n          u_opacity: new e.bM(t),\n          u_image0: new e.bN(t),\n          u_image1: new e.bN(t),\n          u_raster_elevation: new e.bM(t),\n          u_zoom_transition: new e.bM(t),\n          u_merc_center: new e.bK(t),\n          u_cutoff_params: new e.cb(t)\n        }),\n        rasterParticleTexture: t => ({\n          u_texture: new e.bN(t),\n          u_opacity: new e.bM(t)\n        }),\n        rasterParticleDraw: t => ({\n          u_particle_texture: new e.bN(t),\n          u_particle_texture_side_len: new e.bM(t),\n          u_tile_offset: new e.bK(t),\n          u_velocity: new e.bN(t),\n          u_color_ramp: new e.bN(t),\n          u_velocity_res: new e.bK(t),\n          u_max_speed: new e.bM(t),\n          u_uv_offset: new e.bK(t),\n          u_data_scale: new e.bK(t),\n          u_data_offset: new e.bM(t),\n          u_particle_pos_scale: new e.bM(t),\n          u_particle_pos_offset: new e.bK(t)\n        }),\n        rasterParticleUpdate: t => ({\n          u_particle_texture: new e.bN(t),\n          u_particle_texture_side_len: new e.bM(t),\n          u_velocity: new e.bN(t),\n          u_velocity_res: new e.bK(t),\n          u_max_speed: new e.bM(t),\n          u_speed_factor: new e.bM(t),\n          u_reset_rate: new e.bM(t),\n          u_rand_seed: new e.bM(t),\n          u_uv_offset: new e.bK(t),\n          u_data_scale: new e.bK(t),\n          u_data_offset: new e.bM(t),\n          u_particle_pos_scale: new e.bM(t),\n          u_particle_pos_offset: new e.bK(t)\n        }),\n        symbol: t => ({\n          u_is_size_zoom_constant: new e.bN(t),\n          u_is_size_feature_constant: new e.bN(t),\n          u_size_t: new e.bM(t),\n          u_size: new e.bM(t),\n          u_camera_to_center_distance: new e.bM(t),\n          u_rotate_symbol: new e.bN(t),\n          u_aspect_ratio: new e.bM(t),\n          u_fade_change: new e.bM(t),\n          u_matrix: new e.bJ(t),\n          u_label_plane_matrix: new e.bJ(t),\n          u_coord_matrix: new e.bJ(t),\n          u_is_text: new e.bN(t),\n          u_elevation_from_sea: new e.bN(t),\n          u_pitch_with_map: new e.bN(t),\n          u_texsize: new e.bK(t),\n          u_texsize_icon: new e.bK(t),\n          u_texture: new e.bN(t),\n          u_texture_icon: new e.bN(t),\n          u_gamma_scale: new e.bM(t),\n          u_device_pixel_ratio: new e.bM(t),\n          u_tile_id: new e.bL(t),\n          u_zoom_transition: new e.bM(t),\n          u_inv_rot_matrix: new e.bJ(t),\n          u_merc_center: new e.bK(t),\n          u_camera_forward: new e.bL(t),\n          u_tile_matrix: new e.bJ(t),\n          u_up_vector: new e.bL(t),\n          u_ecef_origin: new e.bL(t),\n          u_is_halo: new e.bN(t),\n          u_icon_transition: new e.bM(t),\n          u_color_adj_mat: new e.bJ(t),\n          u_scale_factor: new e.bM(t)\n        }),\n        background: t => ({\n          u_matrix: new e.bJ(t),\n          u_emissive_strength: new e.bM(t),\n          u_opacity: new e.bM(t),\n          u_color: new e.cA(t)\n        }),\n        backgroundPattern: t => ({\n          u_matrix: new e.bJ(t),\n          u_emissive_strength: new e.bM(t),\n          u_opacity: new e.bM(t),\n          u_image: new e.bN(t),\n          u_pattern_tl: new e.bK(t),\n          u_pattern_br: new e.bK(t),\n          u_texsize: new e.bK(t),\n          u_pattern_size: new e.bK(t),\n          u_pixel_coord_upper: new e.bK(t),\n          u_pixel_coord_lower: new e.bK(t),\n          u_pattern_units_to_pixels: new e.bK(t)\n        }),\n        terrainRaster: t => ({\n          u_matrix: new e.bJ(t),\n          u_image0: new e.bN(t),\n          u_skirt_height: new e.bM(t),\n          u_ground_shadow_factor: new e.bL(t)\n        }),\n        skybox: t => ({\n          u_matrix: new e.bJ(t),\n          u_sun_direction: new e.bL(t),\n          u_cubemap: new e.bN(t),\n          u_opacity: new e.bM(t),\n          u_temporal_offset: new e.bM(t)\n        }),\n        skyboxGradient: t => ({\n          u_matrix: new e.bJ(t),\n          u_color_ramp: new e.bN(t),\n          u_center_direction: new e.bL(t),\n          u_radius: new e.bM(t),\n          u_opacity: new e.bM(t),\n          u_temporal_offset: new e.bM(t)\n        }),\n        skyboxCapture: t => ({\n          u_matrix_3f: new e.cB(t),\n          u_sun_direction: new e.bL(t),\n          u_sun_intensity: new e.bM(t),\n          u_color_tint_r: new e.cb(t),\n          u_color_tint_m: new e.cb(t),\n          u_luminance: new e.bM(t)\n        }),\n        globeRaster: t => ({\n          u_proj_matrix: new e.bJ(t),\n          u_globe_matrix: new e.bJ(t),\n          u_normalize_matrix: new e.bJ(t),\n          u_merc_matrix: new e.bJ(t),\n          u_zoom_transition: new e.bM(t),\n          u_merc_center: new e.bK(t),\n          u_image0: new e.bN(t),\n          u_grid_matrix: new e.cB(t),\n          u_skirt_height: new e.bM(t),\n          u_far_z_cutoff: new e.bM(t),\n          u_frustum_tl: new e.bL(t),\n          u_frustum_tr: new e.bL(t),\n          u_frustum_br: new e.bL(t),\n          u_frustum_bl: new e.bL(t),\n          u_globe_pos: new e.bL(t),\n          u_globe_radius: new e.bM(t),\n          u_viewport: new e.bK(t)\n        }),\n        globeAtmosphere: t => ({\n          u_frustum_tl: new e.bL(t),\n          u_frustum_tr: new e.bL(t),\n          u_frustum_br: new e.bL(t),\n          u_frustum_bl: new e.bL(t),\n          u_horizon: new e.bM(t),\n          u_transition: new e.bM(t),\n          u_fadeout_range: new e.bM(t),\n          u_color: new e.cb(t),\n          u_high_color: new e.cb(t),\n          u_space_color: new e.cb(t),\n          u_temporal_offset: new e.bM(t),\n          u_horizon_angle: new e.bM(t)\n        }),\n        model: t => ({\n          u_matrix: new e.bJ(t),\n          u_lighting_matrix: new e.bJ(t),\n          u_normal_matrix: new e.bJ(t),\n          u_node_matrix: new e.bJ(t),\n          u_lightpos: new e.bL(t),\n          u_lightintensity: new e.bM(t),\n          u_lightcolor: new e.bL(t),\n          u_camera_pos: new e.bL(t),\n          u_opacity: new e.bM(t),\n          u_baseColorFactor: new e.cb(t),\n          u_emissiveFactor: new e.cb(t),\n          u_metallicFactor: new e.bM(t),\n          u_roughnessFactor: new e.bM(t),\n          u_baseTextureIsAlpha: new e.bN(t),\n          u_alphaMask: new e.bN(t),\n          u_alphaCutoff: new e.bM(t),\n          u_baseColorTexture: new e.bN(t),\n          u_metallicRoughnessTexture: new e.bN(t),\n          u_normalTexture: new e.bN(t),\n          u_occlusionTexture: new e.bN(t),\n          u_emissionTexture: new e.bN(t),\n          u_lutTexture: new e.bN(t),\n          u_color_mix: new e.cb(t),\n          u_aoIntensity: new e.bM(t),\n          u_emissive_strength: new e.bM(t),\n          u_occlusionTextureTransform: new e.cb(t)\n        }),\n        modelDepth: t => ({\n          u_matrix: new e.bJ(t),\n          u_instance: new e.bJ(t),\n          u_node_matrix: new e.bJ(t)\n        }),\n        groundShadow: t => ({\n          u_matrix: new e.bJ(t),\n          u_ground_shadow_factor: new e.bL(t)\n        }),\n        stars: t => ({\n          u_matrix: new e.bJ(t),\n          u_up: new e.bL(t),\n          u_right: new e.bL(t),\n          u_intensity_multiplier: new e.bM(t)\n        }),\n        snowParticle: t => ({\n          u_modelview: new e.bJ(t),\n          u_projection: new e.bJ(t),\n          u_time: new e.bM(t),\n          u_cam_pos: new e.bL(t),\n          u_velocityConeAperture: new e.bM(t),\n          u_velocity: new e.bM(t),\n          u_horizontalOscillationRadius: new e.bM(t),\n          u_horizontalOscillationRate: new e.bM(t),\n          u_boxSize: new e.bM(t),\n          u_billboardSize: new e.bM(t),\n          u_simpleShapeParameters: new e.bK(t),\n          u_screenSize: new e.bK(t),\n          u_thinningCenterPos: new e.bK(t),\n          u_thinningShape: new e.bL(t),\n          u_thinningAffectedRatio: new e.bM(t),\n          u_thinningParticleOffset: new e.bM(t),\n          u_particleColor: new e.cb(t),\n          u_direction: new e.bL(t)\n        }),\n        rainParticle: t => ({\n          u_modelview: new e.bJ(t),\n          u_projection: new e.bJ(t),\n          u_time: new e.bM(t),\n          u_cam_pos: new e.bL(t),\n          u_texScreen: new e.bN(t),\n          u_velocityConeAperture: new e.bM(t),\n          u_velocity: new e.bM(t),\n          u_boxSize: new e.bM(t),\n          u_rainDropletSize: new e.bK(t),\n          u_distortionStrength: new e.bM(t),\n          u_rainDirection: new e.bL(t),\n          u_color: new e.cb(t),\n          u_screenSize: new e.bK(t),\n          u_thinningCenterPos: new e.bK(t),\n          u_thinningShape: new e.bL(t),\n          u_thinningAffectedRatio: new e.bM(t),\n          u_thinningParticleOffset: new e.bM(t),\n          u_shapeDirectionalPower: new e.bM(t),\n          u_shapeNormalPower: new e.bM(t),\n          u_mode: new e.bM(t)\n        }),\n        vignette: t => ({\n          u_vignetteShape: new e.bL(t),\n          u_vignetteColor: new e.cb(t)\n        }),\n        occlusion: t => ({\n          u_matrix: new e.bJ(t),\n          u_anchorPos: new e.bL(t),\n          u_screenSizePx: new e.bK(t),\n          u_occluderSizePx: new e.bK(t),\n          u_color: new e.cb(t)\n        })\n      };\n    class Sr {\n      constructor(e, t, i, o) {\n        this.id = Sr.uniqueIdxCounter, Sr.uniqueIdxCounter++, this.context = e;\n        const s = e.gl;\n        this.buffer = s.createBuffer(), this.dynamicDraw = Boolean(i), this.context.unbindVAO(), e.bindElementBuffer.set(this.buffer), s.bufferData(s.ELEMENT_ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? s.DYNAMIC_DRAW : s.STATIC_DRAW), this.dynamicDraw || o || t.destroy();\n      }\n      bind() {\n        this.context.bindElementBuffer.set(this.buffer);\n      }\n      updateData(e) {\n        this.id = Sr.uniqueIdxCounter, Sr.uniqueIdxCounter++;\n        const t = this.context.gl;\n        this.context.unbindVAO(), this.bind(), t.bufferSubData(t.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer);\n      }\n      destroy() {\n        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);\n      }\n    }\n    Sr.uniqueIdxCounter = 0;\n    const Cr = {\n      Int8: \"BYTE\",\n      Uint8: \"UNSIGNED_BYTE\",\n      Int16: \"SHORT\",\n      Uint16: \"UNSIGNED_SHORT\",\n      Int32: \"INT\",\n      Uint32: \"UNSIGNED_INT\",\n      Float32: \"FLOAT\"\n    };\n    class Ir {\n      constructor(e, t, i, o, s, r) {\n        this.length = t.length, this.attributes = i, this.itemSize = t.bytesPerElement, this.dynamicDraw = o, this.instanceCount = r, this.context = e;\n        const n = e.gl;\n        this.buffer = n.createBuffer(), e.bindVertexBuffer.set(this.buffer), n.bufferData(n.ARRAY_BUFFER, t.arrayBuffer, this.dynamicDraw ? n.DYNAMIC_DRAW : n.STATIC_DRAW), this.dynamicDraw || s || t.destroy();\n      }\n      bind() {\n        this.context.bindVertexBuffer.set(this.buffer);\n      }\n      updateData(e) {\n        const t = this.context.gl;\n        this.bind(), t.bufferSubData(t.ARRAY_BUFFER, 0, e.arrayBuffer);\n      }\n      enableAttributes(e, t) {\n        for (let i = 0; i < this.attributes.length; i++) {\n          const o = t.attributes[this.attributes[i].name];\n          void 0 !== o && e.enableVertexAttribArray(o);\n        }\n      }\n      setVertexAttribPointers(e, t, i) {\n        for (let o = 0; o < this.attributes.length; o++) {\n          const s = this.attributes[o],\n            r = t.attributes[s.name];\n          void 0 !== r && e.vertexAttribPointer(r, s.components, e[Cr[s.type]], !1, this.itemSize, s.offset + this.itemSize * (i || 0));\n        }\n      }\n      setVertexAttribDivisor(e, t, i) {\n        for (let o = 0; o < this.attributes.length; o++) {\n          const s = t.attributes[this.attributes[o].name];\n          void 0 !== s && this.instanceCount && this.instanceCount > 0 && e.vertexAttribDivisor(s, i);\n        }\n      }\n      destroy() {\n        this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);\n      }\n    }\n    class Rr {\n      constructor(e, t, i, o, s) {\n        this.context = e, this.width = t, this.height = i;\n        const r = this.framebuffer = e.gl.createFramebuffer();\n        o && (this.colorAttachment = new Is(e, r)), s && (this.depthAttachmentType = s, this.depthAttachment = \"renderbuffer\" === s ? new Rs(e, r) : new Ds(e, r));\n      }\n      destroy() {\n        const e = this.context.gl;\n        if (this.colorAttachment) {\n          const t = this.colorAttachment.get();\n          t && e.deleteTexture(t);\n        }\n        if (this.depthAttachment && this.depthAttachmentType) if (\"renderbuffer\" === this.depthAttachmentType) {\n          const t = this.depthAttachment.get();\n          t && e.deleteRenderbuffer(t);\n        } else {\n          const t = this.depthAttachment.get();\n          t && e.deleteTexture(t);\n        }\n        e.deleteFramebuffer(this.framebuffer);\n      }\n    }\n    class Dr {\n      constructor(e, t) {\n        this.gl = e, this.clearColor = new Xo(this), this.clearDepth = new Ko(this), this.clearStencil = new Yo(this), this.colorMask = new Jo(this), this.depthMask = new Qo(this), this.stencilMask = new es(this), this.stencilFunc = new ts(this), this.stencilOp = new is(this), this.stencilTest = new os(this), this.depthRange = new ss(this), this.depthTest = new rs(this), this.depthFunc = new ns(this), this.blend = new as(this), this.blendFunc = new ls(this), this.blendColor = new cs(this), this.blendEquation = new hs(this), this.cullFace = new ds(this), this.cullFaceSide = new us(this), this.frontFace = new _s(this), this.program = new ps(this), this.activeTexture = new fs(this), this.viewport = new ms(this), this.bindFramebuffer = new gs(this), this.bindRenderbuffer = new vs(this), this.bindTexture = new ys(this), this.bindVertexBuffer = new xs(this), this.bindElementBuffer = new bs(this), this.bindVertexArrayOES = new ws(this), this.pixelStoreUnpack = new Ts(this), this.pixelStoreUnpackPremultiplyAlpha = new Es(this), this.pixelStoreUnpackFlipY = new Ss(this), this.options = t ? Object.assign({}, t) : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = e.getExtension(\"EXT_texture_filter_anisotropic\") || e.getExtension(\"MOZ_EXT_texture_filter_anisotropic\") || e.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = e.getExtension(\"WEBGL_debug_renderer_info\"), this.extDebugRendererInfo && (this.renderer = e.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.forceManualRenderingForInstanceIDShaders = t && !!t.forceManualRenderingForInstanceIDShaders || this.renderer && -1 !== this.renderer.indexOf(\"PowerVR\"), this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = e.getExtension(\"OES_texture_float_linear\")), this.extRenderToTextureHalfFloat = e.getExtension(\"EXT_color_buffer_half_float\"), this.extTimerQuery = e.getExtension(\"EXT_disjoint_timer_query_webgl2\"), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), this.maxPointSize = e.getParameter(e.ALIASED_POINT_SIZE_RANGE)[1];\n      }\n      setDefault() {\n        this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();\n      }\n      setDirty() {\n        this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArrayOES.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;\n      }\n      createIndexBuffer(e, t, i) {\n        return new Sr(this, e, t, i);\n      }\n      createVertexBuffer(e, t, i, o, s) {\n        return new Ir(this, e, t, i, o, s);\n      }\n      createRenderbuffer(e, t, i) {\n        const o = this.gl,\n          s = o.createRenderbuffer();\n        return this.bindRenderbuffer.set(s), o.renderbufferStorage(o.RENDERBUFFER, e, t, i), this.bindRenderbuffer.set(null), s;\n      }\n      createFramebuffer(e, t, i, o) {\n        return new Rr(this, e, t, i, o);\n      }\n      clear({\n        color: e,\n        depth: t,\n        stencil: i,\n        colorMask: o\n      }) {\n        const s = this.gl;\n        let r = 0;\n        e && (r |= s.COLOR_BUFFER_BIT, this.clearColor.set(e), this.colorMask.set(o || [!0, !0, !0, !0])), void 0 !== t && (r |= s.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t), this.depthMask.set(!0)), void 0 !== i && (r |= s.STENCIL_BUFFER_BIT, this.clearStencil.set(i), this.stencilMask.set(255)), s.clear(r);\n      }\n      setCullFace(e) {\n        !1 === e.enable ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(e.mode), this.frontFace.set(e.frontFace));\n      }\n      setDepthMode(e) {\n        e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0), this.depthFunc.set(e.func), this.depthMask.set(e.mask), this.depthRange.set(e.range)) : this.depthTest.set(!1);\n      }\n      setStencilMode(e) {\n        e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0), this.stencilMask.set(e.mask), this.stencilOp.set([e.fail, e.depthFail, e.pass]), this.stencilFunc.set({\n          func: e.test.func,\n          ref: e.ref,\n          mask: e.test.mask\n        })) : this.stencilTest.set(!1);\n      }\n      setColorMode(t) {\n        e.bn(t.blendFunction, ki.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor), t.blendEquation ? this.blendEquation.set(t.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(t.mask);\n      }\n      unbindVAO() {\n        this.bindVertexArrayOES.set(null);\n      }\n    }\n    let Ar;\n    function Lr(t, i, o, s, r, n, a) {\n      const l = t.context,\n        c = l.gl,\n        h = t.transform,\n        d = t.getOrCreateProgram(\"collisionBox\"),\n        u = [];\n      let _ = 0,\n        p = 0;\n      for (let l = 0; l < s.length; l++) {\n        const f = s[l],\n          m = i.getTile(f),\n          g = m.getBucket(o);\n        if (!g) continue;\n        const v = li(f, g, h);\n        let y = v;\n        0 === r[0] && 0 === r[1] || (y = t.translatePosMatrix(v, m, r, n));\n        const x = a ? g.textCollisionBox : g.iconCollisionBox,\n          b = g.collisionCircleArray;\n        if (b.length > 0) {\n          const t = e.ad.mat4.create(),\n            i = y;\n          e.ad.mat4.mul(t, g.placementInvProjMatrix, h.glCoordMatrix), e.ad.mat4.mul(t, t, g.placementViewportMatrix), u.push({\n            circleArray: b,\n            circleOffset: p,\n            transform: i,\n            invTransform: t,\n            projection: g.getProjection()\n          }), _ += b.length / 4, p = _;\n        }\n        x && (t.terrain && t.terrain.setupElevationDraw(m, d), d.draw(t, c.LINES, Bi.disabled, Ui.disabled, t.colorModeForRenderPass(), ji.disabled, rr(y, h, m, g.getProjection()), o.id, x.layoutVertexBuffer, x.indexBuffer, x.segments, null, h.zoom, null, [x.collisionVertexBuffer, x.collisionVertexBufferExt]));\n      }\n      if (!a || !u.length) return;\n      const f = t.getOrCreateProgram(\"collisionCircle\"),\n        m = new e.cW();\n      m.resize(4 * _), m._trim();\n      let g = 0;\n      for (const e of u) for (let t = 0; t < e.circleArray.length / 4; t++) {\n        const i = 4 * t,\n          o = e.circleArray[i + 0],\n          s = e.circleArray[i + 1],\n          r = e.circleArray[i + 2],\n          n = e.circleArray[i + 3];\n        m.emplace(g++, o, s, r, n, 0), m.emplace(g++, o, s, r, n, 1), m.emplace(g++, o, s, r, n, 2), m.emplace(g++, o, s, r, n, 3);\n      }\n      (!Ar || Ar.length < 2 * _) && (Ar = function (t) {\n        const i = 2 * t,\n          o = new e.aV();\n        o.resize(i), o._trim();\n        for (let e = 0; e < i; e++) {\n          const t = 6 * e;\n          o.uint16[t + 0] = 4 * e + 0, o.uint16[t + 1] = 4 * e + 1, o.uint16[t + 2] = 4 * e + 2, o.uint16[t + 3] = 4 * e + 2, o.uint16[t + 4] = 4 * e + 3, o.uint16[t + 5] = 4 * e + 0;\n        }\n        return o;\n      }(_));\n      const v = l.createIndexBuffer(Ar, !0),\n        y = l.createVertexBuffer(m, e.cX.members, !0);\n      for (const i of u) {\n        const s = {\n          u_matrix: i.transform,\n          u_inv_matrix: i.invTransform,\n          u_camera_to_center_distance: (x = h).getCameraToCenterDistance(i.projection),\n          u_viewport_size: [x.width, x.height]\n        };\n        f.draw(t, c.TRIANGLES, Bi.disabled, Ui.disabled, t.colorModeForRenderPass(), ji.disabled, s, o.id, y, v, e.b8.simpleSegment(0, 2 * i.circleOffset, i.circleArray.length, i.circleArray.length / 2), null, h.zoom);\n      }\n      var x;\n      y.destroy(), v.destroy();\n    }\n    const Mr = e.ad.mat4.create();\n    function Pr(t) {\n      const i = t._camera.getWorldToCamera(t.worldSize, 1),\n        o = e.ad.mat4.multiply([], i, t.globeMatrix);\n      e.ad.mat4.invert(o, o);\n      const s = [0, 0, 0],\n        r = [0, 1, 0, 0];\n      return e.ad.vec4.transformMat4(r, r, o), s[0] = r[0], s[1] = r[1], s[2] = r[2], e.ad.vec3.normalize(s, s), s;\n    }\n    function zr({\n      width: t,\n      height: i,\n      anchor: o,\n      textOffset: s,\n      textScale: r\n    }, n) {\n      const {\n          horizontalAlign: a,\n          verticalAlign: l\n        } = e.bD(o),\n        c = -(a - .5) * t,\n        h = -(l - .5) * i,\n        d = e.bC(o, s);\n      return new e.P((c / r + d[0]) * n, (h / r + d[1]) * n);\n    }\n    function Or(t, i, o, s, r, n, a, l, c, h, d) {\n      const u = t.text.placedSymbolArray,\n        _ = t.text.dynamicLayoutVertexArray,\n        p = t.icon.dynamicLayoutVertexArray,\n        f = {},\n        m = t.getProjection(),\n        g = ci(l, m, n),\n        v = n.elevation,\n        y = m.upVectorScale(l.canonical, n.center.lat, n.worldSize).metersToTile;\n      _.clear();\n      for (let p = 0; p < u.length; p++) {\n        const x = u.get(p),\n          {\n            tileAnchorX: b,\n            tileAnchorY: w,\n            numGlyphs: T\n          } = x,\n          E = x.hidden || !x.crossTileID || t.allowVerticalPlacement && !x.placedOrientation ? null : s[x.crossTileID];\n        if (E) {\n          let s = 0,\n            u = 0,\n            p = 0;\n          if (v) {\n            const e = v ? v.getAtTileOffset(l, b, w) : 0,\n              [t, i, o] = m.upVector(l.canonical, b, w);\n            s = e * t * y, u = e * i * y, p = e * o * y;\n          }\n          let [S, C, I, R] = Wt(x.projectedAnchorX + s, x.projectedAnchorY + u, x.projectedAnchorZ + p, o ? g : a);\n          const D = $t(n.getCameraToCenterDistance(m), R);\n          let A = r.evaluateSizeForFeature(t.textSizeData, h, x) * D / e.bw;\n          o && (A *= t.tilePixelRatio / c);\n          const L = zr(E, A);\n          o ? ({\n            x: S,\n            y: C,\n            z: I\n          } = m.projectTilePoint(b + L.x, w + L.y, l.canonical), [S, C, I] = Wt(S + s, C + u, I + p, a)) : (i && L._rotate(-n.angle), S += L.x, C += L.y, I = 0);\n          const M = t.allowVerticalPlacement && x.placedOrientation === e.bq.vertical ? Math.PI / 2 : 0;\n          for (let t = 0; t < T; t++) e.bt(_, S, C, I, M);\n          d && x.associatedIconIndex >= 0 && (f[x.associatedIconIndex] = {\n            x: S,\n            y: C,\n            z: I,\n            angle: M\n          });\n        } else oi(T, _);\n      }\n      if (d) {\n        p.clear();\n        const i = t.icon.placedSymbolArray;\n        for (let t = 0; t < i.length; t++) {\n          const o = i.get(t),\n            {\n              numGlyphs: s\n            } = o,\n            r = f[t];\n          if (o.hidden || !r) oi(s, p);else {\n            const {\n              x: t,\n              y: i,\n              z: o,\n              angle: n\n            } = r;\n            for (let r = 0; r < s; r++) e.bt(p, t, i, o, n);\n          }\n        }\n        t.icon.dynamicLayoutVertexBuffer.updateData(p);\n      }\n      t.text.dynamicLayoutVertexBuffer.updateData(_);\n    }\n    function Fr(t, i, o, s, r, n, a = {}) {\n      const l = o.paint.get(\"icon-translate\"),\n        c = o.paint.get(\"text-translate\"),\n        h = o.paint.get(\"icon-translate-anchor\"),\n        d = o.paint.get(\"text-translate-anchor\"),\n        u = o.layout.get(\"icon-rotation-alignment\"),\n        _ = o.layout.get(\"text-rotation-alignment\"),\n        p = o.layout.get(\"icon-pitch-alignment\"),\n        f = o.layout.get(\"text-pitch-alignment\"),\n        m = o.layout.get(\"icon-keep-upright\"),\n        g = o.layout.get(\"text-keep-upright\"),\n        v = o.paint.get(\"icon-color-saturation\"),\n        y = o.paint.get(\"icon-color-contrast\"),\n        x = o.paint.get(\"icon-color-brightness-min\"),\n        b = o.paint.get(\"icon-color-brightness-max\"),\n        w = \"sea\" === o.layout.get(\"symbol-elevation-reference\"),\n        T = t.context,\n        E = T.gl,\n        S = t.transform,\n        C = \"map\" === u,\n        I = \"map\" === _,\n        R = \"map\" === p,\n        D = \"map\" === f,\n        A = void 0 !== o.layout.get(\"symbol-sort-key\").constantOr(1);\n      let L = !1;\n      const M = t.depthModeForSublayer(0, Bi.ReadOnly),\n        P = [e.av(S.center.lng), e.aC(S.center.lat)],\n        z = o.layout.get(\"text-variable-anchor\"),\n        O = \"globe\" === S.projection.name,\n        F = [],\n        k = [0, -1, 0];\n      for (const r of s) {\n        const s = i.getTile(r),\n          n = s.getBucket(o);\n        if (!n) continue;\n        if (\"mercator\" === n.projection.name && O) continue;\n        if (n.fullyClipped) continue;\n        const u = \"globe\" === n.projection.name,\n          _ = u ? e.ag(S.zoom) : 0,\n          p = ci(r, n.getProjection(), S),\n          f = S.calculatePixelsToTileUnitsMatrix(s),\n          T = z && n.hasTextData(),\n          M = n.hasIconTextFit() && T && n.hasIconData(),\n          B = n.getProjection().createInversionMatrix(S, r.canonical),\n          N = e => {\n            S.depthOcclusionForSymbolsAndCircles && (o.hasInitialOcclusionOpacityProperties || t.terrain) && (e.push(\"DEPTH_D24\"), e.push(\"DEPTH_OCCLUSION\"));\n          },\n          U = () => {\n            const i = C && \"point\" !== o.layout.get(\"symbol-placement\"),\n              a = [];\n            N(a);\n            const c = i || M,\n              d = o.paint.get(\"icon-image-cross-fade\").constantOr(0);\n            t.terrainRenderModeElevated() && R && a.push(\"PITCH_WITH_MAP_TERRAIN\"), u && (a.push(\"PROJECTION_GLOBE_VIEW\"), c && a.push(\"PROJECTED_POS_ON_VIEWPORT\")), d > 0 && a.push(\"ICON_TRANSITION\"), n.icon.zOffsetVertexBuffer && a.push(\"Z_OFFSET\"), 0 === v && 0 === y && 0 === x && 1 === b || a.push(\"COLOR_ADJUSTMENT\"), n.sdfIcons && a.push(\"RENDER_SDF\");\n            const g = n.icon.programConfigurations.get(o.id),\n              T = t.getOrCreateProgram(\"symbol\", {\n                config: g,\n                defines: a\n              }),\n              I = s.imageAtlasTexture ? s.imageAtlasTexture.size : [0, 0],\n              D = n.iconSizeData,\n              A = e.bp(D, S.zoom),\n              L = R || 0 !== S.pitch,\n              z = qt(p, s.tileID.canonical, R, C, S, n.getProjection(), f),\n              F = Zt(p, s.tileID.canonical, R, C, S, n.getProjection(), f),\n              U = t.translatePosMatrix(F, s, l, h, !0),\n              V = t.translatePosMatrix(p, s, l, h),\n              G = c ? Mr : z,\n              j = C && !R && !i;\n            let q = k;\n            !O && !S.mercatorFromTransition || C || (q = Pr(S));\n            const H = u ? q : k,\n              Z = o.getColorAdjustmentMatrix(v, y, x, b),\n              W = vr(D.kind, A, j, R, t, V, G, U, w, !1, I, [0, 0], !0, r, _, P, B, H, n.getProjection(), Z, d),\n              $ = s.imageAtlasTexture ? s.imageAtlasTexture : null,\n              X = 1 !== o.layout.get(\"icon-size\").constantOr(0) || n.iconsNeedLinear,\n              K = n.sdfIcons || t.options.rotating || t.options.zooming || X || L ? E.LINEAR : E.NEAREST,\n              Y = n.sdfIcons && 0 !== o.paint.get(\"icon-halo-width\").constantOr(1),\n              J = t.terrain && R && i ? e.ad.mat4.invert(e.ad.mat4.create(), z) : Mr;\n            if (i && n.icon) {\n              const e = S.elevation,\n                i = e ? e.getAtTileOffsetFunc(r, S.center.lat, S.worldSize, n.getProjection()) : null,\n                o = Ht(p, s.tileID.canonical, R, C, S, n.getProjection(), f);\n              Kt(n, p, t, !1, o, F, R, m, i, r);\n            }\n            return {\n              program: T,\n              buffers: n.icon,\n              uniformValues: W,\n              atlasTexture: $,\n              atlasTextureIcon: null,\n              atlasInterpolation: K,\n              atlasInterpolationIcon: null,\n              isSDF: n.sdfIcons,\n              hasHalo: Y,\n              tile: s,\n              labelPlaneMatrixInv: J\n            };\n          },\n          V = () => {\n            const i = I && \"point\" !== o.layout.get(\"symbol-placement\"),\n              a = [],\n              l = i || z || M;\n            t.terrainRenderModeElevated() && D && a.push(\"PITCH_WITH_MAP_TERRAIN\"), u && (a.push(\"PROJECTION_GLOBE_VIEW\"), l && a.push(\"PROJECTED_POS_ON_VIEWPORT\")), n.text.zOffsetVertexBuffer && a.push(\"Z_OFFSET\"), n.iconsInText && a.push(\"RENDER_TEXT_AND_SYMBOL\"), a.push(\"RENDER_SDF\"), N(a);\n            const h = n.text.programConfigurations.get(o.id),\n              m = t.getOrCreateProgram(\"symbol\", {\n                config: h,\n                defines: a\n              });\n            let v,\n              y = [0, 0],\n              x = null;\n            const b = n.textSizeData;\n            n.iconsInText && (y = s.imageAtlasTexture ? s.imageAtlasTexture.size : [0, 0], x = s.imageAtlasTexture ? s.imageAtlasTexture : null, v = D || 0 !== S.pitch || t.options.rotating || t.options.zooming || \"composite\" === b.kind || \"camera\" === b.kind ? E.LINEAR : E.NEAREST);\n            const T = s.glyphAtlasTexture ? s.glyphAtlasTexture.size : [0, 0],\n              C = o.layout.get(\"text-size-scale-range\"),\n              R = e.ay(t.scaleFactor, C[0], C[1]),\n              A = e.bp(b, S.zoom, R),\n              L = qt(p, s.tileID.canonical, D, I, S, n.getProjection(), f),\n              F = Zt(p, s.tileID.canonical, D, I, S, n.getProjection(), f),\n              U = t.translatePosMatrix(F, s, c, d, !0),\n              V = t.translatePosMatrix(p, s, c, d),\n              G = l ? Mr : L,\n              j = I && !D && !i;\n            let q = k;\n            !O && !S.mercatorFromTransition || I || (q = Pr(S));\n            const H = vr(b.kind, A, j, D, t, V, G, U, w, !0, T, y, !0, r, _, P, B, u ? q : k, n.getProjection(), null, null, R),\n              Z = s.glyphAtlasTexture ? s.glyphAtlasTexture : null,\n              W = E.LINEAR,\n              $ = 0 !== o.paint.get(\"text-halo-width\").constantOr(1),\n              X = t.terrain && D && i ? e.ad.mat4.invert(e.ad.mat4.create(), L) : Mr;\n            if (i && n.text) {\n              const e = S.elevation,\n                i = e ? e.getAtTileOffsetFunc(r, S.center.lat, S.worldSize, n.getProjection()) : null,\n                o = Ht(p, s.tileID.canonical, D, I, S, n.getProjection(), f);\n              Kt(n, p, t, !0, o, F, D, g, i, r);\n            }\n            return {\n              program: m,\n              buffers: n.text,\n              uniformValues: H,\n              atlasTexture: Z,\n              atlasTextureIcon: x,\n              atlasInterpolation: W,\n              atlasInterpolationIcon: v,\n              isSDF: !0,\n              hasHalo: $,\n              tile: s,\n              labelPlaneMatrixInv: X\n            };\n          },\n          G = n.icon.segments.get().length,\n          j = n.text.segments.get().length,\n          q = G && !a.onlyText ? U() : null,\n          H = j && !a.onlyIcons ? V() : null,\n          Z = o.paint.get(\"icon-opacity\").constantOr(1),\n          W = o.paint.get(\"text-opacity\").constantOr(1);\n        if (A && n.canOverlap) {\n          L = !0;\n          const t = Z && !a.onlyText ? n.icon.segments.get() : [],\n            i = W && !a.onlyIcons ? n.text.segments.get() : [];\n          for (const i of t) F.push({\n            segments: new e.b8([i]),\n            sortKey: i.sortKey,\n            state: q\n          });\n          for (const t of i) F.push({\n            segments: new e.b8([t]),\n            sortKey: t.sortKey,\n            state: H\n          });\n        } else a.onlyText || F.push({\n          segments: Z ? n.icon.segments : new e.b8([]),\n          sortKey: 0,\n          state: q\n        }), a.onlyIcons || F.push({\n          segments: W ? n.text.segments : new e.b8([]),\n          sortKey: 0,\n          state: H\n        });\n      }\n      L && F.sort((e, t) => e.sortKey - t.sortKey);\n      for (const e of F) {\n        const i = e.state;\n        if (i) if (t.terrain ? t.terrain.setupElevationDraw(i.tile, i.program, {\n          useDepthForOcclusion: S.depthOcclusionForSymbolsAndCircles,\n          labelPlaneMatrixInv: i.labelPlaneMatrixInv\n        }) : t.setupDepthForOcclusion(S.depthOcclusionForSymbolsAndCircles, i.program), T.activeTexture.set(E.TEXTURE0), i.atlasTexture && i.atlasTexture.bind(i.atlasInterpolation, E.CLAMP_TO_EDGE, !0), i.atlasTextureIcon && (T.activeTexture.set(E.TEXTURE1), i.atlasTextureIcon && i.atlasTextureIcon.bind(i.atlasInterpolationIcon, E.CLAMP_TO_EDGE, !0)), t.uploadCommonLightUniforms(t.context, i.program), i.hasHalo) {\n          const s = i.uniformValues;\n          s.u_is_halo = 1, kr(i.buffers, e.segments, o, t, i.program, M, r, n, s, 2), s.u_is_halo = 0;\n        } else {\n          if (i.isSDF) {\n            const s = i.uniformValues;\n            i.hasHalo && (s.u_is_halo = 1, kr(i.buffers, e.segments, o, t, i.program, M, r, n, s, 1)), s.u_is_halo = 0;\n          }\n          kr(i.buffers, e.segments, o, t, i.program, M, r, n, i.uniformValues, 1);\n        }\n      }\n    }\n    function kr(e, t, i, o, s, r, n, a, l, c) {\n      const h = [e.dynamicLayoutVertexBuffer, e.opacityVertexBuffer, e.iconTransitioningVertexBuffer, e.globeExtVertexBuffer, e.zOffsetVertexBuffer];\n      s.draw(o, o.context.gl.TRIANGLES, r, n, a, ji.disabled, l, i.id, e.layoutVertexBuffer, e.indexBuffer, t, i.paint, o.transform.zoom, e.programConfigurations.get(i.id), h, c);\n    }\n    function Br(t, i) {\n      const o = 1 << t.canonical.z,\n        s = (i.x * o - t.canonical.x - t.wrap * o) * e.ai,\n        r = (i.y * o - t.canonical.y) * e.ai,\n        n = e.d5(i.z, i.y);\n      return e.ad.vec3.fromValues(s, r, n);\n    }\n    function Nr(t, i, o, s, r) {\n      if (!o.layout || \"none\" === o.layout.get(\"fill-elevation-reference\")) return;\n      const n = t.context.gl,\n        a = new Bi(t.context.gl.LEQUAL, Bi.ReadWrite, t.depthRangeFor3D),\n        l = new Bi(t.context.gl.GREATER, Bi.ReadWrite, t.depthRangeFor3D),\n        c = function (t) {\n          const i = e.c4(t.pitch);\n          let o = .01;\n          return t.isOrthographic && (o = e.ah(1e-4, o, e.c9(i >= Yi ? 1 : i / Yi))), 2 * o;\n        }(t.transform),\n        h = t.transform.getFreeCameraOptions().position,\n        d = \"elevatedStructuresDepthReconstruct\",\n        u = t.getOrCreateProgram(d, {\n          defines: [\"DEPTH_RECONSTRUCTION\"]\n        }),\n        _ = t.getOrCreateProgram(d);\n      for (const e of s) {\n        const s = i.getTile(e),\n          d = s.getBucket(o);\n        if (!d) continue;\n        const p = d.elevatedStructures;\n        if (!p) continue;\n        const f = d.elevationBufferData.heightRange,\n          m = Br(e.toUnwrapped(), h),\n          g = t.translatePosMatrix(e.projMatrix, s, o.paint.get(\"fill-translate\"), o.paint.get(\"fill-translate-anchor\"));\n        let v, y, x, b;\n        if (\"initialize\" === r) {\n          if (!f || f.min >= 1 || 0 === p.depthSegments.segments[0].primitiveLength) continue;\n          v = sr(g, m, c, 1, 0), y = a, x = p.depthSegments, b = u;\n        } else if (\"reset\" === r) {\n          if (!f || f.min >= 0 || 0 === p.maskSegments.segments[0].primitiveLength) continue;\n          v = sr(g, m, 0, 0, 1), y = l, x = p.maskSegments, b = u;\n        } else if (\"geometry\" === r) {\n          if (0 === p.depthSegments.segments[0].primitiveLength) continue;\n          v = sr(g, m, c, 1, 0), y = a, x = p.depthSegments, b = _;\n        }\n        b.draw(t, n.TRIANGLES, y, Ui.disabled, ki.disabled, ji.disabled, v, o.id, p.vertexBuffer, p.indexBuffer, x, o.paint, t.transform.zoom);\n      }\n    }\n    function Ur(t, i, o) {\n      const {\n          painter: s,\n          sourceCache: r,\n          layer: n,\n          coords: a,\n          colorMode: l,\n          elevationType: c,\n          terrainEnabled: h,\n          pass: d\n        } = t,\n        u = s.context.gl,\n        _ = n.paint.get(\"fill-pattern\");\n      let p = c;\n      \"road\" !== c || i && !h || (p = \"none\");\n      const f = \"road\" === p,\n        m = new Bi(s.context.gl.LEQUAL, Bi.ReadWrite, s.depthRangeFor3D),\n        g = _ && _.constantOr(1),\n        v = (t, c) => {\n          let h, d, v, y, x;\n          c ? (d = g && !n.getPaintProperty(\"fill-outline-color\") ? \"fillOutlinePattern\" : \"fillOutline\", h = u.LINES) : (d = g ? \"fillPattern\" : \"fill\", h = u.TRIANGLES);\n          for (const b of a) {\n            const a = r.getTile(b);\n            if (g && !a.patternsLoaded()) continue;\n            const w = a.getBucket(n);\n            if (!w) continue;\n            const T = i ? w.elevationBufferData : w.bufferData;\n            if (T.isEmpty()) continue;\n            s.prepareDrawTile();\n            const E = T.programConfigurations.get(n.id),\n              S = s.isTileAffectedByFog(b),\n              C = [],\n              I = [];\n            f && (C.push(\"ELEVATED_ROADS\"), I.push(T.elevatedLayoutVertexBuffer));\n            const R = s.getOrCreateProgram(d, {\n              config: E,\n              overrideFog: S,\n              defines: C\n            });\n            g && (s.context.activeTexture.set(u.TEXTURE0), a.imageAtlasTexture && a.imageAtlasTexture.bind(u.LINEAR, u.CLAMP_TO_EDGE), E.updatePaintBuffers());\n            const D = _.constantOr(null);\n            if (D && a.imageAtlas) {\n              const t = a.imageAtlas,\n                i = e.d0.from(D).getPrimary().scaleSelf(e.q.devicePixelRatio).toString(),\n                o = t.patternPositions.get(i);\n              o && E.setConstantPatternPositions(o);\n            }\n            const A = s.translatePosMatrix(b.projMatrix, a, n.paint.get(\"fill-translate\"), n.paint.get(\"fill-translate-anchor\")),\n              L = n.paint.get(\"fill-emissive-strength\");\n            if (c) {\n              y = T.lineIndexBuffer, x = T.lineSegments;\n              const e = s.terrain && s.terrain.renderingToTexture ? s.terrain.drapeBufferSize : [u.drawingBufferWidth, u.drawingBufferHeight];\n              v = \"fillOutlinePattern\" === d && g ? or(A, L, s, a, e) : ir(A, L, e);\n            } else y = T.indexBuffer, x = T.triangleSegments, v = g ? tr(A, L, s, a) : er(A, L);\n            s.uploadCommonUniforms(s.context, R, b.toUnwrapped()), R.draw(s, h, \"none\" !== p ? m : t, o || s.stencilModeForClipping(b), l, ji.disabled, v, n.id, T.layoutVertexBuffer, y, x, n.paint, s.transform.zoom, E, I);\n          }\n        };\n      s.renderPass === d && v(s.depthModeForSublayer(1, \"opaque\" === s.renderPass ? Bi.ReadWrite : Bi.ReadOnly), !1), \"none\" === p && \"translucent\" === s.renderPass && n.paint.get(\"fill-antialias\") && v(s.depthModeForSublayer(n.getPaintProperty(\"fill-outline-color\") ? 2 : 0, Bi.ReadOnly), !0);\n    }\n    function Vr(t, i, o, s, r, n, a, l) {\n      o.resetLayerRenderingStats(t);\n      const c = t.context,\n        h = c.gl,\n        d = t.transform,\n        u = o.paint.get(\"fill-extrusion-pattern\"),\n        _ = u.constantOr(1),\n        p = o.paint.get(\"fill-extrusion-opacity\"),\n        f = t.style.enable3dLights(),\n        m = o.paint.get(f && !_ ? \"fill-extrusion-ambient-occlusion-wall-radius\" : \"fill-extrusion-ambient-occlusion-radius\"),\n        g = [o.paint.get(\"fill-extrusion-ambient-occlusion-intensity\"), m],\n        v = o.layout.get(\"fill-extrusion-edge-radius\"),\n        y = v > 0 && !o.paint.get(\"fill-extrusion-rounded-roof\"),\n        x = y ? 0 : v,\n        b = \"globe\" === d.projection.name ? e.d6() : 0,\n        w = \"globe\" === d.projection.name,\n        T = w ? e.ag(d.zoom) : 0,\n        E = [e.av(d.center.lng), e.aC(d.center.lat)],\n        S = \"none\" === o.paint.get(\"fill-extrusion-flood-light-color-use-theme\").constantOr(\"default\"),\n        C = o.paint.get(\"fill-extrusion-flood-light-color\").toRenderColor(S ? null : o.lut).toArray01().slice(0, 3),\n        I = o.paint.get(\"fill-extrusion-flood-light-intensity\"),\n        R = o.paint.get(\"fill-extrusion-vertical-scale\"),\n        D = 0 !== o.paint.get(\"fill-extrusion-line-width\").constantOr(1),\n        A = o.paint.get(\"fill-extrusion-height-alignment\"),\n        L = o.paint.get(\"fill-extrusion-base-alignment\"),\n        M = Qi(t, o.paint.get(\"fill-extrusion-cutoff-fade-range\")),\n        P = [];\n      let z;\n      w && P.push(\"PROJECTION_GLOBE_VIEW\"), g[0] > 0 && P.push(\"FAUX_AO\"), y && P.push(\"ZERO_ROOF_RADIUS\"), l && P.push(\"HAS_CENTROID\"), I > 0 && P.push(\"FLOOD_LIGHT\"), M.shouldRenderCutoff && P.push(\"RENDER_CUTOFF\"), D && P.push(\"RENDER_WALL_MODE\");\n      const O = \"shadow\" === t.renderPass,\n        F = t.shadowRenderer,\n        k = O && !!F;\n      t.shadowRenderer && (t.shadowRenderer.useNormalOffset = !0);\n      let B = [0, 0, 0];\n      if (F) {\n        const e = t.style.directionalLight,\n          i = t.style.ambientLight;\n        e && i && (B = no(t.style, e, i)), O || (P.push(\"RENDER_SHADOWS\", \"DEPTH_TEXTURE\"), F.useNormalOffset && P.push(\"NORMAL_OFFSET\")), z = P.concat([\"SHADOWS_SINGLE_CASCADE\"]);\n      }\n      const N = k ? \"fillExtrusionDepth\" : _ ? \"fillExtrusionPattern\" : \"fillExtrusion\",\n        U = o.getLayerRenderingStats();\n      for (const f of s) {\n        const s = i.getTile(f),\n          m = s.getBucket(o);\n        if (!m || m.projection.name !== d.projection.name) continue;\n        let v = !1;\n        F && (v = 0 === F.getMaxCascadeForTile(f.toUnwrapped()));\n        const y = t.isTileAffectedByFog(f),\n          S = m.programConfigurations.get(o.id),\n          k = t.getOrCreateProgram(N, {\n            config: S,\n            defines: v ? z : P,\n            overrideFog: y\n          });\n        if (t.terrain && t.terrain.setupElevationDraw(s, k, {\n          useMeterToDem: !0\n        }), !m.centroidVertexBuffer) {\n          const e = k.attributes.a_centroid_pos;\n          void 0 !== e && h.vertexAttrib2f(e, 0, 0);\n        }\n        !O && F && F.setupShadows(s.tileID.toUnwrapped(), k, \"vector-tile\", s.tileID.overscaledZ), _ && (t.context.activeTexture.set(h.TEXTURE0), s.imageAtlasTexture && s.imageAtlasTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), S.updatePaintBuffers());\n        const V = u.constantOr(null);\n        if (V && s.imageAtlas) {\n          const t = s.imageAtlas,\n            i = e.d0.from(V).getPrimary().scaleSelf(e.q.devicePixelRatio),\n            o = t.patternPositions.get(i.toString());\n          o && S.setConstantPatternPositions(o);\n        }\n        const G = o.paint.get(\"fill-extrusion-vertical-gradient\"),\n          j = 1 / m.tileToMeter;\n        let q;\n        if (O && F) {\n          if (Wr(s.tileID, m, t)) continue;\n          const e = F.calculateShadowPassMatrixFromTile(s.tileID.toUnwrapped());\n          q = Js(e, x, j, R, A, L);\n        } else {\n          const e = t.translatePosMatrix(f.expandedProjMatrix, s, o.paint.get(\"fill-extrusion-translate\"), o.paint.get(\"fill-extrusion-translate-anchor\")),\n            i = d.projection.createInversionMatrix(d, f.canonical);\n          q = _ ? Qs(e, t, G, p, g, x, j, f, s, b, A, L, T, E, i, C, R) : Ys(e, t, G, p, g, x, j, f, b, A, L, T, E, i, C, R, I, B);\n        }\n        t.uploadCommonUniforms(c, k, f.toUnwrapped(), null, M);\n        let H = m.segments;\n        if (\"mercator\" === d.projection.name && !O && (H = m.getVisibleSegments(s.tileID, t.terrain, t.transform.getFrustum(0)), !H.get().length)) continue;\n        if (U) if (O) for (const e of H.get()) U.numRenderedVerticesInShadowPass += e.primitiveLength;else for (const e of H.get()) U.numRenderedVerticesInTransparentPass += e.primitiveLength;\n        const Z = [];\n        (t.terrain || l) && Z.push(m.centroidVertexBuffer), w && Z.push(m.layoutVertexExtBuffer), D && Z.push(m.wallVertexBuffer), k.draw(t, c.gl.TRIANGLES, r, n, a, ji.backCCW, q, o.id, m.layoutVertexBuffer, m.indexBuffer, H, o.paint, t.transform.zoom, S, Z);\n      }\n      t.shadowRenderer && (t.shadowRenderer.useNormalOffset = !1);\n    }\n    function Gr(t, i, o, s, r, n, a, l, c, h, d, u, _, p, f, m, g, v, y) {\n      const x = t.context,\n        b = x.gl,\n        w = t.transform,\n        T = t.transform.zoom,\n        E = [],\n        S = Qi(t, o.paint.get(\"fill-extrusion-cutoff-fade-range\"));\n      \"clear\" === h ? (E.push(\"CLEAR_SUBPASS\"), y && (E.push(\"CLEAR_FROM_TEXTURE\"), x.activeTexture.set(b.TEXTURE0), y.bind(b.LINEAR, b.CLAMP_TO_EDGE))) : \"sdf\" === h && E.push(\"SDF_SUBPASS\"), g && E.push(\"HAS_CENTROID\"), S.shouldRenderCutoff && E.push(\"RENDER_CUTOFF\");\n      const C = o.layout.get(\"fill-extrusion-edge-radius\"),\n        I = (e, i, s, h, v) => {\n          const b = i.programConfigurations.get(o.id),\n            w = t.isTileAffectedByFog(e),\n            I = t.getOrCreateProgram(\"fillExtrusionGroundEffect\", {\n              config: b,\n              defines: E,\n              overrideFog: w\n            }),\n            R = ((e, t, i, o, s, r, n, a, l, c, h) => ({\n              u_matrix: t,\n              u_opacity: i,\n              u_ao_pass: o ? 1 : 0,\n              u_meter_to_tile: s,\n              u_ao: r,\n              u_flood_light_intensity: n,\n              u_flood_light_color: a,\n              u_attenuation: l,\n              u_edge_radius: c,\n              u_fb: 0,\n              u_fb_size: h,\n              u_dynamic_offset: 1\n            }))(0, h, d, c, v, [u, _ * v], p, f, m, T >= 17 ? 0 : C * v, y ? y.size[0] : 0),\n            D = [];\n          g && D.push(i.hiddenByLandmarkVertexBuffer), t.uploadCommonUniforms(x, I, e.toUnwrapped(), null, S), I.draw(t, x.gl.TRIANGLES, r, n, a, l, R, o.id, i.vertexBuffer, i.indexBuffer, s, o.paint, T, b, D);\n        };\n      for (const r of s) {\n        const s = i.getTile(r),\n          n = s.getBucket(o);\n        if (!n || n.projection.name !== w.projection.name || !n.groundEffect || n.groundEffect && !n.groundEffect.hasData()) continue;\n        const a = n.groundEffect,\n          l = 1 / n.tileToMeter;\n        {\n          const e = t.translatePosMatrix(r.projMatrix, s, o.paint.get(\"fill-extrusion-translate\"), o.paint.get(\"fill-extrusion-translate-anchor\")),\n            i = a.getDefaultSegment();\n          I(r, a, i, e, l);\n        }\n        if (v) for (let n = 0; n < 4; n++) {\n          const a = e.d7[n](r),\n            c = i.getTile(a);\n          if (!c) continue;\n          const h = c.getBucket(o);\n          if (!h || h.projection.name !== w.projection.name || !h.groundEffect || h.groundEffect && !h.groundEffect.hasData()) continue;\n          const d = h.groundEffect;\n          let u, _;\n          0 === n ? (u = [-e.ai, 0, 0], _ = 1) : 1 === n ? (u = [e.ai, 0, 0], _ = 0) : 2 === n ? (u = [0, -e.ai, 0], _ = 3) : (u = [0, e.ai, 0], _ = 2);\n          const p = d.regionSegments[_];\n          if (!p) continue;\n          const f = new Float32Array(16);\n          e.ad.mat4.translate(f, r.projMatrix, u), I(r, d, p, t.translatePosMatrix(f, s, o.paint.get(\"fill-extrusion-translate\"), o.paint.get(\"fill-extrusion-translate-anchor\")), l);\n        }\n      }\n    }\n    function jr(t, i, o, s, r, n, a) {\n      0 === s.centroidVertexArray.length && s.createCentroidsBuffer();\n      const l = n ? n.findDEMTileFor(o) : null;\n      if (!(l && l.dem || a)) return;\n      n && l && l.dem && s.selfDEMTileTimestamp !== l.dem._timestamp && (s.borderDoneWithNeighborZ = [-1, -1, -1, -1], s.selfDEMTileTimestamp = l.dem._timestamp);\n      const c = t => new e.P(Math.ceil((t + e.da) * e.db), 0),\n        h = e => {\n          const t = i.getSource().minzoom,\n            o = e => {\n              const t = i.getTileByID(e);\n              if (t && t.hasData()) return t.getBucket(r);\n            },\n            s = [0, -1, 1];\n          for (const i of s) {\n            if (e.overscaledZ + i < t) continue;\n            const s = o(e.calculateScaledKey(e.overscaledZ + i));\n            if (s) return s;\n          }\n        },\n        d = [0, 0, 0],\n        u = (t, i) => (d[0] = Math.min(t.min.y, i.min.y), d[1] = Math.max(t.max.y, i.max.y), d[2] = e.ai - i.min.x > t.max.x ? i.min.x - e.ai : t.max.x, d),\n        _ = (t, i) => (d[0] = Math.min(t.min.x, i.min.x), d[1] = Math.max(t.max.x, i.max.x), d[2] = e.ai - i.min.y > t.max.y ? i.min.y - e.ai : t.max.y, d),\n        p = [(e, t) => u(e, t), (e, t) => u(t, e), (e, t) => _(e, t), (e, t) => _(t, e)],\n        f = (t, i, s, r, a, c, h) => {\n          if (!n) return 0;\n          const d = [[c ? s : t, c ? t : s, 0], [c ? s : i, c ? i : s, 0]],\n            u = h < 0 ? e.ai + h : h,\n            _ = [c ? u : (t + i) / 2, c ? (t + i) / 2 : u, 0];\n          return 0 === s && h < 0 || 0 !== s && h > 0 ? n.getForTilePoints(a, [_], !0, r) : d.push(_), n.getForTilePoints(o, d, !0, l), Math.max(d[0][2], d[1][2], _[2]) / n.exaggeration();\n        };\n      for (let t = 0; t < 4; t++) {\n        const i = s.borderFeatureIndices[t];\n        if (0 === i.length) continue;\n        const r = e.d7[t](o),\n          l = h(r);\n        if (!(l && l instanceof e.d8)) continue;\n        const d = n ? n.findDEMTileFor(r) : null;\n        if (!(d && d.dem || a)) continue;\n        if (n && d && d.dem && s.borderDEMTileTimestamp[t] !== d.dem._timestamp && (s.borderDoneWithNeighborZ[t] = -1, s.borderDEMTileTimestamp[t] = d.dem._timestamp), s.borderDoneWithNeighborZ[t] === l.canonical.z) continue;\n        0 === l.centroidVertexArray.length && l.createCentroidsBuffer();\n        const u = (t < 2 ? 1 : 5) - t,\n          _ = l.borderDoneWithNeighborZ[u] !== s.canonical.z,\n          v = l.borderFeatureIndices[u];\n        let y = 0;\n        if (s.canonical.z !== l.canonical.z) {\n          for (const e of i) s.showCentroid(s.featuresOnBorder[e]);\n          if (_) for (const e of v) l.showCentroid(l.featuresOnBorder[e]);\n          s.borderDoneWithNeighborZ[t] = l.canonical.z, l.borderDoneWithNeighborZ[u] = s.canonical.z;\n        }\n        for (const o of i) {\n          const i = s.featuresOnBorder[o],\n            n = s.centroidData[i.centroidDataIndex],\n            h = i.borders[t];\n          let _;\n          for (; y < v.length;) {\n            _ = l.featuresOnBorder[v[y]];\n            const e = _.borders[u];\n            if (e[1] > h[0] + 3 || e[0] > h[0] - 3) break;\n            l.showCentroid(_), y++;\n          }\n          if (_ && y < v.length) {\n            const o = y;\n            let x = 0;\n            for (; !(_.borders[u][0] > h[1] - 3) && (x++, ++y !== v.length);) _ = l.featuresOnBorder[v[y]];\n            _ = l.featuresOnBorder[v[o]];\n            let b = !1;\n            if (x >= 1) {\n              const e = _.borders[u];\n              Math.abs(h[0] - e[0]) < 3 && Math.abs(h[1] - e[1]) < 3 && (x = 1, b = !0, y = o + 1);\n            } else if (0 === x) {\n              s.showCentroid(i);\n              continue;\n            }\n            const w = l.centroidData[_.centroidDataIndex];\n            a && b && (((m = n).flags | (g = w).flags) & e.d9 ? (m.flags |= e.d9, g.flags |= e.d9) : (m.flags &= ~e.d9, g.flags &= ~e.d9));\n            const T = i.intersectsCount() > 1 || _.intersectsCount() > 1;\n            if (x > 1) y = o, n.centroidXY = w.centroidXY = new e.P(0, 0);else if (d && d.dem && !T) {\n              const i = p[t](n, w),\n                o = t % 2 ? e.ai - 1 : 0,\n                s = f(i[0], Math.min(e.ai - 1, i[1]), o, d, r, t < 2, i[2]);\n              n.centroidXY = w.centroidXY = c(s);\n            } else T ? n.centroidXY = w.centroidXY = new e.P(0, 0) : (n.centroidXY = s.encodeBorderCentroid(i), w.centroidXY = l.encodeBorderCentroid(_));\n            s.writeCentroidToBuffer(n), l.writeCentroidToBuffer(w);\n          } else s.showCentroid(i);\n        }\n        s.borderDoneWithNeighborZ[t] = l.canonical.z, l.borderDoneWithNeighborZ[u] = s.canonical.z;\n      }\n      var m, g;\n      (s.needsCentroidUpdate || !s.centroidVertexBuffer && 0 !== s.centroidVertexArray.length) && s.uploadCentroid(t);\n    }\n    const qr = [1, 0, 0],\n      Hr = [0, 1, 0],\n      Zr = [0, 0, 1];\n    function Wr(t, i, o) {\n      const s = o.transform,\n        r = o.shadowRenderer;\n      if (!r) return !0;\n      const n = t.toUnwrapped(),\n        a = s.tileSize * r._cascades[o.currentShadowCascade].scale;\n      let l = i.maxHeight;\n      if (s.elevation) {\n        const e = s.elevation.getMinMaxForTile(t);\n        e && (l += e.max);\n      }\n      const c = [...r.shadowDirection];\n      c[2] = -c[2];\n      const h = r.computeSimplifiedTileShadowVolume(n, l, a, c);\n      if (!h) return !1;\n      const d = [qr, Hr, Zr, c, [c[0], 0, c[2]], [0, c[1], c[2]]],\n        u = \"globe\" === s.projection.name,\n        _ = s.scaleZoom(a),\n        p = e.bR.fromInvProjectionMatrix(s.invProjMatrix, s.worldSize, _, !u),\n        f = r.getCurrentCascadeFrustum();\n      return 0 === p.intersectsPrecise(h.vertices, h.planes, d) || 0 === f.intersectsPrecise(h.vertices, h.planes, d);\n    }\n    function $r(t) {\n      return [t[0] * e.dc, t[1] * e.dc, t[2] * e.dc, 0];\n    }\n    function Xr(t, i, o, s, r, n, a, l, c) {\n      const h = s.getSource(),\n        d = o.globeSharedBuffers;\n      if (!d) return;\n      let u, _, p;\n      if (i && (u = s.getTile(i)), h instanceof e.aK ? (_ = h.texture, p = e.cJ(0, 0, o.transform)) : u && i && (_ = u.texture, p = e.cJ(i.canonical.z, i.canonical.x, o.transform)), !_ || !p) return;\n      t || (p = e.ad.mat4.scale(e.ad.mat4.create(), p, [1, -1, 1]));\n      const f = o.context,\n        m = f.gl,\n        g = \"nearest\" === r.paint.get(\"raster-resampling\") ? m.NEAREST : m.LINEAR,\n        v = o.colorModeForDrapableLayerRenderPass(n),\n        y = a.defines;\n      y.push(\"GLOBE_POLES\");\n      const x = new Bi(m.LEQUAL, Bi.ReadWrite, o.depthRangeFor3D),\n        b = Float32Array.from(o.transform.expandedFarZProjMatrix),\n        w = Float32Array.from(e.bc(e.cI(new e.bT(0, 0, 0))));\n      o.terrain && o.terrain.prepareDrawTile(), f.activeTexture.set(m.TEXTURE0), _.bind(g, m.CLAMP_TO_EDGE), f.activeTexture.set(m.TEXTURE1), _.bind(g, m.CLAMP_TO_EDGE), \"useMipmap\" in _ && f.extTextureFilterAnisotropic && o.transform.pitch > 20 && m.texParameterf(m.TEXTURE_2D, f.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, f.extTextureFilterAnisotropicMax);\n      const [T, E, S, C] = i ? d.getPoleBuffers(i.canonical.z, !1) : d.getPoleBuffers(0, !0),\n        I = r.paint.get(\"raster-elevation\");\n      let R;\n      t ? (R = T, o.renderDefaultNorthPole = 0 !== I) : (R = E, o.renderDefaultSouthPole = 0 !== I);\n      const D = $r(a.mix),\n        A = ((e, t, i, o, s, r, n, a, l, c, h, d, u) => dr(e, t, i, new Float32Array(16), new Float32Array(9), [0, 0], o, [0, 0], [0, 0, 0, 0], 1, {\n          opacity: 1,\n          mix: 0\n        }, r, [0, 0] || [0, 0], a, 2, c, h, d, 1, 0, u))(b, w, p, e.ag(o.transform.zoom), 0, r, 0, I, 0, D, a.offset, a.range, n),\n        L = o.getOrCreateProgram(\"raster\", {\n          defines: y\n        });\n      o.uploadCommonUniforms(f, L, null), L.draw(o, m.TRIANGLES, x, c, v, l, A, r.id, R, S, C);\n    }\n    function Kr(e) {\n      const t = e._nearZ,\n        i = e.projection.farthestPixelDistance(e),\n        o = i - t,\n        s = .2 * e.height,\n        r = t + s;\n      return [t, i, (r - s - t) / o, (r - t) / o];\n    }\n    function Yr(e, t, i, o) {\n      if (e) return t instanceof ot && e instanceof wt ? t.getTextureDescriptor(e, i, !0) : {\n        texture: e.texture,\n        mix: $r(o.mix),\n        offset: o.offset,\n        buffer: 0,\n        tileSize: 1\n      };\n    }\n    var Jr = e.dd([{\n      name: \"a_index\",\n      type: \"Int16\",\n      components: 1\n    }]);\n    class Qr {\n      constructor(t, i, o, s) {\n        const r = {\n            width: o[0],\n            height: o[1],\n            data: null\n          },\n          n = t.gl;\n        this.targetColorTexture = new e.T(t, r, n.RGBA8, {\n          useMipmap: !1\n        }), this.backgroundColorTexture = new e.T(t, r, n.RGBA8, {\n          useMipmap: !1\n        }), this.context = t, this.updateParticleTexture(i, s), this.lastInvalidatedAt = 0;\n      }\n      updateParticleTexture(t, i) {\n        if (this.particleTextureDimension === i.width) return;\n        (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy());\n        const o = this.context.gl,\n          s = i.width * i.height;\n        this.particleTexture0 = new e.T(this.context, i, o.RGBA8, {\n          premultiply: !1,\n          useMipmap: !1\n        }), this.particleTexture1 = new e.T(this.context, i, o.RGBA8, {\n          premultiply: !1,\n          useMipmap: !1\n        });\n        const r = new e.de();\n        r.reserve(s);\n        for (let e = 0; e < s; e++) r.emplaceBack(e);\n        this.particleIndexBuffer = this.context.createVertexBuffer(r, Jr.members, !0), this.particleSegment = e.b8.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = i.width;\n      }\n      update(t) {\n        return !(this.lastInvalidatedAt < t && (this.lastInvalidatedAt = e.q.now(), 1));\n      }\n      destroy() {\n        this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy();\n      }\n    }\n    function en(t, i, o) {\n      if (!t) return null;\n      const s = i.getTextureDescriptor(t, o, !0);\n      if (!s) return null;\n      let {\n        texture: r,\n        mix: n,\n        offset: a,\n        tileSize: l,\n        buffer: c,\n        format: h\n      } = s;\n      if (!r || !h) return null;\n      let d = !1;\n      return \"uint32\" === h && (d = !0, n[3] = 0, n = cr(e.df, n, [0, o.paint.get(\"raster-particle-max-speed\")]), a = hr(e.df, a, [0, o.paint.get(\"raster-particle-max-speed\")])), {\n        texture: r,\n        textureOffset: [c / (l + 2 * c), l / (l + 2 * c)],\n        tileSize: l,\n        scalarData: d,\n        scale: n,\n        offset: a,\n        defines: [\"RASTER_ARRAY\", {\n          uint8: \"DATA_FORMAT_UINT8\",\n          uint16: \"DATA_FORMAT_UINT16\",\n          uint32: \"DATA_FORMAT_UINT32\"\n        }[h]]\n      };\n    }\n    function tn(e) {\n      const t = e._nearZ,\n        i = e.projection.farthestPixelDistance(e),\n        o = i - t,\n        s = .2 * e.height,\n        r = t + s;\n      return [t, i, (r - s - t) / o, (r - t) / o];\n    }\n    const on = new e.al(1, 0, 0, 1),\n      sn = new e.al(0, 1, 0, 1),\n      rn = new e.al(0, 0, 1, 1),\n      nn = new e.al(1, 0, 1, 1),\n      an = new e.al(0, 1, 1, 1);\n    function ln(t, i, o, s, r, n, a) {\n      const l = t.context,\n        c = t.transform,\n        h = l.gl,\n        d = \"globe\" === c.projection.name,\n        u = d ? [\"PROJECTION_GLOBE_VIEW\"] : [];\n      let _ = e.ad.mat4.clone(o.projMatrix);\n      if (d && e.ag(c.zoom) > 0) {\n        const t = e.bb(o.canonical, c),\n          i = e.dg(t);\n        _ = e.ad.mat4.multiply(new Float32Array(16), c.globeMatrix, i), e.ad.mat4.multiply(_, c.projMatrix, _);\n      }\n      const p = e.ad.mat4.create();\n      p[12] += 2 * r / (e.q.devicePixelRatio * c.width), p[13] += 2 * n / (e.q.devicePixelRatio * c.height), e.ad.mat4.multiply(_, p, _);\n      const f = t.getOrCreateProgram(\"debug\", {\n          defines: u\n        }),\n        m = i.getTileByID(o.key);\n      t.terrain && t.terrain.setupElevationDraw(m, f);\n      const g = Bi.disabled,\n        v = Ui.disabled,\n        y = t.colorModeForRenderPass(),\n        x = \"$debug\";\n      l.activeTexture.set(h.TEXTURE0), t.emptyTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), d ? m._makeGlobeTileDebugBuffers(t.context, c) : m._makeDebugTileBoundsBuffers(t.context, c.projection);\n      const b = m._tileDebugBuffer || t.debugBuffer,\n        w = m._tileDebugIndexBuffer || t.debugIndexBuffer,\n        T = m._tileDebugSegments || t.debugSegments;\n      if (f.draw(t, h.LINE_STRIP, g, v, y, ji.disabled, nr(_, s), x, b, w, T, null, null, null, [m._globeTileDebugBorderBuffer]), a) {\n        const e = m.latestRawTileData,\n          i = Math.floor((e && e.byteLength || 0) / 1024);\n        let s = o.canonical.toString();\n        o.overscaledZ !== o.canonical.z && (s += ` => ${o.overscaledZ}`), s += ` ${m.state}`, s += ` ${i}kb`, function (e, t) {\n          e.initDebugOverlayCanvas();\n          const i = e.debugOverlayCanvas,\n            o = e.context.gl,\n            s = e.debugOverlayCanvas.getContext(\"2d\");\n          s.clearRect(0, 0, i.width, i.height), s.shadowColor = \"white\", s.shadowBlur = 2, s.lineWidth = 1.5, s.strokeStyle = \"white\", s.textBaseline = \"top\", s.font = \"bold 36px Open Sans, sans-serif\", s.fillText(t, 5, 5), s.strokeText(t, 5, 5), e.debugOverlayTexture.update(i), e.debugOverlayTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE);\n        }(t, s);\n      }\n      const E = i.getTile(o).tileSize,\n        S = 512 / Math.min(E, 512) * (o.overscaledZ / c.zoom) * .5,\n        C = m._tileDebugTextBuffer || t.debugBuffer,\n        I = m._tileDebugTextIndexBuffer || t.quadTriangleIndexBuffer,\n        R = m._tileDebugTextSegments || t.debugSegments;\n      f.draw(t, h.TRIANGLES, g, v, ki.alphaBlended, ji.disabled, nr(_, e.al.transparent, S), x, C, I, R, null, null, null, [m._globeTileDebugTextBuffer]);\n    }\n    function cn(e, t, i, o) {\n      dn(e, 0, t + i / 2, e.transform.width, i, o);\n    }\n    function hn(e, t, i, o) {\n      dn(e, t - i / 2, 0, i, e.transform.height, o);\n    }\n    function dn(t, i, o, s, r, n) {\n      const a = t.context,\n        l = a.gl;\n      l.enable(l.SCISSOR_TEST), l.scissor(i * e.q.devicePixelRatio, o * e.q.devicePixelRatio, s * e.q.devicePixelRatio, r * e.q.devicePixelRatio), a.clear({\n        color: n\n      }), l.disable(l.SCISSOR_TEST);\n    }\n    const un = e.dd([{\n        name: \"a_pos_3f\",\n        components: 3,\n        type: \"Float32\"\n      }]),\n      {\n        members: _n\n      } = un;\n    function pn(e, t, i, o) {\n      e.emplaceBack(t, i, o);\n    }\n    class fn {\n      constructor(t) {\n        this.vertexArray = new e.dh(), this.indices = new e.aV(), pn(this.vertexArray, -1, -1, 1), pn(this.vertexArray, 1, -1, 1), pn(this.vertexArray, -1, 1, 1), pn(this.vertexArray, 1, 1, 1), pn(this.vertexArray, -1, -1, -1), pn(this.vertexArray, 1, -1, -1), pn(this.vertexArray, -1, 1, -1), pn(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t.createVertexBuffer(this.vertexArray, _n), this.indexBuffer = t.createIndexBuffer(this.indices), this.segment = e.b8.simpleSegment(0, 0, 36, 12);\n      }\n    }\n    function mn(t, i, o, s, r, n) {\n      const a = t.context.gl,\n        l = i.paint.get(\"sky-atmosphere-color\"),\n        c = i.paint.get(\"sky-atmosphere-halo-color\"),\n        h = i.paint.get(\"sky-atmosphere-sun-intensity\"),\n        d = ((e, t, i, o, s) => ({\n          u_matrix_3f: e,\n          u_sun_direction: t,\n          u_sun_intensity: i,\n          u_color_tint_r: [o.r, o.g, o.b, o.a],\n          u_color_tint_m: [s.r, s.g, s.b, s.a],\n          u_luminance: 5e-5\n        }))(e.ad.mat3.fromMat4(e.ad.mat3.create(), s), r, h, l, c);\n      a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_CUBE_MAP_POSITIVE_X + n, i.skyboxTexture, 0), o.draw(t, a.TRIANGLES, Bi.disabled, Ui.disabled, ki.unblended, ji.frontCW, d, \"skyboxCapture\", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);\n    }\n    const gn = e.dd([{\n      type: \"Float32\",\n      name: \"a_pos\",\n      components: 3\n    }, {\n      type: \"Float32\",\n      name: \"a_uv\",\n      components: 2\n    }]);\n    class vn {\n      constructor(t) {\n        const i = new e.di();\n        i.emplaceBack(-1, 1, 1, 0, 0), i.emplaceBack(1, 1, 1, 1, 0), i.emplaceBack(1, -1, 1, 1, 1), i.emplaceBack(-1, -1, 1, 0, 1);\n        const o = new e.aV();\n        o.emplaceBack(0, 1, 2), o.emplaceBack(2, 3, 0), this.vertexBuffer = t.createVertexBuffer(i, gn.members), this.indexBuffer = t.createIndexBuffer(o), this.segments = e.b8.simpleSegment(0, 0, 4, 2);\n      }\n      destroy() {\n        this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();\n      }\n    }\n    const yn = e.dd([{\n      type: \"Float32\",\n      name: \"a_pos_3f\",\n      components: 3\n    }, {\n      type: \"Float32\",\n      name: \"a_uv\",\n      components: 2\n    }, {\n      type: \"Float32\",\n      name: \"a_size_scale\",\n      components: 1\n    }, {\n      type: \"Float32\",\n      name: \"a_fade_opacity\",\n      components: 1\n    }]);\n    class xn {\n      constructor() {\n        this.starsCount = 16e3, this.sizeMultiplier = .15, this.sizeRange = 100, this.intensityRange = 200;\n      }\n    }\n    class bn {\n      constructor(t) {\n        this.colorModeAlphaBlendedWriteRGB = new ki([1, Fi, 1, Fi], e.al.transparent, [!0, !0, !0, !1]), this.colorModeWriteAlpha = new ki([1, 0, 1, 0], e.al.transparent, [!1, !1, !1, !0]), this.params = new xn(), this.updateNeeded = !0, t.tp.registerParameter(this.params, [\"Stars\"], \"starsCount\", {\n          min: 100,\n          max: 16e3,\n          step: 1\n        }, () => {\n          this.updateNeeded = !0;\n        }), t.tp.registerParameter(this.params, [\"Stars\"], \"sizeMultiplier\", {\n          min: .01,\n          max: 2,\n          step: .01\n        }), t.tp.registerParameter(this.params, [\"Stars\"], \"sizeRange\", {\n          min: 0,\n          max: 200,\n          step: 1\n        }, () => {\n          this.updateNeeded = !0;\n        }), t.tp.registerParameter(this.params, [\"Stars\"], \"intensityRange\", {\n          min: 0,\n          max: 200,\n          step: 1\n        }, () => {\n          this.updateNeeded = !0;\n        });\n      }\n      update(t) {\n        const i = t.context;\n        if (!this.atmosphereBuffer || this.updateNeeded) {\n          this.updateNeeded = !1, this.atmosphereBuffer = new vn(i);\n          const t = this.params.sizeRange,\n            o = this.params.intensityRange,\n            s = function (t) {\n              const i = e.dl(30),\n                o = [];\n              for (let s = 0; s < t; ++s) {\n                const t = 2 * Math.PI * i(),\n                  s = Math.acos(1 - 2 * i()) - .5 * Math.PI;\n                o.push(e.ad.vec3.fromValues(Math.cos(s) * Math.cos(t), Math.cos(s) * Math.sin(t), Math.sin(s)));\n              }\n              return o;\n            }(this.params.starsCount),\n            r = e.dl(300),\n            n = new e.dj(),\n            a = new e.aV();\n          let l = 0;\n          for (let i = 0; i < s.length; ++i) {\n            const c = e.ad.vec3.scale([], s[i], 200),\n              h = Math.max(0, 1 + .01 * t * (1 * r() - .5)),\n              d = Math.max(0, 1 + .01 * o * (1 * r() - .5));\n            n.emplaceBack(c[0], c[1], c[2], -1, -1, h, d), n.emplaceBack(c[0], c[1], c[2], 1, -1, h, d), n.emplaceBack(c[0], c[1], c[2], 1, 1, h, d), n.emplaceBack(c[0], c[1], c[2], -1, 1, h, d), a.emplaceBack(l + 0, l + 1, l + 2), a.emplaceBack(l + 0, l + 2, l + 3), l += 4;\n          }\n          this.starsVx = i.createVertexBuffer(n, yn.members), this.starsIdx = i.createIndexBuffer(a), this.starsSegments = e.b8.simpleSegment(0, 0, n.length, a.length);\n        }\n      }\n      destroy() {\n        this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();\n      }\n      drawAtmosphereGlow(t, i) {\n        const o = t.context,\n          s = o.gl,\n          r = t.transform,\n          n = new Bi(s.LEQUAL, Bi.ReadOnly, [0, 1]),\n          a = e.ag(r.zoom),\n          l = t.style.getLut(i.scope),\n          c = \"none\" === i.properties.get(\"color-use-theme\"),\n          h = i.properties.get(\"color\").toRenderColor(c ? null : l).toArray01(),\n          d = \"none\" === i.properties.get(\"high-color-use-theme\"),\n          u = i.properties.get(\"high-color\").toRenderColor(d ? null : l).toArray01(),\n          _ = \"none\" === i.properties.get(\"space-color-use-theme\"),\n          p = i.properties.get(\"space-color\").toRenderColor(_ ? null : l).toArray01PremultipliedAlpha(),\n          f = 5e-4,\n          m = e.dk(i.properties.get(\"horizon-blend\"), 0, 1, f, .25),\n          g = e.cD(t, o, r) && m === f ? r.worldSize / (2 * Math.PI * 1.025) - 1 : r.globeRadius,\n          v = t.frameCounter / 1e3 % 1,\n          y = e.ad.vec3.length(r.globeCenterInViewSpace),\n          x = Math.sqrt(Math.pow(y, 2) - Math.pow(g, 2)),\n          b = Math.acos(x / y),\n          w = e => {\n            const i = \"globe\" === r.projection.name ? [\"PROJECTION_GLOBE_VIEW\", \"FOG\"] : [\"FOG\"];\n            e && i.push(\"ALPHA_PASS\");\n            const l = t.getOrCreateProgram(\"globeAtmosphere\", {\n                defines: i\n              }),\n              c = ((e, t, i, o, s, r, n, a, l, c, h, d) => ({\n                u_frustum_tl: e,\n                u_frustum_tr: t,\n                u_frustum_br: i,\n                u_frustum_bl: o,\n                u_horizon: s,\n                u_transition: r,\n                u_fadeout_range: n,\n                u_color: a,\n                u_high_color: l,\n                u_space_color: c,\n                u_temporal_offset: h,\n                u_horizon_angle: d\n              }))(r.frustumCorners.TL, r.frustumCorners.TR, r.frustumCorners.BR, r.frustumCorners.BL, r.frustumCorners.horizon, a, m, h, u, p, v, b);\n            t.uploadCommonUniforms(o, l);\n            const d = this.atmosphereBuffer;\n            d && l.draw(t, s.TRIANGLES, n, Ui.disabled, e ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, ji.backCW, c, e ? \"atmosphere_glow_alpha\" : \"atmosphere_glow\", d.vertexBuffer, d.indexBuffer, d.segments);\n          };\n        w(!1), w(!0);\n      }\n      drawStars(t, i) {\n        const o = e.ay(i.properties.get(\"star-intensity\"), 0, 1);\n        if (0 === o) return;\n        const s = t.context,\n          r = s.gl,\n          n = t.transform,\n          a = t.getOrCreateProgram(\"stars\"),\n          l = e.ad.quat.identity([]);\n        e.ad.quat.rotateX(l, l, -n._pitch), e.ad.quat.rotateZ(l, l, -n.angle), e.ad.quat.rotateX(l, l, e.ak(n._center.lat)), e.ad.quat.rotateY(l, l, -e.ak(n._center.lng));\n        const c = e.ad.mat4.fromQuat(new Float32Array(16), l),\n          h = e.ad.mat4.multiply([], n.starsProjMatrix, c),\n          d = e.ad.mat3.fromMat4([], c),\n          u = e.ad.mat3.invert([], d),\n          _ = [0, 1, 0];\n        e.ad.vec3.transformMat3(_, _, u), e.ad.vec3.scale(_, _, this.params.sizeMultiplier);\n        const p = [1, 0, 0];\n        e.ad.vec3.transformMat3(p, p, u), e.ad.vec3.scale(p, p, this.params.sizeMultiplier);\n        const f = (m = _, g = p, v = o, {\n          u_matrix: Float32Array.from(h),\n          u_up: m,\n          u_right: g,\n          u_intensity_multiplier: v\n        });\n        var m, g, v;\n        t.uploadCommonUniforms(s, a), this.starsVx && this.starsIdx && a.draw(t, r.TRIANGLES, Bi.disabled, Ui.disabled, this.colorModeAlphaBlendedWriteRGB, ji.disabled, f, \"atmosphere_stars\", this.starsVx, this.starsIdx, this.starsSegments);\n      }\n    }\n    function wn(t, i) {\n      const o = [...t],\n        s = i.cameraWorldSizeForFog / i.worldSize,\n        r = e.ad.mat4.identity([]);\n      return e.ad.mat4.scale(r, r, [s, s, 1]), e.ad.mat4.multiply(o, r, o), e.ad.mat4.multiply(o, i.worldToFogMatrix, o), o;\n    }\n    function Tn(t, i, o, s, r) {\n      const n = o.material,\n        a = s.context,\n        {\n          baseColorTexture: l,\n          metallicRoughnessTexture: c\n        } = n.pbrMetallicRoughness,\n        {\n          normalTexture: h,\n          occlusionTexture: d,\n          emissionTexture: u\n        } = n;\n      function _(e, i, o) {\n        if (e && (t.push(i), a.activeTexture.set(a.gl.TEXTURE0 + o), e.gfxTexture)) {\n          const {\n            minFilter: t,\n            magFilter: i,\n            wrapS: o,\n            wrapT: s\n          } = e.sampler;\n          e.gfxTexture.bindExtraParam(t, i, o, s);\n        }\n      }\n      _(l, \"HAS_TEXTURE_u_baseColorTexture\", Xi.BaseColor), _(c, \"HAS_TEXTURE_u_metallicRoughnessTexture\", Xi.MetallicRoughness), _(h, \"HAS_TEXTURE_u_normalTexture\", Xi.Normal), _(d, \"HAS_TEXTURE_u_occlusionTexture\", Xi.Occlusion), _(u, \"HAS_TEXTURE_u_emissionTexture\", Xi.Emission), r && (r.texture || (r.texture = new e.dn(s.context, r.image, [r.image.height, r.image.height, r.image.height], a.gl.RGBA8)), a.activeTexture.set(a.gl.TEXTURE0 + Xi.LUT), r.texture && r.texture.bind(a.gl.LINEAR, a.gl.CLAMP_TO_EDGE), t.push(\"APPLY_LUT_ON_GPU\")), o.texcoordBuffer && (t.push(\"HAS_ATTRIBUTE_a_uv_2f\"), i.push(o.texcoordBuffer)), o.colorBuffer && (t.push(12 === o.colorBuffer.itemSize ? \"HAS_ATTRIBUTE_a_color_3f\" : \"HAS_ATTRIBUTE_a_color_4f\"), i.push(o.colorBuffer)), o.normalBuffer && (t.push(\"HAS_ATTRIBUTE_a_normal_3f\"), i.push(o.normalBuffer)), o.pbrBuffer && (t.push(\"HAS_ATTRIBUTE_a_pbr\"), t.push(\"HAS_ATTRIBUTE_a_heightBasedEmissiveStrength\"), i.push(o.pbrBuffer)), \"OPAQUE\" !== n.alphaMode && \"MASK\" !== n.alphaMode || t.push(\"UNPREMULT_TEXTURE_IN_SHADER\"), n.defined || t.push(\"DIFFUSE_SHADED\");\n      const p = s.shadowRenderer;\n      p && (t.push(\"RENDER_SHADOWS\", \"DEPTH_TEXTURE\"), p.useNormalOffset && t.push(\"NORMAL_OFFSET\"));\n    }\n    function En(t, i, o, s, r, n) {\n      const a = o.paint.get(\"model-opacity\").constantOr(1),\n        l = i.context,\n        c = new Bi(i.context.gl.LEQUAL, Bi.ReadWrite, i.depthRangeFor3D),\n        h = i.transform,\n        d = t.mesh,\n        u = d.material,\n        _ = u.pbrMetallicRoughness,\n        p = i.style.fog;\n      let f;\n      f = \"pixels\" === i.transform.projection.zAxisUnit ? [...t.nodeModelMatrix] : e.ad.mat4.multiply([], s.zScaleMatrix, t.nodeModelMatrix), e.ad.mat4.multiply(f, s.negCameraPosMatrix, f);\n      const m = e.ad.mat4.invert([], f);\n      e.ad.mat4.transpose(m, m);\n      const g = \"none\" === o.paint.get(\"model-color-use-theme\").constantOr(\"default\"),\n        v = o.paint.get(\"model-emissive-strength\").constantOr(0),\n        y = wr(new Float32Array(t.worldViewProjection), new Float32Array(f), new Float32Array(m), null, i, a, _.baseColorFactor.toRenderColor(null), u.emissiveFactor, _.metallicFactor, _.roughnessFactor, u, v, o),\n        x = {\n          defines: []\n        },\n        b = [],\n        w = i.shadowRenderer;\n      w && (w.useNormalOffset = !1), Tn(x.defines, b, d, i, g ? null : o.lut);\n      let T = null;\n      if (p) {\n        const e = wn(t.nodeModelMatrix, i.transform);\n        if (T = new Float32Array(e), \"globe\" !== h.projection.name) {\n          const t = d.aabb.min,\n            i = d.aabb.max,\n            [o, s] = p.getOpacityForBounds(e, t[0], t[1], i[0], i[1]);\n          x.overrideFog = o >= Fe || s >= Fe;\n        }\n      }\n      const E = Qi(i, o.paint.get(\"model-cutoff-fade-range\"));\n      E.shouldRenderCutoff && x.defines.push(\"RENDER_CUTOFF\");\n      const S = i.getOrCreateProgram(\"model\", x);\n      i.uploadCommonUniforms(l, S, null, T, E), \"shadow\" !== i.renderPass && w && w.setupShadowsFromMatrix(t.nodeModelMatrix, S), S.draw(i, l.gl.TRIANGLES, c, r, n, d.material.doubleSided ? ji.disabled : ji.backCCW, y, o.id, d.vertexBuffer, d.indexBuffer, d.segments, o.paint, i.transform.zoom, void 0, b);\n    }\n    function Sn(t, i, o, s, r, n, a) {\n      let l;\n      l = \"globe\" === t.projection.name ? e.dp(o, t) : [...o], e.ad.mat4.multiply(l, l, i.matrix);\n      const c = e.ad.mat4.multiply([], s, l);\n      if (i.meshes) for (const o of i.meshes) {\n        if (\"BLEND\" !== o.material.alphaMode) {\n          a.push({\n            mesh: o,\n            depth: 0,\n            modelIndex: r,\n            worldViewProjection: c,\n            nodeModelMatrix: l\n          });\n          continue;\n        }\n        const i = e.ad.vec3.transformMat4([], o.centroid, c);\n        !t.isOrthographic && i[2] <= 0 || n.push({\n          mesh: o,\n          depth: i[2],\n          modelIndex: r,\n          worldViewProjection: c,\n          nodeModelMatrix: l\n        });\n      }\n      if (i.children) for (const e of i.children) Sn(t, e, o, s, r, n, a);\n    }\n    function Cn(e, t, i, o) {\n      const s = i.shadowRenderer;\n      if (!s) return;\n      const r = s.getShadowPassDepthMode(),\n        n = s.getShadowPassColorMode(),\n        a = s.calculateShadowPassMatrixFromMatrix(t),\n        l = Tr(a);\n      i.getOrCreateProgram(\"modelDepth\", {\n        defines: i._shadowMapDebug ? [] : [\"DEPTH_TEXTURE\"]\n      }).draw(i, i.context.gl.TRIANGLES, r, Ui.disabled, n, ji.backCCW, l, o.id, e.vertexBuffer, e.indexBuffer, e.segments, o.paint, i.transform.zoom, void 0, void 0);\n    }\n    function In(t, i, o) {\n      const s = i.updateZoomBasedPaintProperties(),\n        r = function (t, i, o) {\n          let s,\n            r,\n            n,\n            a = t.terrain ? t.terrain.exaggeration() : 0;\n          if (t.terrain && a > 0) {\n            const i = t.terrain,\n              r = i.findDEMTileFor(o);\n            r && r.dem ? s = e.dr.create(i, o, r) : a = 0;\n          }\n          if (0 === a && (i.terrainElevationMin = 0, i.terrainElevationMax = 0), a === i.validForExaggeration && (0 === a || s && s._demTile && s._demTile.tileID === i.validForDEMTile.id && s._dem._timestamp === i.validForDEMTile.timestamp)) return !1;\n          for (const e in i.instancesPerModel) {\n            const t = i.instancesPerModel[e];\n            for (let e = 0; e < t.instancedDataArray.length; ++e) {\n              const o = (s ? a * s.getElevationAt(0 | t.instancedDataArray.float32[16 * e], 0 | t.instancedDataArray.float32[16 * e + 1], !0, !0) : 0) + t.instancesEvaluatedElevation[e];\n              t.instancedDataArray.float32[16 * e + 6] = o, r = r ? Math.min(i.terrainElevationMin, o) : o, n = n ? Math.max(i.terrainElevationMax, o) : o;\n            }\n          }\n          return i.terrainElevationMin = r || 0, i.terrainElevationMax = n || 0, i.validForExaggeration = a, i.validForDEMTile = s && s._demTile ? {\n            id: s._demTile.tileID,\n            timestamp: s._dem._timestamp\n          } : {\n            id: void 0,\n            timestamp: 0\n          }, !0;\n        }(t, i, o);\n      (s || r) && (i.uploaded = !1, i.upload(t.context));\n    }\n    const Rn = {\n      shadowUniformsInitialized: !1,\n      useSingleShadowCascade: !1,\n      tileMatrix: new Float64Array(16),\n      shadowTileMatrix: new Float32Array(16),\n      aabb: new e.ce([0, 0, 0], [e.ai, e.ai, 0])\n    };\n    function Dn(t, i) {\n      const o = 1 << t.canonical.z,\n        s = i.getFreeCameraOptions().position,\n        r = i.elevation,\n        n = t.canonical.x / o,\n        a = (t.canonical.x + 1) / o,\n        l = t.canonical.y / o,\n        c = (t.canonical.y + 1) / o;\n      let h = i._centerAltitude;\n      if (r) {\n        const e = r.getMinMaxForTile(t);\n        e && e.max > h && (h = e.max);\n      }\n      const d = e.ay(s.x, n, a) - s.x,\n        u = e.ay(s.y, l, c) - s.y,\n        _ = e.bH(h, i.center.lat) - s.z;\n      return i._zoomFromMercatorZ(Math.sqrt(d * d + u * u + _ * _));\n    }\n    function An(e, t, i, o, s, r, n) {\n      const a = e.context,\n        l = \"shadow\" === e.renderPass,\n        c = e.shadowRenderer,\n        h = l && c ? c.getShadowPassDepthMode() : new Bi(a.gl.LEQUAL, Bi.ReadWrite, e.depthRangeFor3D),\n        d = e.isTileAffectedByFog(r);\n      if (i.meshes) for (const u of i.meshes) {\n        const _ = [\"MODEL_POSITION_ON_GPU\"],\n          p = [];\n        let f, m, g;\n        o.instancedDataArray.length > 20 && _.push(\"INSTANCED_ARRAYS\");\n        const v = Qi(e, t.paint.get(\"model-cutoff-fade-range\"));\n        if (v.shouldRenderCutoff && _.push(\"RENDER_CUTOFF\"), l && c) f = e.getOrCreateProgram(\"modelDepth\", {\n          defines: _\n        }), m = Tr(n.shadowTileMatrix, n.shadowTileMatrix, Float32Array.from(i.matrix)), g = c.getShadowPassColorMode();else {\n          Tn(_, p, u, e, \"none\" === t.paint.get(\"model-color-use-theme\").constantOr(\"default\") ? null : t.lut), f = e.getOrCreateProgram(\"model\", {\n            defines: _,\n            overrideFog: d\n          });\n          const o = u.material,\n            l = o.pbrMetallicRoughness,\n            h = t.paint.get(\"model-opacity\").constantOr(1),\n            y = t.paint.get(\"model-emissive-strength\").constantOr(0);\n          m = wr(r.expandedProjMatrix, Float32Array.from(i.matrix), new Float32Array(16), null, e, h, l.baseColorFactor.toRenderColor(null), o.emissiveFactor, l.metallicFactor, l.roughnessFactor, o, y, t, s), c && (n.shadowUniformsInitialized ? f.setShadowUniformValues(a, c.getShadowUniformValues()) : (c.setupShadows(r.toUnwrapped(), f, \"model-tile\", r.overscaledZ), n.shadowUniformsInitialized = !0)), g = v.shouldRenderCutoff || h < 1 || \"OPAQUE\" !== o.alphaMode ? ki.alphaBlended : ki.unblended;\n        }\n        e.uploadCommonUniforms(a, f, r.toUnwrapped(), null, v);\n        const y = u.material.doubleSided ? ji.disabled : ji.backCCW;\n        if (o.instancedDataArray.length > 20) p.push(o.instancedDataBuffer), f.draw(e, a.gl.TRIANGLES, h, Ui.disabled, g, y, m, t.id, u.vertexBuffer, u.indexBuffer, u.segments, t.paint, e.transform.zoom, void 0, p, o.instancedDataArray.length);else {\n          const i = l ? \"u_instance\" : \"u_normal_matrix\";\n          for (let s = 0; s < o.instancedDataArray.length; ++s) m[i] = new Float32Array(o.instancedDataArray.arrayBuffer, 64 * s, 16), f.draw(e, a.gl.TRIANGLES, h, Ui.disabled, g, y, m, t.id, u.vertexBuffer, u.indexBuffer, u.segments, t.paint, e.transform.zoom, void 0, p);\n        }\n      }\n      if (i.children) for (const a of i.children) An(e, t, a, o, s, r, n);\n    }\n    const Ln = [1, -1, 1];\n    function Mn(t, i, o, s) {\n      if (!o.modelManager) return !0;\n      const r = o.modelManager;\n      if (!o.shadowRenderer) return !0;\n      const n = o.shadowRenderer,\n        a = i.aabb;\n      let l = !0,\n        c = t.maxHeight;\n      if (0 === c) {\n        let e = 0;\n        for (const i in t.instancesPerModel) {\n          const t = r.getModel(i, s);\n          t ? e = Math.max(e, Math.max(Math.max(t.aabb.max[0], t.aabb.max[1]), t.aabb.max[2])) : l = !1;\n        }\n        c = t.maxScale * e * 1.41 + t.maxVerticalOffset, l && (t.maxHeight = c);\n      }\n      a.max[2] = c, a.min[2] += t.terrainElevationMin, a.max[2] += t.terrainElevationMax, e.ad.vec3.transformMat4(a.min, a.min, i.tileMatrix), e.ad.vec3.transformMat4(a.max, a.max, i.tileMatrix);\n      const h = a.intersects(n.getCurrentCascadeFrustum());\n      return 0 === o.currentShadowCascade && (t.isInsideFirstShadowMapFrustum = 2 === h), 0 === h;\n    }\n    function Pn(t, i) {\n      const o = t.uniformValues.u_cutoff_params[0],\n        s = t.uniformValues.u_cutoff_params[1],\n        r = t.uniformValues.u_cutoff_params[2],\n        n = t.uniformValues.u_cutoff_params[3];\n      return s === o || n === r ? 1 : e.ay(((i - o) / (s - o) - r) / (n - r), 0, 1);\n    }\n    function zn(t, i, o, s) {\n      if (i.pitch < 20) return 1;\n      const r = i.getWorldToCameraMatrix();\n      e.ad.mat4.multiply(r, r, t);\n      const n = e.ad.vec4.fromValues(o.min[0], o.min[1], o.min[2], 1);\n      let a = e.ad.vec4.transformMat4(e.ad.vec4.create(), n, r),\n        l = a,\n        c = a;\n      n[1] = o.max[1], a = e.ad.vec4.transformMat4(e.ad.vec4.create(), n, r), l = a[1] < l[1] ? a : l, c = a[1] > c[1] ? a : c, n[0] = o.max[0], a = e.ad.vec4.transformMat4(e.ad.vec4.create(), n, r), l = a[1] < l[1] ? a : l, c = a[1] > c[1] ? a : c, n[1] = o.min[1], a = e.ad.vec4.transformMat4(e.ad.vec4.create(), n, r), l = a[1] < l[1] ? a : l, c = a[1] > c[1] ? a : c;\n      const h = e.ay(s[0], 0, 1),\n        d = 100 * i.pixelsPerMeter * e.ay(s[1], 0, 1),\n        u = e.ay(s[2], 0, 1),\n        _ = e.ad.vec4.lerp(e.ad.vec4.create(), l, c, h),\n        p = Math.tan(.5 * i.fovX),\n        f = -_[2] * p;\n      if (0 === d) return _[1] < -Math.abs(f) ? u : 1;\n      const m = (-Math.abs(f) - _[1]) / d,\n        g = (e, t, i) => (1 - i) * e + i * t,\n        v = e.ay(g(1, u, m), u, 1);\n      return g(1, v, e.ay((i.pitch - 20) / 20, 0, 1));\n    }\n    class On {}\n    class Fn {\n      constructor() {\n        this._storage = new Map();\n      }\n      getLinesFromTrianglesBuffer(t, i, o) {\n        {\n          const e = this._storage.get(i.id);\n          if (e) return e.lastUsedFrameIdx = t, e.buf;\n        }\n        const s = o.gl,\n          r = s.getBufferParameter(s.ELEMENT_ARRAY_BUFFER, s.BUFFER_SIZE),\n          n = new ArrayBuffer(r),\n          a = new Int16Array(n);\n        s.getBufferSubData(s.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(n));\n        const l = new e.dt();\n        for (let e = 0; e < r / 2; e += 3) {\n          const t = a[e],\n            i = a[e + 1],\n            o = a[e + 2];\n          l.emplaceBack(t, i), l.emplaceBack(i, o), l.emplaceBack(o, t);\n        }\n        const c = o.bindVertexArrayOES.current,\n          h = new On();\n        return h.buf = new Sr(o, l), h.lastUsedFrameIdx = t, this._storage.set(i.id, h), o.bindVertexArrayOES.set(c), h.buf;\n      }\n      update(e) {\n        for (const [t, i] of this._storage) e - i.lastUsedFrameIdx > 30 && (i.buf.destroy(), this._storage.delete(t));\n      }\n      destroy() {\n        for (const [e, t] of this._storage) t.buf.destroy(), this._storage.delete(e);\n      }\n    }\n    class kn {\n      constructor(e) {\n        this.occluderSize = 30, this.depthOffset = -1e-4, e.registerParameter(this, [\"Occlusion\"], \"occluderSize\", {\n          min: 1,\n          max: 100,\n          step: 1\n        }), e.registerParameter(this, [\"Occlusion\"], \"depthOffset\", {\n          min: -.05,\n          max: 0,\n          step: 1e-5\n        });\n      }\n    }\n    const Bn = e.dd([{\n      type: \"Float32\",\n      name: \"a_pos_3f\",\n      components: 3\n    }, {\n      type: \"Float32\",\n      name: \"a_uv\",\n      components: 2\n    }, {\n      type: \"Float32\",\n      name: \"a_rainParticleData\",\n      components: 4\n    }]);\n    class Nn {\n      registerParameter() {}\n      registerButton() {}\n      registerBinding() {}\n      refreshUI() {}\n    }\n    class Un {\n      constructor(e, t) {\n        this.revealStart = 11, this.revealRange = 2, e.registerParameter(this, [...t, \"Reveal\"], \"revealStart\", {\n          min: 0,\n          max: 17,\n          step: .05\n        }), e.registerParameter(this, [...t, \"Reveal\"], \"revealRange\", {\n          min: .1,\n          max: 5.1,\n          step: .05\n        });\n      }\n    }\n    const Vn = e.dd([{\n      type: \"Float32\",\n      name: \"a_pos_2f\",\n      components: 2\n    }]);\n    class Gn {\n      destroy() {\n        this.vignetteVx && this.vignetteVx.destroy(), this.vignetteIdx && this.vignetteIdx.destroy();\n      }\n      draw(t, i) {\n        const o = t.getOrCreateProgram(\"vignette\");\n        if (!this.vignetteVx || !this.vignetteIdx) {\n          const i = new e.du(),\n            o = new e.aV();\n          i.emplaceBack(-1, -1), i.emplaceBack(1, -1), i.emplaceBack(1, 1), i.emplaceBack(-1, 1), o.emplaceBack(0, 1, 2), o.emplaceBack(0, 2, 3), this.vignetteVx = t.context.createVertexBuffer(i, Vn.members), this.vignetteIdx = t.context.createIndexBuffer(o);\n        }\n        const s = e.b8.simpleSegment(0, 0, 4, 6);\n        if (this.vignetteVx && this.vignetteIdx) {\n          t.uploadCommonUniforms(t.context, o);\n          const e = {\n            u_vignetteShape: (r = {\n              vignetteShape: [i.start, i.range, Math.pow(10, i.fadePower)],\n              vignetteColor: [i.color.r, i.color.g, i.color.b, i.color.a * i.strength]\n            }).vignetteShape,\n            u_vignetteColor: r.vignetteColor\n          };\n          o.draw(t, t.context.gl.TRIANGLES, Bi.disabled, Ui.disabled, ki.alphaBlended, ji.disabled, e, \"vignette\", this.vignetteVx, this.vignetteIdx, s);\n        }\n        var r;\n      }\n    }\n    class jn {\n      constructor() {\n        this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;\n      }\n      update(t, i) {\n        const o = t.getFreeCameraOptions().position,\n          s = o.toAltitude(),\n          r = o.toLngLat(),\n          n = e.ak(r.lng),\n          a = e.ak(r.lat),\n          l = t.pixelsPerMeter / i,\n          c = n * e.dv,\n          h = e.dv * Math.log(Math.tan(Math.PI / 4 + a / 2));\n        if (void 0 === this._offsetXPrev) this._offsetXPrev = 0, this._offsetYPrev = 0, this._elevationPrev = 0, this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;else {\n          const e = -this._offsetYPrev + h,\n            t = -this._elevationPrev + s;\n          this._accumulatedOffsetX += (-this._offsetXPrev + c) * l, this._accumulatedOffsetY += e * l, this._accumulatedElevation += t * l, this._offsetXPrev = c, this._offsetYPrev = h, this._elevationPrev = s;\n        }\n      }\n      getPosition() {\n        return [this._accumulatedOffsetX, this._accumulatedOffsetY, this._accumulatedElevation];\n      }\n    }\n    function qn(e, t) {\n      return [-(e[0] - Math.floor(e[0] / t) * t), -(e[1] - Math.floor(e[1] / t) * t), -(e[2] - Math.floor(e[2] / t) * t)];\n    }\n    function Hn(t) {\n      const i = e.dl(1323123451230),\n        o = [];\n      for (let s = 0; s < t; ++s) {\n        const t = 2 * i() - 1,\n          s = 2 * i() - 1,\n          r = 2 * i() - 1;\n        o.push(e.ad.vec3.fromValues(t, s, r));\n      }\n      return o;\n    }\n    function Zn(t, i, o, s, r) {\n      const n = e.ay((r - o) / (s - o), 0, 1);\n      return (1 - n) * t + n * i;\n    }\n    class Wn {\n      constructor(e) {\n        this._movement = new jn(), this._accumulatedTimeFromStart = 0, this._prevTime = Date.now() / 1e3, this._vignette = new Gn(), this._ppmScaleFactor = e;\n      }\n      destroy() {\n        this.particlesVx && this.particlesVx.destroy(), this.particlesIdx && this.particlesIdx.destroy(), this._vignette && this._vignette.destroy();\n      }\n      updateOnRender(t, i) {\n        const o = t.transform;\n        this._movement.update(o, this._ppmScaleFactor);\n        const s = o.starsProjMatrix,\n          r = e.ad.quat.identity([]);\n        e.ad.quat.rotateX(r, r, e.ak(90) - o._pitch), e.ad.quat.rotateZ(r, r, -o.angle);\n        const n = e.ad.mat4.fromQuat(new Float32Array(16), r),\n          a = e.ad.mat4.fromValues(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1),\n          l = e.ad.mat4.transpose([], a),\n          c = e.ad.mat4.multiply([], l, n),\n          h = Date.now() / 1e3;\n        return this._accumulatedTimeFromStart += (h - this._prevTime) * i, this._prevTime = h, {\n          projectionMatrix: s,\n          modelviewMatrix: c\n        };\n      }\n    }\n    class $n extends Wn {\n      constructor(e) {\n        super(4.25), this._params = {\n          overrideStyleParameters: !1,\n          intensity: .5,\n          timeFactor: 1,\n          velocityConeAperture: 0,\n          velocity: 300,\n          boxSize: 2500,\n          dropletSizeX: 1,\n          dropletSizeYScale: 10,\n          distortionStrength: 70,\n          screenThinning: {\n            intensity: .57,\n            start: .46,\n            range: 1.17,\n            fadePower: .17,\n            affectedRatio: 1,\n            particleOffset: -.2\n          },\n          color: {\n            r: .66,\n            g: .68,\n            b: .74,\n            a: .7\n          },\n          direction: {\n            x: -50,\n            y: -35\n          },\n          shapeDirPower: 2,\n          shapeNormalPower: 1\n        }, this._revealParams = new Un(e.tp, [\"Precipitation\", \"Rain\"]), this._vignetteParams = {\n          strength: 1,\n          start: .7,\n          range: 1,\n          fadePower: .4,\n          color: {\n            r: .27,\n            g: .27,\n            b: .27,\n            a: 1\n          }\n        }, this.particlesCount = 16e3;\n      }\n      update(t) {\n        const i = t.context;\n        if (!this.particlesVx) {\n          const t = Hn(this.particlesCount),\n            o = new e.dw(),\n            s = new e.aV();\n          let r = 0;\n          const n = e.dl(1323123451230);\n          for (let e = 0; e < t.length; ++e) {\n            const i = t[e],\n              a = [2 * n() - 1, n(), n(), n()];\n            o.emplaceBack(i[0], i[1], i[2], -1, -1, ...a), o.emplaceBack(i[0], i[1], i[2], 1, -1, ...a), o.emplaceBack(i[0], i[1], i[2], 1, 1, ...a), o.emplaceBack(i[0], i[1], i[2], -1, 1, ...a), s.emplaceBack(r + 0, r + 1, r + 2), s.emplaceBack(r + 0, r + 2, r + 3), r += 4;\n          }\n          this.particlesVx = i.createVertexBuffer(o, Bn.members), this.particlesIdx = i.createIndexBuffer(s);\n        }\n      }\n      draw(t) {\n        if (!this._params.overrideStyleParameters && !t.style.rain) return;\n        const i = this._params.overrideStyleParameters ? this._revealParams : {\n            revealStart: 0,\n            revealRange: .01\n          },\n          o = t.transform.zoom;\n        if (i.revealStart > o) return;\n        const s = Zn(0, 1, i.revealStart, i.revealStart + i.revealRange, o);\n        if (!this.particlesVx || !this.particlesIdx) return;\n        const r = structuredClone(this._params);\n        let n = [-r.direction.x, r.direction.y, -100];\n        e.ad.vec3.normalize(n, n);\n        const a = structuredClone(this._vignetteParams);\n        a.strength *= s, r.overrideStyleParameters || (r.intensity = t.style.rain.state.density, r.timeFactor = t.style.rain.state.intensity, r.color = structuredClone(t.style.rain.state.color), n = structuredClone(t.style.rain.state.direction), r.screenThinning.intensity = t.style.rain.state.centerThinning, r.dropletSizeX = t.style.rain.state.dropletSize[0], r.dropletSizeYScale = t.style.rain.state.dropletSize[1] / t.style.rain.state.dropletSize[0], r.distortionStrength = 100 * t.style.rain.state.distortionStrength, a.strength = 1, a.color = structuredClone(t.style.rain.state.vignetteColor));\n        const l = this.updateOnRender(t, r.timeFactor),\n          c = t.context,\n          h = c.gl,\n          d = t.transform;\n        this.screenTexture && this.screenTexture.size[0] === t.width && this.screenTexture.size[1] === t.height || (this.screenTexture = new e.T(c, {\n          width: t.width,\n          height: t.height,\n          data: null\n        }, h.RGBA8)), r.distortionStrength > 0 && (c.activeTexture.set(h.TEXTURE0), this.screenTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE), h.copyTexSubImage2D(h.TEXTURE_2D, 0, 0, 0, 0, 0, t.width, t.height));\n        const u = t.getOrCreateProgram(\"rainParticle\");\n        t.uploadCommonUniforms(c, u), c.activeTexture.set(h.TEXTURE0), this.screenTexture.bind(h.LINEAR, h.CLAMP_TO_EDGE);\n        const _ = [r.color.r, r.color.g, r.color.b, r.color.a],\n          p = (i, o) => {\n            const s = qn(this._movement.getPosition(), i),\n              a = r.dropletSizeX,\n              c = r.dropletSizeX * r.dropletSizeYScale,\n              p = t.width / 2,\n              f = t.height / 2,\n              m = Zn(0, r.screenThinning.start, 0, 1, r.screenThinning.intensity),\n              g = Zn(.001, r.screenThinning.range, 0, 1, r.screenThinning.intensity),\n              v = Zn(0, r.screenThinning.particleOffset, 0, 1, r.screenThinning.intensity),\n              y = (x = {\n                modelview: l.modelviewMatrix,\n                projection: l.projectionMatrix,\n                time: this._accumulatedTimeFromStart,\n                camPos: s,\n                velocityConeAperture: r.velocityConeAperture,\n                velocity: r.velocity,\n                boxSize: i,\n                rainDropletSize: [a, c],\n                distortionStrength: r.distortionStrength,\n                rainDirection: n,\n                color: _,\n                screenSize: [d.width, d.height],\n                thinningCenterPos: [p, f],\n                thinningShape: [m, g, Math.pow(10, r.screenThinning.fadePower)],\n                thinningAffectedRatio: r.screenThinning.affectedRatio,\n                thinningParticleOffset: v,\n                shapeDirectionalPower: r.shapeDirPower,\n                shapeNormalPower: r.shapeNormalPower,\n                mode: o ? 0 : 1\n              }, {\n                u_modelview: Float32Array.from(x.modelview),\n                u_projection: Float32Array.from(x.projection),\n                u_time: x.time,\n                u_cam_pos: x.camPos,\n                u_texScreen: 0,\n                u_velocityConeAperture: x.velocityConeAperture,\n                u_velocity: x.velocity,\n                u_boxSize: x.boxSize,\n                u_rainDropletSize: x.rainDropletSize,\n                u_distortionStrength: x.distortionStrength,\n                u_rainDirection: x.rainDirection,\n                u_color: x.color,\n                u_screenSize: x.screenSize,\n                u_thinningCenterPos: x.thinningCenterPos,\n                u_thinningShape: x.thinningShape,\n                u_thinningAffectedRatio: x.thinningAffectedRatio,\n                u_thinningParticleOffset: x.thinningParticleOffset,\n                u_shapeDirectionalPower: x.shapeDirectionalPower,\n                u_shapeNormalPower: x.shapeNormalPower,\n                u_mode: x.mode\n              });\n            var x;\n            const b = Math.round(r.intensity * this.particlesCount),\n              w = e.b8.simpleSegment(0, 0, 4 * b, 2 * b);\n            u.draw(t, h.TRIANGLES, Bi.disabled, Ui.disabled, ki.alphaBlended, ji.disabled, y, \"rain_particles\", this.particlesVx, this.particlesIdx, w);\n          };\n        r.distortionStrength > 0 && p(r.boxSize, !0), p(r.boxSize, !1), this._vignette.draw(t, a);\n      }\n    }\n    const Xn = e.dd([{\n      type: \"Float32\",\n      name: \"a_pos_3f\",\n      components: 3\n    }, {\n      type: \"Float32\",\n      name: \"a_uv\",\n      components: 2\n    }, {\n      type: \"Float32\",\n      name: \"a_snowParticleData\",\n      components: 4\n    }, {\n      type: \"Float32\",\n      name: \"a_snowParticleDataHorizontalOscillation\",\n      components: 2\n    }]);\n    class Kn extends Wn {\n      constructor(e) {\n        super(2.25), this._params = {\n          overrideStyleParameters: !1,\n          intensity: .85,\n          timeFactor: .75,\n          velocityConeAperture: 70,\n          velocity: 40,\n          horizontalOscillationRadius: 4,\n          horizontalOscillationRate: 1.5,\n          boxSize: 2e3,\n          billboardSize: 2,\n          shapeFadeStart: .27,\n          shapeFadePower: .21,\n          screenThinning: {\n            intensity: .4,\n            start: .15,\n            range: 1.4,\n            fadePower: .24,\n            affectedRatio: 1,\n            particleOffset: -.2\n          },\n          color: {\n            r: 1,\n            g: 1,\n            b: 1,\n            a: 1\n          },\n          direction: {\n            x: -50,\n            y: -35\n          }\n        }, this._revealParams = new Un(e.tp, [\"Precipitation\", \"Snow\"]), this._vignetteParams = {\n          strength: .3,\n          start: .78,\n          range: .46,\n          fadePower: .2,\n          color: {\n            r: 1,\n            g: 1,\n            b: 1,\n            a: 1\n          }\n        }, this.particlesCount = 16e3;\n      }\n      update(t) {\n        const i = t.context;\n        if (!this.particlesVx) {\n          const t = Hn(this.particlesCount),\n            o = new e.dx(),\n            s = new e.aV();\n          let r = 0;\n          const n = e.dl(1323123451230);\n          for (let e = 0; e < t.length; ++e) {\n            const i = t[e],\n              a = n(),\n              l = n(),\n              c = n(),\n              h = [e / t.length, a, l, c],\n              d = [n(), n()];\n            o.emplaceBack(i[0], i[1], i[2], -1, -1, ...h, ...d), o.emplaceBack(i[0], i[1], i[2], 1, -1, ...h, ...d), o.emplaceBack(i[0], i[1], i[2], 1, 1, ...h, ...d), o.emplaceBack(i[0], i[1], i[2], -1, 1, ...h, ...d), s.emplaceBack(r + 0, r + 1, r + 2), s.emplaceBack(r + 0, r + 2, r + 3), r += 4;\n          }\n          this.particlesVx = i.createVertexBuffer(o, Xn.members), this.particlesIdx = i.createIndexBuffer(s);\n        }\n      }\n      draw(t) {\n        if (!this._params.overrideStyleParameters && !t.style.snow) return;\n        const i = structuredClone(this._params);\n        let o = [-i.direction.x, i.direction.y, -100];\n        e.ad.vec3.normalize(o, o);\n        const s = structuredClone(this._vignetteParams),\n          r = i.overrideStyleParameters ? this._revealParams : {\n            revealStart: 0,\n            revealRange: .01\n          },\n          n = t.transform.zoom;\n        if (r.revealStart > n) return;\n        const a = Zn(0, 1, r.revealStart, r.revealStart + r.revealRange, n);\n        s.strength *= a, i.overrideStyleParameters || (i.intensity = t.style.snow.state.density, i.timeFactor = t.style.snow.state.intensity, i.color = structuredClone(t.style.snow.state.color), o = structuredClone(t.style.snow.state.direction), i.screenThinning.intensity = t.style.snow.state.centerThinning, i.billboardSize = 2.79 * t.style.snow.state.flakeSize, s.strength = 1, s.color = structuredClone(t.style.snow.state.vignetteColor));\n        const l = this.updateOnRender(t, i.timeFactor);\n        if (!this.particlesVx || !this.particlesIdx) return;\n        const c = t.context,\n          h = c.gl,\n          d = t.transform,\n          u = t.getOrCreateProgram(\"snowParticle\");\n        t.uploadCommonUniforms(c, u), ((i, s, r) => {\n          const n = qn(this._movement.getPosition(), i),\n            a = d.width / 2,\n            c = d.height / 2,\n            _ = Zn(0, r.screenThinning.start, 0, 1, r.screenThinning.intensity),\n            p = Zn(.001, r.screenThinning.range, 0, 1, r.screenThinning.intensity),\n            f = Zn(0, r.screenThinning.particleOffset, 0, 1, r.screenThinning.intensity),\n            m = (g = {\n              modelview: l.modelviewMatrix,\n              projection: l.projectionMatrix,\n              time: this._accumulatedTimeFromStart,\n              camPos: n,\n              velocityConeAperture: r.velocityConeAperture,\n              velocity: r.velocity,\n              horizontalOscillationRadius: r.horizontalOscillationRadius,\n              horizontalOscillationRate: r.horizontalOscillationRate,\n              boxSize: i,\n              billboardSize: 1 * r.billboardSize,\n              simpleShapeParameters: [r.shapeFadeStart, r.shapeFadePower],\n              screenSize: [d.width, d.height],\n              thinningCenterPos: [a, c],\n              thinningShape: [_, p, Math.pow(10, r.screenThinning.fadePower)],\n              thinningAffectedRatio: r.screenThinning.affectedRatio,\n              thinningParticleOffset: f,\n              color: [r.color.r, r.color.g, r.color.b, r.color.a],\n              direction: o\n            }, {\n              u_modelview: Float32Array.from(g.modelview),\n              u_projection: Float32Array.from(g.projection),\n              u_time: g.time,\n              u_cam_pos: g.camPos,\n              u_velocityConeAperture: g.velocityConeAperture,\n              u_velocity: g.velocity,\n              u_horizontalOscillationRadius: g.horizontalOscillationRadius,\n              u_horizontalOscillationRate: g.horizontalOscillationRate,\n              u_boxSize: g.boxSize,\n              u_billboardSize: g.billboardSize,\n              u_simpleShapeParameters: g.simpleShapeParameters,\n              u_screenSize: g.screenSize,\n              u_thinningCenterPos: g.thinningCenterPos,\n              u_thinningShape: g.thinningShape,\n              u_thinningAffectedRatio: g.thinningAffectedRatio,\n              u_thinningParticleOffset: g.thinningParticleOffset,\n              u_particleColor: g.color,\n              u_direction: g.direction\n            });\n          var g;\n          const v = Math.round(r.intensity * this.particlesCount),\n            y = e.b8.simpleSegment(0, 0, 4 * v, 2 * v);\n          this.particlesVx && this.particlesIdx && u.draw(t, h.TRIANGLES, Bi.disabled, Ui.disabled, ki.alphaBlended, ji.disabled, m, \"snow_particles\", this.particlesVx, this.particlesIdx, y);\n        })(i.boxSize, 0, i), this._vignette.draw(t, s);\n      }\n    }\n    const Yn = {\n        symbol: function (t, i, o, s, r) {\n          if (\"translucent\" !== t.renderPass) return;\n          const n = Ui.disabled,\n            a = t.colorModeForRenderPass(),\n            l = o.layout.get(\"text-variable-anchor\"),\n            c = o.layout.get(\"text-size-scale-range\"),\n            h = e.ay(t.scaleFactor, c[0], c[1]);\n          l && function (t, i, o, s, r, n, a, l) {\n            const c = i.transform,\n              h = \"map\" === r,\n              d = \"map\" === n;\n            for (const i of t) {\n              const t = s.getTile(i),\n                r = t.getBucket(o);\n              if (!r || !r.text || !r.text.segments.get().length) continue;\n              const n = e.bp(r.textSizeData, c.zoom, l),\n                u = ci(i, r.getProjection(), c),\n                _ = c.calculatePixelsToTileUnitsMatrix(t),\n                p = qt(u, t.tileID.canonical, d, h, c, r.getProjection(), _),\n                f = r.hasIconTextFit() && r.hasIconData();\n              if (n) {\n                const o = Math.pow(2, c.zoom - t.tileID.overscaledZ);\n                Or(r, h, d, a, e.cY, c, p, i, o, n, f);\n              }\n            }\n          }(s, t, o, i, o.layout.get(\"text-rotation-alignment\"), o.layout.get(\"text-pitch-alignment\"), r, h);\n          const d = 0 !== o.paint.get(\"icon-opacity\").constantOr(1),\n            u = 0 !== o.paint.get(\"text-opacity\").constantOr(1);\n          void 0 !== o.layout.get(\"symbol-sort-key\").constantOr(1) && (d || u) ? Fr(t, i, o, s, n, a) : (d && Fr(t, i, o, s, n, a, {\n            onlyIcons: !0\n          }), u && Fr(t, i, o, s, n, a, {\n            onlyText: !0\n          })), i.map.showCollisionBoxes && (Lr(t, i, o, s, o.paint.get(\"text-translate\"), o.paint.get(\"text-translate-anchor\"), !0), Lr(t, i, o, s, o.paint.get(\"icon-translate\"), o.paint.get(\"icon-translate-anchor\"), !1));\n        },\n        circle: function (t, i, o, s) {\n          if (\"translucent\" !== t.renderPass) return;\n          const r = o.paint.get(\"circle-opacity\"),\n            n = o.paint.get(\"circle-stroke-width\"),\n            a = o.paint.get(\"circle-stroke-opacity\"),\n            l = void 0 !== o.layout.get(\"circle-sort-key\").constantOr(1),\n            c = o.paint.get(\"circle-emissive-strength\");\n          if (0 === r.constantOr(1) && (0 === n.constantOr(1) || 0 === a.constantOr(1))) return;\n          const h = t.context,\n            d = h.gl,\n            u = t.transform,\n            _ = t.depthModeForSublayer(0, Bi.ReadOnly),\n            p = Ui.disabled,\n            f = t.colorModeForDrapableLayerRenderPass(c),\n            m = \"globe\" === u.projection.name,\n            g = [e.av(u.center.lng), e.aC(u.center.lat)],\n            v = [];\n          for (let r = 0; r < s.length; r++) {\n            const n = s[r],\n              a = i.getTile(n),\n              c = a.getBucket(o);\n            if (!c || c.projection.name !== u.projection.name) continue;\n            const h = c.programConfigurations.get(o.id),\n              d = e.cZ(o),\n              _ = t.isTileAffectedByFog(n);\n            m && d.push(\"PROJECTION_GLOBE_VIEW\"), d.push(\"DEPTH_D24\"), t.terrain && u.depthOcclusionForSymbolsAndCircles && d.push(\"DEPTH_OCCLUSION\");\n            const p = t.getOrCreateProgram(\"circle\", {\n                config: h,\n                defines: d,\n                overrideFog: _\n              }),\n              f = c.layoutVertexBuffer,\n              y = c.globeExtVertexBuffer,\n              x = c.indexBuffer,\n              b = u.projection.createInversionMatrix(u, n.canonical),\n              w = {\n                programConfiguration: h,\n                program: p,\n                layoutVertexBuffer: f,\n                globeExtVertexBuffer: y,\n                indexBuffer: x,\n                uniformValues: e.c_(t, n, a, b, g, o),\n                tile: a\n              };\n            if (l) {\n              const t = c.segments.get();\n              for (const i of t) v.push({\n                segments: new e.b8([i]),\n                sortKey: i.sortKey,\n                state: w\n              });\n            } else v.push({\n              segments: c.segments,\n              sortKey: 0,\n              state: w\n            });\n          }\n          l && v.sort((e, t) => e.sortKey - t.sortKey);\n          const y = {\n            useDepthForOcclusion: u.depthOcclusionForSymbolsAndCircles\n          };\n          for (const e of v) {\n            const {\n                programConfiguration: i,\n                program: s,\n                layoutVertexBuffer: r,\n                globeExtVertexBuffer: n,\n                indexBuffer: a,\n                uniformValues: l,\n                tile: c\n              } = e.state,\n              m = e.segments;\n            t.terrain && t.terrain.setupElevationDraw(c, s, y), t.uploadCommonUniforms(h, s, c.tileID.toUnwrapped()), s.draw(t, d.TRIANGLES, _, p, f, ji.disabled, l, o.id, r, a, m, o.paint, u.zoom, i, [n]);\n          }\n        },\n        heatmap: function (t, i, o, s) {\n          if (0 !== o.paint.get(\"heatmap-opacity\")) if (\"offscreen\" === t.renderPass) {\n            const r = t.context,\n              n = r.gl,\n              a = Ui.disabled,\n              l = new ki([n.ONE, n.ONE, n.ONE, n.ONE], e.al.transparent, [!0, !0, !0, !0]);\n            !function (e, t, i, o) {\n              const s = e.gl,\n                r = t.width * o,\n                n = t.height * o;\n              e.activeTexture.set(s.TEXTURE1), e.viewport.set([0, 0, r, n]);\n              let a = i.heatmapFbo;\n              if (!a || a && (a.width !== r || a.height !== n)) {\n                a && a.destroy();\n                const t = s.createTexture();\n                s.bindTexture(s.TEXTURE_2D, t), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.LINEAR), s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, s.LINEAR), a = i.heatmapFbo = e.createFramebuffer(r, n, !0, null), function (e, t, i, o, s, r) {\n                  const n = e.gl;\n                  n.texImage2D(n.TEXTURE_2D, 0, e.extRenderToTextureHalfFloat ? n.RGBA16F : n.RGBA, s, r, 0, n.RGBA, e.extRenderToTextureHalfFloat ? n.HALF_FLOAT : n.UNSIGNED_BYTE, null), o.colorAttachment.set(i);\n                }(e, 0, t, a, r, n);\n              } else s.bindTexture(s.TEXTURE_2D, a.colorAttachment.get()), e.bindFramebuffer.set(a.framebuffer);\n            }(r, t, o, \"globe\" === t.transform.projection.name ? .5 : .25), r.clear({\n              color: e.al.transparent\n            });\n            const c = t.transform,\n              h = \"globe\" === c.projection.name,\n              d = h ? [\"PROJECTION_GLOBE_VIEW\"] : [],\n              u = h ? ji.frontCCW : ji.disabled,\n              _ = [e.av(c.center.lng), e.aC(c.center.lat)];\n            for (let e = 0; e < s.length; e++) {\n              const p = s[e];\n              if (i.hasRenderableParent(p)) continue;\n              const f = i.getTile(p),\n                m = f.getBucket(o);\n              if (!m || m.projection.name !== c.projection.name) continue;\n              const g = t.isTileAffectedByFog(p),\n                v = m.programConfigurations.get(o.id),\n                y = t.getOrCreateProgram(\"heatmap\", {\n                  config: v,\n                  defines: d,\n                  overrideFog: g\n                }),\n                {\n                  zoom: x\n                } = t.transform;\n              t.terrain && t.terrain.setupElevationDraw(f, y), t.uploadCommonUniforms(r, y, p.toUnwrapped());\n              const b = c.projection.createInversionMatrix(c, p.canonical);\n              y.draw(t, n.TRIANGLES, Bi.disabled, a, l, u, lr(t, p, f, b, _, x, o.paint.get(\"heatmap-intensity\")), o.id, m.layoutVertexBuffer, m.indexBuffer, m.segments, o.paint, t.transform.zoom, v, h ? [m.globeExtVertexBuffer] : null);\n            }\n            r.viewport.set([0, 0, t.width, t.height]);\n          } else \"translucent\" === t.renderPass && (t.context.setColorMode(t.colorModeForRenderPass()), function (t, i) {\n            const o = t.context,\n              s = o.gl,\n              r = i.heatmapFbo;\n            if (!r) return;\n            o.activeTexture.set(s.TEXTURE0), s.bindTexture(s.TEXTURE_2D, r.colorAttachment.get()), o.activeTexture.set(s.TEXTURE1);\n            let n = i.colorRampTexture;\n            n || (n = i.colorRampTexture = new e.T(o, i.colorRamp, s.RGBA8)), n.bind(s.LINEAR, s.CLAMP_TO_EDGE), t.getOrCreateProgram(\"heatmapTexture\").draw(t, s.TRIANGLES, Bi.disabled, Ui.disabled, t.colorModeForRenderPass(), ji.disabled, ((e, t, i, o) => ({\n              u_image: 0,\n              u_color_ramp: 1,\n              u_opacity: t.paint.get(\"heatmap-opacity\")\n            }))(0, i), i.id, t.viewportBuffer, t.quadTriangleIndexBuffer, t.viewportSegments, i.paint, t.transform.zoom);\n          }(t, o));\n        },\n        line: function (t, i, o, s) {\n          if (\"translucent\" !== t.renderPass) return;\n          const r = o.paint.get(\"line-opacity\"),\n            n = o.paint.get(\"line-width\");\n          if (0 === r.constantOr(1) || 0 === n.constantOr(1)) return;\n          const a = o.paint.get(\"line-emissive-strength\"),\n            l = o.paint.get(\"line-occlusion-opacity\"),\n            c = o.layout.get(\"line-elevation-reference\"),\n            h = \"meters\" === o.layout.get(\"line-width-unit\"),\n            d = \"sea\" === c,\n            u = t.context,\n            _ = u.gl;\n          if (o.hasElevatedBuckets && \"globe\" === t.transform.projection.name) return;\n          const p = o.layout.get(\"line-cross-slope\"),\n            f = void 0 !== p,\n            m = p < 1,\n            g = t.colorModeForDrapableLayerRenderPass(a),\n            v = t.terrain && t.terrain.renderingToTexture,\n            y = v ? 1 : e.q.devicePixelRatio,\n            x = o.paint.get(\"line-dasharray\"),\n            b = x.constantOr(1),\n            w = o.layout.get(\"line-cap\"),\n            T = x.constantOr(null),\n            E = w.constantOr(null),\n            S = o.paint.get(\"line-pattern\"),\n            C = S.constantOr(1),\n            I = S.constantOr(null),\n            R = o.paint.get(\"line-opacity\").constantOr(1);\n          let D = !C && 1 !== R || t.depthOcclusion && l > 0 && l < 1;\n          const A = o.paint.get(\"line-gradient\"),\n            L = C ? \"linePattern\" : \"line\",\n            M = e.c$(o);\n          let P;\n          if (v && t.terrain && t.terrain.clipOrMaskOverlapStencilType() && (D = !1), 0 !== l && t.depthOcclusion) {\n            const t = o.paint._values[\"line-opacity\"];\n            t && t.value && \"constant\" === t.value.kind ? P = t.value : e.w(`Occlusion opacity for layer ${o.id} is supported only when line-opacity isn't data-driven.`);\n          }\n          \"constant\" !== n.value.kind && !1 === n.value.isLineProgressConstant && M.push(\"VARIABLE_LINE_WIDTH\");\n          const z = (s, r, n, a, c, p) => {\n            for (const f of s) {\n              const s = i.getTile(f);\n              if (C && !s.patternsLoaded()) continue;\n              const m = s.getBucket(o);\n              if (!m) continue;\n              if (m.hasZOffset && !c || !m.hasZOffset && c) continue;\n              t.prepareDrawTile();\n              const x = m.programConfigurations.get(o.id),\n                w = t.isTileAffectedByFog(f),\n                S = t.getOrCreateProgram(L, {\n                  config: x,\n                  defines: r,\n                  overrideFog: w,\n                  overrideRtt: !c && void 0\n                });\n              if (I && s.imageAtlas) {\n                const t = e.d0.from(I).getPrimary().scaleSelf(y).toString(),\n                  i = s.imageAtlas.patternPositions.get(t);\n                i && x.setConstantPatternPositions(i);\n              }\n              if (!C && T && E && s.lineAtlas) {\n                const e = s.lineAtlas.getDash(T, E);\n                e && x.setConstantPatternPositions(e);\n              }\n              let [M, z] = o.paint.get(\"line-trim-offset\");\n              if (\"round\" === E || \"square\" === E) {\n                const e = 1;\n                M !== z && (0 === M && (M -= e), 1 === z && (z += e));\n              }\n              const O = v ? f.projMatrix : null,\n                F = h ? 1 / m.tileToMeter / e.at(s, 1, t.transform.zoom) : 1,\n                k = h ? 1 / m.tileToMeter / e.at(s, 1, Math.floor(t.transform.zoom)) : 1,\n                B = C ? e.d1(t, s, o, O, y, F, k, [M, z]) : e.d2(t, s, o, O, m.lineClipsArray.length, y, F, k, [M, z]);\n              if (A) {\n                const s = m.gradients[o.id];\n                let r = s.texture;\n                if (o.gradientVersion !== s.version) {\n                  let n = 256;\n                  if (o.stepInterpolant) {\n                    const o = i.getSource().maxzoom,\n                      s = f.canonical.z === o ? Math.ceil(1 << t.transform.maxZoom - f.canonical.z) : 1;\n                    n = e.ay(e.d3(m.maxLineLength / e.ai * 1024 * s), 256, u.maxTextureSize);\n                  }\n                  s.gradient = e.d4({\n                    expression: o.gradientExpression(),\n                    evaluationKey: \"lineProgress\",\n                    resolution: n,\n                    image: s.gradient || void 0,\n                    clips: m.lineClipsArray\n                  }), s.texture ? s.texture.update(s.gradient) : s.texture = new e.T(u, s.gradient, _.RGBA8), s.version = o.gradientVersion, r = s.texture;\n                }\n                u.activeTexture.set(_.TEXTURE1), r.bind(o.stepInterpolant ? _.NEAREST : _.LINEAR, _.CLAMP_TO_EDGE);\n              }\n              b && (u.activeTexture.set(_.TEXTURE0), s.lineAtlasTexture && s.lineAtlasTexture.bind(_.LINEAR, _.REPEAT), x.updatePaintBuffers()), C && (u.activeTexture.set(_.TEXTURE0), s.imageAtlasTexture && s.imageAtlasTexture.bind(_.LINEAR, _.CLAMP_TO_EDGE), x.updatePaintBuffers()), c && !d && t.terrain.setupElevationDraw(s, S), t.uploadCommonUniforms(u, S, f.toUnwrapped());\n              const N = e => {\n                null != P && (P.value = R * l), S.draw(t, _.TRIANGLES, n, e, g, ji.disabled, B, o.id, m.layoutVertexBuffer, m.indexBuffer, m.segments, o.paint, t.transform.zoom, x, [m.layoutVertexBuffer2, m.patternVertexBuffer, m.zOffsetVertexBuffer]), null != P && (P.value = R);\n              };\n              if (D && !c) {\n                const e = t.stencilModeForClipping(f).ref;\n                0 === e && v && u.clear({\n                  stencil: 0\n                });\n                const i = {\n                  func: _.EQUAL,\n                  mask: 255\n                };\n                B.u_alpha_discard_threshold = .8, N(new Ui(i, e, 255, _.KEEP, _.KEEP, _.INVERT)), B.u_alpha_discard_threshold = 0, N(new Ui(i, e, 255, _.KEEP, _.KEEP, _.KEEP));\n              } else B.u_alpha_discard_threshold = D && c && p ? .8 : 0, N(c ? a : t.stencilModeForClipping(f));\n            }\n          };\n          if (o.hasNonElevatedBuckets) {\n            const i = !v && t.terrain;\n            0 !== l && i ? e.w(`Occlusion opacity for layer ${o.id} is supported on terrain only if the layer has line-z-offset enabled.`) : i ? e.w(`Cannot render non-elevated lines in immediate mode when terrain is enabled. Layer: ${o.id}.`) : z(s, M, t.depthModeForSublayer(0, Bi.ReadOnly), Ui.disabled, !1, !0);\n          }\n          if (o.hasElevatedBuckets) {\n            M.push(\"ELEVATED\"), f && M.push(m ? \"CROSS_SLOPE_HORIZONTAL\" : \"CROSS_SLOPE_VERTICAL\"), d && M.push(\"ELEVATION_REFERENCE_SEA\");\n            const e = D ? t.stencilModeFor3D() : Ui.disabled,\n              i = new Bi(t.depthOcclusion ? _.GREATER : _.LEQUAL, Bi.ReadOnly, t.depthRangeFor3D);\n            t.forceTerrainMode = !0, z(s, M, i, e, !0, !0), D && z(s, M, i, e, !0, !1), t.forceTerrainMode = !1;\n          }\n          D && (t.resetStencilClippingMasks(), v && u.clear({\n            stencil: 0\n          })), 0 === l || t.depthOcclusion || v || t.layersWithOcclusionOpacity.push(t.currentLayer);\n        },\n        fill: function (t, i, o, s) {\n          const r = o.paint.get(\"fill-color\"),\n            n = o.paint.get(\"fill-opacity\");\n          if (0 === n.constantOr(1)) return;\n          const a = o.paint.get(\"fill-emissive-strength\"),\n            l = t.colorModeForDrapableLayerRenderPass(a),\n            c = o.paint.get(\"fill-pattern\"),\n            h = t.opaquePassEnabledForLayer() && !c.constantOr(1) && 1 === r.constantOr(e.al.transparent).a && 1 === n.constantOr(0) ? \"opaque\" : \"translucent\";\n          let d = \"none\";\n          \"none\" !== o.layout.get(\"fill-elevation-reference\") ? d = \"road\" : 0 !== o.paint.get(\"fill-z-offset\").constantOr(1) && (d = \"offset\");\n          const u = !(!t.terrain || !t.terrain.enabled),\n            _ = {\n              painter: t,\n              sourceCache: i,\n              layer: o,\n              coords: s,\n              colorMode: l,\n              elevationType: d,\n              terrainEnabled: u,\n              pass: h\n            };\n          if (\"offset\" !== d) {\n            if (Ur(_, !1), \"road\" === d) {\n              const e = !u && \"translucent\" === t.renderPass;\n              e && Nr(t, i, o, s, \"geometry\"), Ur(_, !0, Ui.disabled), e && function (e) {\n                const {\n                    painter: t,\n                    sourceCache: i,\n                    layer: o,\n                    coords: s,\n                    colorMode: r\n                  } = e,\n                  n = t.context.gl,\n                  a = new Bi(t.context.gl.LEQUAL, Bi.ReadOnly, t.depthRangeFor3D);\n                for (const e of s) {\n                  const s = i.getTile(e),\n                    l = s.getBucket(o);\n                  if (!l) continue;\n                  const c = l.elevatedStructures;\n                  if (!c || !c.renderableSegments || 0 === c.renderableSegments.segments[0].primitiveLength) continue;\n                  t.prepareDrawTile();\n                  const h = l.bufferData.programConfigurations.get(o.id),\n                    d = t.isTileAffectedByFog(e),\n                    u = t.getOrCreateProgram(\"elevatedStructures\", {\n                      config: h,\n                      overrideFog: d,\n                      defines: [\"NORMAL_OFFSET\"]\n                    }),\n                    _ = {\n                      u_matrix: t.translatePosMatrix(e.projMatrix, s, o.paint.get(\"fill-translate\"), o.paint.get(\"fill-translate-anchor\"))\n                    };\n                  t.uploadCommonUniforms(t.context, u, e.toUnwrapped()), u.draw(t, n.TRIANGLES, a, Ui.disabled, r, ji.backCCW, _, o.id, c.vertexBuffer, c.indexBuffer, c.renderableSegments, o.paint, t.transform.zoom, h, [c.vertexBufferNormal]);\n                }\n              }(_);\n            }\n          } else Ur(_, !1, t.stencilModeFor3D());\n        },\n        \"fill-extrusion\": function (t, i, o, s) {\n          const r = o.paint.get(\"fill-extrusion-opacity\"),\n            n = t.context,\n            a = n.gl,\n            l = t.terrain,\n            c = l && l.renderingToTexture;\n          if (0 === r) return;\n          const h = t.conflationActive && t.style.isLayerClipped(o, i.getSource()),\n            d = t.style.order.indexOf(o.fqid);\n          if (h && function (e, t, i, o, s) {\n            for (const r of o) {\n              const o = t.getTile(r).getBucket(i);\n              o && (o.updateReplacement(r, e.replacementSource, s), o.uploadCentroid(e.context));\n            }\n          }(t, i, o, s, d), l || h) for (const e of s) {\n            const s = i.getTile(e).getBucket(o);\n            s && jr(t.context, i, e, s, o, l, h);\n          }\n          if (\"shadow\" === t.renderPass && t.shadowRenderer) {\n            const n = t.shadowRenderer;\n            if (l && r < .65 && o._transitionablePaint._values[\"fill-extrusion-opacity\"].value.expression instanceof e.ab) return;\n            const a = n.getShadowPassDepthMode(),\n              c = n.getShadowPassColorMode();\n            Vr(t, i, o, s, a, Ui.disabled, c, h);\n          } else if (\"translucent\" === t.renderPass) {\n            const d = !o.paint.get(\"fill-extrusion-pattern\").constantOr(1),\n              u = o.paint.get(\"fill-extrusion-color\").constantOr(e.al.white);\n            if (!c && 0 !== u.a) {\n              const e = new Bi(t.context.gl.LEQUAL, Bi.ReadWrite, t.depthRangeFor3D);\n              1 === r && d ? Vr(t, i, o, s, e, Ui.disabled, ki.unblended, h) : (Vr(t, i, o, s, e, Ui.disabled, ki.disabled, h), Vr(t, i, o, s, e, t.stencilModeFor3D(), t.colorModeForRenderPass(), h), t.resetStencilClippingMasks());\n            }\n            if (t.style.enable3dLights() && d && (!l && \"globe\" !== t.transform.projection.name || c)) {\n              const r = o.paint.get(\"fill-extrusion-opacity\"),\n                d = o.paint.get(\"fill-extrusion-ambient-occlusion-intensity\"),\n                u = o.paint.get(\"fill-extrusion-ambient-occlusion-ground-radius\"),\n                _ = o.paint.get(\"fill-extrusion-flood-light-intensity\"),\n                p = \"none\" === o.paint.get(\"fill-extrusion-flood-light-color-use-theme\").constantOr(\"default\"),\n                f = o.paint.get(\"fill-extrusion-flood-light-color\").toRenderColor(p ? null : o.lut).toArray01().slice(0, 3),\n                m = d > 0 && u > 0,\n                g = _ > 0,\n                v = (e, t, i) => (1 - i) * e + i * t,\n                y = n => {\n                  const l = t.depthModeForSublayer(1, Bi.ReadOnly, a.LEQUAL, !0),\n                    c = o.paint.get(n ? \"fill-extrusion-ambient-occlusion-ground-attenuation\" : \"fill-extrusion-flood-light-ground-attenuation\"),\n                    p = v(.1, 3, c),\n                    m = t._showOverdrawInspector;\n                  if (!m) {\n                    const c = new Ui({\n                        func: a.ALWAYS,\n                        mask: 255\n                      }, 255, 255, a.KEEP, a.KEEP, a.REPLACE),\n                      m = new ki([a.ONE, a.ONE, a.ONE, a.ONE], e.al.transparent, [!1, !1, !1, !0], a.MIN);\n                    Gr(t, i, o, s, l, c, m, ji.disabled, n, \"sdf\", r, d, u, _, f, p, h, !1);\n                  }\n                  {\n                    const c = m ? Ui.disabled : new Ui({\n                        func: a.EQUAL,\n                        mask: 255\n                      }, 255, 255, a.KEEP, a.DECR, a.DECR),\n                      g = m ? t.colorModeForRenderPass() : new ki([a.ONE_MINUS_DST_ALPHA, a.DST_ALPHA, a.ONE, a.ONE], e.al.transparent, [!0, !0, !0, !0]);\n                    Gr(t, i, o, s, l, c, g, ji.disabled, n, \"color\", r, d, u, _, f, p, h, !1);\n                  }\n                };\n              if (c) {\n                const c = (n, l, c) => {\n                  const p = t.depthModeForSublayer(1, Bi.ReadOnly, a.LEQUAL, !1),\n                    m = o.paint.get(n ? \"fill-extrusion-ambient-occlusion-ground-attenuation\" : \"fill-extrusion-flood-light-ground-attenuation\"),\n                    g = v(.1, 3, m);\n                  {\n                    const c = new ki([a.ONE, a.ONE, a.ONE, a.ONE], e.al.transparent, [!1, !1, !1, !0]);\n                    Gr(t, i, o, s, p, Ui.disabled, c, ji.disabled, n, \"clear\", r, d, u, _, f, g, h, l);\n                  }\n                  {\n                    const c = new Ui({\n                        func: a.ALWAYS,\n                        mask: 255\n                      }, 255, 255, a.KEEP, a.KEEP, a.REPLACE),\n                      m = new ki([a.ONE, a.ONE, a.ONE, a.ONE], e.al.transparent, [!1, !1, !1, !0], a.MIN);\n                    Gr(t, i, o, s, p, c, m, ji.disabled, n, \"sdf\", r, d, u, _, f, g, h, l);\n                  }\n                  {\n                    const c = n ? a.ZERO : a.ONE_MINUS_DST_ALPHA,\n                      m = new Ui({\n                        func: a.EQUAL,\n                        mask: 255\n                      }, 255, 255, a.KEEP, a.DECR, a.DECR),\n                      v = new ki([c, a.DST_ALPHA, a.ONE_MINUS_DST_ALPHA, a.ZERO], e.al.transparent, [!0, !0, !0, !0]);\n                    Gr(t, i, o, s, p, m, v, ji.disabled, n, \"color\", r, d, u, _, f, g, h, l);\n                  }\n                  {\n                    const m = new ki([a.ONE, a.ONE, a.ONE, n ? a.ZERO : a.ONE], e.al.transparent, [!1, !1, !1, !0], n ? a.FUNC_ADD : a.MAX);\n                    Gr(t, i, o, s, p, Ui.disabled, m, ji.disabled, n, \"clear\", r, d, u, _, f, g, h, l, c);\n                  }\n                };\n                if (m || g) {\n                  let i;\n                  if (t.prepareDrawTile(), l) {\n                    const t = l.drapeBufferSize[0],\n                      o = l.drapeBufferSize[1];\n                    i = l.framebufferCopyTexture, i && (!i || i.size[0] === t && i.size[1] === o) || (i && i.destroy(), i = l.framebufferCopyTexture = new e.T(n, new e.r({\n                      width: t,\n                      height: o\n                    }), a.RGBA8)), i.bind(a.LINEAR, a.CLAMP_TO_EDGE), a.copyTexSubImage2D(a.TEXTURE_2D, 0, 0, 0, 0, 0, t, o);\n                  }\n                  m && c(!0, !1, i), g && c(!1, !0, i);\n                }\n              } else m && y(!0), g && y(!1), (m || g) && t.resetStencilClippingMasks();\n            }\n          }\n        },\n        hillshade: function (e, t, i, o) {\n          if (\"offscreen\" !== e.renderPass && \"translucent\" !== e.renderPass) return;\n          if (e.style.disableElevatedTerrain) return;\n          const s = e.context,\n            r = e.terrain && e.terrain.renderingToTexture,\n            [n, a] = \"translucent\" !== e.renderPass || r ? [{}, o] : e.stencilConfigForOverlap(o);\n          for (const o of a) {\n            const s = t.getTile(o);\n            if (s.needsHillshadePrepare && \"offscreen\" === e.renderPass) Wo(e, s, i);else if (\"translucent\" === e.renderPass) {\n              const t = e.depthModeForSublayer(0, Bi.ReadOnly),\n                a = i.paint.get(\"hillshade-emissive-strength\"),\n                l = e.colorModeForDrapableLayerRenderPass(a),\n                c = r && e.terrain ? e.terrain.stencilModeForRTTOverlap(o) : n[o.overscaledZ];\n              Ho(e, o, s, i, t, c, l);\n            }\n          }\n          s.viewport.set([0, 0, e.width, e.height]), e.resetStencilClippingMasks();\n        },\n        raster: function (t, i, o, s, r, n) {\n          if (\"translucent\" !== t.renderPass) return;\n          if (0 === o.paint.get(\"raster-opacity\")) return;\n          const a = \"globe\" === t.transform.projection.name,\n            l = 0 !== o.paint.get(\"raster-elevation\"),\n            c = l && a;\n          if (t.renderElevatedRasterBackface && !c) return;\n          const h = t.context,\n            d = h.gl,\n            u = i.getSource(),\n            _ = function (t, i, o, s) {\n              const r = i.paint.get(\"raster-color\"),\n                n = \"raster-array\" === t.type,\n                a = [],\n                l = i.paint.get(\"raster-resampling\"),\n                c = i.paint.get(\"raster-color-mix\");\n              let h = i.paint.get(\"raster-color-range\");\n              const d = [c[0], c[1], c[2], 0],\n                u = c[3];\n              let _ = \"nearest\" === l ? s.NEAREST : s.LINEAR;\n              if (n && (a.push(\"RASTER_ARRAY\"), r || a.push(\"RASTER_COLOR\"), \"linear\" === l && a.push(\"RASTER_ARRAY_LINEAR\"), _ = s.NEAREST, !h && t.rasterLayers)) {\n                const e = t.rasterLayers.find(({\n                  id: e\n                }) => e === i.sourceLayer);\n                e && e.fields && e.fields.range && (h = e.fields.range);\n              }\n              if (h = h || [0, 1], r) {\n                a.push(\"RASTER_COLOR\"), o.activeTexture.set(s.TEXTURE2), i.updateColorRamp(h);\n                let t = i.colorRampTexture;\n                t || (t = i.colorRampTexture = new e.T(o, i.colorRamp, s.RGBA8)), t.bind(s.LINEAR, s.CLAMP_TO_EDGE);\n              }\n              return {\n                mix: d,\n                range: h,\n                offset: u,\n                defines: a,\n                resampling: _\n              };\n            }(u, o, h, d);\n          if (u instanceof e.aK && !s.length && !a) return;\n          const p = o.paint.get(\"raster-emissive-strength\"),\n            f = t.colorModeForDrapableLayerRenderPass(p),\n            m = t.terrain && t.terrain.renderingToTexture,\n            g = !t.options.moving,\n            v = \"nearest\" === o.paint.get(\"raster-resampling\") ? d.NEAREST : d.LINEAR;\n          if (u instanceof e.aK && !s.length && (u.onNorthPole || u.onSouthPole)) {\n            const e = l ? t.stencilModeFor3D() : Ui.disabled;\n            return void Xr(!!u.onNorthPole, null, t, i, o, p, _, ji.disabled, e);\n          }\n          if (!s.length) return;\n          const [y, x] = u instanceof e.aK || m ? [{}, s] : t.stencilConfigForOverlap(s),\n            b = x[x.length - 1].overscaledZ;\n          c && _.defines.push(\"PROJECTION_GLOBE_VIEW\"), l && _.defines.push(\"RENDER_CUTOFF\");\n          const w = (s, r, x) => {\n            for (const w of s) {\n              const s = w.toUnwrapped(),\n                T = i.getTile(w);\n              if (m && (!T || !T.hasData())) continue;\n              h.activeTexture.set(d.TEXTURE0);\n              const E = Yr(T, u, o, _);\n              if (!E || !E.texture) continue;\n              const {\n                texture: S,\n                mix: C,\n                offset: I,\n                tileSize: R,\n                buffer: D\n              } = E;\n              let A, L;\n              m ? (A = Bi.disabled, L = w.projMatrix) : l ? (A = new Bi(d.LEQUAL, Bi.ReadWrite, t.depthRangeFor3D), L = a ? Float32Array.from(t.transform.expandedFarZProjMatrix) : t.transform.calculateProjMatrix(s, g)) : (A = t.depthModeForSublayer(w.overscaledZ - b, 1 === o.paint.get(\"raster-opacity\") ? Bi.ReadWrite : Bi.ReadOnly, d.LESS), L = t.transform.calculateProjMatrix(s, g));\n              const M = t.terrain && m ? t.terrain.stencilModeForRTTOverlap(w) : y[w.overscaledZ],\n                P = n ? 0 : o.paint.get(\"raster-fade-duration\");\n              T.registerFadeDuration(P);\n              const z = i.findLoadedParent(w, 0),\n                O = Ns(T, z, i, t.transform, P);\n              let F, k;\n              t.terrain && t.terrain.prepareDrawTile(), h.activeTexture.set(d.TEXTURE0), S.bind(v, d.CLAMP_TO_EDGE), h.activeTexture.set(d.TEXTURE1), z ? (z.texture && z.texture.bind(v, d.CLAMP_TO_EDGE), F = Math.pow(2, z.tileID.overscaledZ - T.tileID.overscaledZ), k = [T.tileID.canonical.x * F % 1, T.tileID.canonical.y * F % 1]) : S.bind(v, d.CLAMP_TO_EDGE), \"useMipmap\" in S && h.extTextureFilterAnisotropic && t.transform.pitch > 20 && d.texParameterf(d.TEXTURE_2D, h.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, h.extTextureFilterAnisotropicMax);\n              const B = t.transform;\n              let N;\n              const U = l ? Kr(B) : [0, 0, 0, 0];\n              let V,\n                G,\n                j,\n                q,\n                H,\n                Z = 0;\n              if (c && u instanceof e.aK && u.coordinates.length > 3) V = Float32Array.from(e.bc(e.cI(new e.bT(0, 0, 0)))), G = Float32Array.from(B.globeMatrix), j = Float32Array.from(e.cE(B)), q = [e.av(B.center.lng), e.aC(B.center.lat)], N = u.elevatedGlobePerspectiveTransform, H = u.elevatedGlobeGridMatrix || new Float32Array(9);else if (c) {\n                const t = e.cF(w.canonical);\n                Z = e.cG(t.getCenter().lat), V = Float32Array.from(e.bc(e.cI(w.canonical))), G = Float32Array.from(B.globeMatrix), j = Float32Array.from(e.cE(B)), q = [e.av(B.center.lng), e.aC(B.center.lat)], N = [0, 0], H = Float32Array.from(e.cH(w.canonical, t, Z, B.worldSize / B._pixelsPerMercatorPixel));\n              } else N = u instanceof e.aK ? u.perspectiveTransform : [0, 0], V = new Float32Array(16), G = new Float32Array(9), j = new Float32Array(16), q = [0, 0], H = new Float32Array(9);\n              const W = dr(L, V, G, j, H, k || [0, 0], e.ag(t.transform.zoom), q, U, F || 1, O, o, N, l ? o.paint.get(\"raster-elevation\") : 0, 2, C, I, _.range, R, D, p),\n                $ = t.isTileAffectedByFog(w),\n                X = t.getOrCreateProgram(\"raster\", {\n                  defines: _.defines,\n                  overrideFog: $\n                });\n              if (t.uploadCommonUniforms(h, X, s), u instanceof e.aK) {\n                const i = u.elevatedGlobeVertexBuffer,\n                  s = u.elevatedGlobeIndexBuffer;\n                if (m || !a) u.boundsBuffer && u.boundsSegments && X.draw(t, d.TRIANGLES, A, Ui.disabled, f, ji.disabled, W, o.id, u.boundsBuffer, t.quadTriangleIndexBuffer, u.boundsSegments);else if (i && s) {\n                  const n = B.zoom <= e.c6 ? u.elevatedGlobeSegments : u.getSegmentsForLongitude(B.center.lng);\n                  n && X.draw(t, d.TRIANGLES, A, Ui.disabled, f, r, W, o.id, i, s, n);\n                }\n              } else if (c) {\n                A = new Bi(d.LEQUAL, Bi.ReadOnly, t.depthRangeFor3D);\n                const e = t.globeSharedBuffers;\n                if (e) {\n                  const [i, s, n] = e.getGridBuffers(Z, !1);\n                  X.draw(t, d.TRIANGLES, A, x || M, t.colorModeForRenderPass(), r, W, o.id, i, s, n);\n                }\n              } else {\n                const {\n                  tileBoundsBuffer: e,\n                  tileBoundsIndexBuffer: i,\n                  tileBoundsSegments: s\n                } = t.getTileBoundsBuffers(T);\n                X.draw(t, d.TRIANGLES, A, M, f, ji.disabled, W, o.id, e, i, s);\n              }\n            }\n            if (!(u instanceof e.aK) && c) for (const e of s) {\n              const s = e.canonical.y === (1 << e.canonical.z) - 1;\n              0 === e.canonical.y && Xr(!0, e, t, i, o, p, _, r, x || Ui.disabled), s && Xr(!1, e, t, i, o, p, _, r === ji.frontCW ? ji.backCW : ji.frontCW, x || Ui.disabled);\n            }\n          };\n          c ? w(x, t.renderElevatedRasterBackface ? ji.backCW : ji.frontCW, t.stencilModeFor3D()) : w(x, ji.disabled, void 0), t.resetStencilClippingMasks();\n        },\n        \"raster-particle\": function (t, i, o, s, r, n) {\n          \"offscreen\" === t.renderPass && function (t, i, o, s) {\n            if (!s.length) return;\n            const r = t.context,\n              n = r.gl,\n              a = i.getSource();\n            if (!(a instanceof ot)) return;\n            const l = Math.ceil(Math.sqrt(o.paint.get(\"raster-particle-count\")));\n            let c = o.particlePositionRGBAImage;\n            if (!c || c.width !== l) {\n              const t = function (e) {\n                const t = e * e,\n                  i = new Uint8Array(4 * t),\n                  o = function (e) {\n                    return e |= 0, e = Math.imul(2747636419 ^ e, 2654435769), e = Math.imul(e ^ e >>> 16, 2654435769), ((e = Math.imul(e ^ e >>> 16, 2654435769)) >>> 0) / 4294967296;\n                  },\n                  s = 1 / 1.1;\n                for (let e = 0; e < t; e++) {\n                  const t = s * (o(2 * e + 0) + _r),\n                    r = s * (o(2 * e + 1) + _r),\n                    n = 255 * t % 1,\n                    a = 255 * r % 1,\n                    l = n,\n                    c = r - a / 255,\n                    h = a;\n                  i[4 * e + 0] = 255 * (t - n / 255), i[4 * e + 1] = 255 * l, i[4 * e + 2] = 255 * c, i[4 * e + 3] = 255 * h;\n                }\n                return i;\n              }(l);\n              c = o.particlePositionRGBAImage = new e.r({\n                width: l,\n                height: l\n              }, t);\n            }\n            let h = o.particleFramebuffer;\n            h ? h.width !== l && (h.destroy(), h = o.particleFramebuffer = r.createFramebuffer(l, l, !0, null)) : h = o.particleFramebuffer = r.createFramebuffer(l, l, !0, null);\n            const d = [];\n            for (const e of s) {\n              const t = i.getTile(e);\n              if (!(t instanceof wt)) continue;\n              const s = en(t, a, o);\n              if (!s) continue;\n              const n = [t.tileSize, t.tileSize];\n              let h = o.tileFramebuffer;\n              h || (h = o.tileFramebuffer = r.createFramebuffer(n[0], n[1], !0, null));\n              let u = t.rasterParticleState;\n              u || (u = t.rasterParticleState = new Qr(r, e, n, c));\n              const _ = u.update(o.lastInvalidatedAt);\n              u.particleTextureDimension !== l && u.updateParticleTexture(e, c);\n              const p = u.targetColorTexture;\n              u.targetColorTexture = u.backgroundColorTexture, u.backgroundColorTexture = p;\n              const f = u.particleTexture0;\n              u.particleTexture0 = u.particleTexture1, u.particleTexture1 = f, d.push([e, s, u, _]);\n            }\n            if (0 === d.length) return;\n            const u = e.q.now(),\n              _ = o.previousDrawTimestamp ? .001 * (u - o.previousDrawTimestamp) : .0167;\n            if (o.previousDrawTimestamp = u, o.hasColorMap()) {\n              r.activeTexture.set(n.TEXTURE0 + 2);\n              let t = o.colorRampTexture;\n              t || (t = o.colorRampTexture = new e.T(r, o.colorRamp, n.RGBA8)), t.bind(n.LINEAR, n.CLAMP_TO_EDGE);\n            }\n            r.bindFramebuffer.set(o.tileFramebuffer.framebuffer), function (t, i, o) {\n              const s = t.context,\n                r = s.gl,\n                n = i.tileFramebuffer;\n              s.activeTexture.set(r.TEXTURE0);\n              const a = {\n                  u_texture: 0,\n                  u_opacity: 1.05 * (c = i.paint.get(\"raster-particle-fade-opacity-factor\")) / (c + .05)\n                },\n                l = t.getOrCreateProgram(\"rasterParticleTexture\", {\n                  defines: [],\n                  overrideFog: !1\n                });\n              var c;\n              for (const c of o) {\n                const [,, o, h] = c;\n                n.colorAttachment.set(o.targetColorTexture.texture), s.viewport.set([0, 0, n.width, n.height]), s.clear({\n                  color: e.al.transparent\n                }), h && (o.backgroundColorTexture.bind(r.NEAREST, r.CLAMP_TO_EDGE), l.draw(t, r.TRIANGLES, Bi.disabled, Ui.disabled, ki.alphaBlended, ji.disabled, a, i.id, t.viewportBuffer, t.quadTriangleIndexBuffer, t.viewportSegments));\n              }\n            }(t, o, d), function (t, i, o, s) {\n              const r = t.context,\n                n = r.gl,\n                a = o.tileFramebuffer,\n                l = \"globe\" === t.transform.projection.name,\n                c = o.paint.get(\"raster-particle-max-speed\");\n              for (const h of s) {\n                const [s, d, u] = h;\n                r.activeTexture.set(n.TEXTURE0 + 0), d.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), a.colorAttachment.set(u.targetColorTexture.texture);\n                const _ = t.getOrCreateProgram(\"rasterParticleDraw\", {\n                  defines: d.defines,\n                  overrideFog: !1\n                });\n                r.activeTexture.set(n.TEXTURE0 + 1);\n                const p = d.scalarData ? [] : [0, 1, 2, 3].map(t => e.d7[t](s));\n                p.push(s);\n                const f = s.canonical.x,\n                  m = s.canonical.y;\n                for (const e of p) {\n                  const r = i.getTile(l ? e.wrapped() : e);\n                  if (!r) continue;\n                  const a = r.rasterParticleState;\n                  if (!a) continue;\n                  const h = e.canonical.x + (1 << e.canonical.z) * (e.wrap - s.wrap),\n                    u = e.canonical.y;\n                  a.particleTexture0.bind(n.NEAREST, n.CLAMP_TO_EDGE);\n                  const p = fr(1, a.particleTexture0.size[0], [h - f, u - m], 0, d.texture.size, 2, c, d.textureOffset, d.scale, d.offset);\n                  _.draw(t, n.POINTS, Bi.disabled, Ui.disabled, ki.alphaBlended, ji.disabled, p, o.id, a.particleIndexBuffer, void 0, a.particleSegment);\n                }\n              }\n            }(t, i, o, d), r.bindFramebuffer.set(o.particleFramebuffer.framebuffer), function (t, i, o, s) {\n              const r = t.context,\n                n = r.gl,\n                a = i.paint.get(\"raster-particle-max-speed\"),\n                l = s * i.paint.get(\"raster-particle-speed-factor\") * .15,\n                c = function (e) {\n                  return Math.pow(e, 6);\n                }(.01 + 1 * i.paint.get(\"raster-particle-reset-rate-factor\")),\n                h = i.particleFramebuffer;\n              r.viewport.set([0, 0, h.width, h.height]);\n              for (const s of o) {\n                const [, o, d] = s;\n                r.activeTexture.set(n.TEXTURE0 + 0), o.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE), r.activeTexture.set(n.TEXTURE0 + 1);\n                const u = d.particleTexture0;\n                u.bind(n.NEAREST, n.CLAMP_TO_EDGE);\n                const _ = mr(1, u.size[0], 0, o.texture.size, a, l, c, o.textureOffset, o.scale, o.offset);\n                h.colorAttachment.set(d.particleTexture1.texture), r.clear({\n                  color: e.al.transparent\n                }), t.getOrCreateProgram(\"rasterParticleUpdate\", {\n                  defines: o.defines\n                }).draw(t, n.TRIANGLES, Bi.disabled, Ui.disabled, ki.unblended, ji.disabled, _, i.id, t.viewportBuffer, t.quadTriangleIndexBuffer, t.viewportSegments);\n              }\n            }(t, o, d, _);\n          }(t, i, o, s), \"translucent\" === t.renderPass && (function (t, i, o, s, r) {\n            const n = t.context,\n              a = n.gl,\n              l = i.getSource().tileSize,\n              c = 5 * (1 - e.ae(e.bY, e.bY + 1, t.transform.zoom)) * l + o.paint.get(\"raster-particle-elevation\"),\n              h = !t.options.moving,\n              d = \"globe\" === t.transform.projection.name;\n            if (!s.length) return;\n            const [u, _] = t.stencilConfigForOverlap(s),\n              p = [];\n            d && p.push(\"PROJECTION_GLOBE_VIEW\");\n            const f = t.stencilModeFor3D();\n            for (const s of _) {\n              const r = s.toUnwrapped(),\n                l = i.getTile(s);\n              if (!l.rasterParticleState) continue;\n              const _ = l.rasterParticleState,\n                m = 100;\n              l.registerFadeDuration(m);\n              const g = i.findLoadedParent(s, 0),\n                v = Ns(l, g, i, t.transform, m);\n              let y, x;\n              t.terrain && t.terrain.prepareDrawTile(), n.activeTexture.set(a.TEXTURE0), _.targetColorTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE), n.activeTexture.set(a.TEXTURE1), g && g.rasterParticleState ? (g.rasterParticleState.targetColorTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE), y = Math.pow(2, g.tileID.overscaledZ - l.tileID.overscaledZ), x = [l.tileID.canonical.x * y % 1, l.tileID.canonical.y * y % 1]) : _.targetColorTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE);\n              const b = d ? Float32Array.from(t.transform.expandedFarZProjMatrix) : t.transform.calculateProjMatrix(r, h),\n                w = t.transform,\n                T = tn(w),\n                E = e.cF(s.canonical),\n                S = e.cG(E.getCenter().lat);\n              let C, I, R, D, A;\n              d ? (C = Float32Array.from(e.bc(e.cI(s.canonical))), I = Float32Array.from(w.globeMatrix), R = Float32Array.from(e.cE(w)), D = [e.av(w.center.lng), e.aC(w.center.lat)], A = Float32Array.from(e.cH(s.canonical, E, S, w.worldSize / w._pixelsPerMercatorPixel))) : (C = new Float32Array(16), I = new Float32Array(9), R = new Float32Array(16), D = [0, 0], A = new Float32Array(9));\n              const L = pr(b, C, I, R, A, x || [0, 0], e.ag(t.transform.zoom), D, T, y || 1, v, c),\n                M = t.isTileAffectedByFog(s),\n                P = t.getOrCreateProgram(\"rasterParticle\", {\n                  defines: p,\n                  overrideFog: M\n                });\n              if (t.uploadCommonUniforms(n, P, r), d) {\n                const e = new Bi(a.LEQUAL, Bi.ReadOnly, t.depthRangeFor3D),\n                  i = 0,\n                  s = t.globeSharedBuffers;\n                if (s) {\n                  const [r, n, l] = s.getGridBuffers(S, 0 !== i);\n                  P.draw(t, a.TRIANGLES, e, f, ki.alphaBlended, t.renderElevatedRasterBackface ? ji.frontCCW : ji.backCCW, L, o.id, r, n, l);\n                }\n              } else {\n                const e = t.depthModeForSublayer(0, Bi.ReadOnly),\n                  i = u[s.overscaledZ],\n                  {\n                    tileBoundsBuffer: r,\n                    tileBoundsIndexBuffer: n,\n                    tileBoundsSegments: c\n                  } = t.getTileBoundsBuffers(l);\n                P.draw(t, a.TRIANGLES, e, i, ki.alphaBlended, ji.disabled, L, o.id, r, n, c);\n              }\n            }\n            t.resetStencilClippingMasks();\n          }(t, i, o, s), t.style.map.triggerRepaint());\n        },\n        background: function (t, i, o, s) {\n          const r = o.paint.get(\"background-color\"),\n            n = \"none\" === o.paint.get(\"background-color-use-theme\").constantOr(\"default\"),\n            a = o.paint.get(\"background-opacity\"),\n            l = o.paint.get(\"background-emissive-strength\"),\n            c = \"viewport\" === o.paint.get(\"background-pitch-alignment\");\n          if (0 === a) return;\n          const h = t.context,\n            d = h.gl,\n            u = t.transform,\n            _ = u.tileSize,\n            p = o.paint.get(\"background-pattern\");\n          let f;\n          if (void 0 !== p) {\n            if (null === p) return;\n            if (f = t.imageManager.getPattern(e.I.from(p.toString()), o.scope, t.style.getLut(o.scope)), !f) return;\n          }\n          const m = !p && 1 === r.a && 1 === a && t.opaquePassEnabledForLayer() ? \"opaque\" : \"translucent\";\n          if (t.renderPass !== m) return;\n          const g = Ui.disabled,\n            v = t.depthModeForSublayer(0, \"opaque\" === m ? Bi.ReadWrite : Bi.ReadOnly),\n            y = t.colorModeForDrapableLayerRenderPass(l),\n            x = p ? \"backgroundPattern\" : \"background\";\n          let b,\n            w = s;\n          if (w || (b = t.getBackgroundTiles(), w = Object.values(b).map(e => e.tileID)), p && (h.activeTexture.set(d.TEXTURE0), t.imageManager.bind(t.context, o.scope)), c) {\n            const i = t.getOrCreateProgram(x, {\n                overrideFog: !1,\n                overrideRtt: !0\n              }),\n              s = new Float32Array(e.ad.mat4.identity([])),\n              h = new e.aH(0, 0, 0, 0, 0),\n              u = p ? xr(s, l, a, t, 0, o.scope, f, c, {\n                tileID: h,\n                tileSize: _\n              }) : yr(s, l, a, r.toRenderColor(n ? null : o.lut));\n            i.draw(t, d.TRIANGLES, v, g, y, ji.disabled, u, o.id, t.viewportBuffer, t.quadTriangleIndexBuffer, t.viewportSegments);\n          } else for (const e of w) {\n            const m = t.isTileAffectedByFog(e),\n              w = t.getOrCreateProgram(x, {\n                overrideFog: m\n              }),\n              T = e.toUnwrapped(),\n              E = s ? e.projMatrix : t.transform.calculateProjMatrix(T);\n            t.prepareDrawTile();\n            const S = i ? i.getTile(e) : b ? b[e.key] : new bt(e, _, u.zoom, t),\n              C = p ? xr(E, l, a, t, 0, o.scope, f, c, {\n                tileID: e,\n                tileSize: _\n              }) : yr(E, l, a, r.toRenderColor(n ? null : o.lut));\n            t.uploadCommonUniforms(h, w, T);\n            const {\n              tileBoundsBuffer: I,\n              tileBoundsIndexBuffer: R,\n              tileBoundsSegments: D\n            } = t.getTileBoundsBuffers(S);\n            w.draw(t, d.TRIANGLES, v, g, y, ji.disabled, C, o.id, I, R, D);\n          }\n        },\n        sky: function (t, i, o) {\n          const s = t._atmosphere ? e.ag(t.transform.zoom) : 1,\n            r = o.paint.get(\"sky-opacity\") * s;\n          if (0 === r) return;\n          const n = t.context,\n            a = o.paint.get(\"sky-type\"),\n            l = new Bi(n.gl.LEQUAL, Bi.ReadOnly, [0, 1]),\n            c = t.frameCounter / 1e3 % 1;\n          \"atmosphere\" === a ? \"offscreen\" === t.renderPass ? o.needsSkyboxCapture(t) && (function (t, i, o, s) {\n            const r = t.context,\n              n = r.gl;\n            let a = i.skyboxFbo;\n            if (!a) {\n              a = i.skyboxFbo = r.createFramebuffer(32, 32, !0, null), i.skyboxGeometry = new fn(r), i.skyboxTexture = r.gl.createTexture(), n.bindTexture(n.TEXTURE_CUBE_MAP, i.skyboxTexture), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_WRAP_S, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_WRAP_T, n.CLAMP_TO_EDGE), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_MIN_FILTER, n.LINEAR), n.texParameteri(n.TEXTURE_CUBE_MAP, n.TEXTURE_MAG_FILTER, n.LINEAR);\n              for (let e = 0; e < 6; ++e) n.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, n.RGBA, 32, 32, 0, n.RGBA, n.UNSIGNED_BYTE, null);\n            }\n            r.bindFramebuffer.set(a.framebuffer), r.viewport.set([0, 0, 32, 32]);\n            const l = i.getCenter(t, !0),\n              c = t.getOrCreateProgram(\"skyboxCapture\"),\n              h = new Float64Array(16);\n            e.ad.mat4.identity(h), e.ad.mat4.rotateY(h, h, .5 * -Math.PI), mn(t, i, c, h, l, 0), e.ad.mat4.identity(h), e.ad.mat4.rotateY(h, h, .5 * Math.PI), mn(t, i, c, h, l, 1), e.ad.mat4.identity(h), e.ad.mat4.rotateX(h, h, .5 * -Math.PI), mn(t, i, c, h, l, 2), e.ad.mat4.identity(h), e.ad.mat4.rotateX(h, h, .5 * Math.PI), mn(t, i, c, h, l, 3), e.ad.mat4.identity(h), mn(t, i, c, h, l, 4), e.ad.mat4.identity(h), e.ad.mat4.rotateY(h, h, Math.PI), mn(t, i, c, h, l, 5), r.viewport.set([0, 0, t.width, t.height]);\n          }(t, o), o.markSkyboxValid(t)) : \"sky\" === t.renderPass && function (e, t, i, o, s) {\n            const r = e.context,\n              n = r.gl,\n              a = e.transform,\n              l = e.getOrCreateProgram(\"skybox\");\n            r.activeTexture.set(n.TEXTURE0), n.bindTexture(n.TEXTURE_CUBE_MAP, t.skyboxTexture);\n            const c = ((e, t, i, o, s) => ({\n              u_matrix: e,\n              u_sun_direction: t,\n              u_cubemap: 0,\n              u_opacity: o,\n              u_temporal_offset: s\n            }))(a.skyboxMatrix, t.getCenter(e, !1), 0, o, s);\n            e.uploadCommonUniforms(r, l), l.draw(e, n.TRIANGLES, i, Ui.disabled, e.colorModeForRenderPass(), ji.backCW, c, \"skybox\", t.skyboxGeometry.vertexBuffer, t.skyboxGeometry.indexBuffer, t.skyboxGeometry.segment);\n          }(t, o, l, r, c) : \"gradient\" === a && \"sky\" === t.renderPass && function (t, i, o, s, r) {\n            const n = t.context,\n              a = n.gl,\n              l = t.transform,\n              c = t.getOrCreateProgram(\"skyboxGradient\");\n            i.skyboxGeometry || (i.skyboxGeometry = new fn(n)), n.activeTexture.set(a.TEXTURE0);\n            let h = i.colorRampTexture;\n            h || (h = i.colorRampTexture = new e.T(n, i.colorRamp, a.RGBA8)), h.bind(a.LINEAR, a.CLAMP_TO_EDGE);\n            const d = ((t, i, o, s, r) => ({\n              u_matrix: t,\n              u_color_ramp: 0,\n              u_center_direction: i,\n              u_radius: e.ak(o),\n              u_opacity: s,\n              u_temporal_offset: r\n            }))(l.skyboxMatrix, i.getCenter(t, !1), i.paint.get(\"sky-gradient-radius\"), s, r);\n            t.uploadCommonUniforms(n, c), c.draw(t, a.TRIANGLES, o, Ui.disabled, t.colorModeForRenderPass(), ji.backCW, d, \"skyboxGradient\", i.skyboxGeometry.vertexBuffer, i.skyboxGeometry.indexBuffer, i.skyboxGeometry.segment);\n          }(t, o, l, r, c);\n        },\n        debug: function (t, i, o, s, r, n) {\n          for (let a = 0; a < o.length; a++) if (r) {\n            const r = 1,\n              l = .8,\n              c = new e.al(s.r * l, s.g * l, s.b * l, 1);\n            ln(t, i, o[a], s, -r, -r, n), ln(t, i, o[a], s, -r, r, n), ln(t, i, o[a], s, r, r, n), ln(t, i, o[a], s, r, -r, n), ln(t, i, o[a], c, 0, 0, n);\n          } else ln(t, i, o[a], s, 0, 0, n);\n        },\n        custom: function (t, i, o, s) {\n          const r = t.context,\n            n = o.implementation;\n          if (!t.transform.projection.unsupportedLayers || !t.transform.projection.unsupportedLayers.includes(\"custom\") || t.terrain && (t.terrain.renderingToTexture || \"offscreen\" === t.renderPass) && o.isDraped(i)) {\n            if (\"offscreen\" === t.renderPass) {\n              const i = n.prerender;\n              if (i) {\n                if (t.setCustomLayerDefaults(), r.setColorMode(t.colorModeForRenderPass()), \"globe\" === t.transform.projection.name) {\n                  const o = t.transform.pointMerc;\n                  i.call(n, r.gl, t.transform.customLayerMatrix(), t.transform.getProjection(), t.transform.globeToMercatorMatrix(), e.ag(t.transform.zoom), [o.x, o.y], t.transform.pixelsPerMeterRatio);\n                } else i.call(n, r.gl, t.transform.customLayerMatrix());\n                r.setDirty(), t.setBaseState();\n              }\n            } else if (\"translucent\" === t.renderPass) {\n              if (t.terrain && t.terrain.renderingToTexture) {\n                const i = n.renderToTile;\n                if (i) {\n                  const o = s[0].canonical,\n                    a = new e.ac(o.x + s[0].wrap * (1 << o.z), o.y, o.z);\n                  r.setDepthMode(Bi.disabled), r.setStencilMode(Ui.disabled), r.setColorMode(t.colorModeForRenderPass()), t.setCustomLayerDefaults(), i.call(n, r.gl, a), r.setDirty(), t.setBaseState();\n                }\n                return;\n              }\n              t.setCustomLayerDefaults(), r.setColorMode(t.colorModeForRenderPass()), r.setStencilMode(Ui.disabled);\n              const i = \"3d\" === n.renderingMode ? new Bi(t.context.gl.LEQUAL, Bi.ReadWrite, t.depthRangeFor3D) : t.depthModeForSublayer(0, Bi.ReadOnly);\n              if (r.setDepthMode(i), \"globe\" === t.transform.projection.name) {\n                const i = t.transform.pointMerc;\n                n.render(r.gl, t.transform.customLayerMatrix(), t.transform.getProjection(), t.transform.globeToMercatorMatrix(), e.ag(t.transform.zoom), [i.x, i.y], t.transform.pixelsPerMeterRatio);\n              } else n.render(r.gl, t.transform.customLayerMatrix());\n              r.setDirty(), t.setBaseState(), r.bindFramebuffer.set(null);\n            }\n          } else e.w(\"Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.\");\n        },\n        model: function (t, i, o, s) {\n          if (\"opaque\" === t.renderPass) return;\n          const r = o.paint.get(\"model-opacity\").constantOr(1);\n          if (0 === r) return;\n          const n = o.paint.get(\"model-cast-shadows\");\n          if (\"shadow\" === t.renderPass) {\n            if (!n) return;\n            if (t.terrain && r < .65 && o._transitionablePaint._values[\"model-opacity\"].value.expression instanceof e.ab) return;\n          }\n          const a = t.shadowRenderer,\n            l = o.paint.get(\"model-receive-shadows\");\n          a && (a.useNormalOffset = !0, l || (a.enabled = !1));\n          const c = () => {\n              a && (a.useNormalOffset = !0, l || (a.enabled = !0));\n            },\n            h = i.getSource();\n          if (\"light-beam\" === t.renderPass && \"batched-model\" !== h.type) return;\n          if (\"vector\" === h.type || \"geojson\" === h.type) return function (t, i, o, s, r) {\n            const n = t.transform;\n            if (\"mercator\" !== n.projection.name) return void e.w(`Drawing 3D models for ${n.projection.name} projection is not yet implemented`);\n            const a = n.getFreeCameraOptions().position;\n            if (!t.modelManager) return;\n            const l = t.modelManager;\n            o.modelManager = l;\n            const c = t.shadowRenderer;\n            if (!o._unevaluatedLayout._values.hasOwnProperty(\"model-id\")) return;\n            const h = o._unevaluatedLayout._values[\"model-id\"],\n              d = Object.assign({}, o.layout.get(\"model-id\").parameters),\n              u = t.style.order.indexOf(o.fqid);\n            for (const _ of s) {\n              const s = i.getTile(_).getBucket(o);\n              if (!s || s.projection.name !== n.projection.name) continue;\n              const p = s.getModelUris();\n              p && !s.modelsRequested && (l.addModelsFromBucket(p, r), s.modelsRequested = !0);\n              const f = Dn(_, n);\n              d.zoom = f;\n              const m = h.possiblyEvaluate(d);\n              if (In(t, s, _), Rn.shadowUniformsInitialized = !1, Rn.useSingleShadowCascade = !!c && 0 === c.getMaxCascadeForTile(_.toUnwrapped()), \"shadow\" === t.renderPass && c) {\n                if (1 === t.currentShadowCascade && s.isInsideFirstShadowMapFrustum) continue;\n                const i = n.calculatePosMatrix(_.toUnwrapped(), n.worldSize);\n                if (Rn.tileMatrix.set(i), Rn.shadowTileMatrix = Float32Array.from(c.calculateShadowPassMatrixFromMatrix(i)), Rn.aabb.min.fill(0), Rn.aabb.max[0] = Rn.aabb.max[1] = e.ai, Rn.aabb.max[2] = 0, Mn(s, Rn, t, o.scope)) continue;\n              }\n              const g = 1 << _.canonical.z,\n                v = [((a.x - _.wrap) * g - _.canonical.x) * e.ai, (a.y * g - _.canonical.y) * e.ai, a.z * g * e.ai];\n              t.conflationActive && Object.keys(s.instancesPerModel).length > 0 && t.style.isLayerClipped(o, i.getSource()) && s.updateReplacement(_, t.replacementSource, u, r) && (s.uploaded = !1, s.upload(t.context));\n              for (let e in s.instancesPerModel) {\n                const i = s.instancesPerModel[e];\n                i.features.length > 0 && (e = m.evaluate(i.features[0].feature, {}));\n                const n = l.getModel(e, r);\n                if (n && n.uploaded) for (const e of n.nodes) An(t, o, e, i, v, _, Rn);\n              }\n            }\n          }(t, i, o, s, \"vector\" === h.type ? o.scope : \"\"), void c();\n          if (!h.loaded()) return;\n          if (\"batched-model\" === h.type) return function (t, i, o, s) {\n            o.resetLayerRenderingStats(t);\n            const r = t.context,\n              n = t.transform,\n              a = t.style.fog,\n              l = t.shadowRenderer;\n            if (\"mercator\" !== n.projection.name) return void e.w(`Drawing 3D landmark models for ${n.projection.name} projection is not yet implemented`);\n            const c = t.transform.getFreeCameraOptions().position,\n              h = e.ad.vec3.scale([], [c.x, c.y, c.z], t.transform.worldSize),\n              d = e.ad.vec3.negate([], h),\n              u = e.ad.mat4.identity([]),\n              _ = e.dm(n.center.lat, n.zoom),\n              p = e.ad.mat4.fromScaling([], [1, 1, 1 / _]);\n            e.ad.mat4.translate(u, u, d);\n            const f = o.paint.get(\"model-opacity\").constantOr(1),\n              m = new Bi(r.gl.LEQUAL, Bi.ReadWrite, t.depthRangeFor3D),\n              g = new Bi(r.gl.LEQUAL, Bi.ReadOnly, t.depthRangeFor3D),\n              v = new e.ce([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]),\n              y = \"shadow\" === t.renderPass,\n              x = y && l ? l.getCurrentCascadeFrustum() : n.getFrustum(n.scaleZoom(n.worldSize)),\n              b = o.paint.get(\"model-front-cutoff\"),\n              w = b[2] < 1,\n              T = Qi(t, o.paint.get(\"model-cutoff-fade-range\")),\n              E = o.getLayerRenderingStats();\n            (function (e, t, i, o) {\n              const s = e.terrain ? e.terrain.exaggeration() : 0,\n                r = e.transform.zoom;\n              for (const n of o) {\n                const o = t.getTile(n).getBucket(i);\n                o && (o.setFilter(i.filter), e.conflationActive && o.updateReplacement(n, e.replacementSource), o.evaluateScale(e, i), e.terrain && s > 0 && o.elevationUpdate(e.terrain, s, n, i.source), o.needsReEvaluation(e, r, i) && o.evaluate(i));\n              }\n            })(t, i, o, s), function () {\n              let c, d, S;\n              w ? (c = s.length - 1, d = -1, S = -1) : (c = 0, d = s.length, S = 1);\n              const C = new Float64Array(16),\n                I = e.ad.vec3.create(),\n                R = new e.P(0, 0);\n              for (let D = c; D !== d; D += S) {\n                const c = s[D],\n                  d = i.getTile(c).getBucket(o);\n                if (!d || !d.uploaded) continue;\n                let S = !1;\n                l && (S = 0 === l.getMaxCascadeForTile(c.toUnwrapped()));\n                const A = n.calculatePosMatrix(c.toUnwrapped(), n.worldSize),\n                  L = d.modelTraits;\n                !y && w && (e.ad.mat4.invert(C, A), e.ad.vec3.transformMat4(I, h, C), R.x = I[0], R.y = I[1]);\n                const M = [];\n                d.setFilter(o.filter);\n                for (const i of d.getNodesInfo()) {\n                  if (i.hiddenByReplacement) continue;\n                  if (!i.node.meshes) continue;\n                  const o = i.node;\n                  let s = 0;\n                  t.terrain && o.elevation && (s = o.elevation * t.terrain.exaggeration());\n                  const r = (() => {\n                      const t = i.aabb;\n                      return v.min = [...t.min], v.max = [...t.max], v.min[2] += s, v.max[2] += s, e.ad.vec3.transformMat4(v.min, v.min, A), e.ad.vec3.transformMat4(v.max, v.max, A), v;\n                    })(),\n                    a = i.evaluatedScale;\n                  if (a[0] <= 1 && a[1] <= 1 && a[2] <= 1 && 0 === r.intersects(x)) continue;\n                  if (!y && w) {\n                    const t = 1 / 6;\n                    i.cameraCollisionOpacity = h[0] > r.min[0] && h[0] < r.max[0] && h[1] > r.min[1] && h[1] < r.max[1] && h[2] * _ < r.max[2] && o.footprint && e.bA(R, o.footprint) ? Math.max(i.cameraCollisionOpacity - t, 0) : Math.min(1, i.cameraCollisionOpacity + t);\n                  }\n                  const l = [...A],\n                    c = o.anchor ? o.anchor[0] : 0,\n                    d = o.anchor ? o.anchor[1] : 0;\n                  e.ad.mat4.translate(l, l, [c * (a[0] - 1), d * (a[1] - 1), s]), e.ad.vec3.exactEquals(a, e.dq) || e.ad.mat4.scale(l, l, a);\n                  const u = e.ad.mat4.multiply([], l, o.matrix),\n                    p = e.ad.mat4.multiply([], n.expandedFarZProjMatrix, u),\n                    m = e.ad.mat4.multiply([], n.expandedFarZProjMatrix, l),\n                    g = e.ad.vec4.transformMat4([], [c, d, s, 1], p)[2];\n                  o.hidden = !1;\n                  let E = f;\n                  y || (w && (E *= i.cameraCollisionOpacity, E *= zn(l, n, i.aabb, b)), E *= Pn(T, g)), 0 !== E ? M.push({\n                    nodeInfo: i,\n                    depth: g,\n                    opacity: E,\n                    wvpForNode: p,\n                    wvpForTile: m,\n                    nodeModelMatrix: u,\n                    tileModelMatrix: l\n                  }) : o.hidden = !0;\n                }\n                y || M.sort((e, t) => !w || 1 === e.opacity && 1 === t.opacity ? e.depth < t.depth ? -1 : 1 : 1 === e.opacity ? -1 : 1 === t.opacity ? 1 : e.depth > t.depth ? -1 : 1);\n                for (const i of M) {\n                  const s = i.nodeInfo,\n                    c = s.node;\n                  let h = e.ad.mat4.multiply([], p, i.tileModelMatrix);\n                  e.ad.mat4.multiply(h, u, h);\n                  const d = e.ad.mat4.invert([], h);\n                  e.ad.mat4.transpose(d, d), e.ad.mat4.scale(d, d, Ln), h = e.ad.mat4.multiply(h, h, c.matrix);\n                  const _ = \"light-beam\" === t.renderPass,\n                    f = \"none\" === o.paint.get(\"model-color-use-theme\").constantOr(\"default\"),\n                    v = L & e.ds.HasMapboxMeshFeatures,\n                    x = v ? 0 : s.evaluatedRMEA[0][2];\n                  for (let e = 0; e < c.meshes.length; ++e) {\n                    const u = c.meshes[e],\n                      p = e === c.lightMeshIndex;\n                    let b = i.wvpForNode;\n                    if (p) {\n                      if (!_ && !t.terrain && t.shadowRenderer) {\n                        t.currentLayer < t.firstLightBeamLayer && (t.firstLightBeamLayer = t.currentLayer);\n                        continue;\n                      }\n                      b = i.wvpForTile;\n                    } else if (_) continue;\n                    const w = {\n                        defines: []\n                      },\n                      T = [];\n                    if (!y && l && (l.useNormalOffset = !!u.normalBuffer), Tn(w.defines, T, u, t, f ? null : o.lut), v || w.defines.push(\"DIFFUSE_SHADED\"), S && w.defines.push(\"SHADOWS_SINGLE_CASCADE\"), E && (y ? E.numRenderedVerticesInShadowPass += u.vertexArray.length : E.numRenderedVerticesInTransparentPass += u.vertexArray.length), y) {\n                      Cn(u, i.nodeModelMatrix, t, o);\n                      continue;\n                    }\n                    let C = null;\n                    if (a) {\n                      const e = wn(i.nodeModelMatrix, t.transform);\n                      if (C = new Float32Array(e), \"globe\" !== n.projection.name) {\n                        const t = u.aabb.min,\n                          i = u.aabb.max,\n                          [o, s] = a.getOpacityForBounds(e, t[0], t[1], i[0], i[1]);\n                        w.overrideFog = o >= Fe || s >= Fe;\n                      }\n                    }\n                    const I = u.material;\n                    let R;\n                    I.occlusionTexture && I.occlusionTexture.offsetScale && (R = I.occlusionTexture.offsetScale, w.defines.push(\"OCCLUSION_TEXTURE_TRANSFORM\"));\n                    const D = t.getOrCreateProgram(\"model\", w);\n                    !y && l && l.setupShadowsFromMatrix(i.tileModelMatrix, D, l.useNormalOffset), t.uploadCommonUniforms(r, D, null, C);\n                    const A = I.pbrMetallicRoughness;\n                    A.metallicFactor = .9, A.roughnessFactor = .5;\n                    const L = wr(new Float32Array(b), new Float32Array(h), new Float32Array(d), new Float32Array(c.matrix), t, i.opacity, A.baseColorFactor.toRenderColor(null), I.emissiveFactor, A.metallicFactor, A.roughnessFactor, I, x, o, [0, 0, 0], R);\n                    !p && (s.hasTranslucentParts || i.opacity < 1) && D.draw(t, r.gl.TRIANGLES, m, Ui.disabled, ki.disabled, ji.backCCW, L, o.id, u.vertexBuffer, u.indexBuffer, u.segments, o.paint, t.transform.zoom, void 0, T), D.draw(t, r.gl.TRIANGLES, p ? g : m, Ui.disabled, p || i.opacity < 1 || s.hasTranslucentParts ? ki.alphaBlended : ki.unblended, ji.backCCW, L, o.id, u.vertexBuffer, u.indexBuffer, u.segments, o.paint, t.transform.zoom, void 0, T);\n                  }\n                }\n              }\n            }();\n          }(t, i, o, s), void c();\n          if (\"model\" !== h.type) return;\n          const d = h.getModels(),\n            u = [],\n            _ = t.transform.getFreeCameraOptions().position,\n            p = e.ad.vec3.scale([], [_.x, _.y, _.z], t.transform.worldSize);\n          e.ad.vec3.negate(p, p);\n          const f = [],\n            m = [];\n          let g = 0;\n          for (const i of d) {\n            const s = o.paint.get(\"model-rotation\").constantOr(null),\n              r = o.paint.get(\"model-scale\").constantOr(null),\n              n = o.paint.get(\"model-translation\").constantOr(null);\n            i.computeModelMatrix(t, s, r, n, !0, !0, !1);\n            const a = e.ad.mat4.identity([]),\n              l = e.dm(i.position.lat, t.transform.zoom),\n              c = e.ad.mat4.fromScaling([], [1, 1, 1 / l]);\n            e.ad.mat4.translate(a, a, p), u.push({\n              zScaleMatrix: c,\n              negCameraPosMatrix: a\n            });\n            for (const e of i.nodes) Sn(t.transform, e, i.matrix, t.transform.expandedFarZProjMatrix, g, f, m);\n            g++;\n          }\n          if (f.sort((e, t) => t.depth - e.depth), \"shadow\" !== t.renderPass) {\n            if (1 === r) for (const e of m) En(e, t, o, u[e.modelIndex], Ui.disabled, t.colorModeForRenderPass());else {\n              for (const e of m) En(e, t, o, u[e.modelIndex], Ui.disabled, ki.disabled);\n              for (const e of m) En(e, t, o, u[e.modelIndex], t.stencilModeFor3D(), t.colorModeForRenderPass());\n              t.resetStencilClippingMasks();\n            }\n            for (const e of f) En(e, t, o, u[e.modelIndex], Ui.disabled, t.colorModeForRenderPass());\n            c();\n          } else {\n            for (const e of m) Cn(e.mesh, e.nodeModelMatrix, t, o);\n            for (const e of f) Cn(e.mesh, e.nodeModelMatrix, t, o);\n            c();\n          }\n        }\n      },\n      Jn = {\n        line: function (e, t, i) {\n          if (e.hasElevatedBuckets = !1, e.hasNonElevatedBuckets = !1, void 0 !== e._unevaluatedLayout.getValue(\"line-elevation-reference\") || void 0 !== e._unevaluatedLayout.getValue(\"line-z-offset\")) {\n            if (t) {\n              const i = t.getVisibleCoordinates();\n              for (const o of i) {\n                const i = t.getTile(o).getBucket(e);\n                if (i && (i.hasZOffset ? e.hasElevatedBuckets = !0 : e.hasNonElevatedBuckets = !0, e.hasElevatedBuckets && e.hasNonElevatedBuckets)) break;\n              }\n            }\n          } else e.hasNonElevatedBuckets = !0;\n        },\n        model: function (e, t, i) {\n          const o = t.getSource();\n          if (!o.loaded()) return;\n          if (\"vector\" === o.type || \"geojson\" === o.type) return void (i.modelManager && i.modelManager.upload(i, \"vector\" === o.type ? e.scope : \"\"));\n          if (\"batched-model\" === o.type) return;\n          if (\"model\" !== o.type) return;\n          const s = o.getModels();\n          for (const e of s) e.upload(i.context);\n        },\n        raster: function (e, t, i) {\n          const o = t.getSource();\n          if (!(o instanceof ot && o.loaded())) return;\n          const s = e.sourceLayer || o.rasterLayerIds && o.rasterLayerIds[0];\n          if (!s) return;\n          const r = e.paint.get(\"raster-array-band\") || o.getInitialBand(s);\n          if (null == r) return;\n          const n = t.getIds().map(e => t.getTileByID(e));\n          for (const e of n) e.updateNeeded(s, r) && o.prepareTile(e, s, r);\n        },\n        \"raster-particle\": function (e, t, i) {\n          const o = t.getSource();\n          if (!(o instanceof ot && o.loaded())) return;\n          const s = e.sourceLayer || o.rasterLayerIds && o.rasterLayerIds[0];\n          if (!s) return;\n          const r = e.paint.get(\"raster-particle-array-band\") || o.getInitialBand(s);\n          if (null == r) return;\n          const n = t.getIds().map(e => t.getTileByID(e));\n          for (const e of n) e.updateNeeded(s, r) && o.prepareTile(e, s, r);\n        }\n      },\n      Qn = {\n        fill: Nr\n      };\n    class ea {\n      constructor(t, i, o, s, r) {\n        this.context = new Dr(t, i), this.transform = o, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.tp = r, this._timeStamp = e.q.now(), this._averageFPS = 0, this._fpsHistory = [], this._dt = 0, this._debugParams = {\n          forceEnablePrecipitation: !1,\n          showTerrainProxyTiles: !1,\n          fpsWindow: 30,\n          continousRedraw: !1,\n          enabledLayers: {}\n        };\n        const n = [\"fill\", \"line\", \"symbol\", \"circle\", \"heatmap\", \"fill-extrusion\", \"raster\", \"raster-particle\", \"hillshade\", \"model\", \"background\", \"sky\"];\n        for (const e of n) this._debugParams.enabledLayers[e] = !0;\n        r.registerParameter(this._debugParams, [\"Terrain\"], \"showTerrainProxyTiles\", {}, () => {\n          this.style.map.triggerRepaint();\n        }), r.registerParameter(this._debugParams, [\"Precipitation\"], \"forceEnablePrecipitation\"), r.registerParameter(this._debugParams, [\"FPS\"], \"fpsWindow\", {\n          min: 1,\n          max: 100,\n          step: 1\n        }), r.registerBinding(this._debugParams, [\"FPS\"], \"continousRedraw\", {\n          readonly: !0,\n          label: \"continuous redraw\"\n        }), r.registerBinding(this, [\"FPS\"], \"_averageFPS\", {\n          readonly: !0,\n          label: \"value\"\n        }), r.registerBinding(this, [\"FPS\"], \"_averageFPS\", {\n          readonly: !0,\n          label: \"graph\",\n          view: \"graph\",\n          min: 0,\n          max: 200\n        });\n        for (const e of n) r.registerParameter(this._debugParams.enabledLayers, [\"Debug\", \"Layers\"], e);\n        this.occlusionParams = new kn(r), this.setup(), this.numSublayers = St.maxUnderzooming + St.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = !1, this.replacementSource = new e.dy(), this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = !1, this._cachedTileFogOpacities = {}, this._shadowRenderer = new oo(this), this._wireframeDebugCache = new Fn(), this.renderDefaultNorthPole = !0, this.renderDefaultSouthPole = !0, this.layersWithOcclusionOpacity = [];\n        const a = new e.r({\n          width: 1,\n          height: 1\n        }, Uint8Array.of(0, 0, 0, 0));\n        this.emptyDepthTexture = new e.T(this.context, a, t.RGBA8), this._clippingActiveLastFrame = !1, this.scaleFactor = s;\n      }\n      updateTerrain(e, t) {\n        const i = !!e && !!e.terrain && this.transform.projection.supportsTerrain;\n        if (!(i || this._terrain && this._terrain.enabled)) return;\n        this._terrain || (this._terrain = new js(this, e));\n        const o = this._terrain;\n        this.transform.elevation = i ? o : null, o.update(e, this.transform, t), this.transform.elevation && !o.enabled && (this.transform.elevation = null);\n      }\n      _updateFog(e) {\n        const t = e.fog;\n        if (!t || \"globe\" === this.transform.projection.name || t.getOpacity(this.transform.pitch) < 1 || t.properties.get(\"horizon-blend\") < .03) return void (this.transform.fogCullDistSq = null);\n        const [i, o] = t.getFovAdjustedRange(this.transform._fov);\n        if (i > o) return void (this.transform.fogCullDistSq = null);\n        const s = i + .78 * (o - i);\n        this.transform.fogCullDistSq = s * s;\n      }\n      get terrain() {\n        return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled || this._forceTerrainMode ? this._terrain : null;\n      }\n      get forceTerrainMode() {\n        return this._forceTerrainMode;\n      }\n      set forceTerrainMode(e) {\n        e && !this._terrain && (this._terrain = new js(this, this.style)), this._forceTerrainMode = e;\n      }\n      get shadowRenderer() {\n        return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;\n      }\n      get wireframeDebugCache() {\n        return this._wireframeDebugCache;\n      }\n      resize(t, i) {\n        if (this.width = t * e.q.devicePixelRatio, this.height = i * e.q.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e of this.style.order) this.style._mergedLayers[e].resize();\n      }\n      setup() {\n        const t = this.context,\n          i = new e.b5();\n        i.emplaceBack(0, 0), i.emplaceBack(e.ai, 0), i.emplaceBack(0, e.ai), i.emplaceBack(e.ai, e.ai), this.tileExtentBuffer = t.createVertexBuffer(i, e.b7.members), this.tileExtentSegments = e.b8.simpleSegment(0, 0, 4, 2);\n        const o = new e.b5();\n        o.emplaceBack(0, 0), o.emplaceBack(e.ai, 0), o.emplaceBack(0, e.ai), o.emplaceBack(e.ai, e.ai), this.debugBuffer = t.createVertexBuffer(o, e.b7.members), this.debugSegments = e.b8.simpleSegment(0, 0, 4, 5);\n        const s = new e.b5();\n        s.emplaceBack(-1, -1), s.emplaceBack(1, -1), s.emplaceBack(-1, 1), s.emplaceBack(1, 1), this.viewportBuffer = t.createVertexBuffer(s, e.b7.members), this.viewportSegments = e.b8.simpleSegment(0, 0, 4, 2);\n        const r = new e.aU();\n        r.emplaceBack(0, 0, 0, 0), r.emplaceBack(e.ai, 0, e.ai, 0), r.emplaceBack(0, e.ai, 0, e.ai), r.emplaceBack(e.ai, e.ai, e.ai, e.ai), this.mercatorBoundsBuffer = t.createVertexBuffer(r, e.ba.members), this.mercatorBoundsSegments = e.b8.simpleSegment(0, 0, 4, 2);\n        const n = new e.aV();\n        n.emplaceBack(0, 1, 2), n.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t.createIndexBuffer(n);\n        const a = new e.b6();\n        for (const e of [0, 1, 3, 2, 0]) a.emplaceBack(e);\n        this.debugIndexBuffer = t.createIndexBuffer(a), this.emptyTexture = new e.T(t, new e.r({\n          width: 1,\n          height: 1\n        }, Uint8Array.of(0, 0, 0, 0)), t.gl.RGBA8), this.identityMat = e.ad.mat4.create();\n        const l = this.context.gl;\n        this.stencilClearMode = new Ui({\n          func: l.ALWAYS,\n          mask: 0\n        }, 0, 255, l.ZERO, l.ZERO, l.ZERO), this.loadTimeStamps.push(performance.now());\n      }\n      getMercatorTileBoundsBuffers() {\n        return {\n          tileBoundsBuffer: this.mercatorBoundsBuffer,\n          tileBoundsIndexBuffer: this.quadTriangleIndexBuffer,\n          tileBoundsSegments: this.mercatorBoundsSegments\n        };\n      }\n      getTileBoundsBuffers(e) {\n        return e._makeTileBoundsBuffers(this.context, this.transform.projection), e._tileBoundsBuffer ? {\n          tileBoundsBuffer: e._tileBoundsBuffer,\n          tileBoundsIndexBuffer: e._tileBoundsIndexBuffer,\n          tileBoundsSegments: e._tileBoundsSegments\n        } : this.getMercatorTileBoundsBuffers();\n      }\n      clearStencil() {\n        const e = this.context.gl;\n        this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram(\"clippingMask\").draw(this, e.TRIANGLES, Bi.disabled, this.stencilClearMode, ki.disabled, ji.disabled, Bs(this.identityMat), \"$clipping\", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);\n      }\n      resetStencilClippingMasks() {\n        this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});\n      }\n      _renderTileClippingMasks(e, t, i) {\n        if (!t || this.currentStencilSource === t.id || !e.isTileClipped() || !i || 0 === i.length) return;\n        if (this._tileClippingMaskIDs && !this.terrain) {\n          let e = !1;\n          for (const t of i) if (void 0 === this._tileClippingMaskIDs[t.key]) {\n            e = !0;\n            break;\n          }\n          if (!e) return;\n        }\n        this.currentStencilSource = t.id;\n        const o = this.context,\n          s = o.gl;\n        this.nextStencilID + i.length > 256 && this.clearStencil(), o.setColorMode(ki.disabled), o.setDepthMode(Bi.disabled);\n        const r = this.getOrCreateProgram(\"clippingMask\");\n        this._tileClippingMaskIDs = {};\n        for (const e of i) {\n          const i = t.getTile(e),\n            o = this._tileClippingMaskIDs[e.key] = this.nextStencilID++,\n            {\n              tileBoundsBuffer: n,\n              tileBoundsIndexBuffer: a,\n              tileBoundsSegments: l\n            } = this.getTileBoundsBuffers(i);\n          r.draw(this, s.TRIANGLES, Bi.disabled, new Ui({\n            func: s.ALWAYS,\n            mask: 0\n          }, o, 255, s.KEEP, s.KEEP, s.REPLACE), ki.disabled, ji.disabled, Bs(e.projMatrix), \"$clipping\", n, a, l);\n        }\n      }\n      stencilModeFor3D() {\n        this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();\n        const e = this.nextStencilID++,\n          t = this.context.gl;\n        return new Ui({\n          func: t.NOTEQUAL,\n          mask: 255\n        }, e, 255, t.KEEP, t.KEEP, t.REPLACE);\n      }\n      stencilModeForClipping(e) {\n        if (this.terrain) return this.terrain.stencilModeForRTTOverlap(e);\n        const t = this.context.gl;\n        return new Ui({\n          func: t.EQUAL,\n          mask: 255\n        }, this._tileClippingMaskIDs[e.key], 0, t.KEEP, t.KEEP, t.REPLACE);\n      }\n      stencilConfigForOverlap(e) {\n        const t = this.context.gl,\n          i = e.sort((e, t) => t.overscaledZ - e.overscaledZ),\n          o = i[i.length - 1].overscaledZ,\n          s = i[0].overscaledZ - o + 1;\n        if (s > 1) {\n          this.currentStencilSource = void 0, this.nextStencilID + s > 256 && this.clearStencil();\n          const e = {};\n          for (let i = 0; i < s; i++) e[i + o] = new Ui({\n            func: t.GEQUAL,\n            mask: 255\n          }, i + this.nextStencilID, 255, t.KEEP, t.KEEP, t.REPLACE);\n          return this.nextStencilID += s, [e, i];\n        }\n        return [{\n          [o]: Ui.disabled\n        }, i];\n      }\n      colorModeForRenderPass() {\n        const t = this.context.gl;\n        if (this._showOverdrawInspector) {\n          const i = 1 / 8;\n          return new ki([t.CONSTANT_COLOR, t.ONE, t.CONSTANT_COLOR, t.ONE], new e.al(i, i, i, 0), [!0, !0, !0, !0]);\n        }\n        return \"opaque\" === this.renderPass ? ki.unblended : ki.alphaBlended;\n      }\n      colorModeForDrapableLayerRenderPass(t) {\n        const i = this.context.gl;\n        return (() => this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture)() && \"translucent\" === this.renderPass ? new ki([i.ONE, i.ONE_MINUS_SRC_ALPHA, i.CONSTANT_ALPHA, i.ONE_MINUS_SRC_ALPHA], new e.al(0, 0, 0, void 0 === t ? 0 : t), [!0, !0, !0, !0]) : this.colorModeForRenderPass();\n      }\n      depthModeForSublayer(e, t, i, o = !1) {\n        if (this.depthOcclusion) return new Bi(this.context.gl.GREATER, Bi.ReadOnly, this.depthRangeFor3D);\n        if (!this.opaquePassEnabledForLayer() && !o) return Bi.disabled;\n        const s = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;\n        return new Bi(i || this.context.gl.LEQUAL, t, [s, s]);\n      }\n      opaquePassEnabledForLayer() {\n        return this.currentLayer < this.opaquePassCutoff;\n      }\n      blitDepth() {\n        const t = this.context.gl,\n          i = Math.ceil(this.width),\n          o = Math.ceil(this.height),\n          s = this.context.bindFramebuffer.get(),\n          r = t.getParameter(t.TEXTURE_BINDING_2D);\n        this.depthFBO && this.depthFBO.width === i && this.depthFBO.height === o || (this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), 0 !== i && 0 !== o && (this.depthFBO = new Rr(this.context, i, o, !1, \"texture\"), this.depthTexture = new e.T(this.context, {\n          width: i,\n          height: o,\n          data: null\n        }, t.DEPTH24_STENCIL8), this.depthFBO.depthAttachment.set(this.depthTexture.texture))), this.context.bindFramebuffer.set(s), t.bindTexture(t.TEXTURE_2D, r), this.depthFBO && (t.bindFramebuffer(t.READ_FRAMEBUFFER, null), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, this.depthFBO.framebuffer), t.blitFramebuffer(0, 0, i, o, 0, 0, i, o, t.DEPTH_BUFFER_BIT, t.NEAREST), t.bindFramebuffer(t.FRAMEBUFFER, this.context.bindFramebuffer.current));\n      }\n      updateAverageFPS() {\n        this._fpsHistory.push(0 === this._dt ? 0 : 1e3 / this._dt), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce((e, t) => e + t / this._fpsHistory.length, 0));\n      }\n      render(t, i) {\n        const o = e.q.now();\n        this._dt = o - this._timeStamp, this._timeStamp = o, this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = t.map.repaint, this.style = t, this.options = i;\n        const s = this.style._mergedLayers,\n          r = !(!this.terrain || !this.terrain.enabled),\n          n = () => this.style._getOrder(r).filter(e => {\n            const t = s[e];\n            return !(t.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[t.type];\n          });\n        let a = n(),\n          l = !1,\n          c = !1;\n        for (const e of a) {\n          const t = s[e];\n          \"circle\" === t.type && (l = !0), \"symbol\" === t.type && (t.hasInitialOcclusionOpacityProperties ? c = !0 : l = !0);\n        }\n        let h = a.map(e => s[e]);\n        const d = this.style._mergedSourceCaches;\n        this.imageManager = t.imageManager, this.modelManager = t.modelManager, this.symbolFadeChange = t.placement.symbolFadeChange(e.q.now()), this.imageManager.beginFrame();\n        let u = 0,\n          _ = !1;\n        for (const e in d) {\n          const t = d[e];\n          t.used && (t.prepare(this.context), t.getSource().usedInConflation && ++u);\n        }\n        let p = !1;\n        for (const e of h) e.isHidden(this.transform.zoom) || (\"clip\" === e.type && (p = !0), this.prepareLayer(e));\n        const f = {},\n          m = {},\n          g = {},\n          v = {},\n          y = {};\n        for (const e in d) {\n          const t = d[e];\n          f[e] = t.getVisibleCoordinates(), m[e] = f[e].slice().reverse(), g[e] = t.getVisibleCoordinates(!0).reverse(), v[e] = t.getShadowCasterCoordinates(), y[e] = t.sortCoordinatesByDistance(f[e]);\n        }\n        const x = e => {\n          const t = this.style.getLayerSourceCache(e);\n          return t && t.used ? t.getSource() : null;\n        };\n        if (u || p || this._clippingActiveLastFrame) {\n          const t = [],\n            i = [];\n          let o = 0;\n          for (const e of h) this.isSourceForClippingOrConflation(e, x(e)) && (t.push(e), i.push(o)), o++;\n          if (t && (p || t.length > 1) || this._clippingActiveLastFrame) {\n            p = !1;\n            const o = [];\n            for (let s = 0; s < t.length; s++) {\n              const r = t[s],\n                n = i[s],\n                a = this.style.getLayerSourceCache(r);\n              if (!a || !a.used || !a.getSource().usedInConflation && \"clip\" !== r.type) continue;\n              let l = e.dA,\n                c = e.by.None;\n              const h = [];\n              let d = !0;\n              if (\"clip\" === r.type) {\n                l = n;\n                for (const t of r.layout.get(\"clip-layer-types\")) c |= \"model\" === t ? e.by.Model : \"symbol\" === t ? e.by.Symbol : e.by.FillExtrusion;\n                for (const e of r.layout.get(\"clip-layer-scope\")) h.push(e);\n                r.isHidden(this.transform.zoom) ? d = !1 : p = !0;\n              }\n              d && o.push({\n                layer: r.fqid,\n                cache: a,\n                order: l,\n                clipMask: c,\n                clipScope: h\n              });\n            }\n            this.replacementSource.setSources(o), _ = !0;\n          }\n        }\n        this._clippingActiveLastFrame = p, _ || this.replacementSource.clear(), this.conflationActive = _, this.minCutoffZoom = 0, this.longestCutoffRange = 0, this.opaquePassCutoff = 1 / 0, this._lastOcclusionLayer = -1, this.layersWithOcclusionOpacity = [];\n        for (let e = 0; e < h.length; e++) {\n          const t = h[e],\n            i = t.cutoffRange();\n          if (this.longestCutoffRange = Math.max(i, this.longestCutoffRange), i > 0) {\n            const e = x(t);\n            e && (this.minCutoffZoom = Math.max(e.minzoom, this.minCutoffZoom)), t.minzoom && (this.minCutoffZoom = Math.max(t.minzoom, this.minCutoffZoom));\n          }\n          t.is3D(r) && (this.opaquePassCutoff === 1 / 0 && (this.opaquePassCutoff = e), this._lastOcclusionLayer = e);\n        }\n        const b = this.style && this.style.fog;\n        b ? (this._fogVisible = 0 !== b.getOpacity(this.transform.pitch), this._fogVisible && \"globe\" !== this.transform.projection.name && (this._fogVisible = b.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = !1, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(g), this.opaquePassCutoff = 0, a = n(), h = a.map(e => s[e]));\n        const w = this._shadowRenderer;\n        if (w) {\n          w.updateShadowParameters(this.transform, this.style.directionalLight);\n          for (const e in d) for (const t of f[e]) {\n            let e = {\n              min: 0,\n              max: 0\n            };\n            this.terrain && (e = this.terrain.getMinMaxForTile(t) || e), w.addShadowReceiver(t.toUnwrapped(), e.min, e.max);\n          }\n        }\n        \"globe\" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.dz(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new bn(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0);\n        const T = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.snow),\n          E = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.rain);\n        if (T && !this._snow && (this._snow = new Kn(this)), !T && this._snow && (this._snow.destroy(), delete this._snow), E && !this._rain && (this._rain = new $n(this)), !E && this._rain && (this._rain.destroy(), delete this._rain), this._snow && this._snow.update(this), this._rain && this._rain.update(this), !U.has(this.context.gl)) return;\n        this.renderPass = \"offscreen\";\n        for (const e of h) {\n          const i = t.getLayerSourceCache(e);\n          if (!e.hasOffscreenPass() || e.isHidden(this.transform.zoom)) continue;\n          const o = i ? m[i.id] : void 0;\n          (\"custom\" === e.type || \"raster\" === e.type || \"raster-particle\" === e.type || e.isSky() || o && o.length) && this.renderLayer(this, i, e, o);\n        }\n        this.depthRangeFor3D = [0, 1 - (h.length + 2) * this.numSublayers * this.depthEpsilon], this._shadowRenderer && (this.renderPass = \"shadow\", this._shadowRenderer.drawShadowPass(this.style, v)), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);\n        const S = \"globe\" === this.transform.projection.name || this.transform.isHorizonVisible(),\n          C = (() => {\n            if (i.showOverdrawInspector) return e.al.black;\n            const t = this.style.fog;\n            if (t && this.transform.projection.supportsFog) {\n              const i = this.style.getLut(t.scope);\n              if (!S) {\n                const o = \"none\" === t.properties.get(\"color-use-theme\"),\n                  s = t.properties.get(\"color\").toRenderColor(o ? null : i).toArray01();\n                return new e.al(...s);\n              }\n              if (S) {\n                const o = \"none\" === t.properties.get(\"space-color-use-theme\"),\n                  s = t.properties.get(\"space-color\").toRenderColor(o ? null : i).toArray01();\n                return new e.al(...s);\n              }\n            }\n            return e.al.transparent;\n          })();\n        if (this.context.clear({\n          color: C,\n          depth: 1\n        }), this.clearStencil(), this._showOverdrawInspector = i.showOverdrawInspector, this.renderPass = \"opaque\", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && S && this._atmosphere.drawStars(this, this.style.fog), !this.terrain) for (this.currentLayer = a.length - 1; this.currentLayer >= 0; this.currentLayer--) {\n          const e = h[this.currentLayer],\n            i = t.getLayerSourceCache(e);\n          if (e.isSky()) continue;\n          const o = i ? (e.is3D(r) ? y : m)[i.id] : void 0;\n          this._renderTileClippingMasks(e, i, o), this.renderLayer(this, i, e, o);\n        }\n        if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && S && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = \"sky\", (!this._atmosphere || e.ag(this.transform.zoom) > 0) && (\"globe\" === this.transform.projection.name || this.transform.isHorizonVisible())) for (this.currentLayer = 0; this.currentLayer < a.length; this.currentLayer++) {\n          const e = h[this.currentLayer],\n            i = t.getLayerSourceCache(e);\n          e.isSky() && this.renderLayer(this, i, e, i ? m[i.id] : void 0);\n        }\n        function I(e, t) {\n          let i;\n          return t && (i = (\"symbol\" === e.type ? g : e.is3D(r) ? y : m)[t.id]), i;\n        }\n        if (this.renderPass = \"translucent\", \"globe\" === this.transform.projection.name) {\n          for (this.renderElevatedRasterBackface = !0, this.currentLayer = 0; this.currentLayer < a.length;) {\n            const e = h[this.currentLayer];\n            if (\"raster\" === e.type || \"raster-particle\" === e.type) {\n              const i = t.getLayerSourceCache(e);\n              this.renderLayer(this, i, e, I(e, i));\n            }\n            ++this.currentLayer;\n          }\n          this.renderElevatedRasterBackface = !1;\n        }\n        this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;\n        let R = 0;\n        w && (R = w.getShadowCastingLayerCount());\n        let D = !1,\n          A = -1;\n        for (let e = 0; e < a.length; ++e) {\n          const t = h[e];\n          t.isHidden(this.transform.zoom) || t.is3D(r) && (A = e);\n        }\n        c && -1 === A && (l = !0);\n        let L = !1;\n        for (; this.currentLayer < a.length;) {\n          const e = h[this.currentLayer],\n            i = t.getLayerSourceCache(e);\n          if (e.isSky()) ++this.currentLayer;else if (this.terrain && this.style.isLayerDraped(e)) {\n            if (e.isHidden(this.transform.zoom)) {\n              ++this.currentLayer;\n              continue;\n            }\n            this.currentLayer = this.terrain.renderBatch(this.currentLayer), this._lastOcclusionLayer = Math.max(this.currentLayer, this._lastOcclusionLayer);\n          } else {\n            if (!L && e.is3D(r) && !r) {\n              const e = this.currentLayer,\n                t = e => {\n                  for (this.currentLayer = 0; this.currentLayer < h.length; this.currentLayer++) {\n                    const t = h[this.currentLayer];\n                    if (Qn[t.type]) {\n                      const i = this.style.getLayerSourceCache(t);\n                      Qn[t.type](this, i, t, I(t, i), e);\n                    }\n                  }\n                };\n              t(\"initialize\"), t(\"reset\"), this.currentLayer = e, L = !0;\n            }\n            if (l && !D && this.terrain && !this.transform.isOrthographic && (D = !0, this.blitDepth()), c && -1 !== A && this.currentLayer === A + 1 && !this.transform.isOrthographic && this.blitDepth(), this.terrain || this._renderTileClippingMasks(e, i, i ? f[i.id] : void 0), this.renderLayer(this, i, e, I(e, i)), !this.terrain && w && R > 0 && e.hasShadowPass() && 0 == --R && (w.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer)) {\n              const e = this.currentLayer;\n              for (this.renderPass = \"light-beam\", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= e; this.currentLayer++) {\n                const e = h[this.currentLayer];\n                if (!e.hasLightBeamPass()) continue;\n                const i = t.getLayerSourceCache(e);\n                this.renderLayer(this, i, e, i ? m[i.id] : void 0);\n              }\n              this.currentLayer = e, this.renderPass = \"translucent\";\n            }\n            if (this.currentLayer >= this._lastOcclusionLayer && this.layersWithOcclusionOpacity.length > 0) {\n              const e = this.currentLayer;\n              this.depthOcclusion = !0;\n              for (const e of this.layersWithOcclusionOpacity) {\n                this.currentLayer = e;\n                const i = h[this.currentLayer],\n                  o = t.getLayerSourceCache(i),\n                  s = o ? m[o.id] : void 0;\n                this.terrain || this._renderTileClippingMasks(i, o, o ? f[o.id] : void 0), this.renderLayer(this, o, i, s);\n              }\n              this.depthOcclusion = !1, this.currentLayer = e, this.renderPass = \"translucent\", this.layersWithOcclusionOpacity = [];\n            }\n            ++this.currentLayer;\n          }\n        }\n        if (this.terrain && this.terrain.postRender(), this._snow && this._snow.draw(this), this._rain && this._rain.draw(this), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {\n          let i = null;\n          h.forEach(e => {\n            const o = t.getLayerSourceCache(e);\n            o && !e.isHidden(this.transform.zoom) && o.getVisibleCoordinates().length && (!i || i.getSource().maxzoom < o.getSource().maxzoom) && (i = o);\n          }), i && this.options.showTileBoundaries && Yn.debug(this, i, i.getVisibleCoordinates(), e.al.red, !1, this.options.showParseStatus);\n        }\n        this.terrain && this._debugParams.showTerrainProxyTiles && Yn.debug(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new e.al(1, .8, .1, 1), !0, this.options.showParseStatus), this.options.showPadding && function (e) {\n          const t = e.transform.padding;\n          cn(e, e.transform.height - (t.top || 0), 3, on), cn(e, t.bottom || 0, 3, sn), hn(e, t.left || 0, 3, rn), hn(e, e.transform.width - (t.right || 0), 3, nn);\n          const i = e.transform.centerPoint;\n          !function (e, t, i, o) {\n            dn(e, t - 1, i - 10, 2, 20, o), dn(e, t - 10, i - 1, 20, 2, o);\n          }(e, i.x, e.transform.height - i.y, an);\n        }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), _ || (this.conflationActive = !1);\n      }\n      prepareLayer(e) {\n        this.gpuTimingStart(e);\n        const {\n            unsupportedLayers: t\n          } = this.transform.projection,\n          i = !t || !t.includes(e.type);\n        if (Jn[e.type] && (i || this.terrain && \"custom\" === e.type)) {\n          const t = this.style.getLayerSourceCache(e);\n          Jn[e.type](e, t, this);\n        }\n        this.gpuTimingEnd();\n      }\n      renderLayer(e, t, i, o) {\n        i.isHidden(this.transform.zoom) || (\"background\" === i.type || \"sky\" === i.type || \"custom\" === i.type || \"model\" === i.type || \"raster\" === i.type || \"raster-particle\" === i.type || o && o.length) && (this.id = i.id, this.gpuTimingStart(i), e.transform.projection.unsupportedLayers && e.transform.projection.unsupportedLayers.includes(i.type) && (!e.terrain || \"custom\" !== i.type) || \"clip\" === i.type || Yn[i.type](e, t, i, o, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());\n      }\n      gpuTimingStart(e) {\n        if (!this.options.gpuTiming) return;\n        const t = this.context.extTimerQuery,\n          i = this.context.gl;\n        let o = this.gpuTimers[e.id];\n        o || (o = this.gpuTimers[e.id] = {\n          calls: 0,\n          cpuTime: 0,\n          query: i.createQuery()\n        }), o.calls++, i.beginQuery(t.TIME_ELAPSED_EXT, o.query);\n      }\n      gpuTimingDeferredRenderStart() {\n        if (this.options.gpuTimingDeferredRender) {\n          const e = this.context.extTimerQuery,\n            t = this.context.gl,\n            i = t.createQuery();\n          this.deferredRenderGpuTimeQueries.push(i), t.beginQuery(e.TIME_ELAPSED_EXT, i);\n        }\n      }\n      gpuTimingDeferredRenderEnd() {\n        this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);\n      }\n      gpuTimingEnd() {\n        this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);\n      }\n      collectGpuTimers() {\n        const e = this.gpuTimers;\n        return this.gpuTimers = {}, e;\n      }\n      collectDeferredRenderGpuQueries() {\n        const e = this.deferredRenderGpuTimeQueries;\n        return this.deferredRenderGpuTimeQueries = [], e;\n      }\n      queryGpuTimers(e) {\n        const t = {};\n        for (const i in e) {\n          const o = e[i],\n            s = this.context.extTimerQuery,\n            r = s.getQueryParameter(o.query, this.context.gl.QUERY_RESULT) / 1e6;\n          s.deleteQueryEXT(o.query), t[i] = r;\n        }\n        return t;\n      }\n      queryGpuTimeDeferredRender(e) {\n        if (!this.options.gpuTimingDeferredRender) return 0;\n        const t = this.context.gl;\n        let i = 0;\n        for (const o of e) i += t.getQueryParameter(o, t.QUERY_RESULT) / 1e6, t.deleteQuery(o);\n        return i;\n      }\n      translatePosMatrix(t, i, o, s, r) {\n        if (!o[0] && !o[1]) return t;\n        const n = r ? \"map\" === s ? this.transform.angle : 0 : \"viewport\" === s ? -this.transform.angle : 0;\n        if (n) {\n          const e = Math.sin(n),\n            t = Math.cos(n);\n          o = [o[0] * t - o[1] * e, o[0] * e + o[1] * t];\n        }\n        const a = [r ? o[0] : e.at(i, o[0], this.transform.zoom), r ? o[1] : e.at(i, o[1], this.transform.zoom), 0],\n          l = new Float32Array(16);\n        return e.ad.mat4.translate(l, t, a), l;\n      }\n      saveTileTexture(e) {\n        const t = e.size[0],\n          i = this._tileTextures[t];\n        i ? i.push(e) : this._tileTextures[t] = [e];\n      }\n      getTileTexture(e) {\n        const t = this._tileTextures[e];\n        return t && t.length > 0 ? t.pop() : null;\n      }\n      terrainRenderModeElevated() {\n        return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture || this.forceTerrainMode;\n      }\n      linearFloatFilteringSupported() {\n        return null != this.context.extTextureFloatLinear;\n      }\n      currentGlobalDefines(e, t, i) {\n        const o = void 0 === i ? this.terrain && this.terrain.renderingToTexture : i,\n          s = [];\n        return this.style && this.style.enable3dLights() && (\"globeRaster\" === e || \"terrainRaster\" === e ? (s.push(\"LIGHTING_3D_MODE\"), s.push(\"LIGHTING_3D_ALPHA_EMISSIVENESS\")) : o || s.push(\"LIGHTING_3D_MODE\")), \"shadow\" === this.renderPass && (this._shadowMapDebug || s.push(\"DEPTH_TEXTURE\")), this.terrainRenderModeElevated() && (s.push(\"TERRAIN\"), this.linearFloatFilteringSupported() && s.push(\"TERRAIN_DEM_FLOAT_FORMAT\")), \"globe\" === this.transform.projection.name && s.push(\"GLOBE\"), !this._fogVisible || o || void 0 !== t && !t || s.push(\"FOG\", \"FOG_DITHERING\"), o && s.push(\"RENDER_TO_TEXTURE\"), this._showOverdrawInspector && s.push(\"OVERDRAW_INSPECTOR\"), s;\n      }\n      getOrCreateProgram(e, t) {\n        this.cache = this.cache || {};\n        const i = t && t.defines || [],\n          o = t && t.config,\n          s = this.currentGlobalDefines(e, t && t.overrideFog, t && t.overrideRtt).concat(i),\n          r = Ws.cacheKey(Uo[e], e, s, o);\n        return this.cache[r] || (this.cache[r] = new Ws(this.context, e, Uo[e], o, Er[e], s)), this.cache[r];\n      }\n      setCustomLayerDefaults() {\n        this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();\n      }\n      setBaseState() {\n        const e = this.context.gl;\n        this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e.FUNC_ADD);\n      }\n      initDebugOverlayCanvas() {\n        null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement(\"canvas\"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA8));\n      }\n      destroy() {\n        this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy(), this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), this.emptyDepthTexture && this.emptyDepthTexture.destroy();\n      }\n      prepareDrawTile() {\n        this.terrain && this.terrain.prepareDrawTile();\n      }\n      uploadCommonLightUniforms(t, i) {\n        if (this.style.enable3dLights()) {\n          const o = this.style.directionalLight,\n            s = this.style.ambientLight;\n          if (o && s) {\n            const r = ((t, i, o) => {\n              const s = t.properties.get(\"direction\"),\n                r = \"none\" === t.properties.get(\"color-use-theme\"),\n                n = t.properties.get(\"color\").toRenderColor(r ? null : o.getLut(t.scope)).toArray01(),\n                a = t.properties.get(\"intensity\"),\n                l = \"none\" === i.properties.get(\"color-use-theme\"),\n                c = i.properties.get(\"color\").toRenderColor(l ? null : o.getLut(i.scope)).toArray01(),\n                h = i.properties.get(\"intensity\"),\n                d = [s.x, s.y, s.z],\n                u = e.cN(c, h),\n                _ = e.cN(n, a);\n              return {\n                u_lighting_ambient_color: u,\n                u_lighting_directional_dir: d,\n                u_lighting_directional_color: _,\n                u_ground_radiance: qs(d, _, u)\n              };\n            })(o, s, this.style);\n            i.setLightsUniformValues(t, r);\n          }\n        }\n      }\n      uploadCommonUniforms(t, i, o, s, r) {\n        if (this.uploadCommonLightUniforms(t, i), this.terrain && this.terrain.renderingToTexture) return;\n        const n = this.style.fog;\n        if (n) {\n          const r = n.getOpacity(this.transform.pitch),\n            a = ((t, i, o, s, r, n, a, l, c, h, d, u) => {\n              const _ = t.transform,\n                p = \"none\" === i.properties.get(\"color-use-theme\"),\n                f = i.properties.get(\"color\").toRenderColor(p ? null : t.style.getLut(i.scope)).toArray01();\n              f[3] = s;\n              const m = t.frameCounter / 1e3 % 1,\n                [g, v] = i.properties.get(\"vertical-range\");\n              return {\n                u_fog_matrix: o ? _.calculateFogTileMatrix(o) : u || t.identityMat,\n                u_fog_range: i.getFovAdjustedRange(_._fov),\n                u_fog_color: f,\n                u_fog_horizon_blend: i.properties.get(\"horizon-blend\"),\n                u_fog_vertical_limit: [Math.min(g, v), v],\n                u_fog_temporal_offset: m,\n                u_frustum_tl: r,\n                u_frustum_tr: n,\n                u_frustum_br: a,\n                u_frustum_bl: l,\n                u_globe_pos: c,\n                u_globe_radius: h,\n                u_viewport: d,\n                u_globe_transition: e.ag(_.zoom),\n                u_is_globe: +(\"globe\" === _.projection.name)\n              };\n            })(this, n, o, r, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e.q.devicePixelRatio, this.transform.height * e.q.devicePixelRatio], s);\n          i.setFogUniformValues(t, a);\n        }\n        r && i.setCutoffUniformValues(t, r.uniformValues);\n      }\n      setTileLoadedFlag(e) {\n        this.tileLoaded = e;\n      }\n      saveCanvasCopy() {\n        const e = this.canvasCopy();\n        e && (this.frameCopies.push(e), this.tileLoaded = !1);\n      }\n      canvasCopy() {\n        const e = this.context.gl,\n          t = e.createTexture();\n        return e.bindTexture(e.TEXTURE_2D, t), e.copyTexImage2D(e.TEXTURE_2D, 0, e.RGBA, 0, 0, e.drawingBufferWidth, e.drawingBufferHeight, 0), t;\n      }\n      getCanvasCopiesAndTimestamps() {\n        return {\n          canvasCopies: this.frameCopies,\n          timeStamps: this.loadTimeStamps\n        };\n      }\n      averageElevationNeedsEasing() {\n        if (!this.transform._elevation) return !1;\n        const e = this.style && this.style.fog;\n        return !!e && 0 !== e.getOpacity(this.transform.pitch);\n      }\n      getBackgroundTiles() {\n        const e = this._backgroundTiles,\n          t = this._backgroundTiles = {},\n          i = this.transform.coveringTiles({\n            tileSize: 512\n          });\n        for (const o of i) t[o.key] = e[o.key] || new bt(o, 512, this.transform.tileZoom, this);\n        return t;\n      }\n      clearBackgroundTiles() {\n        this._backgroundTiles = {};\n      }\n      isSourceForClippingOrConflation(e, t) {\n        return !(!e.is3D(!(!this.terrain || !this.terrain.enabled)) || \"clip\" !== e.type && (e.minzoom && e.minzoom > this.transform.zoom || (this.style._clipLayerPresent || \"building\" !== e.sourceLayer) && (!t || \"batched-model\" !== t.type)));\n      }\n      isTileAffectedByFog(e) {\n        if (!this.style || !this.style.fog) return !1;\n        if (\"globe\" === this.transform.projection.name) return !0;\n        let t = this._cachedTileFogOpacities[e.key];\n        return t || (this._cachedTileFogOpacities[e.key] = t = this.style.fog.getOpacityForTile(e)), t[0] >= Fe || t[1] >= Fe;\n      }\n      setupDepthForOcclusion(e, t, i) {\n        const o = this.context,\n          s = o.gl,\n          r = !!i;\n        var n;\n        i || (i = {\n          u_dem: 2,\n          u_dem_prev: 4,\n          u_dem_tl: [0, 0],\n          u_dem_tl_prev: [0, 0],\n          u_dem_scale: 0,\n          u_dem_scale_prev: 0,\n          u_dem_size: 0,\n          u_dem_lerp: 1,\n          u_depth: 3,\n          u_depth_size_inv: [0, 0],\n          u_depth_range_unpack: [0, 1],\n          u_occluder_half_size: 16,\n          u_occlusion_depth_offset: -1e-4,\n          u_exaggeration: 0\n        }), o.activeTexture.set(s.TEXTURE3), e && this.depthFBO && this.depthTexture ? (this.depthTexture.bind(s.NEAREST, s.CLAMP_TO_EDGE), i.u_depth_size_inv = [1 / this.depthFBO.width, 1 / this.depthFBO.height], i.u_depth_range_unpack = [2 / ((n = this.depthRangeFor3D)[1] - n[0]), -1 - 2 * n[0] / (n[1] - n[0])], i.u_occluder_half_size = .5 * this.occlusionParams.occluderSize, i.u_occlusion_depth_offset = this.occlusionParams.depthOffset) : this.emptyDepthTexture.bind(s.NEAREST, s.CLAMP_TO_EDGE), o.activeTexture.set(s.TEXTURE0), r || t.setTerrainUniformValues(o, i);\n      }\n    }\n    function ta(e, t) {\n      let i = !1,\n        o = null;\n      const s = () => {\n        o = null, i && (e(), o = setTimeout(s, t), i = !1);\n      };\n      return () => (i = !0, o || s(), o);\n    }\n    class ia {\n      constructor(t) {\n        this._hashName = t && encodeURIComponent(t), e.aQ([\"_getCurrentHash\", \"_onHashChange\", \"_updateHash\"], this), this._updateHash = ta(this._updateHashUnthrottled.bind(this), 300);\n      }\n      addTo(e) {\n        return this._map = e, window.addEventListener(\"hashchange\", this._onHashChange, !1), e.on(\"moveend\", this._updateHash), this;\n      }\n      remove() {\n        return this._map ? (this._map.off(\"moveend\", this._updateHash), window.removeEventListener(\"hashchange\", this._onHashChange, !1), clearTimeout(this._updateHash()), this._map = void 0, this) : this;\n      }\n      getHashString() {\n        const e = this._map;\n        if (!e) return \"\";\n        const t = oa(e);\n        if (this._hashName) {\n          const e = this._hashName;\n          let i = !1;\n          const o = location.hash.slice(1).split(\"&\").map(o => {\n            const s = o.split(\"=\")[0];\n            return s === e ? (i = !0, `${s}=${t}`) : o;\n          }).filter(e => e);\n          return i || o.push(`${e}=${t}`), `#${o.join(\"&\")}`;\n        }\n        return `#${t}`;\n      }\n      _getCurrentHash() {\n        const e = location.hash.replace(\"#\", \"\");\n        if (this._hashName) {\n          let t;\n          return e.split(\"&\").map(e => e.split(\"=\")).forEach(e => {\n            e[0] === this._hashName && (t = e);\n          }), (t && t[1] || \"\").split(\"/\");\n        }\n        return e.split(\"/\");\n      }\n      _onHashChange() {\n        const e = this._map;\n        if (!e) return !1;\n        const t = this._getCurrentHash();\n        if (t.length >= 3 && !t.some(e => isNaN(e))) {\n          const i = e.dragRotate.isEnabled() && e.touchZoomRotate.isEnabled() ? +(t[3] || 0) : e.getBearing();\n          return e.jumpTo({\n            center: [+t[2], +t[1]],\n            zoom: +t[0],\n            bearing: i,\n            pitch: +(t[4] || 0)\n          }), !0;\n        }\n        return !1;\n      }\n      _updateHashUnthrottled() {\n        history.replaceState(history.state, \"\", location.href.replace(/(#.+)?$/, this.getHashString()));\n      }\n    }\n    function oa(e, t) {\n      const i = e.getCenter(),\n        o = Math.round(100 * e.getZoom()) / 100,\n        s = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10),\n        r = Math.pow(10, s),\n        n = Math.round(i.lng * r) / r,\n        a = Math.round(i.lat * r) / r,\n        l = e.getBearing(),\n        c = e.getPitch();\n      let h = t ? `/${n}/${a}/${o}` : `${o}/${a}/${n}`;\n      return (l || c) && (h += \"/\" + Math.round(10 * l) / 10), c && (h += `/${Math.round(c)}`), h;\n    }\n    const sa = {\n        linearity: .3,\n        easing: e.dB(0, 0, .3, 1)\n      },\n      ra = e.l({\n        deceleration: 2500,\n        maxSpeed: 1400\n      }, sa),\n      na = e.l({\n        deceleration: 20,\n        maxSpeed: 1400\n      }, sa),\n      aa = e.l({\n        deceleration: 1e3,\n        maxSpeed: 360\n      }, sa),\n      la = e.l({\n        deceleration: 1e3,\n        maxSpeed: 90\n      }, sa);\n    class ca {\n      constructor(e) {\n        this._map = e, this.clear();\n      }\n      clear() {\n        this._inertiaBuffer = [];\n      }\n      record(t) {\n        this._drainInertiaBuffer(), this._inertiaBuffer.push({\n          time: e.q.now(),\n          settings: t\n        });\n      }\n      _drainInertiaBuffer() {\n        const t = this._inertiaBuffer,\n          i = e.q.now();\n        for (; t.length > 0 && i - t[0].time > 160;) t.shift();\n      }\n      _onMoveEnd(t) {\n        if (this._map._prefersReducedMotion()) return;\n        if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;\n        const i = {\n          zoom: 0,\n          bearing: 0,\n          pitch: 0,\n          pan: new e.P(0, 0),\n          pinchAround: void 0,\n          around: void 0\n        };\n        for (const {\n          settings: e\n        } of this._inertiaBuffer) i.zoom += e.zoomDelta || 0, i.bearing += e.bearingDelta || 0, i.pitch += e.pitchDelta || 0, e.panDelta && i.pan._add(e.panDelta), e.around && (i.around = e.around), e.pinchAround && (i.pinchAround = e.pinchAround);\n        const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,\n          s = {};\n        if (i.pan.mag()) {\n          const r = da(i.pan.mag(), o, e.l({}, ra, t || {}));\n          s.offset = i.pan.mult(r.amount / i.pan.mag()), s.center = this._map.transform.center, ha(s, r);\n        }\n        if (i.zoom) {\n          const e = da(i.zoom, o, na);\n          s.zoom = this._map.transform.zoom + e.amount, ha(s, e);\n        }\n        if (i.bearing) {\n          const t = da(i.bearing, o, aa);\n          s.bearing = this._map.transform.bearing + e.ay(t.amount, -179, 179), ha(s, t);\n        }\n        if (i.pitch) {\n          const e = da(i.pitch, o, la);\n          s.pitch = this._map.transform.pitch + e.amount, ha(s, e);\n        }\n        if (s.zoom || s.bearing) {\n          const e = void 0 === i.pinchAround ? i.around : i.pinchAround;\n          s.around = e ? this._map.unproject(e) : this._map.getCenter();\n        }\n        return this.clear(), s.noMoveStart = !0, s;\n      }\n    }\n    function ha(e, t) {\n      (!e.duration || e.duration < t.duration) && (e.duration = t.duration, e.easing = t.easing);\n    }\n    function da(t, i, o) {\n      const {\n          maxSpeed: s,\n          linearity: r,\n          deceleration: n\n        } = o,\n        a = e.ay(t * r / (i / 1e3), -s, s),\n        l = Math.abs(a) / (n * r);\n      return {\n        easing: o.easing,\n        duration: 1e3 * l,\n        amount: a * (l / 2)\n      };\n    }\n    class ua extends e.A {\n      preventDefault() {\n        this._defaultPrevented = !0;\n      }\n      get defaultPrevented() {\n        return this._defaultPrevented;\n      }\n      constructor(t, i, o, s = {}) {\n        const r = g(i.getCanvasContainer(), o),\n          n = i.unproject(r);\n        super(t, e.l({\n          point: r,\n          lngLat: n,\n          originalEvent: o\n        }, s)), this._defaultPrevented = !1, this.target = i;\n      }\n    }\n    class _a extends e.A {\n      preventDefault() {\n        this._defaultPrevented = !0;\n      }\n      get defaultPrevented() {\n        return this._defaultPrevented;\n      }\n      constructor(t, i, o) {\n        const s = \"touchend\" === t ? o.changedTouches : o.touches,\n          r = v(i.getCanvasContainer(), s),\n          n = r.map(e => i.unproject(e)),\n          a = r.reduce((e, t, i, o) => e.add(t.div(o.length)), new e.P(0, 0));\n        super(t, {\n          points: r,\n          point: a,\n          lngLats: n,\n          lngLat: i.unproject(a),\n          originalEvent: o\n        }), this._defaultPrevented = !1;\n      }\n    }\n    class pa extends e.A {\n      preventDefault() {\n        this._defaultPrevented = !0;\n      }\n      get defaultPrevented() {\n        return this._defaultPrevented;\n      }\n      constructor(e, t) {\n        super(\"wheel\", {\n          originalEvent: t\n        }), this._defaultPrevented = !1;\n      }\n    }\n    class fa {\n      constructor(e, t) {\n        this._map = e, this._clickTolerance = t.clickTolerance;\n      }\n      reset() {\n        this._mousedownPos = void 0;\n      }\n      wheel(e) {\n        return this._firePreventable(new pa(this._map, e));\n      }\n      mousedown(e, t) {\n        return this._mousedownPos = t, this._firePreventable(new ua(e.type, this._map, e));\n      }\n      mouseup(e) {\n        this._map.fire(new ua(e.type, this._map, e));\n      }\n      preclick(t) {\n        const i = e.l({}, t);\n        i.type = \"preclick\", this._map.fire(new ua(i.type, this._map, i));\n      }\n      click(e, t) {\n        this._mousedownPos && this._mousedownPos.dist(t) >= this._clickTolerance || (this.preclick(e), this._map.fire(new ua(e.type, this._map, e)));\n      }\n      dblclick(e) {\n        return this._firePreventable(new ua(e.type, this._map, e));\n      }\n      mouseover(e) {\n        this._map.fire(new ua(e.type, this._map, e));\n      }\n      mouseout(e) {\n        this._map.fire(new ua(e.type, this._map, e));\n      }\n      touchstart(e) {\n        return this._firePreventable(new _a(e.type, this._map, e));\n      }\n      touchmove(e) {\n        this._map.fire(new _a(e.type, this._map, e));\n      }\n      touchend(e) {\n        this._map.fire(new _a(e.type, this._map, e));\n      }\n      touchcancel(e) {\n        this._map.fire(new _a(e.type, this._map, e));\n      }\n      _firePreventable(e) {\n        if (this._map.fire(e), e.defaultPrevented) return {};\n      }\n      isEnabled() {\n        return !0;\n      }\n      isActive() {\n        return !1;\n      }\n      enable() {}\n      disable() {}\n    }\n    class ma {\n      constructor(e) {\n        this._map = e;\n      }\n      reset() {\n        this._delayContextMenu = !1, this._contextMenuEvent = void 0;\n      }\n      mousemove(e) {\n        this._map.fire(new ua(e.type, this._map, e));\n      }\n      mousedown() {\n        this._delayContextMenu = !0;\n      }\n      mouseup() {\n        this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new ua(\"contextmenu\", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);\n      }\n      contextmenu(e) {\n        this._delayContextMenu ? this._contextMenuEvent = e : this._map.fire(new ua(e.type, this._map, e)), this._map.listens(\"contextmenu\") && e.preventDefault();\n      }\n      isEnabled() {\n        return !0;\n      }\n      isActive() {\n        return !1;\n      }\n      enable() {}\n      disable() {}\n    }\n    class ga {\n      constructor(e, t) {\n        this._map = e, this._el = e.getCanvasContainer(), this._container = e.getContainer(), this._clickTolerance = t.clickTolerance || 1;\n      }\n      isEnabled() {\n        return !!this._enabled;\n      }\n      isActive() {\n        return !!this._active;\n      }\n      enable() {\n        this.isEnabled() || (this._enabled = !0);\n      }\n      disable() {\n        this.isEnabled() && (this._enabled = !1);\n      }\n      mousedown(e, t) {\n        this.isEnabled() && e.shiftKey && 0 === e.button && (_(), this._startPos = this._lastPos = t, this._active = !0);\n      }\n      mousemoveWindow(e, t) {\n        if (!this._active) return;\n        const i = t,\n          o = this._startPos,\n          s = this._lastPos;\n        if (!o || !s || s.equals(i) || !this._box && i.dist(o) < this._clickTolerance) return;\n        this._lastPos = i, this._box || (this._box = l(\"div\", \"mapboxgl-boxzoom\", this._container), this._container.classList.add(\"mapboxgl-crosshair\"), this._fireEvent(\"boxzoomstart\", e));\n        const r = Math.min(o.x, i.x),\n          n = Math.max(o.x, i.x),\n          a = Math.min(o.y, i.y),\n          c = Math.max(o.y, i.y);\n        this._map._requestDomTask(() => {\n          this._box && (this._box.style.transform = `translate(${r}px,${a}px)`, this._box.style.width = n - r + \"px\", this._box.style.height = c - a + \"px\");\n        });\n      }\n      mouseupWindow(t, i) {\n        if (!this._active) return;\n        const o = this._startPos,\n          s = i;\n        if (o && 0 === t.button) {\n          if (this.reset(), m(), o.x !== s.x || o.y !== s.y) return this._map.fire(new e.A(\"boxzoomend\", {\n            originalEvent: t\n          })), {\n            cameraAnimation: e => e.fitScreenCoordinates(o, s, this._map.getBearing(), {\n              linear: !1\n            })\n          };\n          this._fireEvent(\"boxzoomcancel\", t);\n        }\n      }\n      keydown(e) {\n        this._active && 27 === e.keyCode && (this.reset(), this._fireEvent(\"boxzoomcancel\", e));\n      }\n      blur() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1, this._container.classList.remove(\"mapboxgl-crosshair\"), this._box && (this._box.remove(), this._box = null), p(), delete this._startPos, delete this._lastPos;\n      }\n      _fireEvent(t, i) {\n        return this._map.fire(new e.A(t, {\n          originalEvent: i\n        }));\n      }\n    }\n    function va(e, t) {\n      const i = {};\n      for (let o = 0; o < e.length; o++) i[e[o].identifier] = t[o];\n      return i;\n    }\n    class ya {\n      constructor(e) {\n        this.reset(), this.numTouches = e.numTouches;\n      }\n      reset() {\n        this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = !1;\n      }\n      touchstart(t, i, o) {\n        (this.centroid || o.length > this.numTouches) && (this.aborted = !0), this.aborted || (0 === this.startTime && (this.startTime = t.timeStamp), o.length === this.numTouches && (this.centroid = function (t) {\n          const i = new e.P(0, 0);\n          for (const e of t) i._add(e);\n          return i.div(t.length);\n        }(i), this.touches = va(o, i)));\n      }\n      touchmove(e, t, i) {\n        if (this.aborted || !this.centroid) return;\n        const o = va(i, t);\n        for (const e in this.touches) {\n          const t = o[e];\n          (!t || t.dist(this.touches[e]) > 30) && (this.aborted = !0);\n        }\n      }\n      touchend(e, t, i) {\n        if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0), 0 === i.length) {\n          const e = !this.aborted && this.centroid;\n          if (this.reset(), e) return e;\n        }\n      }\n    }\n    class xa {\n      constructor(e) {\n        this.singleTap = new ya(e), this.numTaps = e.numTaps, this.reset();\n      }\n      reset() {\n        this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();\n      }\n      touchstart(e, t, i) {\n        this.singleTap.touchstart(e, t, i);\n      }\n      touchmove(e, t, i) {\n        this.singleTap.touchmove(e, t, i);\n      }\n      touchend(e, t, i) {\n        const o = this.singleTap.touchend(e, t, i);\n        if (o) {\n          const t = e.timeStamp - this.lastTime < 500,\n            i = !this.lastTap || this.lastTap.dist(o) < 30;\n          if (t && i || this.reset(), this.count++, this.lastTime = e.timeStamp, this.lastTap = o, this.count === this.numTaps) return this.reset(), o;\n        }\n      }\n    }\n    class ba {\n      constructor() {\n        this._zoomIn = new xa({\n          numTouches: 1,\n          numTaps: 2\n        }), this._zoomOut = new xa({\n          numTouches: 2,\n          numTaps: 1\n        }), this.reset();\n      }\n      reset() {\n        this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();\n      }\n      touchstart(e, t, i) {\n        this._zoomIn.touchstart(e, t, i), this._zoomOut.touchstart(e, t, i);\n      }\n      touchmove(e, t, i) {\n        this._zoomIn.touchmove(e, t, i), this._zoomOut.touchmove(e, t, i);\n      }\n      touchend(e, t, i) {\n        const o = this._zoomIn.touchend(e, t, i),\n          s = this._zoomOut.touchend(e, t, i);\n        return o ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), {\n          cameraAnimation: t => t.easeTo({\n            duration: 300,\n            zoom: t.getZoom() + 1,\n            around: t.unproject(o)\n          }, {\n            originalEvent: e\n          })\n        }) : s ? (this._active = !0, e.preventDefault(), setTimeout(() => this.reset(), 0), {\n          cameraAnimation: t => t.easeTo({\n            duration: 300,\n            zoom: t.getZoom() - 1,\n            around: t.unproject(s)\n          }, {\n            originalEvent: e\n          })\n        }) : void 0;\n      }\n      touchcancel() {\n        this.reset();\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    const wa = {\n        0: 1,\n        2: 2\n      },\n      Ta = {\n        Control: \"ctrlKey\",\n        Alt: \"altKey\",\n        Shift: \"shiftKey\",\n        Meta: \"metaKey\"\n      };\n    class Ea {\n      constructor(e) {\n        this.reset(), this._clickTolerance = e.clickTolerance || 1;\n      }\n      blur() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1, this._moved = !1, this._lastPoint = void 0, this._eventButton = void 0;\n      }\n      _correctButton(e, t) {\n        return !1;\n      }\n      _move(e, t) {\n        return {};\n      }\n      mousedown(e, t) {\n        if (this._lastPoint) return;\n        const i = y(e);\n        this._correctButton(e, i) && (this._lastPoint = t, this._eventButton = i);\n      }\n      mousemoveWindow(e, t) {\n        const i = this._lastPoint;\n        if (i) if (e.preventDefault(), null != this._eventButton && function (e, t) {\n          const i = wa[t];\n          return void 0 === e.buttons || (e.buttons & i) !== i;\n        }(e, this._eventButton)) this.reset();else if (this._moved || !(t.dist(i) < this._clickTolerance)) return this._moved = !0, this._lastPoint = t, this._move(i, t);\n      }\n      mouseupWindow(e) {\n        this._lastPoint && y(e) === this._eventButton && (this._moved && m(), this.reset());\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    class Sa extends Ea {\n      mousedown(e, t) {\n        super.mousedown(e, t), this._lastPoint && (this._active = !0);\n      }\n      _correctButton(e, t) {\n        return 0 === t && !e.ctrlKey;\n      }\n      _move(e, t) {\n        return {\n          around: t,\n          panDelta: t.sub(e)\n        };\n      }\n    }\n    class Ca extends Ea {\n      constructor(e) {\n        super(e), this._pitchRotateKey = e.pitchRotateKey ? Ta[e.pitchRotateKey] : void 0;\n      }\n      _correctButton(e, t) {\n        return this._pitchRotateKey ? 0 === t && e[this._pitchRotateKey] : 0 === t && e.ctrlKey || 2 === t;\n      }\n      _move(e, t) {\n        const i = .8 * (t.x - e.x);\n        if (i) return this._active = !0, {\n          bearingDelta: i\n        };\n      }\n      contextmenu(e) {\n        this._pitchRotateKey || e.preventDefault();\n      }\n    }\n    class Ia extends Ea {\n      constructor(e) {\n        super(e), this._pitchRotateKey = e.pitchRotateKey ? Ta[e.pitchRotateKey] : void 0;\n      }\n      _correctButton(e, t) {\n        return this._pitchRotateKey ? 0 === t && e[this._pitchRotateKey] : 0 === t && e.ctrlKey || 2 === t;\n      }\n      _move(e, t) {\n        const i = -.5 * (t.y - e.y);\n        if (i) return this._active = !0, {\n          pitchDelta: i\n        };\n      }\n      contextmenu(e) {\n        this._pitchRotateKey || e.preventDefault();\n      }\n    }\n    class Ra {\n      constructor(t, i) {\n        this._map = t, this._el = t.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i.clickTolerance || 1, this.reset(), e.aQ([\"_addTouchPanBlocker\", \"_showTouchPanBlockerAlert\"], this);\n      }\n      reset() {\n        this._active = !1, this._touches = {}, this._sum = new e.P(0, 0);\n      }\n      touchstart(e, t, i) {\n        return this._calculateTransform(e, t, i);\n      }\n      touchmove(t, i, o) {\n        if (this._active && !(o.length < this._minTouches)) {\n          if (this._map._cooperativeGestures && !this._map.isMoving()) {\n            if (1 === o.length && !e.dC()) return void this._showTouchPanBlockerAlert();\n            \"hidden\" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = \"hidden\", clearTimeout(this._alertTimer));\n          }\n          return t.cancelable && t.preventDefault(), this._calculateTransform(t, i, o);\n        }\n      }\n      touchend(e, t, i) {\n        this._calculateTransform(e, t, i), this._active && i.length < this._minTouches && this.reset();\n      }\n      touchcancel() {\n        this.reset();\n      }\n      _calculateTransform(t, i, o) {\n        o.length > 0 && (this._active = !0);\n        const s = va(o, i),\n          r = new e.P(0, 0),\n          n = new e.P(0, 0);\n        let a = 0;\n        for (const e in s) {\n          const t = s[e],\n            i = this._touches[e];\n          i && (r._add(t), n._add(t.sub(i)), a++, s[e] = t);\n        }\n        if (this._touches = s, a < this._minTouches || !n.mag()) return;\n        const l = n.div(a);\n        return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : {\n          around: r.div(a),\n          panDelta: l\n        };\n      }\n      enable() {\n        this._enabled = !0, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add(\"mapboxgl-touch-pan-blocker-override\", \"mapboxgl-scrollable-page\"));\n      }\n      disable() {\n        this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove(\"mapboxgl-touch-pan-blocker-override\", \"mapboxgl-scrollable-page\")), this.reset();\n      }\n      isEnabled() {\n        return !!this._enabled;\n      }\n      isActive() {\n        return !!this._active;\n      }\n      _addTouchPanBlocker() {\n        this._map && !this._alertContainer && (this._alertContainer = l(\"div\", \"mapboxgl-touch-pan-blocker\", this._map._container), this._alertContainer.textContent = this._map._getUIString(\"TouchPanBlocker.Message\"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);\n      }\n      _showTouchPanBlockerAlert() {\n        this._alertContainer.style.visibility = \"visible\", this._alertContainer.classList.add(\"mapboxgl-touch-pan-blocker-show\"), this._alertContainer.setAttribute(\"role\", \"alert\"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {\n          this._alertContainer.classList.remove(\"mapboxgl-touch-pan-blocker-show\"), this._alertContainer.removeAttribute(\"role\");\n        }, 500);\n      }\n    }\n    class Da {\n      constructor() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1, this._firstTwoTouches = void 0;\n      }\n      _start(e) {}\n      _move(e, t, i) {\n        return {};\n      }\n      touchstart(e, t, i) {\n        this._firstTwoTouches || i.length < 2 || (this._firstTwoTouches = [i[0].identifier, i[1].identifier], this._start([t[0], t[1]]));\n      }\n      touchmove(e, t, i) {\n        const o = this._firstTwoTouches;\n        if (!o) return;\n        e.preventDefault();\n        const [s, r] = o,\n          n = Aa(i, t, s),\n          a = Aa(i, t, r);\n        if (!n || !a) return;\n        const l = this._aroundCenter ? null : n.add(a).div(2);\n        return this._move([n, a], l, e);\n      }\n      touchend(e, t, i) {\n        if (!this._firstTwoTouches) return;\n        const [o, s] = this._firstTwoTouches,\n          r = Aa(i, t, o),\n          n = Aa(i, t, s);\n        r && n || (this._active && m(), this.reset());\n      }\n      touchcancel() {\n        this.reset();\n      }\n      enable(e) {\n        this._enabled = !0, this._aroundCenter = !!e && \"center\" === e.around;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    function Aa(e, t, i) {\n      for (let o = 0; o < e.length; o++) if (e[o].identifier === i) return t[o];\n    }\n    function La(e, t) {\n      return Math.log(e / t) / Math.LN2;\n    }\n    class Ma extends Da {\n      reset() {\n        super.reset(), this._distance = 0, this._startDistance = 0;\n      }\n      _start(e) {\n        this._startDistance = this._distance = e[0].dist(e[1]);\n      }\n      _move(e, t) {\n        const i = this._distance;\n        if (this._distance = e[0].dist(e[1]), this._active || !(Math.abs(La(this._distance, this._startDistance)) < .1)) return this._active = !0, {\n          zoomDelta: La(this._distance, i),\n          pinchAround: t\n        };\n      }\n    }\n    function Pa(e, t) {\n      return 180 * e.angleWith(t) / Math.PI;\n    }\n    class za extends Da {\n      reset() {\n        super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;\n      }\n      _start(e) {\n        this._startVector = this._vector = e[0].sub(e[1]), this._minDiameter = e[0].dist(e[1]);\n      }\n      _move(e, t) {\n        const i = this._vector;\n        if (this._vector = e[0].sub(e[1]), i && (this._active || !this._isBelowThreshold(this._vector))) return this._active = !0, {\n          bearingDelta: Pa(this._vector, i),\n          pinchAround: t\n        };\n      }\n      _isBelowThreshold(e) {\n        this._minDiameter = Math.min(this._minDiameter, e.mag());\n        const t = 25 / (Math.PI * this._minDiameter) * 360,\n          i = this._startVector;\n        if (!i) return !1;\n        const o = Pa(e, i);\n        return Math.abs(o) < t;\n      }\n    }\n    function Oa(e) {\n      return Math.abs(e.y) > Math.abs(e.x);\n    }\n    class Fa extends Da {\n      constructor(e) {\n        super(), this._map = e;\n      }\n      reset() {\n        super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;\n      }\n      _start(e) {\n        this._lastPoints = e, Oa(e[0].sub(e[1])) && (this._valid = !1);\n      }\n      _move(t, i, o) {\n        const s = this._lastPoints;\n        if (!s) return;\n        const r = t[0].sub(s[0]),\n          n = t[1].sub(s[1]);\n        return this._map._cooperativeGestures && !e.dC() && o.touches.length < 3 || (this._valid = this.gestureBeginsVertically(r, n, o.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t, this._active = !0, {\n          pitchDelta: (r.y + n.y) / 2 * -.5\n        });\n      }\n      gestureBeginsVertically(e, t, i) {\n        if (void 0 !== this._valid) return this._valid;\n        const o = e.mag() >= 2,\n          s = t.mag() >= 2;\n        if (!o && !s) return;\n        if (!o || !s) return null == this._firstMove && (this._firstMove = i), i - this._firstMove < 100 && void 0;\n        const r = e.y > 0 == t.y > 0;\n        return Oa(e) && Oa(t) && r;\n      }\n    }\n    const ka = {\n      panStep: 100,\n      bearingStep: 15,\n      pitchStep: 10\n    };\n    class Ba {\n      constructor() {\n        const e = ka;\n        this._panStep = e.panStep, this._bearingStep = e.bearingStep, this._pitchStep = e.pitchStep, this._rotationDisabled = !1;\n      }\n      blur() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1;\n      }\n      keydown(e) {\n        if (e.altKey || e.ctrlKey || e.metaKey) return;\n        let t = 0,\n          i = 0,\n          o = 0,\n          s = 0,\n          r = 0;\n        switch (e.keyCode) {\n          case 61:\n          case 107:\n          case 171:\n          case 187:\n            t = 1;\n            break;\n          case 189:\n          case 109:\n          case 173:\n            t = -1;\n            break;\n          case 37:\n            e.shiftKey ? i = -1 : (e.preventDefault(), s = -1);\n            break;\n          case 39:\n            e.shiftKey ? i = 1 : (e.preventDefault(), s = 1);\n            break;\n          case 38:\n            e.shiftKey ? o = 1 : (e.preventDefault(), r = -1);\n            break;\n          case 40:\n            e.shiftKey ? o = -1 : (e.preventDefault(), r = 1);\n            break;\n          default:\n            return;\n        }\n        return this._rotationDisabled && (i = 0, o = 0), {\n          cameraAnimation: n => {\n            const a = n.getZoom();\n            n.easeTo({\n              duration: 300,\n              easeId: \"keyboardHandler\",\n              easing: Na,\n              zoom: t ? Math.round(a) + t * (e.shiftKey ? 2 : 1) : a,\n              bearing: n.getBearing() + i * this._bearingStep,\n              pitch: n.getPitch() + o * this._pitchStep,\n              offset: [-s * this._panStep, -r * this._panStep],\n              center: n.getCenter()\n            }, {\n              originalEvent: e\n            });\n          }\n        };\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n      disableRotation() {\n        this._rotationDisabled = !0;\n      }\n      enableRotation() {\n        this._rotationDisabled = !1;\n      }\n    }\n    function Na(e) {\n      return e * (2 - e);\n    }\n    const Ua = 4.000244140625,\n      Va = 1 / 450;\n    class Ga {\n      constructor(t, i) {\n        this._map = t, this._el = t.getCanvasContainer(), this._handler = i, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = .01, this._wheelZoomRate = Va, e.aQ([\"_onTimeout\", \"_addScrollZoomBlocker\", \"_showBlockerAlert\"], this);\n      }\n      setZoomRate(e) {\n        this._defaultZoomRate = e;\n      }\n      setWheelZoomRate(e) {\n        this._wheelZoomRate = e;\n      }\n      isEnabled() {\n        return !!this._enabled;\n      }\n      isActive() {\n        return this._active || void 0 !== this._finishTimeout;\n      }\n      isZooming() {\n        return !!this._zooming;\n      }\n      enable(e) {\n        this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!e && \"center\" === e.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());\n      }\n      disable() {\n        this.isEnabled() && (this._enabled = !1, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));\n      }\n      wheel(t) {\n        if (!this.isEnabled()) return;\n        if (this._map._cooperativeGestures) {\n          if (!(t.ctrlKey || t.metaKey || this.isZooming() || e.dC())) return void this._showBlockerAlert();\n          \"hidden\" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = \"hidden\", clearTimeout(this._alertTimer));\n        }\n        let i = t.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;\n        const o = e.q.now(),\n          s = o - (this._lastWheelEventTime || 0);\n        this._lastWheelEventTime = o, 0 !== i && i % Ua == 0 ? this._type = \"wheel\" : 0 !== i && Math.abs(i) < 4 ? this._type = \"trackpad\" : s > 400 ? (this._type = null, this._lastValue = i, this._timeout = window.setTimeout(this._onTimeout, 40, t)) : this._type || (this._type = Math.abs(s * i) < 200 ? \"trackpad\" : \"wheel\", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i += this._lastValue)), t.shiftKey && i && (i /= 4), this._type && (this._lastWheelEvent = t, this._delta -= i, this._active || this._start(t)), t.preventDefault();\n      }\n      _onTimeout(e) {\n        this._type = \"wheel\", this._delta -= this._lastValue, this._active || this._start(e);\n      }\n      _start(e) {\n        if (!this._delta) return;\n        this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);\n        const t = g(this._el, e);\n        this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = !0, this._handler._triggerRenderFrame());\n      }\n      renderFrame() {\n        if (!this._frameId) return;\n        if (this._frameId = null, !this.isActive()) return;\n        const t = this._map.transform;\n        \"wheel\" === this._type && t.projection.wrap && (t._center.lng >= 180 || t._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);\n        const i = () => t._terrainEnabled() && this._aroundCoord ? t.computeZoomRelativeTo(this._aroundCoord) : t.zoom;\n        if (0 !== this._delta) {\n          const e = \"wheel\" === this._type && Math.abs(this._delta) > Ua ? this._wheelZoomRate : this._defaultZoomRate;\n          let o = 2 / (1 + Math.exp(-Math.abs(this._delta * e)));\n          this._delta < 0 && 0 !== o && (o = 1 / o);\n          const s = i(),\n            r = Math.pow(2, s),\n            n = \"number\" == typeof this._targetZoom ? t.zoomScale(this._targetZoom) : r;\n          this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(n * o))), \"wheel\" === this._type && (this._startZoom = s, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;\n        }\n        const o = \"number\" == typeof this._targetZoom ? this._targetZoom : i(),\n          s = this._startZoom,\n          r = this._easing;\n        let n,\n          a = !1;\n        if (\"wheel\" === this._type && s && r) {\n          const t = Math.min((e.q.now() - this._lastWheelEventTime) / 200, 1),\n            i = r(t);\n          n = e.ah(s, o, i), t < 1 ? this._frameId || (this._frameId = !0) : a = !0;\n        } else n = o, a = !0;\n        this._active = !0, a && (this._active = !1, this._finishTimeout = window.setTimeout(() => {\n          this._zooming = !1, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;\n        }, 200));\n        let l = n - i();\n        return l * this._lastDelta < 0 && (l = 0), {\n          noInertia: !0,\n          needsRenderFrame: !a,\n          zoomDelta: l,\n          around: this._aroundPoint,\n          aroundCoord: this._aroundCoord,\n          originalEvent: this._lastWheelEvent\n        };\n      }\n      _smoothOutEasing(t) {\n        let i = e.dD;\n        if (this._prevEase) {\n          const t = this._prevEase,\n            o = (e.q.now() - t.start) / t.duration,\n            s = t.easing(o + .01) - t.easing(o),\n            r = .27 / Math.sqrt(s * s + 1e-4) * .01,\n            n = Math.sqrt(.0729 - r * r);\n          i = e.dB(r, n, .25, 1);\n        }\n        return this._prevEase = {\n          start: e.q.now(),\n          duration: t,\n          easing: i\n        }, i;\n      }\n      blur() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1;\n      }\n      _addScrollZoomBlocker() {\n        this._map && !this._alertContainer && (this._alertContainer = l(\"div\", \"mapboxgl-scroll-zoom-blocker\", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString(\"ScrollZoomBlocker.CmdMessage\") : this._map._getUIString(\"ScrollZoomBlocker.CtrlMessage\"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(.05 * this._el.clientWidth)))}px`);\n      }\n      _showBlockerAlert() {\n        this._alertContainer.style.visibility = \"visible\", this._alertContainer.classList.add(\"mapboxgl-scroll-zoom-blocker-show\"), this._alertContainer.setAttribute(\"role\", \"alert\"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {\n          this._alertContainer.classList.remove(\"mapboxgl-scroll-zoom-blocker-show\"), this._alertContainer.removeAttribute(\"role\");\n        }, 200);\n      }\n    }\n    class ja {\n      constructor(e, t) {\n        this._clickZoom = e, this._tapZoom = t;\n      }\n      enable() {\n        this._clickZoom.enable(), this._tapZoom.enable();\n      }\n      disable() {\n        this._clickZoom.disable(), this._tapZoom.disable();\n      }\n      isEnabled() {\n        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();\n      }\n      isActive() {\n        return this._clickZoom.isActive() || this._tapZoom.isActive();\n      }\n    }\n    class qa {\n      constructor() {\n        this.reset();\n      }\n      reset() {\n        this._active = !1;\n      }\n      blur() {\n        this.reset();\n      }\n      dblclick(e, t) {\n        return e.preventDefault(), {\n          cameraAnimation: i => {\n            i.easeTo({\n              duration: 300,\n              zoom: i.getZoom() + (e.shiftKey ? -1 : 1),\n              around: i.unproject(t)\n            }, {\n              originalEvent: e\n            });\n          }\n        };\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    class Ha {\n      constructor() {\n        this._tap = new xa({\n          numTouches: 1,\n          numTaps: 1\n        }), this.reset();\n      }\n      reset() {\n        this._active = !1, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();\n      }\n      touchstart(e, t, i) {\n        this._swipePoint || (this._tapTime && e.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i.length > 0 && (this._swipePoint = t[0], this._swipeTouch = i[0].identifier) : this._tap.touchstart(e, t, i));\n      }\n      touchmove(e, t, i) {\n        if (this._tapTime) {\n          if (this._swipePoint) {\n            if (i[0].identifier !== this._swipeTouch) return;\n            const o = t[0],\n              s = o.y - this._swipePoint.y;\n            return this._swipePoint = o, e.preventDefault(), this._active = !0, {\n              zoomDelta: s / 128\n            };\n          }\n        } else this._tap.touchmove(e, t, i);\n      }\n      touchend(e, t, i) {\n        this._tapTime ? this._swipePoint && 0 === i.length && this.reset() : this._tap.touchend(e, t, i) && (this._tapTime = e.timeStamp);\n      }\n      touchcancel() {\n        this.reset();\n      }\n      enable() {\n        this._enabled = !0;\n      }\n      disable() {\n        this._enabled = !1, this.reset();\n      }\n      isEnabled() {\n        return this._enabled;\n      }\n      isActive() {\n        return this._active;\n      }\n    }\n    class Za {\n      constructor(e, t, i) {\n        this._el = e, this._mousePan = t, this._touchPan = i;\n      }\n      enable(e) {\n        this._inertiaOptions = e || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add(\"mapboxgl-touch-drag-pan\");\n      }\n      disable() {\n        this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove(\"mapboxgl-touch-drag-pan\");\n      }\n      isEnabled() {\n        return this._mousePan.isEnabled() && this._touchPan.isEnabled();\n      }\n      isActive() {\n        return this._mousePan.isActive() || this._touchPan.isActive();\n      }\n    }\n    class Wa {\n      constructor(e, t, i) {\n        this._pitchWithRotate = e.pitchWithRotate, this._mouseRotate = t, this._mousePitch = i;\n      }\n      enable() {\n        this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();\n      }\n      disable() {\n        this._mouseRotate.disable(), this._mousePitch.disable();\n      }\n      isEnabled() {\n        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());\n      }\n      isActive() {\n        return this._mouseRotate.isActive() || this._mousePitch.isActive();\n      }\n    }\n    class $a {\n      constructor(e, t, i, o) {\n        this._el = e, this._touchZoom = t, this._touchRotate = i, this._tapDragZoom = o, this._rotationDisabled = !1, this._enabled = !0;\n      }\n      enable(e) {\n        this._touchZoom.enable(e), this._rotationDisabled || this._touchRotate.enable(e), this._tapDragZoom.enable(), this._el.classList.add(\"mapboxgl-touch-zoom-rotate\");\n      }\n      disable() {\n        this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove(\"mapboxgl-touch-zoom-rotate\");\n      }\n      isEnabled() {\n        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();\n      }\n      isActive() {\n        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();\n      }\n      disableRotation() {\n        this._rotationDisabled = !0, this._touchRotate.disable();\n      }\n      enableRotation() {\n        this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();\n      }\n    }\n    const Xa = e => e.zoom || e.drag || e.pitch || e.rotate;\n    class Ka extends e.A {}\n    class Ya {\n      constructor() {\n        this.constants = [1, 1, .01], this.radius = 0;\n      }\n      setup(t, i) {\n        const o = e.ad.vec3.sub([], i, t);\n        this.radius = e.ad.vec3.length(o[2] < 0 ? e.ad.vec3.div([], o, this.constants) : [o[0], o[1], 0]);\n      }\n      projectRay(t) {\n        e.ad.vec3.div(t, t, this.constants), e.ad.vec3.normalize(t, t), e.ad.vec3.mul(t, t, this.constants);\n        const i = e.ad.vec3.scale([], t, this.radius);\n        if (i[2] > 0) {\n          const t = e.ad.vec3.scale([], [0, 0, 1], e.ad.vec3.dot(i, [0, 0, 1])),\n            o = e.ad.vec3.scale([], e.ad.vec3.normalize([], [i[0], i[1], 0]), this.radius),\n            s = e.ad.vec3.add([], i, e.ad.vec3.scale([], e.ad.vec3.sub([], e.ad.vec3.add([], o, t), i), 2));\n          i[0] = s[0], i[1] = s[1];\n        }\n        return i;\n      }\n    }\n    function Ja(e) {\n      return e.panDelta && e.panDelta.mag() || e.zoomDelta || e.bearingDelta || e.pitchDelta;\n    }\n    class Qa {\n      constructor(t, i) {\n        this._map = t, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ca(t), this._bearingSnap = i.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Ya(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i), e.aQ([\"handleEvent\", \"handleWindowEvent\"], this);\n        const o = this._el;\n        this._listeners = [[o, \"touchstart\", {\n          passive: !0\n        }], [o, \"touchmove\", {\n          passive: !1\n        }], [o, \"touchend\", void 0], [o, \"touchcancel\", void 0], [o, \"mousedown\", void 0], [o, \"mousemove\", void 0], [o, \"mouseup\", void 0], [document, \"mousemove\", {\n          capture: !0\n        }], [document, \"mouseup\", void 0], [o, \"mouseover\", void 0], [o, \"mouseout\", void 0], [o, \"dblclick\", void 0], [o, \"click\", void 0], [o, \"keydown\", {\n          capture: !1\n        }], [o, \"keyup\", void 0], [o, \"wheel\", {\n          passive: !1\n        }], [o, \"contextmenu\", void 0], [window, \"blur\", void 0]];\n        for (const [e, t, i] of this._listeners) {\n          const o = e === document ? this.handleWindowEvent : this.handleEvent;\n          e.addEventListener(t, o, i);\n        }\n      }\n      destroy() {\n        for (const [e, t, i] of this._listeners) {\n          const o = e === document ? this.handleWindowEvent : this.handleEvent;\n          e.removeEventListener(t, o, i);\n        }\n      }\n      _addDefaultHandlers(e) {\n        const t = this._map,\n          i = t.getCanvasContainer();\n        this._add(\"mapEvent\", new fa(t, e));\n        const o = t.boxZoom = new ga(t, e);\n        this._add(\"boxZoom\", o);\n        const s = new ba(),\n          r = new qa();\n        t.doubleClickZoom = new ja(r, s), this._add(\"tapZoom\", s), this._add(\"clickZoom\", r);\n        const n = new Ha();\n        this._add(\"tapDragZoom\", n);\n        const a = t.touchPitch = new Fa(t);\n        this._add(\"touchPitch\", a);\n        const l = new Ca(e),\n          c = new Ia(e);\n        t.dragRotate = new Wa(e, l, c), this._add(\"mouseRotate\", l, [\"mousePitch\"]), this._add(\"mousePitch\", c, [\"mouseRotate\"]);\n        const h = new Sa(e),\n          d = new Ra(t, e);\n        t.dragPan = new Za(i, h, d), this._add(\"mousePan\", h), this._add(\"touchPan\", d, [\"touchZoom\", \"touchRotate\"]);\n        const u = new za(),\n          _ = new Ma();\n        t.touchZoomRotate = new $a(i, _, u, n), this._add(\"touchRotate\", u, [\"touchPan\", \"touchZoom\"]), this._add(\"touchZoom\", _, [\"touchPan\", \"touchRotate\"]), this._add(\"blockableMapEvent\", new ma(t));\n        const p = t.scrollZoom = new Ga(t, this);\n        this._add(\"scrollZoom\", p, [\"mousePan\"]);\n        const f = t.keyboard = new Ba();\n        this._add(\"keyboard\", f);\n        for (const i of [\"boxZoom\", \"doubleClickZoom\", \"tapDragZoom\", \"touchPitch\", \"dragRotate\", \"dragPan\", \"touchZoomRotate\", \"scrollZoom\", \"keyboard\"]) e.interactive && e[i] && t[i].enable(e[i]);\n      }\n      _add(e, t, i) {\n        this._handlers.push({\n          handlerName: e,\n          handler: t,\n          allowed: i\n        }), this._handlersById[e] = t;\n      }\n      stop(e) {\n        if (!this._updatingCamera) {\n          for (const {\n            handler: e\n          } of this._handlers) e.reset();\n          this._inertia.clear(), this._fireEvents({}, {}, e), this._changes = [], this._originalZoom = void 0;\n        }\n      }\n      isActive() {\n        for (const {\n          handler: e\n        } of this._handlers) if (e.isActive()) return !0;\n        return !1;\n      }\n      isZooming() {\n        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();\n      }\n      isRotating() {\n        return !!this._eventsInProgress.rotate;\n      }\n      isMoving() {\n        return !!Xa(this._eventsInProgress) || this.isZooming();\n      }\n      _isDragging() {\n        return !!this._eventsInProgress.drag;\n      }\n      _blockedByActive(e, t, i) {\n        for (const o in e) if (o !== i && (!t || t.indexOf(o) < 0)) return !0;\n        return !1;\n      }\n      handleWindowEvent(e) {\n        this.handleEvent(e, `${e.type}Window`);\n      }\n      _getMapTouches(e) {\n        const t = [];\n        for (const i of e) this._el.contains(i.target) && t.push(i);\n        return t;\n      }\n      handleEvent(e, t) {\n        this._updatingCamera = !0;\n        const i = \"renderFrame\" === e.type,\n          o = i ? void 0 : e,\n          s = {\n            needsRenderFrame: !1\n          },\n          r = {},\n          n = {},\n          a = e.touches ? this._getMapTouches(e.touches) : void 0,\n          l = a ? v(this._el, a) : i ? void 0 : g(this._el, e);\n        for (const {\n          handlerName: i,\n          handler: c,\n          allowed: h\n        } of this._handlers) {\n          if (!c.isEnabled()) continue;\n          let d;\n          this._blockedByActive(n, h, i) ? c.reset() : c[t || e.type] && (d = c[t || e.type](e, l, a), this.mergeHandlerResult(s, r, d, i, o), d && d.needsRenderFrame && this._triggerRenderFrame()), (d || c.isActive()) && (n[i] = c);\n        }\n        const c = {};\n        for (const e in this._previousActiveHandlers) n[e] || (c[e] = o);\n        this._previousActiveHandlers = n, (Object.keys(c).length || Ja(s)) && (this._changes.push([s, r, c]), this._triggerRenderFrame()), (Object.keys(n).length || Ja(s)) && this._map._stop(!0), this._updatingCamera = !1;\n        const {\n          cameraAnimation: h\n        } = s;\n        h && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], h(this._map));\n      }\n      mergeHandlerResult(t, i, o, s, r) {\n        if (!o) return;\n        e.l(t, o);\n        const n = {\n          handlerName: s,\n          originalEvent: o.originalEvent || r\n        };\n        void 0 !== o.zoomDelta && (i.zoom = n), void 0 !== o.panDelta && (i.drag = n), void 0 !== o.pitchDelta && (i.pitch = n), void 0 !== o.bearingDelta && (i.rotate = n);\n      }\n      _applyChanges() {\n        const t = {},\n          i = {},\n          o = {};\n        for (const [s, r, n] of this._changes) s.panDelta && (t.panDelta = (t.panDelta || new e.P(0, 0))._add(s.panDelta)), s.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + s.zoomDelta), s.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + s.bearingDelta), s.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + s.pitchDelta), void 0 !== s.around && (t.around = s.around), void 0 !== s.aroundCoord && (t.aroundCoord = s.aroundCoord), void 0 !== s.pinchAround && (t.pinchAround = s.pinchAround), s.noInertia && (t.noInertia = s.noInertia), e.l(i, r), e.l(o, n);\n        this._updateMapTransform(t, i, o), this._changes = [];\n      }\n      _updateMapTransform(t, i, o) {\n        const s = this._map,\n          r = s.transform,\n          n = e => [e.x, e.y, e.z];\n        if ((e => {\n          const t = this._eventsInProgress.drag;\n          return t && !this._handlersById[t.handlerName].isActive();\n        })() && !Ja(t)) {\n          const e = r.zoom;\n          r.cameraElevationReference = \"sea\", null != this._originalZoom && r._orthographicProjectionAtLowPitch && \"globe\" !== r.projection.name && 0 === r.pitch ? (r.cameraElevationReference = \"ground\", r.zoom = this._originalZoom) : (r.recenterOnTerrain(), r.cameraElevationReference = \"ground\"), e !== r.zoom && this._map._update(!0);\n        }\n        if (r._isCameraConstrained && s._stop(!0), !Ja(t)) return void this._fireEvents(i, o, !0);\n        let {\n          panDelta: a,\n          zoomDelta: l,\n          bearingDelta: c,\n          pitchDelta: h,\n          around: d,\n          aroundCoord: u,\n          pinchAround: _\n        } = t;\n        r._isCameraConstrained && (l > 0 && (l = 0), r._isCameraConstrained = !1), void 0 !== _ && (d = _), (l || (e => i[e] && !this._eventsInProgress[e])(\"drag\")) && d && (this._dragOrigin = n(r.pointCoordinate3D(d)), this._originalZoom = r.zoom, this._trackingEllipsoid.setup(r._camera.position, this._dragOrigin)), r.cameraElevationReference = \"sea\", s._stop(!0), d = d || s.transform.centerPoint, c && (r.bearing += c), h && (r.pitch += h), r._updateCameraState();\n        const p = [0, 0, 0];\n        if (a) if (\"mercator\" === r.projection.name) {\n          const e = this._trackingEllipsoid.projectRay(r.screenPointToMercatorRay(d).dir),\n            t = this._trackingEllipsoid.projectRay(r.screenPointToMercatorRay(d.sub(a)).dir);\n          p[0] = t[0] - e[0], p[1] = t[1] - e[1];\n        } else {\n          const t = r.pointCoordinate(d);\n          if (\"globe\" === r.projection.name) {\n            a = a.rotate(-r.angle);\n            const i = r._pixelsPerMercatorPixel / r.worldSize;\n            p[0] = -a.x * e.dE(e.aT(t.y)) * i, p[1] = -a.y * e.dE(r.center.lat) * i;\n          } else {\n            const e = r.pointCoordinate(d.sub(a));\n            t && e && (p[0] = e.x - t.x, p[1] = e.y - t.y);\n          }\n        }\n        const f = r.zoom,\n          m = [0, 0, 0];\n        if (l) {\n          const t = n(u || r.pointCoordinate3D(d)),\n            i = {\n              dir: e.ad.vec3.normalize([], e.ad.vec3.sub([], t, r._camera.position))\n            };\n          if (i.dir[2] < 0) {\n            const o = r.zoomDeltaToMovement(t, l);\n            e.ad.vec3.scale(m, i.dir, o);\n          }\n        }\n        const g = e.ad.vec3.add(p, p, m);\n        r._translateCameraConstrained(g), l && Math.abs(r.zoom - f) > 1e-4 && r.recenterOnTerrain(), r.cameraElevationReference = \"ground\", this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(i, o, !0);\n      }\n      _fireEvents(t, i, o) {\n        const s = Xa(this._eventsInProgress),\n          r = Xa(t),\n          n = {};\n        for (const e in t) {\n          const {\n            originalEvent: i\n          } = t[e];\n          this._eventsInProgress[e] || (n[`${e}start`] = i), this._eventsInProgress[e] = t[e];\n        }\n        !s && r && this._fireEvent(\"movestart\", r.originalEvent);\n        for (const e in n) this._fireEvent(e, n[e]);\n        r && this._fireEvent(\"move\", r.originalEvent);\n        for (const e in t) {\n          const {\n            originalEvent: i\n          } = t[e];\n          this._fireEvent(e, i);\n        }\n        const a = {};\n        let l;\n        for (const e in this._eventsInProgress) {\n          const {\n            handlerName: t,\n            originalEvent: o\n          } = this._eventsInProgress[e];\n          this._handlersById[t].isActive() || (delete this._eventsInProgress[e], l = i[t] || o, a[`${e}end`] = l);\n        }\n        for (const e in a) this._fireEvent(e, a[e]);\n        const c = Xa(this._eventsInProgress);\n        if (o && (s || r) && !c) {\n          this._updatingCamera = !0;\n          const t = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),\n            i = e => 0 !== e && -this._bearingSnap < e && e < this._bearingSnap;\n          t ? (i(t.bearing || this._map.getBearing()) && (t.bearing = 0), this._map.easeTo(t, {\n            originalEvent: l\n          })) : (this._map.fire(new e.A(\"moveend\", {\n            originalEvent: l\n          })), i(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = !1;\n        }\n      }\n      _fireEvent(t, i) {\n        this._map.fire(new e.A(t, i ? {\n          originalEvent: i\n        } : {}));\n      }\n      _requestFrame() {\n        return this._map.triggerRepaint(), this._map._renderTaskQueue.add(e => {\n          this._frameId = void 0, this.handleEvent(new Ka(\"renderFrame\", {\n            timeStamp: e\n          })), this._applyChanges();\n        });\n      }\n      _triggerRenderFrame() {\n        void 0 === this._frameId && (this._frameId = this._requestFrame());\n      }\n    }\n    const el = \"map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.\";\n    class tl extends e.E {\n      constructor(t, i) {\n        super(), this._moving = !1, this._zooming = !1, this.transform = t, this._bearingSnap = i.bearingSnap, this._respectPrefersReducedMotion = !1 !== i.respectPrefersReducedMotion, e.aQ([\"_renderFrameCallback\"], this);\n      }\n      getCenter() {\n        return new e.bO(this.transform.center.lng, this.transform.center.lat);\n      }\n      setCenter(e, t) {\n        return this.jumpTo({\n          center: e\n        }, t);\n      }\n      panBy(t, i, o) {\n        return t = e.P.convert(t).mult(-1), this.panTo(this.transform.center, e.l({\n          offset: t\n        }, i), o);\n      }\n      panTo(t, i, o) {\n        return this.easeTo(e.l({\n          center: t\n        }, i), o);\n      }\n      getZoom() {\n        return this.transform.zoom;\n      }\n      setZoom(e, t) {\n        return this.jumpTo({\n          zoom: e\n        }, t), this;\n      }\n      zoomTo(t, i, o) {\n        return this.easeTo(e.l({\n          zoom: t\n        }, i), o);\n      }\n      zoomIn(e, t) {\n        return this.zoomTo(this.getZoom() + 1, e, t), this;\n      }\n      zoomOut(e, t) {\n        return this.zoomTo(this.getZoom() - 1, e, t), this;\n      }\n      getBearing() {\n        return this.transform.bearing;\n      }\n      setBearing(e, t) {\n        return this.jumpTo({\n          bearing: e\n        }, t), this;\n      }\n      getPadding() {\n        return this.transform.padding;\n      }\n      setPadding(e, t) {\n        return this.jumpTo({\n          padding: e\n        }, t), this;\n      }\n      rotateTo(t, i, o) {\n        return this.easeTo(e.l({\n          bearing: t\n        }, i), o);\n      }\n      resetNorth(t, i) {\n        return this.rotateTo(0, e.l({\n          duration: 1e3\n        }, t), i), this;\n      }\n      resetNorthPitch(t, i) {\n        return this.easeTo(e.l({\n          bearing: 0,\n          pitch: 0,\n          duration: 1e3\n        }, t), i), this;\n      }\n      snapToNorth(e, t) {\n        return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, t) : this;\n      }\n      getPitch() {\n        return this.transform.pitch;\n      }\n      setPitch(e, t) {\n        return this.jumpTo({\n          pitch: e\n        }, t), this;\n      }\n      cameraForBounds(t, i) {\n        t = e.aB.convert(t);\n        const o = i && i.bearing || 0,\n          s = i && i.pitch || 0,\n          r = t.getNorthWest(),\n          n = t.getSouthEast();\n        return this._cameraForBounds(this.transform, r, n, o, s, i);\n      }\n      _extendPadding(t) {\n        const i = {\n          top: 0,\n          right: 0,\n          bottom: 0,\n          left: 0\n        };\n        return null == t ? e.l({}, i, this.transform.padding) : \"number\" == typeof t ? {\n          top: t,\n          bottom: t,\n          right: t,\n          left: t\n        } : e.l({}, i, t);\n      }\n      _extendCameraOptions(t) {\n        return (t = e.l({\n          offset: [0, 0],\n          maxZoom: this.transform.maxZoom\n        }, t)).padding = this._extendPadding(t.padding), t;\n      }\n      _minimumAABBFrustumDistance(e, t) {\n        const i = t.max[0] - t.min[0],\n          o = t.max[1] - t.min[1];\n        return i / o > e.aspect ? i / (2 * Math.tan(.5 * e.fovX) * e.aspect) : o / (2 * Math.tan(.5 * e.fovY) * e.aspect);\n      }\n      _cameraForBoundsOnGlobe(t, i, o, s, r, n) {\n        const a = t.clone(),\n          l = this._extendCameraOptions(n);\n        a.bearing = s, a.pitch = r;\n        const c = e.bO.convert(i),\n          h = e.bO.convert(o),\n          d = .5 * (c.lat + h.lat),\n          u = .5 * (c.lng + h.lng),\n          _ = e.dF(d, u),\n          p = e.ad.vec3.normalize([], _),\n          f = e.ad.vec3.normalize([], e.ad.vec3.cross([], p, [0, 1, 0])),\n          m = e.ad.vec3.cross([], f, p),\n          g = [f[0], f[1], f[2], 0, m[0], m[1], m[2], 0, p[0], p[1], p[2], 0, 0, 0, 0, 1],\n          v = [_, e.dF(c.lat, c.lng), e.dF(h.lat, c.lng), e.dF(h.lat, h.lng), e.dF(c.lat, h.lng), e.dF(d, c.lng), e.dF(d, h.lng), e.dF(c.lat, u), e.dF(h.lat, u)];\n        let y = e.ce.fromPoints(v.map(t => [e.ad.vec3.dot(f, t), e.ad.vec3.dot(m, t), e.ad.vec3.dot(p, t)]));\n        const x = e.ad.vec3.transformMat4([], y.center, g);\n        0 === e.ad.vec3.squaredLength(x) && e.ad.vec3.set(x, 0, 0, 1), e.ad.vec3.normalize(x, x), e.ad.vec3.scale(x, x, e.az), a.center = e.dG(x);\n        const b = a.getWorldToCameraMatrix(),\n          w = e.ad.mat4.invert(new Float64Array(16), b);\n        y = e.ce.applyTransform(y, e.ad.mat4.multiply([], b, g));\n        const T = this._extendAABB(y, a, l, s);\n        if (!T) return void e.w(\"Map cannot fit within canvas with the given bounds, padding, and/or offset.\");\n        y = T, e.ad.vec3.transformMat4(x, x, b);\n        const E = .5 * (y.max[2] - y.min[2]),\n          S = this._minimumAABBFrustumDistance(a, y),\n          C = e.ad.vec3.scale([], [0, 0, 1], E),\n          I = e.ad.vec3.add(C, x, C),\n          R = S + (0 === a.pitch ? 0 : e.ad.vec3.distance(x, I)),\n          D = a.globeCenterInViewSpace,\n          A = e.ad.vec3.sub([], x, [D[0], D[1], D[2]]);\n        e.ad.vec3.normalize(A, A), e.ad.vec3.scale(A, A, R);\n        const L = e.ad.vec3.add([], x, A);\n        e.ad.vec3.transformMat4(L, L, w);\n        const M = e.dv / e.az,\n          P = e.ad.vec3.length(L),\n          z = e.bH(Math.max(P * M - e.dv, Number.EPSILON), 0),\n          O = Math.min(a.zoomFromMercatorZAdjusted(z), l.maxZoom);\n        return O > .5 * (e.c6 + e.bY) ? (a.setProjection({\n          name: \"mercator\"\n        }), a.zoom = O, this._cameraForBounds(a, i, o, s, r, n)) : {\n          center: a.center,\n          zoom: O,\n          bearing: s,\n          pitch: r\n        };\n      }\n      _extendAABB(t, i, o, s) {\n        const r = .5 * ((o.padding.left || 0) + (o.padding.right || 0)),\n          n = .5 * ((o.padding.top || 0) + (o.padding.bottom || 0)),\n          a = n,\n          l = r,\n          c = r,\n          h = n,\n          d = i.width - (l + c),\n          u = i.height - (a + h),\n          _ = e.ad.vec3.sub([], t.max, t.min),\n          p = Math.min(d / _[0], u / _[1]),\n          f = Math.min(i.scaleZoom(i.scale * p), o.maxZoom);\n        if (isNaN(f)) return null;\n        const m = i.scale / i.zoomScale(f),\n          g = new e.ce([t.min[0] - l * m, t.min[1] - h * m, t.min[2]], [t.max[0] + c * m, t.max[1] + a * m, t.max[2]]),\n          v = (\"number\" == typeof o.offset.x && \"number\" == typeof o.offset.y ? new e.P(o.offset.x, o.offset.y) : e.P.convert(o.offset)).rotate(-e.ak(s));\n        return g.center[0] -= v.x * m, g.center[1] += v.y * m, g;\n      }\n      queryTerrainElevation(t, i) {\n        const o = this.transform.elevation;\n        return o ? (i = e.l({}, {\n          exaggerated: !0\n        }, i), o.getAtPoint(e.ac.fromLngLat(t), null, i.exaggerated)) : null;\n      }\n      _cameraForBounds(t, i, o, s, r, n) {\n        if (\"globe\" === t.projection.name) return this._cameraForBoundsOnGlobe(t, i, o, s, r, n);\n        const a = t.clone(),\n          l = this._extendCameraOptions(n);\n        a.bearing = s, a.pitch = r;\n        const c = e.bO.convert(i),\n          h = e.bO.convert(o),\n          d = new e.bO(c.lng, h.lat),\n          u = new e.bO(h.lng, c.lat),\n          _ = a.project(c),\n          p = a.project(h),\n          f = this.queryTerrainElevation(c),\n          m = this.queryTerrainElevation(h),\n          g = this.queryTerrainElevation(d),\n          v = this.queryTerrainElevation(u),\n          y = [[_.x, _.y, Math.min(f || 0, m || 0, g || 0, v || 0)], [p.x, p.y, Math.max(f || 0, m || 0, g || 0, v || 0)]];\n        let x = e.ce.fromPoints(y);\n        const b = a.getWorldToCameraMatrix(),\n          w = e.ad.mat4.invert(new Float64Array(16), b);\n        x = e.ce.applyTransform(x, b);\n        const T = this._extendAABB(x, a, l, s);\n        if (!T) return void e.w(\"Map cannot fit within canvas with the given bounds, padding, and/or offset.\");\n        x = T;\n        const E = .5 * e.ad.vec3.sub([], x.max, x.min)[2],\n          S = this._minimumAABBFrustumDistance(a, x),\n          C = [0, 0, 1, 0];\n        e.ad.vec4.transformMat4(C, C, b), e.ad.vec4.normalize(C, C);\n        const I = e.ad.vec3.scale([], C, S + E),\n          R = e.ad.vec3.add([], x.center, I);\n        e.ad.vec3.transformMat4(x.center, x.center, w), e.ad.vec3.transformMat4(R, R, w);\n        const D = a.unproject(new e.P(x.center[0], x.center[1])),\n          A = e.dH(a.projection, D),\n          L = Math.pow(2, A),\n          M = Math.min(a._zoomFromMercatorZ(R[2] * a.pixelsPerMeter * L / a.worldSize), l.maxZoom);\n        return a.mercatorFromTransition && M < .5 * (e.c6 + e.bY) ? (a.setProjection({\n          name: \"globe\"\n        }), a.zoom = M, this._cameraForBounds(a, i, o, s, r, n)) : {\n          center: D,\n          zoom: M,\n          bearing: s,\n          pitch: r\n        };\n      }\n      fitBounds(e, t, i) {\n        const o = this.cameraForBounds(e, t);\n        return this._fitInternal(o, t, i);\n      }\n      fitScreenCoordinates(t, i, o, s, r) {\n        const n = e.P.convert(t),\n          a = e.P.convert(i),\n          l = new e.P(Math.min(n.x, a.x), Math.min(n.y, a.y)),\n          c = new e.P(Math.max(n.x, a.x), Math.max(n.y, a.y));\n        if (\"mercator\" === this.transform.projection.name && this.transform.anyCornerOffEdge(n, a)) return this;\n        const h = this.transform.pointLocation3D(l),\n          d = this.transform.pointLocation3D(c),\n          u = this.transform.pointLocation3D(new e.P(l.x, c.y)),\n          _ = this.transform.pointLocation3D(new e.P(c.x, l.y)),\n          p = [Math.min(h.lng, d.lng, u.lng, _.lng), Math.min(h.lat, d.lat, u.lat, _.lat)],\n          f = [Math.max(h.lng, d.lng, u.lng, _.lng), Math.max(h.lat, d.lat, u.lat, _.lat)],\n          m = s && s.pitch ? s.pitch : this.getPitch(),\n          g = this._cameraForBounds(this.transform, p, f, o, m, s);\n        return this._fitInternal(g, s, r);\n      }\n      _fitInternal(t, i, o) {\n        return t ? (i = e.l(t, i)).linear ? this.easeTo(i, o) : this.flyTo(i, o) : this;\n      }\n      jumpTo(t, i) {\n        this.stop();\n        const o = t.preloadOnly ? this.transform.clone() : this.transform;\n        let s = !1,\n          r = !1,\n          n = !1;\n        \"zoom\" in t && o.zoom !== +t.zoom && (s = !0, o.zoom = +t.zoom), void 0 !== t.center && (o.center = e.bO.convert(t.center)), \"bearing\" in t && o.bearing !== +t.bearing && (r = !0, o.bearing = +t.bearing), \"pitch\" in t && o.pitch !== +t.pitch && (n = !0, o.pitch = +t.pitch);\n        const a = \"number\" == typeof t.padding ? this._extendPadding(t.padding) : t.padding;\n        if (null != t.padding && !o.isPaddingEqual(a)) if (!1 === t.retainPadding) {\n          const e = o.clone();\n          e.padding = a, o.setLocationAtPoint(o.center, e.centerPoint);\n        } else o.padding = a;\n        return t.preloadOnly ? (this._preloadTiles(o), this) : (this.fire(new e.A(\"movestart\", i)).fire(new e.A(\"move\", i)), s && this.fire(new e.A(\"zoomstart\", i)).fire(new e.A(\"zoom\", i)).fire(new e.A(\"zoomend\", i)), r && this.fire(new e.A(\"rotatestart\", i)).fire(new e.A(\"rotate\", i)).fire(new e.A(\"rotateend\", i)), n && this.fire(new e.A(\"pitchstart\", i)).fire(new e.A(\"pitch\", i)).fire(new e.A(\"pitchend\", i)), this.fire(new e.A(\"moveend\", i)));\n      }\n      getFreeCameraOptions() {\n        return this.transform.projection.supportsFreeCamera || e.w(el), this.transform.getFreeCameraOptions();\n      }\n      setFreeCameraOptions(t, i) {\n        const o = this.transform;\n        if (!o.projection.supportsFreeCamera) return e.w(el), this;\n        this.stop();\n        const s = o.zoom,\n          r = o.pitch,\n          n = o.bearing;\n        o.setFreeCameraOptions(t);\n        const a = s !== o.zoom,\n          l = r !== o.pitch,\n          c = n !== o.bearing;\n        return this.fire(new e.A(\"movestart\", i)).fire(new e.A(\"move\", i)), a && this.fire(new e.A(\"zoomstart\", i)).fire(new e.A(\"zoom\", i)).fire(new e.A(\"zoomend\", i)), c && this.fire(new e.A(\"rotatestart\", i)).fire(new e.A(\"rotate\", i)).fire(new e.A(\"rotateend\", i)), l && this.fire(new e.A(\"pitchstart\", i)).fire(new e.A(\"pitch\", i)).fire(new e.A(\"pitchend\", i)), this.fire(new e.A(\"moveend\", i)), this;\n      }\n      easeTo(t, i) {\n        this._stop(!1, t.easeId), (!1 === (t = e.l({\n          offset: [0, 0],\n          duration: 500,\n          easing: e.dD\n        }, t)).animate || this._prefersReducedMotion(t)) && (t.duration = 0);\n        const o = this.transform,\n          s = this.getZoom(),\n          r = this.getBearing(),\n          n = this.getPitch(),\n          a = this.getPadding(),\n          l = \"zoom\" in t ? +t.zoom : s,\n          c = \"bearing\" in t ? this._normalizeBearing(t.bearing, r) : r,\n          h = \"pitch\" in t ? +t.pitch : n,\n          d = this._extendPadding(t.padding),\n          u = e.P.convert(t.offset);\n        let _, p, f;\n        if (\"globe\" === o.projection.name) {\n          const i = e.ac.fromLngLat(o.center),\n            s = u.rotate(-o.angle);\n          i.x += s.x / o.worldSize, i.y += s.y / o.worldSize;\n          const r = i.toLngLat(),\n            n = e.bO.convert(t.center || r);\n          this._normalizeCenter(n), _ = o.centerPoint.add(s), p = new e.P(i.x, i.y).mult(o.worldSize), f = new e.P(e.av(n.lng), e.aC(n.lat)).mult(o.worldSize).sub(p);\n        } else {\n          _ = o.centerPoint.add(u);\n          const i = o.pointLocation(_),\n            s = e.bO.convert(t.center || i);\n          this._normalizeCenter(s), p = o.project(i), f = o.project(s).sub(p);\n        }\n        const m = o.zoomScale(l - s);\n        let g, v;\n        t.around && (g = e.bO.convert(t.around), v = o.locationPoint(g));\n        const y = this._zooming || l !== s,\n          x = this._rotating || r !== c,\n          b = this._pitching || h !== n,\n          w = !o.isPaddingEqual(d),\n          T = !1 === t.retainPadding ? o.clone() : o,\n          E = o => E => {\n            if (y && (o.zoom = e.ah(s, l, E)), x && (o.bearing = e.ah(r, c, E)), b && (o.pitch = e.ah(n, h, E)), w && (T.interpolatePadding(a, d, E), _ = T.centerPoint.add(u)), g) o.setLocationAtPoint(g, v);else {\n              const e = o.zoomScale(o.zoom - s),\n                t = l > s ? Math.min(2, m) : Math.max(.5, m),\n                i = Math.pow(t, 1 - E),\n                r = o.unproject(p.add(f.mult(E * i)).mult(e));\n              o.setLocationAtPoint(o.renderWorldCopies ? r.wrap() : r, _);\n            }\n            return t.preloadOnly || this._fireMoveEvents(i), o;\n          };\n        if (t.preloadOnly) {\n          const e = this._emulate(E, t.duration, o);\n          return this._preloadTiles(e), this;\n        }\n        const S = {\n          moving: this._moving,\n          zooming: this._zooming,\n          rotating: this._rotating,\n          pitching: this._pitching\n        };\n        return this._zooming = y, this._rotating = x, this._pitching = b, this._padding = w, this._easeId = t.easeId, this._prepareEase(i, t.noMoveStart, S), this._ease(E(o), e => {\n          \"sea\" === o.cameraElevationReference && o.recenterOnTerrain(), this._afterEase(i, e);\n        }, t), this;\n      }\n      _prepareEase(t, i, o = {}) {\n        this._moving = !0, this.transform.cameraElevationReference = \"sea\", this.transform._orthographicProjectionAtLowPitch && 0 === this.transform.pitch && \"globe\" !== this.transform.projection.name && (this.transform.cameraElevationReference = \"ground\"), i || o.moving || this.fire(new e.A(\"movestart\", t)), this._zooming && !o.zooming && this.fire(new e.A(\"zoomstart\", t)), this._rotating && !o.rotating && this.fire(new e.A(\"rotatestart\", t)), this._pitching && !o.pitching && this.fire(new e.A(\"pitchstart\", t));\n      }\n      _fireMoveEvents(t) {\n        this.fire(new e.A(\"move\", t)), this._zooming && this.fire(new e.A(\"zoom\", t)), this._rotating && this.fire(new e.A(\"rotate\", t)), this._pitching && this.fire(new e.A(\"pitch\", t));\n      }\n      _afterEase(t, i) {\n        if (this._easeId && i && this._easeId === i) return;\n        this._easeId = void 0, this.transform.cameraElevationReference = \"ground\";\n        const o = this._zooming,\n          s = this._rotating,\n          r = this._pitching;\n        this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._padding = !1, o && this.fire(new e.A(\"zoomend\", t)), s && this.fire(new e.A(\"rotateend\", t)), r && this.fire(new e.A(\"pitchend\", t)), this.fire(new e.A(\"moveend\", t));\n      }\n      flyTo(t, i) {\n        if (this._prefersReducedMotion(t)) {\n          const o = e.aA(t, [\"center\", \"zoom\", \"bearing\", \"pitch\", \"around\", \"padding\", \"retainPadding\"]);\n          return this.jumpTo(o, i);\n        }\n        this.stop(), t = e.l({\n          offset: [0, 0],\n          speed: 1.2,\n          curve: 1.42,\n          easing: e.dD\n        }, t);\n        const o = this.transform,\n          s = this.getZoom(),\n          r = this.getBearing(),\n          n = this.getPitch(),\n          a = this.getPadding(),\n          l = \"zoom\" in t ? e.ay(+t.zoom, o.minZoom, o.maxZoom) : s,\n          c = \"bearing\" in t ? this._normalizeBearing(t.bearing, r) : r,\n          h = \"pitch\" in t ? +t.pitch : n,\n          d = this._extendPadding(t.padding),\n          u = o.zoomScale(l - s),\n          _ = e.P.convert(t.offset);\n        let p = o.centerPoint.add(_);\n        const f = o.pointLocation(p),\n          m = e.bO.convert(t.center || f);\n        this._normalizeCenter(m);\n        const g = o.project(f),\n          v = o.project(m).sub(g);\n        let y = t.curve;\n        const x = Math.max(o.width, o.height),\n          b = x / u,\n          w = v.mag();\n        if (\"minZoom\" in t) {\n          const i = e.ay(Math.min(t.minZoom, s, l), o.minZoom, o.maxZoom),\n            r = x / o.zoomScale(i - s);\n          y = Math.sqrt(r / w * 2);\n        }\n        const T = y * y;\n        function E(e) {\n          const t = (b * b - x * x + (e ? -1 : 1) * T * T * w * w) / (2 * (e ? b : x) * T * w);\n          return Math.log(Math.sqrt(t * t + 1) - t);\n        }\n        function S(e) {\n          return (Math.exp(e) - Math.exp(-e)) / 2;\n        }\n        function C(e) {\n          return (Math.exp(e) + Math.exp(-e)) / 2;\n        }\n        const I = E(0);\n        let R = function (e) {\n            return C(I) / C(I + y * e);\n          },\n          D = function (e) {\n            return x * ((C(I) * (S(t = I + y * e) / C(t)) - S(I)) / T) / w;\n            var t;\n          },\n          A = (E(1) - I) / y;\n        if (Math.abs(w) < 1e-6 || !isFinite(A)) {\n          if (Math.abs(x - b) < 1e-6) return this.easeTo(t, i);\n          const e = b < x ? -1 : 1;\n          A = Math.abs(Math.log(b / x)) / y, D = function () {\n            return 0;\n          }, R = function (t) {\n            return Math.exp(e * y * t);\n          };\n        }\n        t.duration = \"duration\" in t ? +t.duration : 1e3 * A / (\"screenSpeed\" in t ? +t.screenSpeed / y : +t.speed), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0);\n        const L = r !== c,\n          M = h !== n,\n          P = !o.isPaddingEqual(d),\n          z = !1 === t.retainPadding ? o.clone() : o,\n          O = o => u => {\n            const f = u * A,\n              y = 1 / R(f);\n            o.zoom = 1 === u ? l : s + o.scaleZoom(y), L && (o.bearing = e.ah(r, c, u)), M && (o.pitch = e.ah(n, h, u)), P && (z.interpolatePadding(a, d, u), p = z.centerPoint.add(_));\n            const x = 1 === u ? m : o.unproject(g.add(v.mult(D(f))).mult(y));\n            return o.setLocationAtPoint(o.renderWorldCopies ? x.wrap() : x, p), o._updateCameraOnTerrain(), t.preloadOnly || this._fireMoveEvents(i), o;\n          };\n        if (t.preloadOnly) {\n          const e = this._emulate(O, t.duration, o);\n          return this._preloadTiles(e), this;\n        }\n        return this._zooming = !0, this._rotating = L, this._pitching = M, this._padding = P, this._prepareEase(i, !1), this._ease(O(o), () => this._afterEase(i), t), this;\n      }\n      isEasing() {\n        return !!this._easeFrameId;\n      }\n      stop() {\n        return this._stop();\n      }\n      _requestRenderFrame(e) {}\n      _cancelRenderFrame(e) {}\n      _stop(e, t) {\n        if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {\n          const e = this._onEaseEnd;\n          this._onEaseEnd = void 0, e.call(this, t);\n        }\n        if (!e) {\n          const e = this.handlers;\n          e && e.stop(!1);\n        }\n        return this;\n      }\n      _ease(t, i, o) {\n        !1 === o.animate || 0 === o.duration ? (t(1), i()) : (this._easeStart = e.q.now(), this._easeOptions = o, this._onEaseFrame = t, this._onEaseEnd = i, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));\n      }\n      _renderFrameCallback() {\n        const t = Math.min((e.q.now() - this._easeStart) / this._easeOptions.duration, 1),\n          i = this._onEaseFrame;\n        i && i(this._easeOptions.easing(t)), t < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();\n      }\n      _normalizeBearing(t, i) {\n        t = e.bF(t, -180, 180);\n        const o = Math.abs(t - i);\n        return Math.abs(t - 360 - i) < o && (t -= 360), Math.abs(t + 360 - i) < o && (t += 360), t;\n      }\n      _normalizeCenter(e) {\n        const t = this.transform;\n        if (t.maxBounds) return;\n        if (\"globe\" !== t.projection.name && !t.renderWorldCopies) return;\n        const i = e.lng - t.center.lng;\n        e.lng += i > 180 ? -360 : i < -180 ? 360 : 0;\n      }\n      _prefersReducedMotion(t) {\n        return this._respectPrefersReducedMotion && e.q.prefersReducedMotion && !(t && t.essential);\n      }\n      _emulate(e, t, i) {\n        const o = Math.ceil(15 * t / 1e3),\n          s = [],\n          r = e(i.clone());\n        for (let e = 0; e <= o; e++) {\n          const t = r(e / o);\n          s.push(t.clone());\n        }\n        return s;\n      }\n      _preloadTiles(e, t) {}\n    }\n    class il {\n      constructor(t = {}) {\n        this.options = t, e.aQ([\"_toggleAttribution\", \"_updateEditLink\", \"_updateData\", \"_updateCompact\"], this);\n      }\n      getDefaultPosition() {\n        return \"bottom-right\";\n      }\n      onAdd(e) {\n        const t = this.options && this.options.compact,\n          i = e._getUIString(\"AttributionControl.ToggleAttribution\");\n        this._map = e, this._container = l(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-attrib\"), this._compactButton = l(\"button\", \"mapboxgl-ctrl-attrib-button\", this._container), this._compactButton.type = \"button\", this._compactButton.addEventListener(\"click\", this._toggleAttribution), this._compactButton.setAttribute(\"aria-label\", i);\n        const o = l(\"span\", \"mapboxgl-ctrl-icon\", this._compactButton);\n        return o.setAttribute(\"aria-hidden\", \"true\"), o.setAttribute(\"title\", i), this._innerContainer = l(\"div\", \"mapboxgl-ctrl-attrib-inner\", this._container), t && this._container.classList.add(\"mapboxgl-compact\"), this._updateAttributions(), this._updateEditLink(), this._map.on(\"styledata\", this._updateData), this._map.on(\"sourcedata\", this._updateData), this._map.on(\"moveend\", this._updateEditLink), void 0 === t && (this._map.on(\"resize\", this._updateCompact), this._updateCompact()), this._container;\n      }\n      onRemove() {\n        this._container.remove(), this._map.off(\"styledata\", this._updateData), this._map.off(\"sourcedata\", this._updateData), this._map.off(\"moveend\", this._updateEditLink), this._map.off(\"resize\", this._updateCompact), this._map = void 0, this._attribHTML = void 0;\n      }\n      _toggleAttribution() {\n        this._container.classList.contains(\"mapboxgl-compact-show\") ? (this._container.classList.remove(\"mapboxgl-compact-show\"), this._compactButton.setAttribute(\"aria-expanded\", \"false\")) : (this._container.classList.add(\"mapboxgl-compact-show\"), this._compactButton.setAttribute(\"aria-expanded\", \"true\"));\n      }\n      _updateEditLink() {\n        let t = this._editLink;\n        t || (t = this._editLink = this._container.querySelector(\".mapbox-improve-map\"));\n        const i = [{\n          key: \"owner\",\n          value: this.styleOwner\n        }, {\n          key: \"id\",\n          value: this.styleId\n        }, {\n          key: \"access_token\",\n          value: this._map._requestManager._customAccessToken || e.e.ACCESS_TOKEN\n        }];\n        if (t) {\n          const o = i.reduce((e, t, o) => (t.value && (e += `${t.key}=${t.value}${o < i.length - 1 ? \"&\" : \"\"}`), e), \"?\");\n          t.href = `${e.e.FEEDBACK_URL}/${o}#${oa(this._map, !0)}`, t.rel = \"noopener nofollow\";\n        }\n      }\n      _updateData(e) {\n        !e || \"metadata\" !== e.sourceDataType && \"visibility\" !== e.sourceDataType && \"style\" !== e.dataType || (this._updateAttributions(), this._updateEditLink());\n      }\n      _updateAttributions() {\n        if (!this._map.style) return;\n        let e = [];\n        if (this._map.style.stylesheet) {\n          const e = this._map.style.stylesheet;\n          this.styleOwner = e.owner, this.styleId = e.id;\n        }\n        const t = this._map.style._mergedSourceCaches;\n        for (const i in t) {\n          const o = t[i];\n          if (o.used) {\n            const t = o.getSource();\n            t.attribution && e.indexOf(t.attribution) < 0 && e.push(t.attribution);\n          }\n        }\n        e.sort((e, t) => e.length - t.length), e = e.filter((t, i) => {\n          for (let o = i + 1; o < e.length; o++) if (e[o].indexOf(t) >= 0) return !1;\n          return !0;\n        }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = [...this.options.customAttribution, ...e] : e.unshift(this.options.customAttribution));\n        const i = e.join(\" | \");\n        i !== this._attribHTML && (this._attribHTML = i, e.length ? (this._innerContainer.innerHTML = i, this._container.classList.remove(\"mapboxgl-attrib-empty\")) : this._container.classList.add(\"mapboxgl-attrib-empty\"), this._editLink = null);\n      }\n      _updateCompact() {\n        this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add(\"mapboxgl-compact\") : this._container.classList.remove(\"mapboxgl-compact\", \"mapboxgl-compact-show\");\n      }\n    }\n    class ol {\n      constructor() {\n        e.aQ([\"_updateLogo\", \"_updateCompact\"], this);\n      }\n      onAdd(e) {\n        this._map = e, this._container = l(\"div\", \"mapboxgl-ctrl\");\n        const t = l(\"a\", \"mapboxgl-ctrl-logo\");\n        return t.target = \"_blank\", t.rel = \"noopener nofollow\", t.href = \"https://www.mapbox.com/\", t.setAttribute(\"aria-label\", this._map._getUIString(\"LogoControl.Title\")), t.setAttribute(\"rel\", \"noopener nofollow\"), this._container.appendChild(t), this._container.style.display = \"none\", this._map.on(\"sourcedata\", this._updateLogo), this._updateLogo(), this._map.on(\"resize\", this._updateCompact), this._updateCompact(), this._container;\n      }\n      onRemove() {\n        this._container.remove(), this._map.off(\"sourcedata\", this._updateLogo), this._map.off(\"resize\", this._updateCompact);\n      }\n      getDefaultPosition() {\n        return \"bottom-left\";\n      }\n      _updateLogo(e) {\n        e && \"metadata\" !== e.sourceDataType || (this._container.style.display = this._logoRequired() ? \"block\" : \"none\");\n      }\n      _logoRequired() {\n        if (!this._map.style) return !0;\n        const e = this._map.style._sourceCaches;\n        if (0 === Object.entries(e).length) return !0;\n        for (const t in e) {\n          const i = e[t].getSource();\n          if (i.hasOwnProperty(\"mapbox_logo\") && !i.mapbox_logo) return !1;\n        }\n        return !0;\n      }\n      _updateCompact() {\n        const e = this._container.children;\n        if (e.length) {\n          const t = e[0];\n          this._map.getCanvasContainer().offsetWidth < 250 ? t.classList.add(\"mapboxgl-compact\") : t.classList.remove(\"mapboxgl-compact\");\n        }\n      }\n    }\n    class sl {\n      constructor() {\n        this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;\n      }\n      add(e) {\n        const t = ++this._id;\n        return this._queue.push({\n          callback: e,\n          id: t,\n          cancelled: !1\n        }), t;\n      }\n      remove(e) {\n        const t = this._currentlyRunning,\n          i = t ? this._queue.concat(t) : this._queue;\n        for (const t of i) if (t.id === e) return void (t.cancelled = !0);\n      }\n      run(e = 0) {\n        const t = this._currentlyRunning = this._queue;\n        this._queue = [];\n        for (const i of t) if (!i.cancelled && (i.callback(e), this._cleared)) break;\n        this._cleared = !1, this._currentlyRunning = !1;\n      }\n      clear() {\n        this._currentlyRunning && (this._cleared = !0), this._queue = [];\n      }\n    }\n    class rl {\n      constructor(e) {\n        this.jumpTo(e);\n      }\n      getValue(t) {\n        if (t <= this._startTime) return this._start;\n        if (t >= this._endTime) return this._end;\n        const i = e.cC((t - this._startTime) / (this._endTime - this._startTime));\n        return this._start * (1 - i) + this._end * i;\n      }\n      isEasing(e) {\n        return e >= this._startTime && e <= this._endTime;\n      }\n      jumpTo(e) {\n        this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e, this._end = e;\n      }\n      easeTo(e, t, i) {\n        this._start = this.getValue(t), this._end = e, this._startTime = t, this._endTime = t + i;\n      }\n    }\n    const nl = {\n      \"AttributionControl.ToggleAttribution\": \"Toggle attribution\",\n      \"FullscreenControl.Enter\": \"Enter fullscreen\",\n      \"FullscreenControl.Exit\": \"Exit fullscreen\",\n      \"GeolocateControl.FindMyLocation\": \"Find my location\",\n      \"GeolocateControl.LocationNotAvailable\": \"Location not available\",\n      \"LogoControl.Title\": \"Mapbox homepage\",\n      \"Map.Title\": \"Map\",\n      \"NavigationControl.ResetBearing\": \"Reset bearing to north\",\n      \"NavigationControl.ZoomIn\": \"Zoom in\",\n      \"NavigationControl.ZoomOut\": \"Zoom out\",\n      \"ScrollZoomBlocker.CtrlMessage\": \"Use ctrl + scroll to zoom the map\",\n      \"ScrollZoomBlocker.CmdMessage\": \"Use â + scroll to zoom the map\",\n      \"TouchPanBlocker.Message\": \"Use two fingers to move the map\"\n    };\n    class al extends e.A {\n      constructor(e, t, i, o) {\n        const {\n          point: s,\n          lngLat: r,\n          originalEvent: n,\n          target: a\n        } = e;\n        super(e.type, {\n          point: s,\n          lngLat: r,\n          originalEvent: n,\n          target: a\n        }), this.preventDefault = () => {\n          e.preventDefault();\n        }, this.id = t, this.interaction = i, this.feature = o;\n      }\n    }\n    class ll {\n      constructor(e) {\n        this.map = e, this.interactionsByType = new Map(), this.delegatedInteractions = new Map(), this.typeById = new Map(), this.filters = new Map(), this.handleType = this.handleType.bind(this), this.handleMove = this.handleMove.bind(this), this.handleOut = this.handleOut.bind(this), this.hoveredFeatures = new Map(), this.prevHoveredFeatures = new Map();\n      }\n      add(t, i) {\n        if (this.typeById.has(t)) throw new Error(`Interaction id \"${t}\" already exists.`);\n        const o = i.filter;\n        let s = i.type;\n        o && this.filters.set(t, e.a_(o)), \"mouseover\" === s && (s = \"mouseenter\"), \"mouseout\" === s && (s = \"mouseleave\");\n        const r = this.interactionsByType.get(s) || new Map();\n        \"mouseenter\" === s || \"mouseleave\" === s ? (0 === this.delegatedInteractions.size && (this.map.on(\"mousemove\", this.handleMove), this.map.on(\"mouseout\", this.handleOut)), this.delegatedInteractions.set(t, i)) : 0 === r.size && this.map.on(s, this.handleType), 0 === r.size && this.interactionsByType.set(s, r), r.set(t, i), this.typeById.set(t, s);\n      }\n      get(e) {\n        const t = this.typeById.get(e);\n        if (!t) return;\n        const i = this.interactionsByType.get(t);\n        return i ? i.get(e) : void 0;\n      }\n      remove(e) {\n        const t = this.typeById.get(e);\n        if (!t) return;\n        this.typeById.delete(e), this.filters.delete(e);\n        const i = this.interactionsByType.get(t);\n        i && (i.delete(e), \"mouseenter\" === t || \"mouseleave\" === t ? (this.delegatedInteractions.delete(e), 0 === this.delegatedInteractions.size && (this.map.off(\"mousemove\", this.handleMove), this.map.off(\"mouseout\", this.handleOut))) : 0 === i.size && this.map.off(t, this.handleType));\n      }\n      queryTargets(e, t) {\n        const i = [];\n        for (const [e, o] of t) o.target && i.push({\n          targetId: e,\n          target: o.target,\n          filter: this.filters.get(e)\n        });\n        return this.map.style.queryRenderedTargets(e, i, this.map.transform);\n      }\n      handleMove(e) {\n        this.prevHoveredFeatures = this.hoveredFeatures, this.hoveredFeatures = new Map();\n        const t = this.queryTargets(e.point, Array.from(this.delegatedInteractions).reverse());\n        t.length && (e.type = \"mouseenter\", this.handleType(e, t));\n        const i = new Map();\n        for (const [e, {\n          feature: t\n        }] of this.prevHoveredFeatures) this.hoveredFeatures.has(e) || i.set(t.id, t);\n        i.size && (e.type = \"mouseleave\", this.handleType(e, Array.from(i.values())));\n      }\n      handleOut(e) {\n        const t = Array.from(this.hoveredFeatures.values()).map(({\n          feature: e\n        }) => e);\n        t.length && (e.type = \"mouseleave\", this.handleType(e, t)), this.hoveredFeatures.clear();\n      }\n      handleType(t, i) {\n        const o = Array.from(this.interactionsByType.get(t.type)).reverse(),\n          s = !!i;\n        i = i || this.queryTargets(t.point, o);\n        const r = \"mouseenter\" === t.type;\n        let n = !1;\n        const a = new Set();\n        for (const l of i) {\n          for (const [i, c] of o) {\n            if (!c.target) continue;\n            const o = l.variants ? l.variants[i] : null;\n            if (o) {\n              for (const h of o) {\n                if (at(h, l, a, i)) continue;\n                const o = new e.cx(l, h),\n                  d = nt(h, l, i);\n                s && (o.state = this.map.getFeatureState(o));\n                const u = r ? this.prevHoveredFeatures.get(d) : null,\n                  _ = new al(t, i, c, o),\n                  p = u ? u.stop : c.handler(_);\n                if (r && this.hoveredFeatures.set(d, {\n                  feature: l,\n                  stop: p\n                }), !1 !== p) {\n                  n = !0;\n                  break;\n                }\n              }\n              if (n) break;\n            }\n          }\n          if (n) break;\n        }\n        if (!n) for (const [e, i] of o) {\n          const {\n            handler: o,\n            target: s\n          } = i;\n          if (!s && !1 !== o(new al(t, e, i, null))) break;\n        }\n      }\n    }\n    function cl(t, i) {\n      if (Array.isArray(t) && Array.isArray(i)) {\n        const e = new Set(t),\n          o = new Set(i);\n        return e.size === o.size && t.every(e => o.has(e));\n      }\n      return e.bn(t, i);\n    }\n    const hl = {\n        center: [0, 0],\n        zoom: 0,\n        bearing: 0,\n        pitch: 0,\n        minZoom: -2,\n        maxZoom: 22,\n        minPitch: 0,\n        maxPitch: 85,\n        interactive: !0,\n        scrollZoom: !0,\n        boxZoom: !0,\n        dragRotate: !0,\n        dragPan: !0,\n        keyboard: !0,\n        doubleClickZoom: !0,\n        touchZoomRotate: !0,\n        touchPitch: !0,\n        cooperativeGestures: !1,\n        performanceMetricsCollection: !0,\n        bearingSnap: 7,\n        clickTolerance: 3,\n        pitchWithRotate: !0,\n        hash: !1,\n        attributionControl: !0,\n        antialias: !1,\n        failIfMajorPerformanceCaveat: !1,\n        preserveDrawingBuffer: !1,\n        trackResize: !0,\n        renderWorldCopies: !0,\n        refreshExpiredTiles: !0,\n        minTileCacheSize: null,\n        maxTileCacheSize: null,\n        localIdeographFontFamily: \"sans-serif\",\n        localFontFamily: null,\n        transformRequest: null,\n        accessToken: null,\n        fadeDuration: 300,\n        respectPrefersReducedMotion: !0,\n        crossSourceCollisions: !0,\n        collectResourceTiming: !1,\n        testMode: !1,\n        precompilePrograms: !0,\n        scaleFactor: 1,\n        spriteFormat: \"auto\"\n      },\n      dl = {\n        showCompass: !0,\n        showZoom: !0,\n        visualizePitch: !1\n      };\n    class ul {\n      constructor(t, i, o = !1) {\n        this._clickTolerance = 10, this.element = i, this.mouseRotate = new Ca({\n          clickTolerance: t.dragRotate._mouseRotate._clickTolerance\n        }), this.map = t, o && (this.mousePitch = new Ia({\n          clickTolerance: t.dragRotate._mousePitch._clickTolerance\n        })), e.aQ([\"mousedown\", \"mousemove\", \"mouseup\", \"touchstart\", \"touchmove\", \"touchend\", \"reset\"], this), i.addEventListener(\"mousedown\", this.mousedown), i.addEventListener(\"touchstart\", this.touchstart, {\n          passive: !1\n        }), i.addEventListener(\"touchmove\", this.touchmove), i.addEventListener(\"touchend\", this.touchend), i.addEventListener(\"touchcancel\", this.reset);\n      }\n      down(e, t) {\n        this.mouseRotate.mousedown(e, t), this.mousePitch && this.mousePitch.mousedown(e, t), _();\n      }\n      move(e, t) {\n        const i = this.map,\n          o = this.mouseRotate.mousemoveWindow(e, t),\n          s = o && o.bearingDelta;\n        if (s && i.setBearing(i.getBearing() + s), this.mousePitch) {\n          const o = this.mousePitch.mousemoveWindow(e, t),\n            s = o && o.pitchDelta;\n          s && i.setPitch(i.getPitch() + s);\n        }\n      }\n      off() {\n        const e = this.element;\n        e.removeEventListener(\"mousedown\", this.mousedown), e.removeEventListener(\"touchstart\", this.touchstart, {\n          passive: !1\n        }), e.removeEventListener(\"touchmove\", this.touchmove), e.removeEventListener(\"touchend\", this.touchend), e.removeEventListener(\"touchcancel\", this.reset), this.offTemp();\n      }\n      offTemp() {\n        p(), window.removeEventListener(\"mousemove\", this.mousemove), window.removeEventListener(\"mouseup\", this.mouseup);\n      }\n      mousedown(t) {\n        this.down(e.l({}, t, {\n          ctrlKey: !0,\n          preventDefault: () => t.preventDefault()\n        }), g(this.element, t)), window.addEventListener(\"mousemove\", this.mousemove), window.addEventListener(\"mouseup\", this.mouseup);\n      }\n      mousemove(e) {\n        this.move(e, g(this.element, e));\n      }\n      mouseup(e) {\n        this.mouseRotate.mouseupWindow(e), this.mousePitch && this.mousePitch.mouseupWindow(e), this.offTemp();\n      }\n      touchstart(e) {\n        1 !== e.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = v(this.element, e.targetTouches)[0], this.down({\n          type: \"mousedown\",\n          button: 0,\n          ctrlKey: !0,\n          preventDefault: () => e.preventDefault()\n        }, this._startPos));\n      }\n      touchmove(e) {\n        1 !== e.targetTouches.length ? this.reset() : (this._lastPos = v(this.element, e.targetTouches)[0], this.move({\n          preventDefault: () => e.preventDefault()\n        }, this._lastPos));\n      }\n      touchend(e) {\n        0 === e.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();\n      }\n      reset() {\n        this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();\n      }\n    }\n    function _l(t, i, o) {\n      if (t = new e.bO(t.lng, t.lat), i) {\n        const s = new e.bO(t.lng - 360, t.lat),\n          r = new e.bO(t.lng + 360, t.lat),\n          n = 360 * Math.ceil(Math.abs(t.lng - o.center.lng) / 360),\n          a = o.locationPoint3D(t).distSqr(i),\n          l = i.x < 0 || i.y < 0 || i.x > o.width || i.y > o.height;\n        o.locationPoint3D(s).distSqr(i) < a && (l || Math.abs(s.lng - o.center.lng) < n) ? t = s : o.locationPoint3D(r).distSqr(i) < a && (l || Math.abs(r.lng - o.center.lng) < n) && (t = r);\n      }\n      for (; Math.abs(t.lng - o.center.lng) > 180;) {\n        const e = o.locationPoint3D(t);\n        if (e.x >= 0 && e.y >= 0 && e.x <= o.width && e.y <= o.height) break;\n        t.lng > o.center.lng ? t.lng -= 360 : t.lng += 360;\n      }\n      return t;\n    }\n    const pl = {\n        center: \"translate(-50%,-50%)\",\n        top: \"translate(-50%,0)\",\n        \"top-left\": \"translate(0,0)\",\n        \"top-right\": \"translate(-100%,0)\",\n        bottom: \"translate(-50%,-100%)\",\n        \"bottom-left\": \"translate(0,-100%)\",\n        \"bottom-right\": \"translate(-100%,-100%)\",\n        left: \"translate(0,-50%)\",\n        right: \"translate(-100%,-50%)\"\n      },\n      fl = {\n        anchor: \"center\",\n        color: \"#3FB1CE\",\n        scale: 1,\n        draggable: !1,\n        clickTolerance: 0,\n        rotation: 0,\n        rotationAlignment: \"auto\",\n        pitchAlignment: \"auto\",\n        occludedOpacity: .2,\n        altitude: 0\n      };\n    class ml extends e.E {\n      constructor(t, i) {\n        super(), (t instanceof HTMLElement || i) && (t = e.l({\n          element: t\n        }, i)), e.aQ([\"_update\", \"_onMove\", \"_onUp\", \"_addDragHandler\", \"_onMapClick\", \"_onKeyPress\", \"_clearFadeTimer\"], this), t = e.l({}, fl, t), this._anchor = t.anchor, this._color = t.color, this._scale = t.scale, this._draggable = t.draggable, this._clickTolerance = t.clickTolerance, this._rotation = t.rotation, this._rotationAlignment = t.rotationAlignment, this._pitchAlignment = t.pitchAlignment, this._occludedOpacity = t.occludedOpacity, this._altitude = t.altitude, this._state = \"inactive\", this._isDragging = !1, this._updateMoving = () => this._update(!0), t && t.element ? (this._element = t.element, this._offset = e.P.convert(t && t.offset || [0, 0])) : (this._defaultMarker = !0, this._element = this._createDefaultMarker(), this._offset = e.P.convert(t && t.offset || [0, -14])), this._element.hasAttribute(\"aria-label\") || this._element.setAttribute(\"aria-label\", \"Map marker\"), this._element.hasAttribute(\"role\") || this._element.setAttribute(\"role\", \"img\"), this._element.classList.add(\"mapboxgl-marker\"), this._element.addEventListener(\"dragstart\", e => {\n          e.preventDefault();\n        }), this._element.addEventListener(\"mousedown\", e => {\n          e.preventDefault();\n        });\n        const o = this._element.classList;\n        for (const e in pl) o.remove(`mapboxgl-marker-anchor-${e}`);\n        o.add(`mapboxgl-marker-anchor-${this._anchor}`);\n        const s = t && t.className ? t.className.trim().split(/\\s+/) : [];\n        o.add(...s), this._popup = null;\n      }\n      _createDefaultMarker() {\n        const e = l(\"div\"),\n          t = c(\"svg\", {\n            display: \"block\",\n            height: 41 * this._scale + \"px\",\n            width: 27 * this._scale + \"px\",\n            viewBox: \"0 0 27 41\"\n          }, e);\n        if (0 === this._altitude) {\n          const e = c(\"radialGradient\", {\n            id: \"shadowGradient\"\n          }, c(\"defs\", {}, t));\n          c(\"stop\", {\n            offset: \"10%\",\n            \"stop-opacity\": .4\n          }, e), c(\"stop\", {\n            offset: \"100%\",\n            \"stop-opacity\": .05\n          }, e), c(\"ellipse\", {\n            cx: 13.5,\n            cy: 34.8,\n            rx: 10.5,\n            ry: 5.25,\n            fill: \"url(#shadowGradient)\"\n          }, t);\n        }\n        return c(\"path\", {\n          fill: this._color,\n          d: \"M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z\"\n        }, t), c(\"path\", {\n          opacity: .25,\n          d: \"M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z\"\n        }, t), c(\"circle\", {\n          fill: \"white\",\n          cx: 13.5,\n          cy: 13.5,\n          r: 5.5\n        }, t), e;\n      }\n      addTo(e) {\n        return e === this._map || (this.remove(), this._map = e, e.getCanvasContainer().appendChild(this._element), e.on(\"move\", this._updateMoving), e.on(\"moveend\", this._update), e.on(\"remove\", this._clearFadeTimer), e._addMarker(this), this.setDraggable(this._draggable), this._update(), e.on(\"click\", this._onMapClick)), this;\n      }\n      remove() {\n        const e = this._map;\n        return e && (e.off(\"click\", this._onMapClick), e.off(\"move\", this._updateMoving), e.off(\"moveend\", this._update), e.off(\"mousedown\", this._addDragHandler), e.off(\"touchstart\", this._addDragHandler), e.off(\"mouseup\", this._onUp), e.off(\"touchend\", this._onUp), e.off(\"mousemove\", this._onMove), e.off(\"touchmove\", this._onMove), e.off(\"remove\", this._clearFadeTimer), e._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;\n      }\n      getLngLat() {\n        return this._lngLat;\n      }\n      setLngLat(t) {\n        return this._lngLat = e.bO.convert(t), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;\n      }\n      setAltitude(e) {\n        return e === this._altitude || (this._defaultMarker && (0 === this._altitude && 0 !== e || 0 !== this._altitude && 0 === e) && (this._element = this._createDefaultMarker()), this._altitude = e || fl.altitude, this._update()), this;\n      }\n      getAltitude() {\n        return this._altitude;\n      }\n      getElement() {\n        return this._element;\n      }\n      setPopup(e) {\n        if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute(\"role\"), this._element.removeEventListener(\"keypress\", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute(\"tabindex\")), e) {\n          if (!(\"offset\" in e.options)) {\n            const t = 38.1,\n              i = 13.5,\n              o = Math.sqrt(Math.pow(i, 2) / 2);\n            e.options.offset = this._defaultMarker ? {\n              top: [0, 0],\n              \"top-left\": [0, 0],\n              \"top-right\": [0, 0],\n              bottom: [0, -t],\n              \"bottom-left\": [o, -1 * (t - i + o)],\n              \"bottom-right\": [-o, -1 * (t - i + o)],\n              left: [i, -1 * (t - i)],\n              right: [-i, -1 * (t - i)]\n            } : this._offset;\n          }\n          this._popup = e, e._marker = this, e._altitude = this._altitude, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute(\"role\", \"button\"), this._originalTabIndex = this._element.getAttribute(\"tabindex\"), this._originalTabIndex || this._element.setAttribute(\"tabindex\", \"0\"), this._element.addEventListener(\"keypress\", this._onKeyPress), this._element.setAttribute(\"aria-expanded\", \"false\");\n        }\n        return this;\n      }\n      _onKeyPress(e) {\n        const t = e.code,\n          i = e.charCode || e.keyCode;\n        \"Space\" !== t && \"Enter\" !== t && 32 !== i && 13 !== i || this.togglePopup();\n      }\n      _onMapClick(e) {\n        const t = e.originalEvent.target,\n          i = this._element;\n        this._popup && (t === i || i.contains(t)) && this.togglePopup();\n      }\n      getPopup() {\n        return this._popup;\n      }\n      togglePopup() {\n        const e = this._popup;\n        return e ? (e.isOpen() ? (e.remove(), this._element.setAttribute(\"aria-expanded\", \"false\")) : this._map && (e.addTo(this._map), this._element.setAttribute(\"aria-expanded\", \"true\")), this) : this;\n      }\n      _behindTerrain() {\n        const e = this._map,\n          t = this._pos;\n        if (!e || !t) return !1;\n        const i = e.unproject(t, this._altitude),\n          o = e.getFreeCameraOptions();\n        if (!o.position) return !1;\n        const s = o.position.toLngLat();\n        return s.distanceTo(i) < .9 * s.distanceTo(this._lngLat);\n      }\n      _evaluateOpacity() {\n        const t = this._map;\n        if (!t) return;\n        const i = this._pos;\n        if (!i || i.x < 0 || i.x > t.transform.width || i.y < 0 || i.y > t.transform.height) return void this._clearFadeTimer();\n        const o = t.unproject(i, this._altitude);\n        let s;\n        t._showingGlobe() && e.dK(t.transform, this._lngLat) ? s = 0 : (s = 1 - t._queryFogOpacity(o), t.transform._terrainEnabled() && t.getTerrain() && this._behindTerrain() && (s *= this._occludedOpacity)), this._element.style.opacity = `${s}`, this._element.style.pointerEvents = s > 0 ? \"auto\" : \"none\", this._popup && this._popup._setOpacity(s), this._fadeTimer = null;\n      }\n      _clearFadeTimer() {\n        this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);\n      }\n      _updateDOM() {\n        const e = this._pos;\n        if (!e || !this._map) return;\n        const t = this._offset.mult(this._scale);\n        this._element.style.transform = `\\n            translate(${e.x}px,${e.y}px)\\n            ${pl[this._anchor]}\\n            ${this._calculateXYTransform()} ${this._calculateZTransform()}\\n            translate(${t.x}px,${t.y}px)\\n        `;\n      }\n      _calculateXYTransform() {\n        const t = this._pos,\n          i = this._map,\n          o = this.getPitchAlignment();\n        if (!i || !t || \"map\" !== o) return \"\";\n        if (!i._showingGlobe()) {\n          const e = i.getPitch();\n          return e ? `rotateX(${e}deg)` : \"\";\n        }\n        const s = e.c4(e.dL(i.transform, this._lngLat)),\n          r = t.sub(e.dM(i.transform)),\n          n = Math.abs(r.x) + Math.abs(r.y);\n        if (0 === n) return \"\";\n        const a = s / n;\n        return `rotateX(${-r.y * a}deg) rotateY(${r.x * a}deg)`;\n      }\n      _calculateZTransform() {\n        const t = this._pos,\n          i = this._map;\n        if (!i || !t) return \"\";\n        let o = 0;\n        const s = this.getRotationAlignment();\n        if (\"map\" === s) {\n          if (i._showingGlobe()) {\n            const t = i.project(new e.bO(this._lngLat.lng, this._lngLat.lat + .001), this._altitude),\n              s = i.project(new e.bO(this._lngLat.lng, this._lngLat.lat - .001), this._altitude).sub(t);\n            o = e.c4(Math.atan2(s.y, s.x)) - 90;\n          } else o = -i.getBearing();\n        } else if (\"horizon\" === s) {\n          const s = e.ae(4, 6, i.getZoom()),\n            r = e.dM(i.transform);\n          r.y += s * i.transform.height;\n          const n = t.sub(r),\n            a = e.c4(Math.atan2(n.y, n.x));\n          o = (a > 90 ? a - 270 : a + 90) * (1 - s);\n        }\n        return o += this._rotation, o ? `rotateZ(${o}deg)` : \"\";\n      }\n      _update(e) {\n        cancelAnimationFrame(this._updateFrameId);\n        const t = this._map;\n        t && (t.transform.renderWorldCopies && (this._lngLat = _l(this._lngLat, this._pos, t.transform)), this._pos = t.project(this._lngLat, this._altitude), !0 === e ? this._updateFrameId = requestAnimationFrame(() => {\n          this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());\n        }) : this._pos = this._pos.round(), t._requestDomTask(() => {\n          this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (t._showingGlobe() || t.getTerrain() || t.getFog()) && !this._fadeTimer && (this._fadeTimer = window.setTimeout(this._evaluateOpacity.bind(this), 60)));\n        }));\n      }\n      getOffset() {\n        return this._offset;\n      }\n      setOffset(t) {\n        return this._offset = e.P.convert(t), this._update(), this;\n      }\n      addClassName(e) {\n        return this._element.classList.add(e), this;\n      }\n      removeClassName(e) {\n        return this._element.classList.remove(e), this;\n      }\n      toggleClassName(e) {\n        return this._element.classList.toggle(e);\n      }\n      _onMove(t) {\n        const i = this._map;\n        if (!i) return;\n        const o = this._pointerdownPos,\n          s = this._positionDelta;\n        if (o && s) {\n          if (!this._isDragging) {\n            const e = this._clickTolerance || i._clickTolerance;\n            if (t.point.dist(o) < e) return;\n            this._isDragging = !0;\n          }\n          this._pos = t.point.sub(s), this._lngLat = i.unproject(this._pos, this._altitude), this.setLngLat(this._lngLat), this._element.style.pointerEvents = \"none\", \"pending\" === this._state && (this._state = \"active\", this.fire(new e.A(\"dragstart\"))), this.fire(new e.A(\"drag\"));\n        }\n      }\n      _onUp() {\n        this._element.style.pointerEvents = \"auto\", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1;\n        const t = this._map;\n        t && (t.off(\"mousemove\", this._onMove), t.off(\"touchmove\", this._onMove)), \"active\" === this._state && this.fire(new e.A(\"dragend\")), this._state = \"inactive\";\n      }\n      _addDragHandler(e) {\n        const t = this._map,\n          i = this._pos;\n        t && i && this._element.contains(e.originalEvent.target) && (e.preventDefault(), this._positionDelta = e.point.sub(i), this._pointerdownPos = e.point, this._state = \"pending\", t.on(\"mousemove\", this._onMove), t.on(\"touchmove\", this._onMove), t.once(\"mouseup\", this._onUp), t.once(\"touchend\", this._onUp));\n      }\n      setDraggable(e) {\n        this._draggable = !!e;\n        const t = this._map;\n        return t && (e ? (t.on(\"mousedown\", this._addDragHandler), t.on(\"touchstart\", this._addDragHandler)) : (t.off(\"mousedown\", this._addDragHandler), t.off(\"touchstart\", this._addDragHandler))), this;\n      }\n      isDraggable() {\n        return this._draggable;\n      }\n      setRotation(e) {\n        return this._rotation = e || fl.rotation, this._update(), this;\n      }\n      getRotation() {\n        return this._rotation;\n      }\n      setRotationAlignment(e) {\n        return this._rotationAlignment = e || fl.rotationAlignment, this._update(), this;\n      }\n      getRotationAlignment() {\n        return \"auto\" === this._rotationAlignment || \"horizon\" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? \"viewport\" : this._rotationAlignment;\n      }\n      setPitchAlignment(e) {\n        return this._pitchAlignment = e || fl.pitchAlignment, this._update(), this;\n      }\n      getPitchAlignment() {\n        return \"auto\" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;\n      }\n      setOccludedOpacity(e) {\n        return this._occludedOpacity = e || fl.occludedOpacity, this._update(), this;\n      }\n      getOccludedOpacity() {\n        return this._occludedOpacity;\n      }\n    }\n    const gl = {\n        positionOptions: {\n          enableHighAccuracy: !1,\n          maximumAge: 0,\n          timeout: 6e3\n        },\n        fitBoundsOptions: {\n          maxZoom: 15\n        },\n        trackUserLocation: !1,\n        showAccuracyCircle: !0,\n        showUserLocation: !0,\n        showUserHeading: !1\n      },\n      vl = {\n        maxWidth: 100,\n        unit: \"metric\"\n      },\n      yl = {\n        kilometer: \"km\",\n        meter: \"m\",\n        mile: \"mi\",\n        foot: \"ft\",\n        \"nautical-mile\": \"nm\"\n      },\n      xl = {\n        closeButton: !0,\n        closeOnClick: !0,\n        focusAfterOpen: !0,\n        className: \"\",\n        maxWidth: \"240px\",\n        altitude: 0\n      },\n      bl = [\"a[href]\", \"[tabindex]:not([tabindex='-1'])\", \"[contenteditable]:not([contenteditable='false'])\", \"button:not([disabled])\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\"].join(\", \");\n    function wl(t = new e.P(0, 0), i = \"bottom\") {\n      if (\"number\" == typeof t) {\n        const o = Math.round(Math.sqrt(.5 * Math.pow(t, 2)));\n        switch (i) {\n          case \"top\":\n            return new e.P(0, t);\n          case \"top-left\":\n            return new e.P(o, o);\n          case \"top-right\":\n            return new e.P(-o, o);\n          case \"bottom\":\n            return new e.P(0, -t);\n          case \"bottom-left\":\n            return new e.P(o, -o);\n          case \"bottom-right\":\n            return new e.P(-o, -o);\n          case \"left\":\n            return new e.P(t, 0);\n          case \"right\":\n            return new e.P(-t, 0);\n        }\n        return new e.P(0, 0);\n      }\n      return t instanceof e.P || Array.isArray(t) ? e.P.convert(t) : e.P.convert(t[i] || [0, 0]);\n    }\n    const Tl = {\n      version: t,\n      supported: a.supported,\n      setRTLTextPlugin: e.dN,\n      getRTLTextPluginStatus: e.dO,\n      Map: class extends tl {\n        constructor(t) {\n          o.mark(i.create);\n          const s = t;\n          if (null != (t = e.l({}, hl, t)).minZoom && null != t.maxZoom && t.minZoom > t.maxZoom) throw new Error(\"maxZoom must be greater than or equal to minZoom\");\n          if (null != t.minPitch && null != t.maxPitch && t.minPitch > t.maxPitch) throw new Error(\"maxPitch must be greater than or equal to minPitch\");\n          if (null != t.minPitch && t.minPitch < 0) throw new Error(\"minPitch must be greater than or equal to 0\");\n          if (null != t.maxPitch && t.maxPitch > 85) throw new Error(\"maxPitch must be less than or equal to 85\");\n          if (t.antialias && e.dI(window) && (t.antialias = !1, e.w(\"Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609\")), super(new Ji(t.minZoom, t.maxZoom, t.minPitch, t.maxPitch, t.renderWorldCopies, null, null), t), this._repaint = !!t.repaint, this._interactive = t.interactive, this._minTileCacheSize = t.minTileCacheSize, this._maxTileCacheSize = t.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t.preserveDrawingBuffer, this._antialias = t.antialias, this._trackResize = t.trackResize, this._bearingSnap = t.bearingSnap, this._refreshExpiredTiles = t.refreshExpiredTiles, this._fadeDuration = t.fadeDuration, this._isInitialLoad = !0, this._crossSourceCollisions = t.crossSourceCollisions, this._collectResourceTiming = t.collectResourceTiming, this._language = this._parseLanguage(t.language), this._worldview = t.worldview, this._renderTaskQueue = new sl(), this._domRenderTaskQueue = new sl(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e.aW(), this._locale = e.l({}, nl, t.locale), this._clickTolerance = t.clickTolerance, this._cooperativeGestures = t.cooperativeGestures, this._performanceMetricsCollection = t.performanceMetricsCollection, this._tessellationStep = t.tessellationStep, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = !0, this._precompilePrograms = t.precompilePrograms, this._scaleFactorChanged = !1, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new rl(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = !1, this._frameId = 0, this._scaleFactor = t.scaleFactor, this._requestManager = new T(t.transformRequest, t.accessToken, t.testMode), this._silenceAuthErrors = !!t.testMode, this._contextCreateOptions = t.contextCreateOptions ? Object.assign({}, t.contextCreateOptions) : {}, \"string\" == typeof t.container) {\n            const e = document.getElementById(t.container);\n            if (!e) throw new Error(`Container '${t.container.toString()}' not found.`);\n            this._container = e;\n          } else {\n            if (!(t.container instanceof HTMLElement)) throw new Error(\"Invalid type: 'container' must be a String or HTMLElement.\");\n            this._container = t.container;\n          }\n          if (this._container.childNodes.length > 0 && e.w(\"The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead.\"), t.maxBounds && this.setMaxBounds(t.maxBounds), this._spriteFormat = t.spriteFormat, e.aQ([\"_onWindowOnline\", \"_onWindowResize\", \"_onVisibilityChange\", \"_onMapScroll\", \"_contextLost\", \"_contextRestored\"], this), this._setupContainer(), this._tp || (this._tp = new Nn()), this._tp.registerParameter(this, [\"Debug\"], \"showOverdrawInspector\"), this._tp.registerParameter(this, [\"Debug\"], \"showTileBoundaries\"), this._tp.registerParameter(this, [\"Debug\"], \"showParseStatus\"), this._tp.registerParameter(this, [\"Debug\"], \"repaint\"), this._tp.registerParameter(this, [\"Debug\"], \"showTileAABBs\"), this._tp.registerParameter(this, [\"Debug\"], \"showPadding\"), this._tp.registerParameter(this, [\"Debug\"], \"showCollisionBoxes\", {\n            noSave: !0\n          }), this._tp.registerParameter(this.transform, [\"Debug\"], \"freezeTileCoverage\", {\n            noSave: !0\n          }, () => {\n            this._update();\n          }), this._tp.registerParameter(this, [\"Debug\", \"Wireframe\"], \"showTerrainWireframe\"), this._tp.registerParameter(this, [\"Debug\", \"Wireframe\"], \"showLayers2DWireframe\"), this._tp.registerParameter(this, [\"Debug\", \"Wireframe\"], \"showLayers3DWireframe\"), this._tp.registerParameter(this, [\"Scaling\"], \"_scaleFactor\", {\n            min: .1,\n            max: 10,\n            step: .1\n          }, () => {\n            this.setScaleFactor(this._scaleFactor);\n          }), this._setupPainter(), void 0 === this.painter) throw new Error(\"Failed to initialize WebGL.\");\n          if (this.on(\"move\", () => this._update(!1)), this.on(\"moveend\", () => this._update(!1)), this.on(\"zoom\", () => this._update(!0)), this._fullscreenchangeEvent = \"onfullscreenchange\" in document ? \"fullscreenchange\" : \"webkitfullscreenchange\", window.addEventListener(\"online\", this._onWindowOnline, !1), window.addEventListener(\"resize\", this._onWindowResize, !1), window.addEventListener(\"orientationchange\", this._onWindowResize, !1), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.addEventListener(\"visibilitychange\", this._onVisibilityChange, !1), this.handlers = new Qa(this, t), this._localFontFamily = t.localFontFamily, this._localIdeographFontFamily = t.localIdeographFontFamily, (t.style || !t.testMode) && this.setStyle(t.style || e.e.DEFAULT_STYLE, {\n            config: t.config,\n            localFontFamily: this._localFontFamily,\n            localIdeographFontFamily: this._localIdeographFontFamily\n          }), t.projection && this.setProjection(t.projection), this.indoor = new _o(this), t.hash && (this._hash = new ia(\"string\" == typeof t.hash && t.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {\n            null == s.center && null == s.zoom || (this.transform._unmodified = !1), this.jumpTo({\n              center: t.center,\n              zoom: t.zoom,\n              bearing: t.bearing,\n              pitch: t.pitch\n            });\n            const i = t.bounds;\n            i && (this.resize(), this.fitBounds(i, e.l({}, t.fitBoundsOptions, {\n              duration: 0\n            })));\n          }\n          this.resize(), t.attributionControl && this.addControl(new il({\n            customAttribution: t.customAttribution\n          })), this._logoControl = new ol(), this.addControl(this._logoControl, t.logoPosition), this.on(\"style.load\", () => {\n            this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent();\n          }), this.on(\"data\", t => {\n            this._update(\"style\" === t.dataType), this.fire(new e.A(`${t.dataType}data`, t));\n          }), this.on(\"dataloading\", t => {\n            this.fire(new e.A(`${t.dataType}dataloading`, t));\n          }), this._interactions = new ll(this);\n        }\n        _getMapId() {\n          return this._mapId;\n        }\n        addControl(t, i) {\n          if (void 0 === i && (i = t.getDefaultPosition ? t.getDefaultPosition() : \"top-right\"), !t || !t.onAdd) return this.fire(new e.z(new Error(\"Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.\")));\n          const o = t.onAdd(this);\n          this._controls.push(t);\n          const s = this._controlPositions[i];\n          return -1 !== i.indexOf(\"bottom\") ? s.insertBefore(o, s.firstChild) : s.appendChild(o), this;\n        }\n        removeControl(t) {\n          if (!t || !t.onRemove) return this.fire(new e.z(new Error(\"Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.\")));\n          const i = this._controls.indexOf(t);\n          return i > -1 && this._controls.splice(i, 1), t.onRemove(this), this;\n        }\n        hasControl(e) {\n          return this._controls.indexOf(e) > -1;\n        }\n        getContainer() {\n          return this._container;\n        }\n        getCanvasContainer() {\n          return this._canvasContainer;\n        }\n        getCanvas() {\n          return this._canvas;\n        }\n        resize(t) {\n          if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;\n          this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));\n          const i = !this._moving;\n          return i && this.fire(new e.A(\"movestart\", t)).fire(new e.A(\"move\", t)), this.fire(new e.A(\"resize\", t)), i && this.fire(new e.A(\"moveend\", t)), this;\n        }\n        getBounds() {\n          return this.transform.getBounds();\n        }\n        getMaxBounds() {\n          return this.transform.getMaxBounds() || null;\n        }\n        setMaxBounds(t) {\n          return this.transform.setMaxBounds(e.aB.convert(t)), this._update();\n        }\n        setMinZoom(t) {\n          if ((t = t ?? -2) >= -2 && t <= this.transform.maxZoom) return this.transform.minZoom = t, this._update(), this.getZoom() < t ? this.setZoom(t) : this.fire(new e.A(\"zoomstart\")).fire(new e.A(\"zoom\")).fire(new e.A(\"zoomend\")), this;\n          throw new Error(\"minZoom must be between -2 and the current maxZoom, inclusive\");\n        }\n        getMinZoom() {\n          return this.transform.minZoom;\n        }\n        setMaxZoom(t) {\n          if ((t = t ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = t, this._update(), this.getZoom() > t ? this.setZoom(t) : this.fire(new e.A(\"zoomstart\")).fire(new e.A(\"zoom\")).fire(new e.A(\"zoomend\")), this;\n          throw new Error(\"maxZoom must be greater than the current minZoom\");\n        }\n        getMaxZoom() {\n          return this.transform.maxZoom;\n        }\n        setMinPitch(t) {\n          if ((t = t ?? 0) < 0) throw new Error(\"minPitch must be greater than or equal to 0\");\n          if (t >= 0 && t <= this.transform.maxPitch) return this.transform.minPitch = t, this._update(), this.getPitch() < t ? this.setPitch(t) : this.fire(new e.A(\"pitchstart\")).fire(new e.A(\"pitch\")).fire(new e.A(\"pitchend\")), this;\n          throw new Error(\"minPitch must be between 0 and the current maxPitch, inclusive\");\n        }\n        getMinPitch() {\n          return this.transform.minPitch;\n        }\n        setMaxPitch(t) {\n          if ((t = t ?? 85) > 85) throw new Error(\"maxPitch must be less than or equal to 85\");\n          if (t >= this.transform.minPitch) return this.transform.maxPitch = t, this._update(), this.getPitch() > t ? this.setPitch(t) : this.fire(new e.A(\"pitchstart\")).fire(new e.A(\"pitch\")).fire(new e.A(\"pitchend\")), this;\n          throw new Error(\"maxPitch must be greater than or equal to minPitch\");\n        }\n        getMaxPitch() {\n          return this.transform.maxPitch;\n        }\n        getScaleFactor() {\n          return this._scaleFactor;\n        }\n        setScaleFactor(e) {\n          return this._scaleFactor = e, this.painter.scaleFactor = e, this._tp.refreshUI(), this._scaleFactorChanged = !0, this.style._updateFilteredLayers(e => \"symbol\" === e.type), this._update(!0), this;\n        }\n        getRenderWorldCopies() {\n          return this.transform.renderWorldCopies;\n        }\n        setRenderWorldCopies(e) {\n          return this.transform.renderWorldCopies = e, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();\n        }\n        getLanguage() {\n          return this._language;\n        }\n        _parseLanguage(e) {\n          return \"auto\" === e ? navigator.language : Array.isArray(e) ? 0 === e.length ? void 0 : e.map(e => \"auto\" === e ? navigator.language : e) : e;\n        }\n        setLanguage(e) {\n          const t = this._parseLanguage(e);\n          if (!this.style || t === this._language) return this;\n          this._language = t, this.style.reloadSources();\n          for (const e of this._controls) e._setLanguage && e._setLanguage(this._language);\n          return this;\n        }\n        getWorldview() {\n          return this._worldview;\n        }\n        setWorldview(e) {\n          return this.style && e !== this._worldview ? (this._worldview = e, this.style.reloadSources(), this) : this;\n        }\n        getProjection() {\n          return this.transform.mercatorFromTransition ? {\n            name: \"globe\",\n            center: [0, 0]\n          } : this.transform.getProjection();\n        }\n        _showingGlobe() {\n          return \"globe\" === this.transform.projection.name;\n        }\n        setProjection(e) {\n          return this._lazyInitEmptyStyle(), e ? \"string\" == typeof e && (e = {\n            name: e\n          }) : e = null, this._useExplicitProjection = !!e, this._prioritizeAndUpdateProjection(e, this.style.projection);\n        }\n        _updateProjectionTransition() {\n          if (\"globe\" !== this.getProjection().name) return;\n          const t = this.transform,\n            i = t.projection.name;\n          let o;\n          \"globe\" === i && t.zoom >= e.bY ? (t.setMercatorFromTransition(), o = !0) : \"mercator\" === i && t.zoom < e.bY && (t.setProjection({\n            name: \"globe\"\n          }), o = !0), o && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());\n        }\n        _prioritizeAndUpdateProjection(e, t) {\n          return this._updateProjection(e || t || {\n            name: \"mercator\"\n          });\n        }\n        _updateProjection(t) {\n          let i;\n          return i = \"globe\" === t.name && this.transform.zoom >= e.bY ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t), this.style.applyProjectionUpdate(), i && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(!0), this._forceMarkerAndPopupUpdate(!0)), this;\n        }\n        project(t, i) {\n          return this.transform.locationPoint3D(e.bO.convert(t), i);\n        }\n        unproject(t, i) {\n          return this.transform.pointLocation3D(e.P.convert(t), i);\n        }\n        isMoving() {\n          return this._moving || this.handlers && this.handlers.isMoving() || !1;\n        }\n        isZooming() {\n          return this._zooming || this.handlers && this.handlers.isZooming() || !1;\n        }\n        isRotating() {\n          return this._rotating || this.handlers && this.handlers.isRotating() || !1;\n        }\n        _isDragging() {\n          return this.handlers && this.handlers._isDragging() || !1;\n        }\n        _createDelegatedListener(e, t, i) {\n          const o = e => {\n            let i = [];\n            if (Array.isArray(t)) {\n              const o = t.filter(e => this.getLayer(e));\n              i = o.length ? this.queryRenderedFeatures(e, {\n                layers: o\n              }) : [];\n            } else i = this.queryRenderedFeatures(e, {\n              target: t\n            });\n            return i;\n          };\n          if (\"mouseenter\" === e || \"mouseover\" === e) {\n            let s = !1;\n            const r = t => {\n              const r = o(t.point);\n              r.length ? s || (s = !0, i.call(this, new ua(e, this, t.originalEvent, {\n                features: r\n              }))) : s = !1;\n            };\n            return {\n              listener: i,\n              targets: t,\n              delegates: {\n                mousemove: r,\n                mouseout: () => {\n                  s = !1;\n                }\n              }\n            };\n          }\n          if (\"mouseleave\" === e || \"mouseout\" === e) {\n            let s = !1;\n            const r = t => {\n                o(t.point).length ? s = !0 : s && (s = !1, i.call(this, new ua(e, this, t.originalEvent)));\n              },\n              n = t => {\n                s && (s = !1, i.call(this, new ua(e, this, t.originalEvent)));\n              };\n            return {\n              listener: i,\n              targets: t,\n              delegates: {\n                mousemove: r,\n                mouseout: n\n              }\n            };\n          }\n          {\n            const s = e => {\n              const t = o(e.point);\n              t.length && (e.features = t, i.call(this, e), delete e.features);\n            };\n            return {\n              listener: i,\n              targets: t,\n              delegates: {\n                [e]: s\n              }\n            };\n          }\n        }\n        on(e, t, i) {\n          if (\"function\" == typeof t || void 0 === i) return super.on(e, t);\n          if (\"string\" == typeof t && (t = [t]), !this._areTargetsValid(t)) return this;\n          const o = this._createDelegatedListener(e, t, i);\n          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e] = this._delegatedListeners[e] || [], this._delegatedListeners[e].push(o);\n          for (const e in o.delegates) this.on(e, o.delegates[e]);\n          return this;\n        }\n        once(e, t, i) {\n          if (\"function\" == typeof t || void 0 === i) return super.once(e, t);\n          if (\"string\" == typeof t && (t = [t]), !this._areTargetsValid(t)) return this;\n          const o = this._createDelegatedListener(e, t, i);\n          for (const e in o.delegates) this.once(e, o.delegates[e]);\n          return this;\n        }\n        off(e, t, i) {\n          if (\"function\" == typeof t || void 0 === i) return super.off(e, t);\n          if (\"string\" == typeof t && (t = [t]), !this._areTargetsValid(t)) return this;\n          const o = this._delegatedListeners ? this._delegatedListeners[e] : void 0;\n          return o && (e => {\n            for (let o = 0; o < e.length; o++) {\n              const s = e[o];\n              if (s.listener === i && cl(s.targets, t)) {\n                for (const e in s.delegates) this.off(e, s.delegates[e]);\n                return e.splice(o, 1), this;\n              }\n            }\n          })(o), this;\n        }\n        queryRenderedFeatures(t, i) {\n          if (!this.style) return [];\n          if (void 0 === t || t instanceof e.P || Array.isArray(t) || void 0 !== i || (i = t, t = void 0), t = t || [[0, 0], [this.transform.width, this.transform.height]], !i) {\n            const e = this.style.queryRenderedFeatures(t, void 0, this.transform),\n              i = this.style.queryRenderedFeatureset(t, void 0, this.transform);\n            return e.concat(i);\n          }\n          let o = !0;\n          if (i.target && (o = this._isTargetValid(i.target), o && !i.layers)) return this.style.queryRenderedFeatureset(t, i, this.transform);\n          let s = !0;\n          if (i.layers && Array.isArray(i.layers)) {\n            for (const e of i.layers) if (!this._isValidId(e)) {\n              s = !1;\n              break;\n            }\n            if (s && !i.target) return this.style.queryRenderedFeatures(t, i, this.transform);\n          }\n          let r = [];\n          return s && (r = r.concat(this.style.queryRenderedFeatures(t, i, this.transform))), o && (r = r.concat(this.style.queryRenderedFeatureset(t, i, this.transform))), r;\n        }\n        querySourceFeatures(e, t) {\n          return !e || \"string\" == typeof e && !this._isValidId(e) ? [] : this.style.querySourceFeatures(e, t);\n        }\n        isPointOnSurface(t) {\n          const {\n            name: i\n          } = this.transform.projection;\n          return \"globe\" !== i && \"mercator\" !== i && e.w(`${i} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(e.P.convert(t));\n        }\n        addInteraction(e, t) {\n          return this._interactions.add(e, t), this;\n        }\n        removeInteraction(e) {\n          return this._interactions.remove(e), this;\n        }\n        getCooperativeGestures() {\n          return this._cooperativeGestures;\n        }\n        setCooperativeGestures(e) {\n          return this._cooperativeGestures = e, this;\n        }\n        setStyle(t, i) {\n          return i = e.l({}, {\n            localIdeographFontFamily: this._localIdeographFontFamily,\n            localFontFamily: this._localFontFamily\n          }, i), this.style && t && !1 !== i.diff && i.localFontFamily === this._localFontFamily && i.localIdeographFontFamily === this._localIdeographFontFamily && !i.config ? (this.style._diffStyle(t, (o, s) => {\n            o ? (e.w(`Unable to perform style diff: ${String(o.message || o.error || o)}. Rebuilding the style from scratch.`), this._updateStyle(t, i)) : s && this._update(!0);\n          }, () => {\n            this._postStyleLoadEvent();\n          }), this) : (this._localIdeographFontFamily = i.localIdeographFontFamily, this._localFontFamily = i.localFontFamily, this._updateStyle(t, i));\n        }\n        _getUIString(e) {\n          const t = this._locale[e];\n          if (null == t) throw new Error(`Missing UI string '${e}'`);\n          return t;\n        }\n        _updateStyle(t, i) {\n          if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), t) {\n            const o = e.l({}, i);\n            i && i.config && (o.initialConfig = i.config, delete o.config), this.style = new To(this, o).load(t), this.style.setEventedParent(this, {\n              style: this.style\n            });\n          }\n          return this._updateTerrain(), this;\n        }\n        _lazyInitEmptyStyle() {\n          this.style || (this.style = new To(this, {}), this.style.setEventedParent(this, {\n            style: this.style\n          }), this.style.loadEmpty());\n        }\n        getStyle() {\n          if (this.style) return this.style.serialize();\n        }\n        isStyleLoaded() {\n          return this.style ? this.style.loaded() : (e.w(\"There is no style added to the map.\"), !1);\n        }\n        _isValidId(t) {\n          return null == t ? (this.fire(new e.z(new Error(\"IDs can't be empty.\"))), !1) : !e.cs(t) || (this.fire(new e.z(new Error(`IDs can't contain special symbols: \"${t}\".`))), !1);\n        }\n        _isTargetValid(e) {\n          return \"featuresetId\" in e ? this._isValidId(\"importId\" in e ? e.importId : e.featuresetId) : \"layerId\" in e && this._isValidId(e.layerId);\n        }\n        _areTargetsValid(e) {\n          if (Array.isArray(e)) {\n            for (const t of e) if (!this._isValidId(t)) return !1;\n            return !0;\n          }\n          return this._isTargetValid(e);\n        }\n        addSource(e, t) {\n          return this._isValidId(e) ? (this._lazyInitEmptyStyle(), this.style.addSource(e, t), this._update(!0)) : this;\n        }\n        isSourceLoaded(e) {\n          return !!this._isValidId(e) && !!this.style && this.style._isSourceCacheLoaded(e);\n        }\n        areTilesLoaded() {\n          return this.style.areTilesLoaded();\n        }\n        addSourceType(e, t, i) {\n          this._lazyInitEmptyStyle(), this.style.addSourceType(e, t, i);\n        }\n        removeSource(e) {\n          return this._isValidId(e) ? (this.style.removeSource(e), this._updateTerrain(), this._update(!0)) : this;\n        }\n        getSource(e) {\n          return this._isValidId(e) ? this.style.getOwnSource(e) : null;\n        }\n        addImage(t, i, {\n          pixelRatio: o = 1,\n          sdf: s = !1,\n          stretchX: r,\n          stretchY: n,\n          content: a\n        } = {}) {\n          this._lazyInitEmptyStyle();\n          const l = e.I.from(t);\n          if (i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap) {\n            const {\n              width: t,\n              height: c,\n              data: h\n            } = e.q.getImageData(i);\n            this.style.addImage(l, {\n              data: new e.r({\n                width: t,\n                height: c\n              }, h),\n              pixelRatio: o,\n              stretchX: r,\n              stretchY: n,\n              content: a,\n              sdf: s,\n              version: 0,\n              usvg: !1\n            });\n          } else if (void 0 === i.width || void 0 === i.height) this.fire(new e.z(new Error(\"Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`\")));else {\n            const {\n                width: c,\n                height: h\n              } = i,\n              d = i;\n            this.style.addImage(l, {\n              data: new e.r({\n                width: c,\n                height: h\n              }, new Uint8Array(d.data)),\n              pixelRatio: o,\n              stretchX: r,\n              stretchY: n,\n              content: a,\n              sdf: s,\n              usvg: !1,\n              version: 0,\n              userImage: d\n            }), d.onAdd && d.onAdd(this, t);\n          }\n        }\n        updateImage(t, i) {\n          this._lazyInitEmptyStyle();\n          const o = e.I.from(t),\n            s = this.style.getImage(o);\n          if (!s) return void this.fire(new e.z(new Error(\"The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.\")));\n          const r = i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap ? e.q.getImageData(i) : i,\n            {\n              width: n,\n              height: a,\n              data: l\n            } = r;\n          if (void 0 === n || void 0 === a) return void this.fire(new e.z(new Error(\"Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`\")));\n          if (n !== (s.usvg ? s.icon.usvg_tree.width : s.data.width) || a !== (s.usvg ? s.icon.usvg_tree.height : s.data.height)) return void this.fire(new e.z(new Error(`The width and height of the updated image (${n}, ${a})\\n                must be that same as the previous version of the image\\n                (${s.data.width}, ${s.data.height})`)));\n          const c = !(i instanceof HTMLImageElement || ImageBitmap && i instanceof ImageBitmap);\n          let h = !1;\n          s.usvg ? (s.data = new e.r({\n            width: n,\n            height: a\n          }, new Uint8Array(l)), s.usvg = !1, s.icon = void 0, h = !0) : s.data.replace(l, c), this.style.updateImage(o, s, h);\n        }\n        hasImage(t) {\n          return t ? !!this.style && !!this.style.getImage(e.I.from(t)) : (this.fire(new e.z(new Error(\"Missing required image id\"))), !1);\n        }\n        removeImage(t) {\n          this.style.removeImage(e.I.from(t));\n        }\n        loadImage(t, i) {\n          e.o(this._requestManager.transformRequest(t, e.R.Image), (t, o) => {\n            i(t, o instanceof HTMLImageElement ? e.q.getImageData(o) : o);\n          });\n        }\n        listImages() {\n          return this.style.listImages().map(e => e.name);\n        }\n        addModel(e, t) {\n          this._lazyInitEmptyStyle(), this.style.addModel(e, t);\n        }\n        hasModel(t) {\n          return t ? this.style.hasModel(t) : (this.fire(new e.z(new Error(\"Missing required model id\"))), !1);\n        }\n        removeModel(e) {\n          this.style.removeModel(e);\n        }\n        listModels() {\n          return this.style.listModels();\n        }\n        addLayer(e, t) {\n          return this._isValidId(e.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(e, t), this._update(!0)) : this;\n        }\n        getSlot(e) {\n          const t = this.getLayer(e);\n          return t && t.slot || null;\n        }\n        setSlot(e, t) {\n          return this.style.setSlot(e, t), this.style.mergeLayers(), this._update(!0);\n        }\n        addImport(e, t) {\n          return this.style.addImport(e, t), this;\n        }\n        updateImport(e, t) {\n          return \"string\" != typeof t && t.id !== e ? (this.removeImport(e), this.addImport(t)) : (this.style.updateImport(e, t), this._update(!0));\n        }\n        removeImport(e) {\n          return this.style.removeImport(e), this;\n        }\n        moveImport(e, t) {\n          return this.style.moveImport(e, t), this._update(!0);\n        }\n        moveLayer(e, t) {\n          return this._isValidId(e) ? (this.style.moveLayer(e, t), this._update(!0)) : this;\n        }\n        removeLayer(e) {\n          return this._isValidId(e) ? (this.style.removeLayer(e), this._update(!0)) : this;\n        }\n        getLayer(e) {\n          if (!this._isValidId(e)) return null;\n          const t = this.style.getOwnLayer(e);\n          return t ? \"custom\" === t.type ? t.implementation : t.serialize() : void 0;\n        }\n        getSlots() {\n          return this.style.getSlots();\n        }\n        setLayerZoomRange(e, t, i) {\n          return this._isValidId(e) ? (this.style.setLayerZoomRange(e, t, i), this._update(!0)) : this;\n        }\n        setFilter(e, t, i = {}) {\n          return this._isValidId(e) ? (this.style.setFilter(e, t, i), this._update(!0)) : this;\n        }\n        getFilter(e) {\n          return this._isValidId(e) ? this.style.getFilter(e) : null;\n        }\n        setPaintProperty(e, t, i, o = {}) {\n          return this._isValidId(e) ? (this.style.setPaintProperty(e, t, i, o), this._update(!0)) : this;\n        }\n        getPaintProperty(e, t) {\n          return this._isValidId(e) ? this.style.getPaintProperty(e, t) : null;\n        }\n        setLayoutProperty(e, t, i, o = {}) {\n          return this._isValidId(e) ? (this.style.setLayoutProperty(e, t, i, o), this._update(!0)) : this;\n        }\n        getLayoutProperty(e, t) {\n          return this._isValidId(e) ? this.style.getLayoutProperty(e, t) : null;\n        }\n        getGlyphsUrl() {\n          return this.style.getGlyphsUrl();\n        }\n        setGlyphsUrl(e) {\n          return this.style.setGlyphsUrl(e), this._update(!0);\n        }\n        getSchema(e) {\n          return this.style.getSchema(e);\n        }\n        setSchema(e, t) {\n          return this.style.setSchema(e, t), this._update(!0);\n        }\n        getConfig(e) {\n          return this.style.getConfig(e);\n        }\n        setConfig(e, t) {\n          return this.style.setConfig(e, t), this._update(!0);\n        }\n        getConfigProperty(e, t) {\n          return this.style.getConfigProperty(e, t);\n        }\n        setConfigProperty(e, t, i) {\n          return this.style.setConfigProperty(e, t, i), this._update(!0);\n        }\n        getFeaturesetDescriptors(e) {\n          return this.style.getFeaturesetDescriptors(e);\n        }\n        setLights(e) {\n          if (this._lazyInitEmptyStyle(), e && 1 === e.length && \"flat\" === e[0].type) {\n            const t = e[0];\n            t.properties ? this.style.setFlatLight(t.properties, t.id, {}) : this.style.setFlatLight({}, \"flat\");\n          } else this.style.setLights(e), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = !0);\n          return this._update(!0);\n        }\n        getLights() {\n          const e = this.style.getLights() || [];\n          return 0 === e.length && e.push({\n            id: this.style.light.id,\n            type: \"flat\",\n            properties: this.style.getFlatLight()\n          }), e;\n        }\n        setLight(e, t = {}) {\n          return console.log(\"The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead.\"), this.setLights([{\n            id: \"flat\",\n            type: \"flat\",\n            properties: e\n          }]);\n        }\n        getLight() {\n          return console.log(\"The `map.getLight` function is deprecated, prefer using `map.getLights` instead.\"), this.style.getFlatLight();\n        }\n        setTerrain(e) {\n          return this._lazyInitEmptyStyle(), !e && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e), this._averageElevationLastSampledAt = -1 / 0, this._update(!0);\n        }\n        getTerrain() {\n          return this.style ? this.style.getTerrain() : null;\n        }\n        setFog(e) {\n          return this._lazyInitEmptyStyle(), this.style.setFog(e), this._update(!0);\n        }\n        getFog() {\n          return this.style ? this.style.getFog() : null;\n        }\n        setSnow(e) {\n          return this._lazyInitEmptyStyle(), this.style.setSnow(e), this._update(!0);\n        }\n        getSnow() {\n          return this.style ? this.style.getSnow() : null;\n        }\n        setRain(e) {\n          return this._lazyInitEmptyStyle(), this.style.setRain(e), this._update(!0);\n        }\n        getRain() {\n          return this.style ? this.style.getRain() : null;\n        }\n        setColorTheme(e) {\n          return this._lazyInitEmptyStyle(), this.style.setColorTheme(e), this._update(!0);\n        }\n        setImportColorTheme(e, t) {\n          return this._lazyInitEmptyStyle(), this.style.setImportColorTheme(e, t), this._update(!0);\n        }\n        setCamera(e) {\n          return this.style.setCamera(e), this._triggerCameraUpdate(e);\n        }\n        _triggerCameraUpdate(e) {\n          return this._update(this.transform.setOrthographicProjectionAtLowPitch(\"orthographic\" === e[\"camera-projection\"]));\n        }\n        getCamera() {\n          return this.style.camera;\n        }\n        _queryFogOpacity(t) {\n          return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.bO.convert(t), this.transform) : 0;\n        }\n        setFeatureState(e, t) {\n          return e.source && !this._isValidId(e.source) ? this : (this.style.setFeatureState(e, t), this._update());\n        }\n        removeFeatureState(e, t) {\n          return e.source && !this._isValidId(e.source) ? this : (this.style.removeFeatureState(e, t), this._update());\n        }\n        getFeatureState(e) {\n          return e.source && !this._isValidId(e.source) ? null : this.style.getFeatureState(e);\n        }\n        _updateContainerDimensions() {\n          if (!this._container) return;\n          const e = this._container.getBoundingClientRect().width || 400,\n            t = this._container.getBoundingClientRect().height || 300;\n          let i,\n            o,\n            s,\n            r = this._container;\n          for (; r && (!o || !s);) {\n            const e = window.getComputedStyle(r).transform;\n            e && \"none\" !== e && (i = e.match(/matrix.*\\((.+)\\)/)[1].split(\", \"), i[0] && \"0\" !== i[0] && \"1\" !== i[0] && (o = i[0]), i[3] && \"0\" !== i[3] && \"1\" !== i[3] && (s = i[3])), r = r.parentElement;\n          }\n          this._containerWidth = o ? Math.abs(e / o) : e, this._containerHeight = s ? Math.abs(t / s) : t;\n        }\n        _detectMissingCSS() {\n          \"rgb(250, 128, 114)\" !== window.getComputedStyle(this._missingCSSCanary).getPropertyValue(\"background-color\") && e.w(\"This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.\");\n        }\n        _setupContainer() {\n          const e = this._container;\n          e.classList.add(\"mapboxgl-map\"), (this._missingCSSCanary = l(\"div\", \"mapboxgl-canary\", e)).style.visibility = \"hidden\", this._detectMissingCSS();\n          const t = this._canvasContainer = l(\"div\", \"mapboxgl-canvas-container\", e);\n          this._canvas = l(\"canvas\", \"mapboxgl-canvas\", t), this._interactive && (t.classList.add(\"mapboxgl-interactive\"), this._canvas.setAttribute(\"tabindex\", \"0\")), this._canvas.addEventListener(\"webglcontextlost\", this._contextLost, !1), this._canvas.addEventListener(\"webglcontextrestored\", this._contextRestored, !1), this._canvas.setAttribute(\"aria-label\", this._getUIString(\"Map.Title\")), this._canvas.setAttribute(\"role\", \"region\"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);\n          const i = this._controlContainer = l(\"div\", \"mapboxgl-control-container\", e),\n            o = this._controlPositions = {};\n          [\"top-left\", \"top\", \"top-right\", \"right\", \"bottom-right\", \"bottom\", \"bottom-left\", \"left\"].forEach(e => {\n            o[e] = l(\"div\", `mapboxgl-ctrl-${e}`, i);\n          }), this._container.addEventListener(\"scroll\", this._onMapScroll, !1);\n        }\n        _resizeCanvas(t, i) {\n          const o = e.q.devicePixelRatio || 1;\n          this._canvas.width = o * Math.ceil(t), this._canvas.height = o * Math.ceil(i), this._canvas.style.width = `${t}px`, this._canvas.style.height = `${i}px`;\n        }\n        _addMarker(e) {\n          this._markers.push(e);\n        }\n        _removeMarker(e) {\n          const t = this._markers.indexOf(e);\n          -1 !== t && this._markers.splice(t, 1);\n        }\n        _addPopup(e) {\n          this._popups.push(e);\n        }\n        _removePopup(e) {\n          const t = this._popups.indexOf(e);\n          -1 !== t && this._popups.splice(t, 1);\n        }\n        _setupPainter() {\n          const t = e.l({}, a.supported.webGLContextAttributes, {\n              failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,\n              preserveDrawingBuffer: this._preserveDrawingBuffer,\n              antialias: this._antialias || !1\n            }),\n            i = this._canvas.getContext(\"webgl2\", t);\n          i ? (V(i, !0), this.painter = new ea(i, this._contextCreateOptions, this.transform, this._scaleFactor, this._tp), this.on(\"data\", e => {\n            \"source\" === e.dataType && this.painter.setTileLoadedFlag(!0);\n          }), e.m.testSupport(i)) : this.fire(new e.z(new Error(\"Failed to initialize WebGL\")));\n        }\n        _contextLost(t) {\n          t.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.A(\"webglcontextlost\", {\n            originalEvent: t\n          }));\n        }\n        _contextRestored(t) {\n          this._setupPainter(), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight)), this._updateTerrain(), this.style.reloadModels(), this.style.clearSources(), this._update(), this.fire(new e.A(\"webglcontextrestored\", {\n            originalEvent: t\n          }));\n        }\n        _onMapScroll(e) {\n          if (e.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;\n        }\n        idle() {\n          return !this.isMoving() && this.loaded();\n        }\n        loaded() {\n          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();\n        }\n        frameReady() {\n          return this.loaded() && !this._placementDirty;\n        }\n        _update(e) {\n          return this.style ? (this._styleDirty = this._styleDirty || e, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;\n        }\n        _requestRenderFrame(e) {\n          return this._update(), this._renderTaskQueue.add(e);\n        }\n        _cancelRenderFrame(e) {\n          this._renderTaskQueue.remove(e);\n        }\n        _requestDomTask(e) {\n          !this.loaded() || this.loaded() && !this.isMoving() ? e() : this._domRenderTaskQueue.add(e);\n        }\n        _render(t) {\n          let s;\n          this.fire(new e.A(\"renderstart\")), ++this._frameId;\n          const r = this.painter.context.extTimerQuery,\n            n = e.q.now(),\n            a = this.painter.context.gl;\n          if (this.listens(\"gpu-timing-frame\") && (s = a.createQuery(), a.beginQuery(r.TIME_ELAPSED_EXT, s)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(t), this._domRenderTaskQueue.run(t), this._removed) return;\n          this._updateProjectionTransition();\n          const l = this._isInitialLoad ? 0 : this._fadeDuration;\n          if (this.style && this._styleDirty) {\n            this._styleDirty = !1;\n            const t = this.transform.zoom,\n              i = this.transform.pitch,\n              o = e.q.now(),\n              s = new e.aa(t, {\n                now: o,\n                fadeDuration: l,\n                pitch: i,\n                transition: this.style.transition\n              });\n            this.style.update(s);\n          }\n          this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = !0, this._sourcesDirty = !0);\n          let c = !1;\n          this.style && this._sourcesDirty ? (this._sourcesDirty = !1, this.painter._updateFog(this.style), this._updateTerrain(), c = this._updateAverageElevation(n), this.style.updateSources(this.transform), this.isMoving() || this._forceMarkerAndPopupUpdate()) : c = this._updateAverageElevation(n);\n          const h = this.style && this.style._updatePlacement(this.painter, this.painter.transform, this.showCollisionBoxes, l, this._crossSourceCollisions, this.painter.replacementSource, this._scaleFactorChanged);\n          if (this._scaleFactorChanged && (this._scaleFactorChanged = !1), h && (this._placementDirty = h.needsRerender), this.style && this.painter.render(this.style, {\n            showTileBoundaries: this.showTileBoundaries,\n            showParseStatus: this.showParseStatus,\n            wireframe: {\n              terrain: this.showTerrainWireframe,\n              layers2D: this.showLayers2DWireframe,\n              layers3D: this.showLayers3DWireframe\n            },\n            showOverdrawInspector: this._showOverdrawInspector,\n            showQueryGeometry: !!this._showQueryGeometry,\n            showTileAABBs: this.showTileAABBs,\n            rotating: this.isRotating(),\n            zooming: this.isZooming(),\n            moving: this.isMoving(),\n            fadeDuration: l,\n            isInitialLoad: this._isInitialLoad,\n            showPadding: this.showPadding,\n            gpuTiming: !!this.listens(\"gpu-timing-layer\"),\n            gpuTimingDeferredRender: !!this.listens(\"gpu-timing-deferred-render\"),\n            speedIndexTiming: this.speedIndexTiming\n          }), this.fire(new e.A(\"render\")), this.loaded() && !this._loaded && (this._loaded = !0, o.mark(i.load), this.fire(new e.A(\"load\"))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && (this.style.snow || this.style.rain) && (this._styleDirty = !0), this.style && this.style.imageManager.hasPatternsInFlight() && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), s) {\n            const t = e.q.now() - n;\n            a.endQuery(r.TIME_ELAPSED_EXT), setTimeout(() => {\n              const i = a.getQueryParameter(s, a.QUERY_RESULT) / 1e6;\n              a.deleteQuery(s), this.fire(new e.A(\"gpu-timing-frame\", {\n                cpuTime: t,\n                gpuTime: i\n              }));\n            }, 50);\n          }\n          if (this.listens(\"gpu-timing-layer\")) {\n            const t = this.painter.collectGpuTimers();\n            setTimeout(() => {\n              const i = this.painter.queryGpuTimers(t);\n              this.fire(new e.A(\"gpu-timing-layer\", {\n                layerTimes: i\n              }));\n            }, 50);\n          }\n          if (this.listens(\"gpu-timing-deferred-render\")) {\n            const t = this.painter.collectDeferredRenderGpuQueries();\n            setTimeout(() => {\n              const i = this.painter.queryGpuTimeDeferredRender(t);\n              this.fire(new e.A(\"gpu-timing-deferred-render\", {\n                gpuTime: i\n              }));\n            }, 50);\n          }\n          const d = this._sourcesDirty || this._styleDirty || this._placementDirty || c;\n          if (d || this._repaint) this.triggerRepaint();else {\n            const t = this.idle();\n            if (t && (c = this._updateAverageElevation(n, !0)), c) this.triggerRepaint();else if (this._triggerFrame(!1), t && (this.fire(new e.A(\"idle\")), this._isInitialLoad = !1, this.speedIndexTiming)) {\n              const t = this._calculateSpeedIndex();\n              this.fire(new e.A(\"speedindexcompleted\", {\n                speedIndex: t\n              })), this.speedIndexTiming = !1;\n            }\n          }\n          !this._loaded || this._fullyLoaded || d || (this._fullyLoaded = !0, o.mark(i.fullLoad), this._performanceMetricsCollection && k(this._requestManager._customAccessToken, {\n            width: this.painter.width,\n            height: this.painter.height,\n            interactionRange: this._interactionRange,\n            visibilityHidden: this._visibilityHidden,\n            terrainEnabled: !!this.painter.style.getTerrain(),\n            fogEnabled: !!this.painter.style.getFog(),\n            projection: this.getProjection().name,\n            zoom: this.transform.zoom,\n            renderer: this.painter.context.renderer,\n            vendor: this.painter.context.vendor\n          }), this._authenticate());\n        }\n        _forceMarkerAndPopupUpdate(e) {\n          for (const t of this._markers) e && !this.getRenderWorldCopies() && (t._lngLat = t._lngLat.wrap()), t._update();\n          for (const t of this._popups) !e || this.getRenderWorldCopies() || t._trackPointer || (t._lngLat = t._lngLat.wrap()), t._update();\n        }\n        _updateAverageElevation(e, t = !1) {\n          const i = e => (this.transform.averageElevation = e, this._update(!1), !0);\n          if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i(0);\n          const o = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;\n          if (o || (t || e - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e)) {\n            const t = this.transform.averageElevation;\n            let s = this.transform.sampleAverageElevation();\n            null != this.transform.elevation && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(s) ? s = 0 : this._averageElevationLastSampledAt = e;\n            const r = Math.abs(t - s);\n            if (r > 1) {\n              if (this._isInitialLoad || o) return this._averageElevation.jumpTo(s), i(s);\n              this._averageElevation.easeTo(s, e, 300);\n            } else if (r > 1e-4) return this._averageElevation.jumpTo(s), i(s);\n          }\n          return !!this._averageElevation.isEasing(e) && i(this._averageElevation.getValue(e));\n        }\n        _authenticate() {\n          N(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, t => {\n            if (t && (t.message === w || 401 === t.status)) {\n              const t = this.painter.context.gl;\n              V(t, !1), this._logoControl instanceof ol && this._logoControl._updateLogo(), t && t.clear(t.DEPTH_BUFFER_BIT | t.COLOR_BUFFER_BIT | t.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.z(new Error(\"A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/\")));\n            }\n          }), P(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {});\n        }\n        _postStyleLoadEvent() {\n          this.style.globalId && O(this._requestManager._customAccessToken, {\n            map: this,\n            style: this.style.globalId,\n            importedStyles: this.style.getImportGlobalIds()\n          });\n        }\n        _updateTerrain() {\n          const e = this._isDragging();\n          this.painter.updateTerrain(this.style, e);\n        }\n        _calculateSpeedIndex() {\n          const e = this.painter.canvasCopy(),\n            t = this.painter.getCanvasCopiesAndTimestamps();\n          t.timeStamps.push(performance.now());\n          const i = this.painter.context.gl,\n            o = i.createFramebuffer();\n          function s(e) {\n            i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0);\n            const t = new Uint8Array(i.drawingBufferWidth * i.drawingBufferHeight * 4);\n            return i.readPixels(0, 0, i.drawingBufferWidth, i.drawingBufferHeight, i.RGBA, i.UNSIGNED_BYTE, t), t;\n          }\n          return i.bindFramebuffer(i.FRAMEBUFFER, o), this._canvasPixelComparison(s(e), t.canvasCopies.map(s), t.timeStamps);\n        }\n        _canvasPixelComparison(e, t, i) {\n          let o = i[1] - i[0];\n          const s = e.length / 4;\n          for (let r = 0; r < t.length; r++) {\n            const n = t[r];\n            let a = 0;\n            for (let t = 0; t < n.length; t += 4) n[t] === e[t] && n[t + 1] === e[t + 1] && n[t + 2] === e[t + 2] && n[t + 3] === e[t + 3] && (a += 1);\n            o += (i[r + 2] - i[r + 1]) * (1 - a / s);\n          }\n          return o;\n        }\n        remove() {\n          this._hash && this._hash.remove();\n          for (const e of this._controls) e.onRemove(this);\n          this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.indoor.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener(\"resize\", this._onWindowResize, !1), window.removeEventListener(\"orientationchange\", this._onWindowResize, !1), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), window.removeEventListener(\"online\", this._onWindowOnline, !1), window.removeEventListener(\"visibilitychange\", this._onVisibilityChange, !1);\n          const t = this.painter.context.gl.getExtension(\"WEBGL_lose_context\");\n          t && t.loseContext(), this._canvas.removeEventListener(\"webglcontextlost\", this._contextLost, !1), this._canvas.removeEventListener(\"webglcontextrestored\", this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove(\"mapboxgl-map\"), this._container.removeEventListener(\"scroll\", this._onMapScroll, !1), U.delete(this.painter.context.gl), B.remove(), M.remove(), this._removed = !0, this.fire(new e.A(\"remove\"));\n        }\n        triggerRepaint() {\n          this._triggerFrame(!0);\n        }\n        _triggerFrame(t) {\n          this._renderNextFrame = this._renderNextFrame || t, this.style && !this._frame && (this._frame = e.q.frame(e => {\n            const t = !!this._renderNextFrame;\n            this._frame = null, this._renderNextFrame = null, t && this._render(e);\n          }));\n        }\n        _preloadTiles(t) {\n          const i = this.style ? this.style.getSourceCaches() : [];\n          return e.bl(i, (e, i) => e._preloadTiles(t, i), () => {\n            this.triggerRepaint();\n          }), this;\n        }\n        _onWindowOnline() {\n          this._update();\n        }\n        _onWindowResize(e) {\n          this._trackResize && this.resize({\n            originalEvent: e\n          })._update();\n        }\n        _onVisibilityChange() {\n          \"hidden\" === document.visibilityState && this._visibilityHidden++;\n        }\n        get showTileBoundaries() {\n          return !!this._showTileBoundaries;\n        }\n        set showTileBoundaries(e) {\n          this._showTileBoundaries !== e && (this._showTileBoundaries = e, this._tp.refreshUI(), this._update());\n        }\n        get showParseStatus() {\n          return !!this._showParseStatus;\n        }\n        set showParseStatus(e) {\n          this._showParseStatus !== e && (this._showParseStatus = e, this._tp.refreshUI(), this._update());\n        }\n        get showTerrainWireframe() {\n          return !!this._showTerrainWireframe;\n        }\n        set showTerrainWireframe(e) {\n          this._showTerrainWireframe !== e && (this._showTerrainWireframe = e, this._tp.refreshUI(), this._update());\n        }\n        get showLayers2DWireframe() {\n          return !!this._showLayers2DWireframe;\n        }\n        set showLayers2DWireframe(e) {\n          this._showLayers2DWireframe !== e && (this._showLayers2DWireframe = e, this._tp.refreshUI(), this._update());\n        }\n        get showLayers3DWireframe() {\n          return !!this._showLayers3DWireframe;\n        }\n        set showLayers3DWireframe(e) {\n          this._showLayers3DWireframe !== e && (this._showLayers3DWireframe = e, this._tp.refreshUI(), this._update());\n        }\n        get speedIndexTiming() {\n          return !!this._speedIndexTiming;\n        }\n        set speedIndexTiming(e) {\n          this._speedIndexTiming !== e && (this._speedIndexTiming = e, this._update());\n        }\n        get showPadding() {\n          return !!this._showPadding;\n        }\n        set showPadding(e) {\n          this._showPadding !== e && (this._showPadding = e, this._tp.refreshUI(), this._update());\n        }\n        get showCollisionBoxes() {\n          return !!this._showCollisionBoxes;\n        }\n        set showCollisionBoxes(e) {\n          this._showCollisionBoxes !== e && (this._showCollisionBoxes = e, this._tp.refreshUI(), e ? this.style._generateCollisionBoxes() : this._update());\n        }\n        get showOverdrawInspector() {\n          return !!this._showOverdrawInspector;\n        }\n        set showOverdrawInspector(e) {\n          this._showOverdrawInspector !== e && (this._showOverdrawInspector = e, this._tp.refreshUI(), this._update());\n        }\n        get repaint() {\n          return !!this._repaint;\n        }\n        set repaint(e) {\n          this._repaint !== e && (this._repaint = e, this._tp.refreshUI(), this.triggerRepaint());\n        }\n        get vertices() {\n          return !!this._vertices;\n        }\n        set vertices(e) {\n          this._vertices = e, this._update();\n        }\n        get showTileAABBs() {\n          return !!this._showTileAABBs;\n        }\n        set showTileAABBs(e) {\n          this._showTileAABBs !== e && (this._showTileAABBs = e, this._tp.refreshUI(), e && this._update());\n        }\n        _setCacheLimits(t, i) {\n          e.dJ(t, i);\n        }\n        get version() {\n          return t;\n        }\n      },\n      NavigationControl: class {\n        constructor(t = {}) {\n          this.options = e.l({}, dl, t), this._container = l(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-group\"), this._container.addEventListener(\"contextmenu\", e => e.preventDefault()), this.options.showZoom && (e.aQ([\"_setButtonTitle\", \"_updateZoomButtons\"], this), this._zoomInButton = this._createButton(\"mapboxgl-ctrl-zoom-in\", e => {\n            this._map && this._map.zoomIn({}, {\n              originalEvent: e\n            });\n          }), l(\"span\", \"mapboxgl-ctrl-icon\", this._zoomInButton).setAttribute(\"aria-hidden\", \"true\"), this._zoomOutButton = this._createButton(\"mapboxgl-ctrl-zoom-out\", e => {\n            this._map && this._map.zoomOut({}, {\n              originalEvent: e\n            });\n          }), l(\"span\", \"mapboxgl-ctrl-icon\", this._zoomOutButton).setAttribute(\"aria-hidden\", \"true\")), this.options.showCompass && (e.aQ([\"_rotateCompassArrow\"], this), this._compass = this._createButton(\"mapboxgl-ctrl-compass\", e => {\n            const t = this._map;\n            t && (this.options.visualizePitch ? t.resetNorthPitch({}, {\n              originalEvent: e\n            }) : t.resetNorth({}, {\n              originalEvent: e\n            }));\n          }), this._compassIcon = l(\"span\", \"mapboxgl-ctrl-icon\", this._compass), this._compassIcon.setAttribute(\"aria-hidden\", \"true\"));\n        }\n        _updateZoomButtons() {\n          const e = this._map;\n          if (!e) return;\n          const t = e.getZoom(),\n            i = t === e.getMaxZoom(),\n            o = t === e.getMinZoom();\n          this._zoomInButton.disabled = i, this._zoomOutButton.disabled = o, this._zoomInButton.setAttribute(\"aria-disabled\", i.toString()), this._zoomOutButton.setAttribute(\"aria-disabled\", o.toString());\n        }\n        _rotateCompassArrow() {\n          const e = this._map;\n          if (!e) return;\n          const t = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e.transform.pitch * (Math.PI / 180)), .5)}) rotateX(${e.transform.pitch}deg) rotateZ(${e.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e.transform.angle * (180 / Math.PI)}deg)`;\n          e._requestDomTask(() => {\n            this._compassIcon && (this._compassIcon.style.transform = t);\n          });\n        }\n        onAdd(e) {\n          return this._map = e, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, \"ZoomIn\"), this._setButtonTitle(this._zoomOutButton, \"ZoomOut\"), e.on(\"zoom\", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, \"ResetBearing\"), this.options.visualizePitch && e.on(\"pitch\", this._rotateCompassArrow), e.on(\"rotate\", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new ul(e, this._compass, this.options.visualizePitch)), this._container;\n        }\n        onRemove() {\n          const e = this._map;\n          e && (this._container.remove(), this.options.showZoom && e.off(\"zoom\", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e.off(\"pitch\", this._rotateCompassArrow), e.off(\"rotate\", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);\n        }\n        _createButton(e, t) {\n          const i = l(\"button\", e, this._container);\n          return i.type = \"button\", i.addEventListener(\"click\", t), i;\n        }\n        _setButtonTitle(e, t) {\n          if (!this._map) return;\n          const i = this._map._getUIString(`NavigationControl.${t}`);\n          e.setAttribute(\"aria-label\", i), e.firstElementChild && e.firstElementChild.setAttribute(\"title\", i);\n        }\n      },\n      GeolocateControl: class extends e.E {\n        constructor(t = {}) {\n          super();\n          const i = navigator.geolocation;\n          this.options = e.l({\n            geolocation: i\n          }, gl, t), e.aQ([\"_onSuccess\", \"_onError\", \"_onZoom\", \"_finish\", \"_setupUI\", \"_updateCamera\", \"_updateMarker\", \"_updateMarkerRotation\", \"_onDeviceOrientation\"], this), this._updateMarkerRotationThrottled = ta(this._updateMarkerRotation, 20), this._numberOfWatches = 0;\n        }\n        onAdd(e) {\n          return this._map = e, this._container = l(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-group\"), this._checkGeolocationSupport(this._setupUI), this._container;\n        }\n        onRemove() {\n          void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off(\"zoom\", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = !1;\n        }\n        _checkGeolocationSupport(e) {\n          const t = (t = !!this.options.geolocation) => {\n            this._supportsGeolocation = t, e(t);\n          };\n          void 0 !== this._supportsGeolocation ? e(this._supportsGeolocation) : void 0 !== navigator.permissions ? navigator.permissions.query({\n            name: \"geolocation\"\n          }).then(e => t(\"denied\" !== e.state)).catch(() => t()) : t();\n        }\n        _isOutOfMapMaxBounds(e) {\n          const t = this._map.getMaxBounds(),\n            i = e.coords;\n          return !!t && (i.longitude < t.getWest() || i.longitude > t.getEast() || i.latitude < t.getSouth() || i.latitude > t.getNorth());\n        }\n        _setErrorState() {\n          switch (this._watchState) {\n            case \"WAITING_ACTIVE\":\n              this._watchState = \"ACTIVE_ERROR\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active-error\");\n              break;\n            case \"ACTIVE_LOCK\":\n              this._watchState = \"ACTIVE_ERROR\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\");\n              break;\n            case \"BACKGROUND\":\n              this._watchState = \"BACKGROUND_ERROR\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\");\n          }\n        }\n        _onSuccess(t) {\n          if (this._map) {\n            if (this._isOutOfMapMaxBounds(t)) return this._setErrorState(), this.fire(new e.A(\"outofmaxbounds\", t)), this._updateMarker(), void this._finish();\n            if (this.options.trackUserLocation) switch (this._lastKnownPosition = t, this._watchState) {\n              case \"WAITING_ACTIVE\":\n              case \"ACTIVE_LOCK\":\n              case \"ACTIVE_ERROR\":\n                this._watchState = \"ACTIVE_LOCK\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active\");\n                break;\n              case \"BACKGROUND\":\n              case \"BACKGROUND_ERROR\":\n                this._watchState = \"BACKGROUND\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background-error\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background\");\n            }\n            this.options.showUserLocation && \"OFF\" !== this._watchState && this._updateMarker(t), this.options.trackUserLocation && \"ACTIVE_LOCK\" !== this._watchState || this._updateCamera(t), this.options.showUserLocation && this._userLocationDotMarker.removeClassName(\"mapboxgl-user-location-dot-stale\"), this.fire(new e.A(\"geolocate\", t)), this._finish();\n          }\n        }\n        _updateCamera(t) {\n          const i = new e.bO(t.coords.longitude, t.coords.latitude),\n            o = t.coords.accuracy,\n            s = this._map.getBearing(),\n            r = e.l({\n              bearing: s\n            }, this.options.fitBoundsOptions);\n          this._map.fitBounds(i.toBounds(o), r, {\n            geolocateSource: !0\n          });\n        }\n        _updateMarker(t) {\n          if (t) {\n            const i = new e.bO(t.coords.longitude, t.coords.latitude);\n            this._accuracyCircleMarker.setLngLat(i).addTo(this._map), this._userLocationDotMarker.setLngLat(i).addTo(this._map), this._accuracy = t.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n          } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();\n        }\n        _updateCircleRadius() {\n          const t = this._map.transform,\n            i = e.bH(1, t._center.lat) * t.worldSize,\n            o = Math.ceil(2 * this._accuracy * i);\n          this._circleElement.style.width = `${o}px`, this._circleElement.style.height = `${o}px`;\n        }\n        _onZoom() {\n          this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();\n        }\n        _updateMarkerRotation() {\n          this._userLocationDotMarker && \"number\" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName(\"mapboxgl-user-location-show-heading\")) : (this._userLocationDotMarker.removeClassName(\"mapboxgl-user-location-show-heading\"), this._userLocationDotMarker.setRotation(0));\n        }\n        _onError(t) {\n          if (this._map) {\n            if (this.options.trackUserLocation) if (1 === t.code) {\n              this._watchState = \"OFF\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background-error\"), this._geolocateButton.disabled = !0;\n              const e = this._map._getUIString(\"GeolocateControl.LocationNotAvailable\");\n              this._geolocateButton.setAttribute(\"aria-label\", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute(\"title\", e), void 0 !== this._geolocationWatchID && this._clearWatch();\n            } else {\n              if (3 === t.code && this._noTimeout) return;\n              this._setErrorState();\n            }\n            \"OFF\" !== this._watchState && this.options.showUserLocation && this._userLocationDotMarker.addClassName(\"mapboxgl-user-location-dot-stale\"), this.fire(new e.A(\"error\", t)), this._finish();\n          }\n        }\n        _finish() {\n          this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;\n        }\n        _setupUI(t) {\n          if (void 0 !== this._map) {\n            if (this._container.addEventListener(\"contextmenu\", e => e.preventDefault()), this._geolocateButton = l(\"button\", \"mapboxgl-ctrl-geolocate\", this._container), l(\"span\", \"mapboxgl-ctrl-icon\", this._geolocateButton).setAttribute(\"aria-hidden\", \"true\"), this._geolocateButton.type = \"button\", !1 === t) {\n              e.w(\"Geolocation support is not available so the GeolocateControl will be disabled.\");\n              const t = this._map._getUIString(\"GeolocateControl.LocationNotAvailable\");\n              this._geolocateButton.disabled = !0, this._geolocateButton.setAttribute(\"aria-label\", t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute(\"title\", t);\n            } else {\n              const e = this._map._getUIString(\"GeolocateControl.FindMyLocation\");\n              this._geolocateButton.setAttribute(\"aria-label\", e), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute(\"title\", e);\n            }\n            this.options.trackUserLocation && (this._geolocateButton.setAttribute(\"aria-pressed\", \"false\"), this._watchState = \"OFF\"), this.options.showUserLocation && (this._dotElement = l(\"div\", \"mapboxgl-user-location\"), this._dotElement.appendChild(l(\"div\", \"mapboxgl-user-location-dot\")), this._dotElement.appendChild(l(\"div\", \"mapboxgl-user-location-heading\")), this._userLocationDotMarker = new ml({\n              element: this._dotElement,\n              rotationAlignment: \"map\",\n              pitchAlignment: \"map\"\n            }), this._circleElement = l(\"div\", \"mapboxgl-user-location-accuracy-circle\"), this._accuracyCircleMarker = new ml({\n              element: this._circleElement,\n              pitchAlignment: \"map\"\n            }), this.options.trackUserLocation && (this._watchState = \"OFF\"), this._map.on(\"zoom\", this._onZoom)), this._geolocateButton.addEventListener(\"click\", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on(\"movestart\", t => {\n              t.geolocateSource || \"ACTIVE_LOCK\" !== this._watchState || t.originalEvent && \"resize\" === t.originalEvent.type || (this._watchState = \"BACKGROUND\", this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this.fire(new e.A(\"trackuserlocationend\")));\n            });\n          }\n        }\n        _onDeviceOrientation(e) {\n          this._userLocationDotMarker && (e.webkitCompassHeading ? this._heading = e.webkitCompassHeading : !0 === e.absolute && (this._heading = -1 * e.alpha), this._updateMarkerRotationThrottled());\n        }\n        trigger() {\n          if (!this._setup) return e.w(\"Geolocate control triggered before added to a map\"), !1;\n          if (this.options.trackUserLocation) {\n            switch (this._watchState) {\n              case \"OFF\":\n                this._watchState = \"WAITING_ACTIVE\", this.fire(new e.A(\"trackuserlocationstart\"));\n                break;\n              case \"WAITING_ACTIVE\":\n              case \"ACTIVE_LOCK\":\n              case \"ACTIVE_ERROR\":\n              case \"BACKGROUND_ERROR\":\n                this._numberOfWatches--, this._noTimeout = !1, this._watchState = \"OFF\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-active-error\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background-error\"), this.fire(new e.A(\"trackuserlocationend\"));\n                break;\n              case \"BACKGROUND\":\n                this._watchState = \"ACTIVE_LOCK\", this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-background\"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.A(\"trackuserlocationstart\"));\n            }\n            switch (this._watchState) {\n              case \"WAITING_ACTIVE\":\n                this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active\");\n                break;\n              case \"ACTIVE_LOCK\":\n                this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active\");\n                break;\n              case \"ACTIVE_ERROR\":\n                this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-active-error\");\n                break;\n              case \"BACKGROUND\":\n                this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background\");\n                break;\n              case \"BACKGROUND_ERROR\":\n                this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-background-error\");\n            }\n            if (\"OFF\" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();else if (void 0 === this._geolocationWatchID) {\n              let e;\n              this._geolocateButton.classList.add(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.setAttribute(\"aria-pressed\", \"true\"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e = {\n                maximumAge: 6e5,\n                timeout: 0\n              }, this._noTimeout = !0) : (e = this.options.positionOptions, this._noTimeout = !1), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e), this.options.showUserHeading && this._addDeviceOrientationListener();\n            }\n          } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = window.setTimeout(this._finish, 1e4);\n          return !0;\n        }\n        _addDeviceOrientationListener() {\n          const e = () => {\n            \"ondeviceorientationabsolute\" in window ? window.addEventListener(\"deviceorientationabsolute\", this._onDeviceOrientation) : window.addEventListener(\"deviceorientation\", this._onDeviceOrientation);\n          };\n          \"undefined\" != typeof DeviceMotionEvent && \"function\" == typeof DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then(t => {\n            \"granted\" === t && e();\n          }).catch(console.error) : e();\n        }\n        _clearWatch() {\n          this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener(\"deviceorientation\", this._onDeviceOrientation), window.removeEventListener(\"deviceorientationabsolute\", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove(\"mapboxgl-ctrl-geolocate-waiting\"), this._geolocateButton.setAttribute(\"aria-pressed\", \"false\"), this.options.showUserLocation && this._updateMarker(null);\n        }\n      },\n      AttributionControl: il,\n      ScaleControl: class {\n        constructor(t = {}) {\n          this.options = e.l({}, vl, t), this._isNumberFormatSupported = function () {\n            try {\n              return new Intl.NumberFormat(\"en\", {\n                style: \"unit\",\n                unitDisplay: \"short\",\n                unit: \"meter\"\n              }), !0;\n            } catch (e) {\n              return !1;\n            }\n          }(), e.aQ([\"_update\", \"_setScale\", \"setUnit\"], this);\n        }\n        getDefaultPosition() {\n          return \"bottom-left\";\n        }\n        _update() {\n          const e = this.options.maxWidth || 100,\n            t = this._map,\n            i = t._containerHeight / 2,\n            o = t._containerWidth / 2 - e / 2,\n            s = t.unproject([o, i]),\n            r = t.unproject([o + e, i]),\n            n = s.distanceTo(r);\n          if (\"imperial\" === this.options.unit) {\n            const t = 3.2808 * n;\n            t > 5280 ? this._setScale(e, t / 5280, \"mile\") : this._setScale(e, t, \"foot\");\n          } else \"nautical\" === this.options.unit ? this._setScale(e, n / 1852, \"nautical-mile\") : n >= 1e3 ? this._setScale(e, n / 1e3, \"kilometer\") : this._setScale(e, n, \"meter\");\n        }\n        _setScale(e, t, i) {\n          this._map._requestDomTask(() => {\n            const o = function (e) {\n                const t = Math.pow(10, `${Math.floor(e)}`.length - 1);\n                let i = e / t;\n                return i = i >= 10 ? 10 : i >= 5 ? 5 : i >= 3 ? 3 : i >= 2 ? 2 : i >= 1 ? 1 : function (e) {\n                  const t = Math.pow(10, Math.ceil(-Math.log(e) / Math.LN10));\n                  return Math.round(e * t) / t;\n                }(i), t * i;\n              }(t),\n              s = o / t;\n            this._container.innerHTML = this._isNumberFormatSupported && \"nautical-mile\" !== i ? new Intl.NumberFormat(this._language, {\n              style: \"unit\",\n              unitDisplay: \"short\",\n              unit: i\n            }).format(o) : `${o}&nbsp;${yl[i]}`, this._container.style.width = e * s + \"px\";\n          });\n        }\n        onAdd(e) {\n          return this._map = e, this._language = e.getLanguage(), this._container = l(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-scale\", e.getContainer()), this._container.dir = \"auto\", this._map.on(\"move\", this._update), this._update(), this._container;\n        }\n        onRemove() {\n          this._container.remove(), this._map.off(\"move\", this._update), this._map = void 0;\n        }\n        _setLanguage(e) {\n          this._language = e, this._update();\n        }\n        setUnit(e) {\n          this.options.unit = e, this._update();\n        }\n      },\n      FullscreenControl: class {\n        constructor(t = {}) {\n          this._fullscreen = !1, t && t.container && (t.container instanceof HTMLElement ? this._container = t.container : e.w(\"Full screen control 'container' must be a DOM element.\")), e.aQ([\"_onClickFullscreen\", \"_changeIcon\"], this), \"onfullscreenchange\" in document ? this._fullscreenchange = \"fullscreenchange\" : \"onwebkitfullscreenchange\" in document && (this._fullscreenchange = \"webkitfullscreenchange\");\n        }\n        onAdd(t) {\n          return this._map = t, this._container || (this._container = this._map.getContainer()), this._controlContainer = l(\"div\", \"mapboxgl-ctrl mapboxgl-ctrl-group\"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = \"none\", e.w(\"This device does not support fullscreen mode.\")), this._controlContainer;\n        }\n        onRemove() {\n          this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);\n        }\n        _checkFullscreenSupport() {\n          return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);\n        }\n        _setupUI() {\n          const e = this._fullscreenButton = l(\"button\", \"mapboxgl-ctrl-fullscreen\", this._controlContainer);\n          l(\"span\", \"mapboxgl-ctrl-icon\", e).setAttribute(\"aria-hidden\", \"true\"), e.type = \"button\", this._updateTitle(), this._fullscreenButton.addEventListener(\"click\", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);\n        }\n        _updateTitle() {\n          const e = this._getTitle();\n          this._fullscreenButton.setAttribute(\"aria-label\", e), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute(\"title\", e);\n        }\n        _getTitle() {\n          return this._map._getUIString(this._isFullscreen() ? \"FullscreenControl.Exit\" : \"FullscreenControl.Enter\");\n        }\n        _isFullscreen() {\n          return this._fullscreen;\n        }\n        _changeIcon() {\n          (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle(\"mapboxgl-ctrl-shrink\"), this._fullscreenButton.classList.toggle(\"mapboxgl-ctrl-fullscreen\"), this._updateTitle());\n        }\n        _onClickFullscreen() {\n          this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();\n        }\n      },\n      Popup: class extends e.E {\n        constructor(t) {\n          super(), this.options = e.l(Object.create(xl), t), this._altitude = this.options.altitude, e.aQ([\"_update\", \"_onClose\", \"remove\", \"_onMouseEvent\"], this), this._classList = new Set(t && t.className ? t.className.trim().split(/\\s+/) : []);\n        }\n        addTo(t) {\n          return this._map && this.remove(), this._map = t, this.options.closeOnClick && t.on(\"preclick\", this._onClose), this.options.closeOnMove && t.on(\"move\", this._onClose), t.on(\"remove\", this.remove), this._update(), t._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t.on(\"mousemove\", this._onMouseEvent), t.on(\"mouseup\", this._onMouseEvent), t._canvasContainer.classList.add(\"mapboxgl-track-pointer\")) : t.on(\"move\", this._update), this.fire(new e.A(\"open\")), this;\n        }\n        isOpen() {\n          return !!this._map;\n        }\n        remove() {\n          this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);\n          const t = this._map;\n          return t && (t.off(\"move\", this._update), t.off(\"move\", this._onClose), t.off(\"preclick\", this._onClose), t.off(\"click\", this._onClose), t.off(\"remove\", this.remove), t.off(\"mousemove\", this._onMouseEvent), t.off(\"mouseup\", this._onMouseEvent), t.off(\"drag\", this._onMouseEvent), t._canvasContainer && t._canvasContainer.classList.remove(\"mapboxgl-track-pointer\"), t._removePopup(this), this._map = void 0), this.fire(new e.A(\"close\")), this;\n        }\n        getLngLat() {\n          return this._lngLat;\n        }\n        setLngLat(t) {\n          this._lngLat = e.bO.convert(t), this._pos = null, this._trackPointer = !1, this._update();\n          const i = this._map;\n          return i && (i.on(\"move\", this._update), i.off(\"mousemove\", this._onMouseEvent), i._canvasContainer.classList.remove(\"mapboxgl-track-pointer\")), this;\n        }\n        getAltitude() {\n          return this._altitude;\n        }\n        setAltitude(e) {\n          return this._altitude = e, this._update(), this;\n        }\n        trackPointer() {\n          this._trackPointer = !0, this._pos = null, this._update();\n          const e = this._map;\n          return e && (e.off(\"move\", this._update), e.on(\"mousemove\", this._onMouseEvent), e.on(\"drag\", this._onMouseEvent), e._canvasContainer.classList.add(\"mapboxgl-track-pointer\")), this;\n        }\n        getElement() {\n          return this._container;\n        }\n        setText(e) {\n          return this.setDOMContent(document.createTextNode(e));\n        }\n        setHTML(e) {\n          const t = document.createDocumentFragment(),\n            i = document.createElement(\"body\");\n          let o;\n          for (i.innerHTML = e; o = i.firstChild, o;) t.appendChild(o);\n          return this.setDOMContent(t);\n        }\n        getMaxWidth() {\n          return this._container && this._container.style.maxWidth;\n        }\n        setMaxWidth(e) {\n          return this.options.maxWidth = e, this._update(), this;\n        }\n        setDOMContent(e) {\n          let t = this._content;\n          if (t) for (; t.hasChildNodes();) t.firstChild && t.removeChild(t.firstChild);else t = this._content = l(\"div\", \"mapboxgl-popup-content\", this._container || void 0);\n          if (t.appendChild(e), this.options.closeButton) {\n            const e = this._closeButton = l(\"button\", \"mapboxgl-popup-close-button\", t);\n            e.type = \"button\", e.setAttribute(\"aria-label\", \"Close popup\"), e.innerHTML = '<span aria-hidden=\"true\">&#215;</span>', e.addEventListener(\"click\", this._onClose);\n          }\n          return this._update(), this._focusFirstElement(), this;\n        }\n        addClassName(e) {\n          return this._classList.add(e), this._updateClassList(), this;\n        }\n        removeClassName(e) {\n          return this._classList.delete(e), this._updateClassList(), this;\n        }\n        setOffset(e) {\n          return this.options.offset = e, this._update(), this;\n        }\n        toggleClassName(e) {\n          let t;\n          return this._classList.delete(e) ? t = !1 : (this._classList.add(e), t = !0), this._updateClassList(), t;\n        }\n        _onMouseEvent(e) {\n          this._update(e.point);\n        }\n        _getAnchor(e) {\n          if (this.options.anchor) return this.options.anchor;\n          const t = this._map,\n            i = this._container,\n            o = this._pos;\n          if (!t || !i || !o) return \"bottom\";\n          const s = i.offsetWidth,\n            r = i.offsetHeight,\n            n = o.x < s / 2,\n            a = o.x > t.transform.width - s / 2;\n          if (o.y + e < r) return n ? \"top-left\" : a ? \"top-right\" : \"top\";\n          if (o.y > t.transform.height - r) {\n            if (n) return \"bottom-left\";\n            if (a) return \"bottom-right\";\n          }\n          return n ? \"left\" : a ? \"right\" : \"bottom\";\n        }\n        _updateClassList() {\n          const e = this._container;\n          if (!e) return;\n          const t = [...this._classList];\n          t.push(\"mapboxgl-popup\"), this._anchor && t.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t.push(\"mapboxgl-popup-track-pointer\"), e.className = t.join(\" \");\n        }\n        _update(t) {\n          const i = this._map,\n            o = this._content;\n          if (!i || !this._lngLat && !this._trackPointer || !o) return;\n          let s = this._container;\n          if (s || (s = this._container = l(\"div\", \"mapboxgl-popup\", i.getContainer()), this._tip = l(\"div\", \"mapboxgl-popup-tip\", s), s.appendChild(o)), this.options.maxWidth && s.style.maxWidth !== this.options.maxWidth && (s.style.maxWidth = this.options.maxWidth), i.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = _l(this._lngLat, this._pos, i.transform)), !this._trackPointer || t) {\n            const o = this._pos = this._trackPointer && t instanceof e.P ? t : i.project(this._lngLat, this._altitude),\n              s = wl(this.options.offset),\n              r = this._anchor = this._getAnchor(s.y),\n              n = wl(this.options.offset, r),\n              a = o.add(n).round();\n            i._requestDomTask(() => {\n              this._container && r && (this._container.style.transform = `${pl[r]} translate(${a.x}px,${a.y}px)`);\n            });\n          }\n          if (!this._marker && i._showingGlobe()) {\n            const t = e.dK(i.transform, this._lngLat) ? 0 : 1;\n            this._setOpacity(t);\n          }\n          this._updateClassList();\n        }\n        _focusFirstElement() {\n          if (!this.options.focusAfterOpen || !this._container) return;\n          const e = this._container.querySelector(bl);\n          e && e.focus();\n        }\n        _onClose() {\n          this.remove();\n        }\n        _setOpacity(e) {\n          this._container && (this._container.style.opacity = `${e}`), this._content && (this._content.style.pointerEvents = e ? \"auto\" : \"none\");\n        }\n      },\n      Marker: ml,\n      Style: To,\n      LngLat: e.bO,\n      LngLatBounds: e.aB,\n      Point: e.P,\n      MercatorCoordinate: e.ac,\n      FreeCameraOptions: Wi,\n      Evented: e.E,\n      config: e.e,\n      prewarm: e.dP,\n      clearPrewarmedResources: e.dQ,\n      get accessToken() {\n        return e.e.ACCESS_TOKEN;\n      },\n      set accessToken(t) {\n        e.e.ACCESS_TOKEN = t;\n      },\n      get baseApiUrl() {\n        return e.e.API_URL;\n      },\n      set baseApiUrl(t) {\n        e.e.API_URL = t;\n      },\n      get workerCount() {\n        return e.dR.workerCount;\n      },\n      set workerCount(t) {\n        e.dR.workerCount = t;\n      },\n      get maxParallelImageRequests() {\n        return e.e.MAX_PARALLEL_IMAGE_REQUESTS;\n      },\n      set maxParallelImageRequests(t) {\n        e.e.MAX_PARALLEL_IMAGE_REQUESTS = t;\n      },\n      clearStorage(t) {\n        e.dS(t);\n      },\n      get workerUrl() {\n        return e.dT.workerUrl;\n      },\n      set workerUrl(t) {\n        e.dT.workerUrl = t;\n      },\n      get workerClass() {\n        return e.dT.workerClass;\n      },\n      set workerClass(t) {\n        e.dT.workerClass = t;\n      },\n      get workerParams() {\n        return e.dT.workerParams;\n      },\n      set workerParams(t) {\n        e.dT.workerParams = t;\n      },\n      get dracoUrl() {\n        return e.dU();\n      },\n      set dracoUrl(t) {\n        e.dV(t);\n      },\n      get meshoptUrl() {\n        return e.dW();\n      },\n      set meshoptUrl(t) {\n        e.dX(t);\n      },\n      setNow: e.q.setNow,\n      restoreNow: e.q.restoreNow\n    };\n    return Tl;\n  });\n\n  //\n  // Our custom intro provides a specialized \"define()\" function, called by the\n  // AMD modules below, that sets up the worker blob URL and then executes the\n  // main module, storing its exported value as 'mapboxgl'\n\n  var mapboxgl$1 = mapboxgl;\n  return mapboxgl$1;\n});","map":null,"metadata":{},"sourceType":"script"}